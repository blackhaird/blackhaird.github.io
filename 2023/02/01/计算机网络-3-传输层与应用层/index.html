<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="传输层传输层提供的服务及功能  传输层的功能如下:1)传输层提供应用进程之间的逻辑通信(即端到端的通信)。  与网络层的区别是，网络层提供的是主机之间的逻辑通信。 从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址。 但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称端到端的逻辑通信。 这里“逻辑通信”的意思是:传输层之间的通信好像">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络(3)-传输层与应用层">
<meta property="og:url" content="http://example.com/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:description" content="传输层传输层提供的服务及功能  传输层的功能如下:1)传输层提供应用进程之间的逻辑通信(即端到端的通信)。  与网络层的区别是，网络层提供的是主机之间的逻辑通信。 从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址。 但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称端到端的逻辑通信。 这里“逻辑通信”的意思是:传输层之间的通信好像">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011631465.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011642474.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643998.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643442.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011652356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011702423.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011708708.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011724860.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011729465.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742289.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011748224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011749892.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011750146.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753161.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753219.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754971.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754021.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754063.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011755349.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012046974.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012047854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012058140.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012102975.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103517.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103897.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103883.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012104058.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012110668.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118546.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012119412.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012121629.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012122103.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012127416.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012144530.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148576.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148271.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012150621.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152913.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152357.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012153295.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154629.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154870.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155883.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155920.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157298.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157757.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157575.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158446.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158231.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012159989.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200877.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200164.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012201443.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012202965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203168.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012204214.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205051.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205842.png">
<meta property="article:published_time" content="2023-02-01T08:21:55.000Z">
<meta property="article:modified_time" content="2023-02-01T14:36:18.122Z">
<meta property="article:author" content="MEIDE">
<meta property="article:tag" content="考研408">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011631465.png">

<link rel="canonical" href="http://example.com/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络(3)-传输层与应用层 | MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络(3)-传输层与应用层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:21:55 / 修改时间：22:36:18" itemprop="dateCreated datePublished" datetime="2023-02-01T16:21:55+08:00">2023-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层提供的服务及功能"><a href="#传输层提供的服务及功能" class="headerlink" title="传输层提供的服务及功能"></a>传输层提供的服务及功能</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011631465.png"/>

<p><strong>传输层的功能如下:</strong><br><strong>1)传输层提供应用进程之间的逻辑通信(即端到端的通信)。</strong></p>
<ul>
<li>与网络层的区别是，网络层提供的是主机之间的逻辑通信。</li>
<li>从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址。</li>
<li>但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称<code>端到端</code>的逻辑通信。</li>
<li>这里<code>“逻辑通信”</code>的意思是:传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有–条水平方向的物理连接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011642474.png"/>

<p><strong>2)复用和分用。</strong></p>
<ul>
<li>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据;</li>
<li>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>传输层的复用分用功能与网络层的复用分用功能不同。</strong></li>
<li>网络层的<code>复用</code>是指发送方不同协议的数据都可以封装成IP数据报发送出去,</li>
<li>网络层的<code>分用</code>是指接收方的网络层在剥去首部后把数据交付给相应的协议。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643998.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643442.png"/>

<p><strong>3)传输层还要对收到的报文进行差错检测(首部和数据部分)。</strong></p>
<ul>
<li>网络层只检查IP数据报的首部，不检验数据部分是否出错。</li>
</ul>
<p><strong>4)提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。</strong></p>
<ul>
<li>网络层无法同时实现两种协议(即在网络层要么只提供面向连接的服务，如虚电路;要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式)。</li>
</ul>
<h2 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a><strong>传输层的寻址与端口</strong></h2><h3 id="（1）端口的作用"><a href="#（1）端口的作用" class="headerlink" title="（1）端口的作用"></a>（1）端口的作用</h3><ul>
<li>端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li>
<li>端口是传输层<code>服务访问点</code>(TSAP)，它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，只不过<code>IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程</code>。</li>
<li><code>数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口</code>。</li>
<li>在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。</li>
<li>传输层使用的是软件端口。</li>
</ul>
<h3 id="（2）端口号的分类"><a href="#（2）端口号的分类" class="headerlink" title="（2）端口号的分类"></a>（2）端口号的分类</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011652356.png"/>

<h3 id="（3）套接字"><a href="#（3）套接字" class="headerlink" title="（3）套接字"></a>（3）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a></h3><p>在网络中通过IP地址来标识和区别不同的主机，<code>通过端口号来标识和区分一台主机中的不同应用进程</code>。在网络中采用发送方和接收方的<code>套接字(Socket)</code>组合来识别<code>端点</code>。</p>
<p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。<br>$$<br>套接字Socket&#x3D;(主机IP地址，端口号)<br>$$</p>
<h2 id="无连接UDP和面向连接TCP服务"><a href="#无连接UDP和面向连接TCP服务" class="headerlink" title="无连接UDP和面向连接TCP服务"></a>无连接UDP和面向连接TCP服务</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011702423.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>面向</th>
<th>说明</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>TCP面向连接的传输控制协议</td>
<td>面向连接（可靠）</td>
<td>传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。（监控管理）</td>
<td><strong>可靠，面向连接，时延大，适用于大文件。</strong>【TCP主要适用于可靠性更重要的场合，如文件传输协议（FTP)、超文本传输协议（HTTP)、远程登录（TELNET)等。】</td>
</tr>
<tr>
<td>UDP无连接的用户数据报协议</td>
<td>面向无连接（不可靠）</td>
<td>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。</td>
<td><strong>不可靠，无连接，时延小，适用于小文件。</strong>【UDP的应用主要包括小文件传送协议（TFTP)、DNS、SNMP和实时传输协议（RTP)。】</td>
</tr>
</tbody></table>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p>
<h4 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h4><ol>
<li>UDP是无连接的，减少开销和发送数据之前的时延。</li>
<li>UDP使用最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的，适合一次性传输少量数据的网络应用。</li>
<li>UDP无拥塞控制，适合很多实时应用。</li>
<li>UDP首部开销小，8B,TCP20B。</li>
</ol>
<p>应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011708708.png"/>

<p><strong>为什么应用开发人员宁愿在UDP之上构建应用，也不选择TCP?既然TCP提供可靠的服务，而UDP不提供，那么TCP总是首选吗?答案是否定的，因为有很多应用更适合用UDP，主要是因为UDP具有如下优点:</strong></p>
<p><strong>1)UDP无须建立连接。</strong></p>
<ul>
<li>UDP不会引入建立连接的时延。</li>
<li>试想如果DNS运行在TCP而非UDP.上，那么DNS的<code>速度</code>会慢很多。</li>
<li>HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，<code>可靠性</code>是至关重要的。</li>
</ul>
<p><strong>2)无连接状态。</strong></p>
<ul>
<li>TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。</li>
<li>而UDP不维护连接状态，也不跟踪这些参数。</li>
<li>因此，<code>某些专用应用服务器使用UDP</code>时，<code>一般都能支持更多的活动客户机</code>。</li>
</ul>
<p><strong>3)分组首部开销小。</strong></p>
<ul>
<li><code>TCP</code>有<code>20B</code>的<code>首部</code>开销，而<code>UDP</code>仅有<code>8B</code>的开销。</li>
</ul>
<p><strong>4)应用层能更好地控制要发送的数据和发送时间。</strong></p>
<ul>
<li>UDP没有拥塞控制，因此网络中的拥塞<code>不会影响主机的发送效率</code>。</li>
<li><code>某些实时应用要求以稳定的速度发送</code>，能容忍一些数据的丢失，但<code>不允许有较大的时延</code>，而UDP正好满足这些应用的需求。</li>
</ul>
<p><strong>5)UDP常用于一次性传输较少数据的网络应用</strong></p>
<ul>
<li>如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。</li>
<li>UDP也常用于多媒体应用(如IP电话、实时视频会议、流媒体等)，显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。</li>
</ul>
<p><strong>6)UDP提供尽最大努力的交付，即不保证可靠交付</strong></p>
<ul>
<li>但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成。</li>
<li><code>应用实体可以根据应用的需求来灵活设计自己的可靠性机制</code>。</li>
</ul>
<p><strong>7)UDP是面向报文的。</strong></p>
<ul>
<li><p>发送方UDP对<code>应用层交下来的报文</code>，在添加首部后就向下交付给IP层，<br><code>既不合并，也不拆分</code>，而是保留这些报文的边界;</p>
</li>
<li><p>接收方UDP对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。</p>
</li>
<li><p>因此<code>报文不可分割，是UDP数据报处理的最小单位</code>。</p>
</li>
</ul>
<h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011724860.png"/>

<p><strong>各字段意义如下：</strong></p>
<ul>
<li>1)源端口。源端口号。在需要对方回信时选用，不需要时可用全0。</li>
<li>2)目的端口。目的端口号。这在终点交付报文时必须使用到。</li>
<li>3)长度。UDP数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)。</li>
<li>4)校验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。</li>
</ul>
<h4 id="当传输层从IP层收到UDP数据报时"><a href="#当传输层从IP层收到UDP数据报时" class="headerlink" title="当传输层从IP层收到UDP数据报时"></a>当传输层从IP层收到UDP数据报时</h4><p>根据首部中的目的端口，把UDP数据报通过相应的端口.上交给应用进程</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011729465.png"/>

<p>如果接收方UDP发现收到的报文中的目的端口号不正确(即不存在对应于端口号的应用进程)，那么就丢弃该报文，并由ICMP发送“端口不可达”<code>差错报文给发送方</code>。</p>
<h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><ul>
<li>伪首部和全0字节是不发送的，仅供校验使用</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742344.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742289.png"/>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h4><ol>
<li><p>TCP是面向连接（虚连接）的传输层协议。(打call)</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。[可靠有序，不丢不重]</p>
</li>
<li><p>TCP提供全双工通信。<br> 发送缓存:准备发送的数据已发送但尚未收到确认的数据<br> 接收缓存:按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</p>
</li>
<li><p>TCP面向字节流<br> TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p>
</li>
</ol>
<p>  （流：流入到进程或从进程流出的字节序列。）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011748224.png"/>

<h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><ul>
<li><code>TCP传送的数据单元称为报文段</code>。一个TCP报文段分为TCP首部和TCP数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中</li>
<li>其首部的前20B是固定的。TCP报文段的首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度为4B的整数倍。</li>
<li>TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011749892.png"/>

<ul>
<li>1)<code>源端口和目的端口字段</code>。各占2B。端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现。</li>
<li>2)<code>序号字段</code>。占4B。TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011750146.png"/>

<ul>
<li>3)<code>确认号字段</code>。占4B,是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表明到序号N- 1为止的所有数据都已正确收到。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753161.png"/>

<ul>
<li>4)<code>数据偏移(即首部长度)</code>。占4位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位(以4B为计算单位)。因此当此字段的值为15时，达到TCP首部的最大长度60B.</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753880.png"/>

<ul>
<li>5)<code>保留字段</code>。占6位，保留为今后使用，但目前应置为0，该字段可以忽略不计。</li>
<li>6)<code>紧急位URG</code>。URG&#x3D; 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。但<code>URG需要和紧急指针配套使用</code>，即<code>数据从第一个字节到紧急指针所指字节</code>就是<code>紧急数据</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753219.png"/>

<ul>
<li>7)<code>确认位ACK</code>。只有当ACK&#x3D; 1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.</li>
<li>8)<code>推送位PSH (Push)</code>。 接收TCP收到PSH&#x3D; 1的报文段，就尽快地交付给接收应用进程而不再等到整个缓存都填满后再向上交付。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754971.png"/>

<ul>
<li>9)<code>复位位RST (Reset)</code>。RST&#x3D;1时，表明TCP连接中出现严重差错(如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</li>
<li>10)<code>同步位SYN</code>。同步SYN&#x3D; 1表示这是一个<code>连接请求或连接接收报文</code>。当<code>SYN=1, ACK=0</code>时，表明这是一个<code>连接请求</code>报文，对方若同意建立连接，则在响应报文中使用<code>SYN=1, ACK=1</code>。即SYN&#x3D; 1表示这是一个连接请求或连接接收报文。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754021.png"/>

<ul>
<li>11)<code>终止位FIN (Finish)</code>。用来释放一个连接。FIN&#x3D; 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</li>
<li>12)<code>窗口字段</code>。占2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。<br>例如，假设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的接收方方还有接收1000B数据(字节序号为701 ~1700)的接收缓存空间。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754063.png"/>

<ul>
<li>13)<code>校验和</code>。占2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6，其他的和UDP一样)。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43914604/article/details/105453096">UDP协议</a></li>
<li>14)<code>紧急指针字段</code>。占16 位，指出在本报文段中紧急数据共有多少字节(紧急数据放在本报文段数据的最前面)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011755349.png"/>

<p>15)<code>选项字段</code>。长度可变。TCP最初只规定了一种选项，即最大报文段长度(Maximum SegmentSize，MSS)。MSS是TCP报文段中的数据字段的最大长度。窗口扩大、时间戳、选择确认<br>16)<code>填充字段</code>。这是为了使整个首部长度是4B的整数倍。填充0</p>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><ul>
<li>TCP是面向连接的协议，因此每个TCP连接都有三个阶段:<code>连接建立、数据传送和连接释放</code>。</li>
<li><code>TCP连接的管理就是使运输连接的建立和释放都能正常进行</code>。</li>
</ul>
<p><strong>在TCP连接建立的过程中，要解决以下三个问题:</strong></p>
<ul>
<li>1)要使每一方都能够确知对方的存在。</li>
<li>2)要允许双方协商一些参数(如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等)。</li>
<li>3)能够对运输实体资源( 如缓存大小、连接表中的项目等)进行分配。</li>
</ul>
<p>每条TCP连接通过通信两端的<code>两个端点( 即两个套接字)</code>确定。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012046974.png"/>

<h4 id="TCP的三次握手-连接的建立"><a href="#TCP的三次握手-连接的建立" class="headerlink" title="*TCP的三次握手-连接的建立"></a>*TCP的三次握手-连接的建立</h4><ul>
<li>seq为序号字段，标明本次报文段数据部分的第一个字节的序号</li>
<li>ack是<code>确认号字段</code>，告诉对方我接下来应该接收的数据是从字节序号ack开始的数据</li>
<li>ACK是确认位,0时<code>确认号字段ack</code>无效，1时<code>确认号字段ack</code>有效</li>
<li>SYN是同步位</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012047854.png"/>

<ul>
<li>第一步:客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号 seq&#x3D; x(连接请求报文不携带数据，但要消耗一个序号)。</li>
<li>第二步:服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1,确认号字段的值为x+ 1, 并且服务器随机产生起始序号seq &#x3D; y(确认报文不携带数据,但也要消耗-一个序号)。确认报文段同样不包含应用层数据。</li>
<li>第三步:当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1,序号字段为x+1,确认号字段ack&#x3D;y+ 1。该报文段可以携带数据，若不携带数据则不消耗序号。<br>成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。</li>
</ul>
<p><strong>TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。</strong></p>
<ul>
<li>服务器端的资源是在完成第二次握手时分配的</li>
<li>而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</li>
</ul>
<h5 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h5><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。</p>
<p>攻击者发送TCP SYN,SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。</p>
<p>攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p>
<h4 id="TCP的四次挥手-连接的释放"><a href="#TCP的四次挥手-连接的释放" class="headerlink" title="*TCP的四次挥手-连接的释放"></a>*TCP的四次挥手-连接的释放</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012058140.png"/>

<ul>
<li>第一步:客户机打算关闭连接时，向其TCP发送一个连接释放报文段， 并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1, <code>seq=u, 它等于前面已传送过的数据的最后一个字节的序号加1</code> (FIN报文段即使不携带数据，也要消耗一个序号)。<br>TCP 是全双工的，即可以想象为一条TCP连接上有两条数据通路。<br>发送FIN报文时，发送FIN的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</li>
<li>第二步:服务器收到连接释放报文段后即发出确认，<code>确认号是ack=u+ 1,而这个报文段自己的序号是v,等于它前面已传送过的数据的最后一个字节的序号加1</code>。<br>此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。<br>但服务器若发送数据，客户机仍要接收，即<code>从服务器到客户机这个方向的连接并未关闭</code>。</li>
<li>第三步:若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其<code>发出FIN= 1的连接释放报文段</code>。</li>
<li>第四步:<code>客户机收到连接释放报文段后，必须发出确认</code>。在确认报文段中，ACK字段被置为1，确认号ack&#x3D;w+1,序号seq&#x3D;u+1.此时TCP连接还未释放，<code>必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态</code>。</li>
</ul>
<h4 id="TCP连接建立和释放的总结"><a href="#TCP连接建立和释放的总结" class="headerlink" title="TCP连接建立和释放的总结"></a>TCP连接建立和释放的总结</h4><ul>
<li><ol>
<li>连接建立。分为3步:<br>① SYN&#x3D;1，seq&#x3D;x。<br>② SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ack&#x3D;x+ 1。<br>③ ACK&#x3D;1，seq&#x3D;x+1, ack&#x3D;y+ 1。</li>
</ol>
</li>
<li><ol start="2">
<li>释放连接。分为4步:<br>① FIN&#x3D;1, seq&#x3D; u<br>② ACK&#x3D;1, seq&#x3D;v, ack&#x3D;u+ 1。<br>③ FIN&#x3D;1，ACK&#x3D;1, seq&#x3D;w，ack&#x3D;u+ 1。<br>④ ACK&#x3D;1, seq&#x3D;u+1, ack&#x3D;w+ 1。</li>
</ol>
</li>
</ul>
<p>关于连接和释放，ACK、 SYN、 FIN 一定等于1</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012102975.png"/>

<h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103517.png"/>

<h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103897.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103883.png"/>

<h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012104058.png"/>

<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul>
<li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为<code>接收窗口rwnd</code>, 即<code>调整TCP报文段首部中的“窗口”字段值</code>，来限制发送方向网络注入报文的速率。</li>
<li>同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<code>拥塞窗口cwnd</code>，其大小与网络的带宽和时延密切相关。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012110668.png"/>

<ul>
<li><code>例如</code>，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A。</li>
<li>rwnd 即接收方允许连续接收的最大能力，单位是字节。</li>
<li>发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存溢出。</li>
<li>当然，<code>A的发送窗口的实际大小取rwnd和cwnd中的最小值</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118546.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118055.png"/>

<p><strong>传输层和数据链路层的流量控制的区别是:</strong></p>
<ul>
<li>传输层定义<code>端到端</code>用户之间的流量控制，数据链路层定义<code>两个中间的相邻结点</code>的流量控制。</li>
<li>另外，<code>数据链路层</code>的滑动窗口协议的<code>窗口</code>大小<code>不能动态变化</code>，<code>传输层</code>的则可以<code>动态变化</code>。</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="1-什么是拥塞控制？"><a href="#1-什么是拥塞控制？" class="headerlink" title="1. 什么是拥塞控制？"></a>1. 什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">拥塞控制</a>？</h5><ul>
<li>所谓<code>拥塞控制，是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</code>。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。</li>
</ul>
<h5 id="2-拥塞控制与流量控制的区别"><a href="#2-拥塞控制与流量控制的区别" class="headerlink" title="2. 拥塞控制与流量控制的区别"></a>2. 拥塞控制与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">流量控制</a>的区别</h5><ul>
<li><code>拥塞控制</code>是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li><code>流量控制</code>往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012119412.png"/>

<ul>
<li><strong>例如：</strong></li>
<li>某个链路的传输速率为10Gb&#x2F;s,某巨型机向一台PC以1Gb&#x2F;s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行<code>流量控制</code>。</li>
<li>但若有100万台PC在此链路上以1Mb&#x2F;s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</li>
</ul>
<p><strong>为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下4种算法:<code>慢开始、拥塞避免、快重传、快恢复。</code></strong></p>
<h5 id="3-拥塞控制的4种算法"><a href="#3-拥塞控制的4种算法" class="headerlink" title="3. 拥塞控制的4种算法"></a>3. 拥塞控制的4种算法</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012121629.png"/>

<h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012122103.png"/>

<ul>
<li>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd&#x3D; 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加1,即增大一个 MSS.用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</li>
</ul>
<blockquote>
<p>例如，A向B发送数据，发送时A的拥塞窗口为2,那么A一次可以发送两个TCP报文段，经过一个RTT后(也称一个<code>传输轮次</code>)，A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。</p>
</blockquote>
<ul>
<li>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</li>
</ul>
<h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><ul>
<li>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过- -一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。</li>
<li>根据cwnd的大小执行不同的算法，可归纳如下:<br>●当cwnd &lt; ssthresh时，使用慢开始算法。<br>●当 cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>●当cwnd &#x3D; sthresh时，既可使用慢开始算法，又可使用拥塞避免算法(通常做法)。</li>
</ul>
<p><strong>网络拥塞的处理</strong></p>
<ul>
<li><p>网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生(未按时收到确认，重传计时器超时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。<br>然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
</li>
<li><p>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></p>
</li>
<li><p>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></p>
</li>
</ul>
<blockquote>
<p>在慢开始和拥塞避免算法中使用了<code>“乘法减小”和“加法增大”方法</code>。</p>
<ul>
<li><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</li>
<li><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢<br>增大，以防止网络过早出现拥塞。</li>
</ul>
</blockquote>
<h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><p><strong>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</strong></p>
<ul>
<li>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</li>
</ul>
<h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><p><strong>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</strong></p>
<ul>
<li><code>快恢复算法</code>的原理如下:</li>
<li>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</li>
<li>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</li>
<li><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</li>
</ul>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012127416.png"/>

<ul>
<li>在<code>流量控制</code>中，发送方发送数据的量由接收方决定，而在<code>拥塞控制</code>中，则由发送方自己通过检测网络状况来决定。</li>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<blockquote>
<p><code>注意：</code> <code>发送方发送窗口的实际大小</code>由<code>流量控制</code>和<code>拥塞控制</code>共同决定。<br>因此，当题目中同时出现接收端窗口(rwnd) 和拥塞窗口(cwnd) 时，发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012144530.png"/>

<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>客户&#x2F;服务器模型（Client&#x2F;Server)<br>P2P模型（Peer-to-peer)</p>
<h3 id="c-x2F-s模型（客户-x2F-服务器模型）"><a href="#c-x2F-s模型（客户-x2F-服务器模型）" class="headerlink" title="c&#x2F;s模型（客户&#x2F;服务器模型）"></a>c&#x2F;s模型（客户&#x2F;服务器模型）</h3><p>服务器：提供计算服务的设备。</p>
<ol>
<li><p>永久提供服务</p>
</li>
<li><p>永久性访问地址&#x2F;域名</p>
</li>
</ol>
<p>客户机：请求计算服务的主机。</p>
<ol>
<li><p>与服务器通信，使用服务器提供的服务</p>
</li>
<li><p>间歇性接入网络</p>
</li>
<li><p>可能使用动态IP地址</p>
</li>
<li><p>不与其他客户机直接通信</p>
</li>
</ol>
<p>应用：Web,文件传输FTP,远程登录，电子邮件</p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><ul>
<li><p>在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一一对计算机一称为<code>对等方(Peer)</code>， 直接相互通信。</p>
</li>
<li><p>P2P 模型从本质上来看仍然使用客户&#x2F;服务器方式，每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
</li>
<li><p>当前比较流行的P2P应用有PPlive、Bittorrent 和电驴等。</p>
</li>
<li><p>不存在永远在线的服务器</p>
</li>
<li><p>每个主机既可以提供服务，也可以请求服务</p>
</li>
<li><p>任意端系统&#x2F;节点之间可以直接通讯</p>
</li>
<li><p>节点间歇性接入网络</p>
</li>
<li><p>节点可能改变IP地址</p>
</li>
<li><p>可扩展性好</p>
</li>
<li><p>网络健壮性强</p>
</li>
</ul>
<p><strong>与C&#x2F;S模型相比，P2P 模型的优点主要体现如下:</strong></p>
<ul>
<li>1)减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率(例如，播放流媒体时对服务器的压力过大，而通过P2P模型，可以利用大量的客户机来提供服务)。</li>
<li>2)多个客户机之间可以直接共享文档。</li>
<li>3)可扩展性好，传统服务器有响应和带宽的限制，因此只能接受- -定 数量的请求。</li>
<li>4)网络健壮性强，单个结点的失效不会影响其他部分的结点。</li>
</ul>
<p><code>P2P模型也有缺点</code>。在获取服务的同时,还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。<br>例如，经常进行P2P下载还会对硬盘造成较大的损伤。据某互联网调研机构统计，当前P2P程序已占互联网50%~90%的流量，使网络变得非常拥塞，因此各大ISP (互联网服务2提供商，如电信、网通等)通常都对P2P应用持反对态度。</p>
<h2 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS(域名解析系统)"></a>DNS(域名解析系统)</h2><ul>
<li><code>域名系统(Domain Name System, DNS)</code>是因特网使用的命名系统，用来<code>把便于人们记忆的具有特定含义的主机名(如www.BitHachi.com)转换为便于机器处理的IP地址</code>。</li>
<li>相对于IP地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的计算机。</li>
<li>DNS系统采用客户&#x2F;服务器模型，其协议运行在<code>UDP</code>之上，使用<code>53</code>号端口。</li>
<li>从概念上可将DNS分为3部分:<code>层次域名空间、域名服务器和解析器</code>。</li>
</ul>
<p>某台主机访问网站<a target="_blank" rel="noopener" href="http://www.bithachi.cn网站为例,dns的大致流程/">www.bithachi.cn网站为例，DNS的大致流程</a></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148576.png"/>

<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul>
<li><code>因特网采用层次树状结构的命名方法</code>。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即<code>域名(Domain Name)</code>。</li>
<li><code>域(Domain)</code>是名字空间中一个可被管理的划分。</li>
<li>域还可以划分为子域，而子域还可以继续划分为子域的子域，这样就形成<br>了顶级域、二级域、三级域等。</li>
</ul>
<p><strong>在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理。</strong></p>
<ul>
<li>例如，管理CN域的中国将EDU.CN子域授权给中国教育和科研计算机网(CERNET)来管理。</li>
<li>比如我的域名bithachi.cn是一个二级域名，我可以任意分配三级域名，比如1001.bithachi.cn和1002.bithachi.cn，这两个网址是可以访问的，小项目。</li>
</ul>
<p><strong>域名空间的树状结构：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148271.png"/>

<p>每个域名都由<code>标号</code>序列组.成，而各标号之间用点<code>(“.”)</code>隔开。</p>
<p>$$<br><a target="_blank" rel="noopener" href="http://www.bithachi.cn/">www.BitHachi.cn</a>. &#x3D;&gt;(三级域名).(二级域名).(顶级域名).<br>$$<br>最后的一个点叫<strong>根</strong></p>
<p><strong>关于域名中的标号有以下几点需要注意:</strong></p>
<ul>
<li>1)标号中的英文<code>不区分大小写</code>。.</li>
<li>2)标号中除连字符(-) 外不能使用其他的标点符号。</li>
<li>3)每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符。</li>
<li>4)级别最低的域名写在最左边，级别最高的顶级域名写在最右边。</li>
</ul>
<p><code>顶级域名(Top Level Domain, TLD)</code>分为如下三大类:</p>
<ul>
<li>1)国家顶级域名(nTLD)。国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，.uk”表示英国。</li>
<li>2)通用顶级域名(gTLD)。 常见的有“.com” (公司)、“.net” (网络服务机构)、“.org”(非营利性组织)和“.gov” (国家或政府部门)等。</li>
<li>3)基础结构域名。<code>这种顶级域名只有一个，即arpa,用于反向域名解析</code>，因此又称反向域名。<code>反向域名解析与通常的正向域名解析相反，提供IP地址到域名的对应</code>，反向域名格式如：X.X.X.in-addr.arpa。很多网络服务提供商要求访问的IP地址具有反向域名解析的结果，否则不提供服务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">国家顶级域名下注册的二级域名均由该国家自行确定。</span><br></pre></td></tr></table></figure>

<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><ul>
<li><code>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型</code>。</li>
<li>域名到IP地址的解析是由运行在域名服务器上的程序完成的，<code>一个服务器所负责管辖的(或有权限的)范围称为区(不以“域”为单位)</code>，各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，每个区设置相应的<code>权限域名服务器</code>，用来保存该区中的所有主机的域名到IP地址的映射。</li>
<li>每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器。</li>
<li>DNS使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上。</li>
<li>采用分布式设计的DNS，是一个在因特网上实现分布式数据库的精彩范例。主要有4种类型的域名服务器。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012150621.png"/>

<h4 id="（1）根域名服务器"><a href="#（1）根域名服务器" class="headerlink" title="（1）根域名服务器"></a>（1）根域名服务器</h4><ul>
<li><code>根域名服务器</code>是<code>最高层次</code>的域名服务器，所有的<code>根域名服务器</code>都知道<code>所有</code>的<code>顶级域名服务器的IP地址</code>。</li>
<li>根域名服务器也是最重要的域名服务器，不管是哪个<code>本地域名服务器</code>，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先要求助于<code>根域名服务器</code>。</li>
<li>因特网上有<code>13个根域名服务器</code>，尽管我们将这13个根域名服务器中的每个都视为单个服务器，但<code>每个“服务器”实际上是冗余服务器的集群</code>，以提供安全性和可靠性。</li>
<li>需要注意的是，<code>根域名服务器</code>用来<code>管辖顶级域(如.com)</code>， 通常它并不直接把待查询的域名直接转换成IP地址，而是<code>告诉本地域名服务器</code>下一步应当找哪个<code>顶级域名服务器</code>进行查询。</li>
</ul>
<h4 id="（2）顶级域名服务器"><a href="#（2）顶级域名服务器" class="headerlink" title="（2）顶级域名服务器"></a>（2）顶级域名服务器</h4><ul>
<li>这些域名服务器负责<code>管理在该顶级域名服务器注册的所有二级域名</code>。</li>
<li>收到DNS查询请求时,就给出相应的回答(可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址)。</li>
</ul>
<h4 id="（3）授权域名服务器-权限域名服务器"><a href="#（3）授权域名服务器-权限域名服务器" class="headerlink" title="（3）授权域名服务器(权限域名服务器)"></a>（3）授权域名服务器(权限域名服务器)</h4><ul>
<li><code>每台主机</code>都必须在<code>授权域名服务器</code>处登记。为了更加可靠地工作，一台主机最好至少有两个授权域名服务器。</li>
<li>实际上，许多<code>域名服务器</code>都<code>同时</code>充当<code>本地域名服务器</code>和<code>授权域名服务器</code>。</li>
<li><code>授权域名服务器</code>总能将其管辖的<code>主机名</code>转换为该主机的<code>IP地址</code>。</li>
</ul>
<h4 id="（4）本地域名服务器"><a href="#（4）本地域名服务器" class="headerlink" title="（4）本地域名服务器"></a>（4）本地域名服务器</h4><ul>
<li>本地域名服务器对域名系统非常重要。</li>
<li>每个因特网服务提供者(ISP)， 或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。</li>
<li><code>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</code>。</li>
<li>事实上，我们在Windows系统中配置<code>“本地连接”</code>时，就需要填写DNS地址，这个地址就是<code>本地DNS (域名服务器)的地址</code>。</li>
</ul>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><ul>
<li><code>域名解析是指把域名映射成为IP地址或把IP地址映射成域名的过程。前者称为正向解析，后者称为反向解析。</code></li>
<li>当客户端需要域名解析时，通过本机的DNS客户端构造一个<code>DNS请求报文</code>，以<code>UDP数据报</code>方式发往<code>本地域名服务器</code>。</li>
<li>域名解析有两种方式:<code>递归查询</code>和<code>递归与迭代</code>相结合的查询。</li>
</ul>
<h4 id="递归查询方式"><a href="#递归查询方式" class="headerlink" title="递归查询方式"></a>递归查询方式</h4><ul>
<li><strong>递归查询的过程如下图所示</strong>， 由于该方法给根域名服务造成的负载过大，所以在实际中几乎不使用。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152913.png"/>

<p><strong>常用递归与迭代相结合的查询方式如下图所示，该方式分为两个部分。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152357.png"/>

<p><strong>(1)<code>主机</code>向<code>本地域名服务器</code>的查询采用的是<code>递归</code>查询</strong></p>
<ul>
<li>也就是说，如果<code>本地主机</code>所询问的<code>本地域名服务器</code>不知道被查询域名的IP 地址，那么<code>本地域名服务器</code>就以<code>DNS客户</code>的身份，向<code>根域名服务器</code>继续发出<code>查询请求报文</code>(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。</li>
<li>在这种情况下，<code>本地域名服务器</code>只需向<code>根域名服务器查询</code>一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的[见图6.6(a)中的步骤③~⑥]。</li>
<li>在步骤⑦中，<code>本地域名服务器</code>从<code>根域名服务器</code>得到了所需的<code>IP地址</code>,最后在步骤⑧中，<code>本地域名服务器</code>把查询结果告诉<code>主机</code>m.xyz.com.</li>
</ul>
<p><strong>(2)<code>本地域名服务器</code>向<code>根域名服务器</code>的查询采用<code>迭代</code>查询</strong></p>
<ul>
<li>当<code>根域名服务器</code>收到<code>本地域名服务器</code>发出的<code>迭代查询请求报文</code>时，要么给出所要查询的IP地址，要么告诉<code>本地域名服务器</code>:“你下一步应当向哪个<code>顶级域名服务器</code>进行查询”。</li>
<li>然后让<code>本地域名服务器</code>向这个<code>顶级域名服务器</code>进行后续的查询，如图6.6(b)所示。</li>
<li>同样，<code>顶级域名服务器</code>收到查询报文后，要么给出所要查询的IP地址，要么告诉<code>本地域名服务器</code>下一步应向哪个·权限域名服务器·查询。</li>
<li>最后，知道所要<code>解析的域名的IP地址</code>后，把这个<code>结果返回</code>给发起查询的<code>主机</code>。</li>
</ul>
<p><strong><code>下面举例说明域名解析的过程:</code></strong><br><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012153295.png"/>

<blockquote>
<ul>
<li>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<code>高速缓存</code>。</li>
<li>当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速<br>缓存中。这样，当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问。</li>
<li>因为<code>主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息</code>。</li>
</ul>
</blockquote>
<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><ul>
<li>文件传输协议( File Transfer Protocol, FTP)是因特网上使用得最广泛的<code>文件传输协议。</code></li>
<li>FTP提供<code>交互式的访问</code>，允许客户指明文件的类型与格式，并允许文件具有<code>存取权限</code>。</li>
<li>它屏蔽了各计算机系统的细节，因而适合于在异构网络中的<code>任意计算机之间传送文件</code>。</li>
</ul>
<p><strong>FTP提供以下功能:</strong><br>①提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力。<br>②<code>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</code>。<br>③以<code>匿名FTP</code>的方式提供<code>公用文件共享</code>的能力。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154629.png"/>

<h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><ul>
<li>FTP采用客户&#x2F;服务器（C&#x2F;S）的工作方式，它使用TCP可靠的传输服务。</li>
<li>一个FTP服务器进程可同时为多个客户进程提供服务。</li>
<li>依照FTP协议提供服务，进行文件传送的计算机就是<code>FTP服务器</code>。</li>
<li>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是<code>FTP客户端</code>。</li>
<li><code>FTP的服务器进程</code>由两大部分组成:<br><code>一个主进程，负责接收新的请求;</code><br><code>若干从属进程，负责处理单个请求。</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154870.png"/>

<hr>

<p><strong>其工作步骤如下:</strong><br>①打开熟知端口21 (控制端口)，使客户进程能够连接上。<br>②等待客户进程发连接请求。<br>③启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。<br>④回到等待状态，继续接收其他客户进程的请求。</p>
<hr>

<ul>
<li>FTP服务器必须在整个会话期间保留用户的状态信息。<br>特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。</li>
</ul>
<h3 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h3><ul>
<li>FTP在工作时使用两个<code>并行的TCP连接</code>:<br>一个是<code>控制连接(端口号21)</code>，<br>一个是<code>数据连接(端口号20)</code>。</li>
<li>使用两个不同的端口号可使协议更加简单和更容易实现。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155883.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155920.png"/>

<p><strong>1.控制连接</strong></p>
<ul>
<li>服务器监听21号端口，等待客户连接，建立在这个端口.上的连接称为控制连接，<code>控制连接用来传输控制信息(如连接请求、传送请求等)</code>，并且<code>控制信息都以7位ASCII格式传送</code>。</li>
<li>FTP客户发出的<code>传送请求</code>，<code>通过控制连接发送给服务器端的控制进程,但控制连接并不用来传送文件。</code></li>
<li>在传输文件时还可以使用控制连接(如客户在传输中途发一个中止传输的命令)，因此控制连接在整个会话期间一直保持打开状态。</li>
</ul>
<p><strong>2.数据连接</strong></p>
<ul>
<li><code>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。</code></li>
<li><code>数据连接</code>用来<code>连接客户端和服务器端的数据传送进程</code>，<code>数据传送进程</code>实际<code>完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</code></li>
</ul>
<hr>
<ul>
<li>因为FTP使用了一个分离的控制连接，所以<code>也称FTP的控制信息是带外(Out-of-band) 传送的。</code></li>
<li>使用FTP时，<code>若要修改服务器上的文件，则需要先将此文件传送到本地主机,然后再将修改后的文件副本传送到原服务器</code>。</li>
<li>网络文件系统(NFS)允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</li>
</ul>
<h2 id="SMTP-POP3-IMAP-MIME…"><a href="#SMTP-POP3-IMAP-MIME…" class="headerlink" title="SMTP,POP3,IMAP,MIME…."></a>SMTP,POP3,IMAP,MIME….</h2><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><ul>
<li>一个电子邮件分为<code>信封和内容</code>两大部分，邮件<code>内容</code>又<code>分为首部和主体</code>两部分。</li>
<li>RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。</li>
<li>用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。</li>
<li><code>邮件内容的首部包含一些首部行</code>，<code>每个首部行由一个关键字后跟冒号再后跟值组成。</code>有些关键字是必需的，有些则是可选的。最重要的关键字是To:和Subject。</li>
<li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。<br>电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名<br>如<a href="mailto:&#x61;&#98;&#99;&#64;&#x63;&#115;&#x6b;&#x61;&#111;&#x79;&#97;&#x6e;&#46;&#99;&#x6f;&#109;">&#x61;&#98;&#99;&#64;&#x63;&#115;&#x6b;&#x61;&#111;&#x79;&#97;&#x6e;&#46;&#99;&#x6f;&#109;</a>,其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的 。这也就保证了<a href="mailto:&#x61;&#x62;&#x63;&#64;&#99;&#115;&#107;&#97;&#111;&#x79;&#97;&#x6e;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#x62;&#x63;&#64;&#99;&#115;&#107;&#97;&#111;&#x79;&#97;&#x6e;&#46;&#x63;&#x6f;&#x6d;</a> 这个邮件<br>地址在整个因特网上是唯一的。</li>
<li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。</li>
<li>还有一个必填的关键字是From,但它通常由邮件系统自动填入。</li>
<li>首部与主体之间用一个空行进行分割。典型的邮件内容如下:</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157298.png"/>

<h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><ul>
<li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157757.png"/>

<hr>

<ul>
<li>一个 电子邮件系统应具有三个最主要的组成构件：<br>用户代理(User Agent)<br>邮件服务器<br>电子邮件使用的协议，如SMTP、POP3 (或IMAP)等。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157575.png"/>

<p><code>用户代理(UA):</code>用户与电子邮件系统的接口。</p>
<ul>
<li>用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的功能。</li>
<li>通常情况下，用户代理就是一个运行在PC.上的程序，常见的有Outlook、Foxmail 和Thunderbird等。</li>
</ul>
<p><code>邮件服务器:</code>组成电子邮件系统的核心。</p>
<ul>
<li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况(已交付、被拒绝、丢失等)。</li>
<li>邮件服务器采用客户&#x2F;服务器方式工作，但它能够同时充当客户和服务器。</li>
<li>例如，当邮件服务器A向邮件服务器B发送邮件时，A就作为SMTP客户，而B是SMTP服务器;反之，当B向A发送邮件时，B就是SMTP客户，而A就是SMTP服务器。</li>
</ul>
<p><strong>邮件发送协议和读取协议</strong>:</p>
<ul>
<li><code>邮件发送协议</code>用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用的是<code>SMTP</code>;</li>
<li><code>邮件读取协议</code>用于用户代理从邮件服务器读取邮件，如<code>POP3</code>。</li>
<li>SMTP采用的是“推”(Push)的通信方式，即在用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP客户端主动将邮件“推”送到SMTP服务器端。</li>
<li>POP3采用的是“拉”(Pull)的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
</ul>
<h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158446.png"/>

<ul>
<li>发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定 时间对邮件缓存扫描一次。<br>如发现有邮件，就使用SMTP的熟知端口号(25) 与接收方邮件服务器的SMTP服务器建立TCP连接。</li>
<li>连接建立后，接收方SMTP服务器发出220 Service ready (服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li>
<li>SMTP不使用中间邮件服务器。<br>TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远。<br>接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158231.png"/>

<p><strong>邮件发送</strong></p>
<ul>
<li>连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL 命令后面有发件人的地址。如MAIL FROM: <a href="mailto:hoopdog@hust.edu.cn">hoopdog@hust.edu.cn</a>。</li>
<li>若SMTP服务器已准备好接收邮件，则回答250 OK。</li>
<li>接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令，格式为RCPTTO: &lt;收件人地址&gt;。<br>每发送一个 RCPT命令，都应有相应的信息从SMTP服务器返回，如250 OK或550 No such user here (无此用户)。<br>RCPT命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。</li>
<li>获得0K的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。<br>正常情况下，SMTP服务器回复信息是354 Start mail input; end with . 。表示回车换行。此时SMTP客户端就可开始传送邮件内容，并用. (两个回车，中间一个点)表示邮件内容的结束。</li>
</ul>
<p><strong>释放连接</strong></p>
<ul>
<li>邮件发送完毕后，SMTP客户应发送QUIT命令。</li>
<li>SMTP服务器返回的信息是221 (服务关闭)，表示SMTP同意释放TCP连接。邮件传送的全部过程就此结束。</li>
</ul>
<h4 id="MIME—多用途网络邮件扩充"><a href="#MIME—多用途网络邮件扩充" class="headerlink" title="MIME—多用途网络邮件扩充"></a>MIME—多用途网络邮件扩充</h4><ul>
<li>由于SMTP只能传送一定长度的ASCII码，许多其他非英语国家的文字(如中文、俄文，甚至带重音符号的法文或德文)就无法传送，且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充( Multipurpose Internet MailExtensions，MIME)。</li>
<li>MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。也就是说，MIME邮件可在现有的电子邮件程序和协议下传送。MIME与SMTP的关系如图</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012159989.png"/>

<p><strong>MIME主要包括以下三部分内容:</strong></p>
<ul>
<li>①5个新的邮件首部字段，包括MIME版本、内容 描述、内容标识、内容传送编码和内容类型。</li>
<li>②定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>③定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ul>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200877.png"/>

<ul>
<li>邮局协议( Post Office Protocol, POP) 是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3。</li>
<li>POP3 采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
<li>POP也使用客户&#x2F;服务器的工作方式，在传输层使用TCP,端口号为110。接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序。</li>
<li>POP有两种工作方式:<code>“下载并保留”和“下载并删除”。</code><br>在<code>“下载并保留”</code>方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件;<br>使用<code>“下载并删除”</code>方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。</li>
</ul>
<h4 id="IMAP-因特网报文存取协议"><a href="#IMAP-因特网报文存取协议" class="headerlink" title="IMAP-因特网报文存取协议"></a>IMAP-因特网报文存取协议</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200164.png"/>

<ul>
<li>另一个邮件接收协议是<code>因特网报文存取协议(IMAP)</code>,它比POP复杂得多，IMAP为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此<code>IMAP服务器维护了会话用户的状态信息</code>。</li>
<li>IMAP的另一特性是<code>允许用户代理只获取报文的某些部分</code>，例如可以只读取一个报文的首部,或一个多部分MIME报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。</li>
</ul>
<h3 id="万维网的电子邮件"><a href="#万维网的电子邮件" class="headerlink" title="万维网的电子邮件"></a>万维网的电子邮件</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012201443.png"/>

<ul>
<li>随着万维网的流行，目前出现了很多基于万维网的电子邮件，如Hotmail、Gmail 等。</li>
<li>这种电子邮件的特点是，用户浏览器与Hotmail或Gmail的邮件服务器之间的邮件发送或接收使用的是HTTP，而<code>仅在不同邮件服务器之间传送邮件时才使用SMTP.</code></li>
</ul>
<h2 id="万维网（www）和HTTP协议"><a href="#万维网（www）和HTTP协议" class="headerlink" title="*万维网（www）和HTTP协议"></a>*万维网（www）和HTTP协议</h2><h3 id="万维网WWW协议"><a href="#万维网WWW协议" class="headerlink" title="万维网WWW协议"></a>万维网WWW协议</h3><p>URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置</p>
<p>HTTP用来将这些资源传送给用户</p>
<p>HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012202965.png"/>

<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>服务器通过TCP 80端口来监听HTTP请求</p>
<p><strong>注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分</strong>，其他音频视频等待用户下一步请求之后再传输</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203168.png"/>

<h4 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203522.png"/>

<h4 id="HTTP的连接方式-持久连接和非持久连接"><a href="#HTTP的连接方式-持久连接和非持久连接" class="headerlink" title="HTTP的连接方式-持久连接和非持久连接"></a>HTTP的连接方式-持久连接和非持久连接</h4><p>非持久连接在TCP三次握手的<strong>第三次握手时发生</strong>，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。<br>缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始</p>
<p>持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012204214.png"/>

<h4 id="持久连接的两种方式——非流水线和流水线"><a href="#持久连接的两种方式——非流水线和流水线" class="headerlink" title="持久连接的两种方式——非流水线和流水线"></a>持久连接的两种方式——非流水线和流水线</h4><p>非流水线就是发一个，确认一个，才能再发下一个<br>流水线就是一个个连着发，然后多个确认<br>和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下</p>
<h4 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h4><p>开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样</p>
<p>请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取&#x2F;删除等等<br>URL就是之间说的资源标识符<br>版本是指使用的是什么版本的HTTP协议</p>
<p>CRLF相当于我们程序里面的<code>；</code>，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205051.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205842.png"/>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%80%83%E7%A0%94408/" rel="tag"># 考研408</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="prev" title="数据库原理知识点总结">
      <i class="fa fa-chevron-left"></i> 数据库原理知识点总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="计算机操作系统">
      计算机操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.</span> <span class="nav-text">传输层提供的服务及功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E5%AF%BB%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">传输层的寻址与端口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">（1）端口的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">（2）端口号的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">（3）套接字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5UDP%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5TCP%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.3.</span> <span class="nav-text">无连接UDP和面向连接TCP服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP"><span class="nav-number">1.3.1.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">UDP的主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">UDP首部格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E4%BC%A0%E8%BE%93%E5%B1%82%E4%BB%8EIP%E5%B1%82%E6%94%B6%E5%88%B0UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%97%B6"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">当传输层从IP层收到UDP数据报时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E6%A0%A1%E9%AA%8C"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">UDP校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">1.3.2.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">TCP的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">TCP报文段的首部格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">TCP连接管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">*TCP的三次握手-连接的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SYN%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="nav-number">1.3.2.4.1.</span> <span class="nav-text">SYN洪泛攻击</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">*TCP的四次挥手-连接的释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%87%8A%E6%94%BE%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">TCP连接建立和释放的总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%8F%E5%8F%B7"><span class="nav-number">1.3.2.7.1.</span> <span class="nav-text">序号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4"><span class="nav-number">1.3.2.7.2.</span> <span class="nav-text">确认</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E4%BC%A0"><span class="nav-number">1.3.2.7.3.</span> <span class="nav-text">重传</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.2.8.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.2.9.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="nav-number">1.3.2.9.1.</span> <span class="nav-text">1. 什么是拥塞控制？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.9.2.</span> <span class="nav-text">2. 拥塞控制与流量控制的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%844%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.2.9.3.</span> <span class="nav-text">3. 拥塞控制的4种算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B"><span class="nav-number">1.3.2.9.3.1.</span> <span class="nav-text">慢开始</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">1.3.2.9.3.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0"><span class="nav-number">1.3.2.9.3.3.</span> <span class="nav-text">快重传</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">1.3.2.9.3.4.</span> <span class="nav-text">快恢复</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">网络应用模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c-x2F-s%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%AE%A2%E6%88%B7-x2F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">c&#x2F;s模型（客户&#x2F;服务器模型）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2P%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">P2P模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.2.</span> <span class="nav-text">DNS(域名解析系统)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">域名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">域名服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">（1）根域名服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">（2）顶级域名服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%8E%88%E6%9D%83%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%9D%83%E9%99%90%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">（3）授权域名服务器(权限域名服务器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">（4）本地域名服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">域名解析过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">递归查询方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.3.</span> <span class="nav-text">FTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FTP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.1.</span> <span class="nav-text">FTP工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.3.2.</span> <span class="nav-text">控制连接和数据连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SMTP-POP3-IMAP-MIME%E2%80%A6"><span class="nav-number">2.4.</span> <span class="nav-text">SMTP,POP3,IMAP,MIME….</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%BF%A1%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">电子邮件的信息格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.2.</span> <span class="nav-text">电子邮件系统的组成结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.4.3.</span> <span class="nav-text">电子邮件协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMTP"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">SMTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MIME%E2%80%94%E5%A4%9A%E7%94%A8%E9%80%94%E7%BD%91%E7%BB%9C%E9%82%AE%E4%BB%B6%E6%89%A9%E5%85%85"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">MIME—多用途网络邮件扩充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POP3"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">POP3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMAP-%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8A%A5%E6%96%87%E5%AD%98%E5%8F%96%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">IMAP-因特网报文存取协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">2.4.4.</span> <span class="nav-text">万维网的电子邮件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E7%BB%B4%E7%BD%91%EF%BC%88www%EF%BC%89%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.5.</span> <span class="nav-text">*万维网（www）和HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%87%E7%BB%B4%E7%BD%91WWW%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.5.1.</span> <span class="nav-text">万维网WWW协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.5.2.</span> <span class="nav-text">HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">HTTP协议的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%9D%9E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">HTTP的连接方式-持久连接和非持久连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E9%9D%9E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">持久连接的两种方式——非流水线和流水线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%9A%84%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">HTTP的报文结构</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
