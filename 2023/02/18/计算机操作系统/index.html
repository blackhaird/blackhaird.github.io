<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录 目录 计算机系统概述 简介 操作系统的功能和目标 操作系统的四个特征 操作系统的运行机制和体系结构 指令 CPU 程序 操作系统的内核   中断和异常 概念和作用 分类   系统调用 含义 作用 系统调用和库函数的区别 其他     进程管理 进程的定义，组成，组织方式，特征 进程 进程的组织方式 进程的特征   进程的状态和转换 状态 转换   进程控制 含义 实现 相关原语   进程通信">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统">
<meta property="og:url" content="http://example.com/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:description" content="目录 目录 计算机系统概述 简介 操作系统的功能和目标 操作系统的四个特征 操作系统的运行机制和体系结构 指令 CPU 程序 操作系统的内核   中断和异常 概念和作用 分类   系统调用 含义 作用 系统调用和库函数的区别 其他     进程管理 进程的定义，组成，组织方式，特征 进程 进程的组织方式 进程的特征   进程的状态和转换 状态 转换   进程控制 含义 实现 相关原语   进程通信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181513303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181514707.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181515691.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181520216.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181523855.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201633291.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201634493.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201635642.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201638848.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640201.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640665.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121229670.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201648777.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201704327.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121237633.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121238008.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121239248.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121240249.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201843057.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201847528.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201849801.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121248665.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201852799.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121252713.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121253934.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201913689.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201917778.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201918142.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121258062.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201923361.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201924752.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201926432.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202014458.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202048883.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251342602.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251358421.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282350043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282351880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282359512.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091148134.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091154224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091158727.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091200387.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516619.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516916.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518466.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261531895.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261532635.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072113564.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072114497.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072115578.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072117802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072118787.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119845.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119979.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119956.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119961.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123688.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124996.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124492.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125799.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125176.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125944.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126626.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126279.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072127517.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072128379.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072129588.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072130399.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061307159.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081538138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061302897.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061316431.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317519.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317630.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081539943.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061319738.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061320350.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321161.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321531.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061323512.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061326837.png">
<meta property="article:published_time" content="2023-02-18T05:27:36.000Z">
<meta property="article:modified_time" content="2023-05-06T05:26:51.492Z">
<meta property="article:author" content="MEIDE">
<meta property="article:tag" content="考研408">
<meta property="article:tag" content="计算机操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181513303.png">

<link rel="canonical" href="http://example.com/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机操作系统 | MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 13:27:36" itemprop="dateCreated datePublished" datetime="2023-02-18T13:27:36+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-06 13:26:51" itemprop="dateModified" datetime="2023-05-06T13:26:51+08:00">2023-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">计算机系统概述</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87">操作系统的功能和目标</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81">操作系统的四个特征</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">操作系统的运行机制和体系结构</a><ul>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a></li>
<li><a href="#cpu">CPU</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F">程序</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8">操作系统的内核</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8">中断和异常</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8">概念和作用</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>系统调用和库函数的区别</strong></a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%84%E6%88%90%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%89%B9%E5%BE%81">进程的定义，组成，组织方式，特征</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F">进程的组织方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2">进程的状态和转换</a><ul>
<li><a href="#%E7%8A%B6%E6%80%81">状态</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2">转换</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-1">含义</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD">相关原语</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-2">含义</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1">共享存储，消息传递，管道通信。</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">线程概念和多线程模型</a><ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB">线程分类</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">多线程模型</a><ul>
<li><a href="#%E5%A4%9A%E5%AF%B91%E6%A8%A1%E5%9E%8B">多对1模型</a></li>
<li><a href="#1%E5%AF%B91%E6%A8%A1%E5%9E%8B">1对1模型</a></li>
<li><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B">多对多模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1">处理机调度的概念和层次</a><ul>
<li><a href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%88%9D%E7%BA%A7%E8%B0%83%E5%BA%A6">高级调度，中级调度，初级调度。</a><ul>
<li><a href="#1%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6">1.高级调度</a></li>
<li><a href="#2%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6">2.中级调度</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B">补充知识：进程的七状态模型</a></li>
</ul>
</li>
<li><a href="#3%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6">3.低级调度</a></li>
<li><a href="#%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%AF%B9%E6%AF%94">三种调度的联系和对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%B9%E5%BC%8F">进程调度的时机，切换过程和方式</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">进程调度时机</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B">进程的切换与过程</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">调度算法的评价指标</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">调度算法</a><ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E9%AB%98%E5%93%8D%E5%BA%94%E5%BF%85%E4%BC%98%E5%85%88">先来先服务，短作业优先，高响应必优先</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85">补充：</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">时间片轮转调度，优先级调度算法，多级反馈队列调度算法</a><ul>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6rr">时间片轮转调度RR</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">优先级调度算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级反馈队列调度算法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程同步与进程互斥</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程互斥</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的软件实现方法</a><ul>
<li><a href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95">单标志法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95">双标志先检查法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95">双标志后检查法</a></li>
<li><a href="#peterson%E7%AE%97%E6%B3%95">Peterson算法</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的硬件实现方法</a><ul>
<li><a href="#testandset%E6%8C%87%E4%BB%A4">TestAndSet指令</a></li>
<li><a href="#swap%E6%8C%87%E4%BB%A4">Swap指令</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81">进程互斥：锁</a><ul>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81-1">互斥锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6">信号量机制</a><ul>
<li><a href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F">整形信号量</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">记录型信号量</a></li>
<li><a href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">用信号量实现进程互斥，同步，前驱关系</a><ul>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">信号量机制实现进程互斥</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">信号量机制实现进程同步</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">信号量机制实现前驱关系</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者——消费者问题</a></li>
<li><a href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85">多生产者——多消费者</a></li>
<li><a href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98">吸烟者问题</a></li>
<li><a href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">读者——写者问题</a></li>
<li><a href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD">哲学家吃饭</a></li>
<li><a href="#%E7%AE%A1%E7%A8%8B">管程</a><ul>
<li><a href="#java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">java中类似于管程的机制（单例模式）</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a><ul>
<li><a href="#%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB">死锁，饥饿，死循环的区别</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁产生的必要条件</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81">什么时候会发生死锁</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">死锁的处理策略</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ol>
<li><p>作为系统资源的管理者</p>
<ul>
<li><p>文件管理</p>
</li>
<li><p>内存管理</p>
</li>
<li><p>处理及（CPU）管理</p>
</li>
<li><p>设备（计算机硬件，例如摄像头）管理</p>
</li>
</ul>
</li>
<li><p>作为用户和计算机硬件之间的接口</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181513303.png"/>


</li>
<li><p>对硬件机器的扩展</p>
</li>
</ol>
<h2 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a>操作系统的四个特征</h2><ol>
<li><p>并发</p>
<p>并发是指<strong>两个或多个事件在同一时间间隔内发生</strong>。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p>
<p><span style="color:red">易混淆的概念——并行：两个或多个事件在同一时刻同时发生</span></p>
</li>
<li><p>共享</p>
<p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p>
<table>
<thead>
<tr>
<th>两种资源共享方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>互斥共享方式</td>
<td>系统中的某些资源，虽然可以提供给多个进程使用，<br><span style="color:red">但<strong>一个时间段内只允许一个进程访问该资源</strong></span></td>
</tr>
<tr>
<td>同时共享方式</td>
<td>系统中的某些资源，<br><span style="color:red"><strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></span></td>
</tr>
</tbody></table>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p>
<p>例如：</p>
<ul>
<li><p>互斥共享方式：使用QQ和微信进行视频，但是同一个时间段内摄像头只能分配给其中一个进程</p>
</li>
<li><p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></p>
</li>
</ul>
</li>
<li><p>虚拟</p>
<p>虚拟是指把一个屋里上的实体变成若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<table>
<thead>
<tr>
<th>虚拟技术</th>
<th>例如</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空分复用技术</td>
<td>虚拟存储器技术</td>
<td></td>
</tr>
<tr>
<td>时分复用技术</td>
<td>虚拟处理器</td>
<td>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<span style="color:red"><strong>没有并发性，就谈不上虚拟性</strong></span></td>
</tr>
</tbody></table>
</li>
<li><p>异步</p>
<p>异步是指,在多道程序环境下，<strong>允许多个程序并发执行</strong>，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<ul>
<li>只有系统拥有并发性，才有可能导致异步性。</li>
</ul>
</li>
</ol>
<h2 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>特权指令</td>
<td>如内存清零指令（不允许用户程序使用）</td>
</tr>
<tr>
<td>非特权指令</td>
<td>如普通的运算指令</td>
</tr>
</tbody></table>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><table>
<thead>
<tr>
<th>两种处理器状态</th>
<th>(用程序状态字寄存器（PSW)中的某 标志位来标识当前处理器处于什么状 态。如0为用户态，1为核心态)</th>
</tr>
</thead>
<tbody><tr>
<td>用户态（目态）</td>
<td>此时CPU只能执行非特权指令</td>
</tr>
<tr>
<td>核心态（管态）</td>
<td>特权指令、非特权指令都可执行</td>
</tr>
</tbody></table>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table>
<thead>
<tr>
<th>两种程序</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内核程序</td>
<td>操作系统的内核程序是系统的管理者，即可执行特权指令，也可以执行非特权指令，运行也在核心态</td>
</tr>
<tr>
<td>应用程序</td>
<td>为了保证系统能安全运行，普通应用程序只能执行费特权指令，运行在用户态</td>
</tr>
</tbody></table>
<h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>由于内核划分功能的不同，内核分为大内核和微内核</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181514707.png"/>

<ul>
<li><p>大内核和微内核的优缺点</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181515691.png"/></li>
</ul>
<p>类比：</p>
<ul>
<li>操作系统的体系结构问题与企业的管理问题很相似。</li>
<li>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</li>
<li>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</li>
<li>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</li>
</ul>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><p><strong>中断</strong>是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li>
<li>对于不同的中断信号，会进行不同的处理。</li>
<li>有了中断，才能实现多道程序并发执行。</li>
<li>“用户态→核心态”是通过中断实现的，<strong>并且中断是唯一途径</strong>。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p> 中断型号的来源来自CPU内部称为内中断，外部称为外中断。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181520216.png"/>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181523855.png"/>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证操作系统的稳定性和安全性，防止用户进行非法操作。</p>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h3><p>编程语言（C、JAVA）中里边有很多库函数，其实他们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li>
<li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进行核心态。</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，组成，组织方式，特征"><a href="#进程的定义，组成，组织方式，特征" class="headerlink" title="进程的定义，组成，组织方式，特征"></a>进程的定义，组成，组织方式，特征</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序：就是指令序列</p>
<p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p>
<p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p>
<p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p>
<p><strong>PCB是进程存在的唯一标识。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201633291.png"/>



<h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p>
<p>相当于java中的链表和数组。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201634493.png"/>

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201635642.png"/>



<h2 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201638848.png"/>

<p>除此之外，进程还有两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640201.png"/>

<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640665.png"/>

<blockquote>
<p>注意：<strong>不能由阻塞态直接转换为运行态也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121229670.png"/>

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>进程控制就是要<strong>实现进程状态转换</strong>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</p>
<p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 <strong>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201648777.png"/>

<p>那么原语是如何实现进程状态的转换呢？</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>a.所有的进程控制原语一定都会修改进程状态标志<br>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c.某进程开始运行前必然要恢复期运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配&#x2F;回收资源</li>
</ol>
<p>具体实现如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201704327.png"/>

<h3 id="相关原语"><a href="#相关原语" class="headerlink" title="相关原语"></a>相关原语</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121237633.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121238008.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121239248.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121240249.png"/>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>进程通信就是<strong>进程间的信息交换</strong></p>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p>
<h3 id="共享存储，消息传递，管道通信。"><a href="#共享存储，消息传递，管道通信。" class="headerlink" title="共享存储，消息传递，管道通信。"></a>共享存储，消息传递，管道通信。</h3><ol>
<li><p>共享存储</p>
<p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式<br><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</p>
<p>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的（互斥访问通过操作系统提供的工具实现）<br>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201843057.png"/>
</li>
<li><p>管道通信</p>
</li>
</ol>
<blockquote>
<p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
<p>2.各进程要互斥地访问管道。</p>
<p>3.数据以字符流的形式写入管道，当管道<strong>写满时</strong>，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。</p>
<p>4.<strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></p>
<p>5．数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个，否则可能会有读错数据的情况。</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201847528.png"/>

<ol start="3">
<li><p>消息传递</p>
<p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p>
<p>类似于Http协议。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201849801.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121248665.png"/></li>
</ol>
<h2 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h2><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能<strong>串行</strong>执行一系列程序。因此，引入“线程”，来增加并发度。</p>
<ul>
<li>可以把线程理解为轻量级的进程。</li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</li>
<li>引入线程后，进程作为除CPU之外的系统资源的分配单元。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201852799.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121252713.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121253934.png"/></p>
<h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><ol>
<li>用户级线程</li>
</ol>
<ul>
<li>用户级线程由应用程序通过线程库实现。<strong>所有的线程管理工作都由应用程序负责（包括线程切换)</strong></li>
<li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预。</strong></li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li>
<li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li>
</ul>
<ol start="2">
<li>内核级线程</li>
</ol>
<ul>
<li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li>
</ul>
<p><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对1模型"><a href="#多对1模型" class="headerlink" title="多对1模型"></a>多对1模型</h4><ul>
<li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li>
<li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li>
<li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201913689.png"/>

<h4 id="1对1模型"><a href="#1对1模型" class="headerlink" title="1对1模型"></a>1对1模型</h4><ul>
<li>一对一模型:一个用户级线程映射到一个内核级线程。</li>
<li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li>
<li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201917778.png"/>

<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><ul>
<li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201918142.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121258062.png"/></p>
<h2 id="处理机调度的概念和层次"><a href="#处理机调度的概念和层次" class="headerlink" title="处理机调度的概念和层次"></a>处理机调度的概念和层次</h2><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p>
<p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p>
<p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p>
<h3 id="高级调度，中级调度，初级调度。"><a href="#高级调度，中级调度，初级调度。" class="headerlink" title="高级调度，中级调度，初级调度。"></a>高级调度，中级调度，初级调度。</h3><h4 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h4><ul>
<li><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
</li>
<li><p>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</p>
</li>
<li><p><strong>高级调度是辅存（外存）与内存之间的调度</strong>。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。<strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201923361.png"/></li>
</ul>
<h4 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h4><ul>
<li><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量</strong>。</p>
</li>
<li><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p>
</li>
<li><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></p>
</li>
<li><p>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201924752.png"/></li>
</ul>
<h5 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h5><ul>
<li><p>暂时被调到外存等待的进程状态称为挂起状态。</p>
</li>
<li><p>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201926432.png"/></li>
</ul>
<h4 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h4><ul>
<li>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的频率很高，一般几十毫秒一次。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202014458.png"/>

<h4 id="三种调度的联系和对比"><a href="#三种调度的联系和对比" class="headerlink" title="三种调度的联系和对比"></a>三种调度的联系和对比</h4><table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存（面向作业）</td>
<td>最低</td>
<td>无-创建态-就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td>外存-&gt;内存（面向进程）</td>
<td>中等</td>
<td>挂起态-就绪态（阻塞挂起-阻塞态）</td>
</tr>
<tr>
<td>低级调度（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-运行态</td>
</tr>
</tbody></table>
<h2 id="进程调度的时机，切换过程和方式"><a href="#进程调度的时机，切换过程和方式" class="headerlink" title="进程调度的时机，切换过程和方式"></a>进程调度的时机，切换过程和方式</h2><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202048883.png"/>

<p>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><ul>
<li>非剥夺调度方式，又称非抢占方式。即，<strong>只允许进程主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
</ul>
<p>优点：实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
<ul>
<li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
</ul>
<p>优点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<p><strong>优点：</strong></p>
<p>可以有限处理更紧急的进程，也可实现让哥进程按时间骗轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别:</p>
<ul>
<li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p>
</li>
<li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
</li>
</ul>
<p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p>
<p>进程切换的过程主要完成了:</p>
<ul>
<li>1.对原来运行进程各种数据的保存</li>
<li>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ul>
<p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><ul>
<li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li>
<li>系统吞吐量：单位时间内完成作业的数量。</li>
</ul>
<p>$$<br>系统吞吐量&#x3D;{总共完成了多少道作业\over总共花了多少时间}<br>$$</p>
<ul>
<li><p>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</p>
<p><span style="color:red"><strong>周转时间&#x3D;作业完成时的时间-作业提交时间</strong></span></p>
<p><span style="color:red"><strong>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</strong></span></p>
</li>
</ul>
<p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。<br>$$<br>带权周转时间&#x3D;{作业周转时间\over作业实际运行的时间}&#x3D;{作业完成的时间-作业提交时间\over作业实际运行的时间}<br>$$</p>
<p>$$<br>平均的带权周转时间&#x3D;{各个作业带权周转时间之和\over作业数}<br>$$</p>
<ul>
<li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li>
</ul>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<ul>
<li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务，短作业优先，高响应必优先"><a href="#先来先服务，短作业优先，高响应必优先" class="headerlink" title="先来先服务，短作业优先，高响应必优先"></a>先来先服务，短作业优先，高响应必优先</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>算法思想与规则</th>
<th>可抢占？</th>
<th>优点</th>
<th>缺点</th>
<th>考虑到等待时间&amp;运行时间？</th>
<th>会导致饥饿？</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务</td>
<td>FCFS</td>
<td>公平，先到先得</td>
<td>非</td>
<td>公平，实现简单</td>
<td>对短作业不利</td>
<td>有等待，无运行</td>
<td>不</td>
</tr>
<tr>
<td>短作业优先</td>
<td>SJF&#x2F;SPF</td>
<td>追求快<br />时间最短的先服务</td>
<td>默认为非抢占式版本，也有SJF的抢占式版本最短剩余时间优先算法(SRTN)</td>
<td>“最短的”平均等待&#x2F;周转时间</td>
<td>对长作业不利，可能导致饥饿；难以做到真正的短时间优先</td>
<td>有运行，无等待</td>
<td>会</td>
</tr>
<tr>
<td>高响应必优先</td>
<td>HRRN</td>
<td>作业&#x2F;进程的等待时间<br />计算<span style="color:red">响应比</span>,选择<span style="color:red">响应比最高的</span>作业&#x2F;进程优先</td>
<td>非</td>
<td>权衡折中，综合考虑等待时间和运行时间</td>
<td></td>
<td>都有</td>
<td>不</td>
</tr>
</tbody></table>
<p><span style="color:red">响应比</span> (响应比&gt;&#x3D;1) ：<br>$$<br>响应比&#x3D;{等待时间+要求服务时间\over要求服务时间}<br>$$<br>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><blockquote>
<ol>
<li><p>FCFS 由于在长作业过程中，后面的短作业需要等很长的时间，带权周转时间很大，对短作业用户体验不好。</p>
</li>
<li><p>FCFS 用于作业调度时，考虑的是那个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p>
</li>
<li><p>SJF 是用于作业调度，也可用于进程调度。用于进程调度时成为”短进程优先”(SPF，Shortest Process First)</p>
</li>
<li><p>SJF 和 SPF 是非抢占式算法，但是也有抢占式的版本–最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)</p>
</li>
<li><p>SJF 对长作业不利，可能产生饥饿现象。另外，作业&#x2F;进程真正运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p>
</li>
<li><p>SJF 如果有源源不断地有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生”饥饿”现象，如果一直得不到服务，则称为 饿死</p>
</li>
<li><p>HRRN 在每次调度室先计算各个作业&#x2F;进程的 响应比 ，选择响应比<span style="color:red">最高</span>的作业&#x2F;进程为其服务</p>
</li>
<li><ul>
<li><p>HRRN 综合考虑了等待时间和运行时间（要求服务时间）</p>
</li>
<li><p>等待时间相同时，要求服务时间端的优先（SJF 的优点）</p>
</li>
<li><p>要求服务时间相同时，等待时间长的优先（FCFS的优点）</p>
</li>
<li><p>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"><a href="#时间片轮转调度，优先级调度算法，多级反馈队列调度算法" class="headerlink" title="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"></a>时间片轮转调度，优先级调度算法，多级反馈队列调度算法</h3><h4 id="时间片轮转调度RR"><a href="#时间片轮转调度RR" class="headerlink" title="时间片轮转调度RR"></a>时间片轮转调度RR</h4><table>
<thead>
<tr>
<th>时间片轮转调度<br />（RR，Round-Robin）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td>
</tr>
<tr>
<td>算法规则</td>
<td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<span style="color:red">时间片</span>（如100ms)。若进程未在一个时间片内执行完则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度（只有作业放入内存建立了相应的进程后，<br/>才能被分配处理机时间片）</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>若进程未能在时间片内运行完，将被强行剥夺处理机使权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平；响应快，适用于分时操作系统；<br />缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>否</td>
</tr>
<tr>
<td>补充</td>
<td>时间片问题：<br />如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。<br />另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。<br />一般来说，设计时间片要让切换进程的开销占比不超过1%。</td>
</tr>
</tbody></table>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><table>
<thead>
<tr>
<th>优先级调度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场最需要根据任务的紧急程度来决定处理顺序</td>
</tr>
<tr>
<td>算法规则</td>
<td>调度时选择优先级最高的作业&#x2F;进程</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>既可用于作业调度，也可用于进程调度。甚至还会用于在之后会学习的I&#x2F;O调度中</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需任就绪队列变化时，检查是否会发生抢占。</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：用优先级区分紧总程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充</td>
<td>如下图</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251342602.png"/>

<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><table>
<thead>
<tr>
<th>多级反馈队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>对其他调度算法的折中权衡</td>
</tr>
<tr>
<td>算法规则</td>
<td>1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k级 队列队尾</td>
</tr>
<tr>
<td>优缺点</td>
<td>对各类型进程相对公平(FCFS的优点)：每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的时间就可完成(SPF的优点)；不必实现估计进程的运行时间（避免用户作假）：可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、&#x2F;O密集型进程（拓展：可以将因&#x2F;O而阻塞的进程重新放回原队列，这样&#x2F;O型进程就可以保持较高优先级)</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充理解</td>
<td>如下文</td>
</tr>
</tbody></table>
<blockquote>
<p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>P1(1) —— P2(1) —— P1(2) —— P2(1) —— P3(1) —— P2(2) —— P1(4) —— P1(1)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251358421.png"/>

<p>设置多级就绪队列，各级队列<strong>优先级从高到低</strong>，<strong>时间片从小到大</strong></p>
<p><span style="color:red">新进程</span>到达时<span style="color:red">先进入第1级队列</span>，按<span style="color:red">FCFS原则</span>排队等待被分配时间片。若用完时间片进程还<strong>未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>己经在最下级</strong>的队列，则<strong>重新放回</strong>最下级队列队尾</p>
<p>只有第<strong>k级队列为空</strong>时，才会<strong>为k+1级</strong>队头的进程<strong>分配时间片</strong><br><strong>被抢占处理机的进程重新放回原队列队尾</strong></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括<strong>分时操作系统、实时操作系统</strong>等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统。</strong>(比如UNIX使用的就是多级反馈队列调度算法)</p>
<h3 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>以下例子为管道通信为实例</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282350043.png"/>

<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></p>
<blockquote>
<p>含义</p>
</blockquote>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><ul>
<li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li>
<li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li>
<li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282351880.png"/>

<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282359512.png"/>

<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091148134.png"/>

<blockquote>
<p>turn的初值为0，即刚开始只允许0号进程进入临界区。<br>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。<br>因此，<strong>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p>
<p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→…这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。<br>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p>
</blockquote>
<h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091154224.png"/>

<p>若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091158727.png"/>

<p>若按照①⑤②⑥…的顺序执行，P0和P1将都无法进入临界区因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091200387.png"/>

<ul>
<li>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li>
<li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li>
</ul>
<h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516619.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516916.png"/>

<blockquote>
<p>关中断指令只对执行关中断指令的处理机有用</p>
</blockquote>
<h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518026.png"/>

<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518466.png"/>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="进程互斥：锁"><a href="#进程互斥：锁" class="headerlink" title="进程互斥：锁"></a>进程互斥：锁</h4><h5 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>解决临界区最简单的工具就是互斥锁（mutexlock)。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available); <span class="comment">//忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>; <span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>; <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。<br>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁（</strong>spin lock)，如TSL指令、swap指令、单标志法 </p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261531895.png"/>

<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li><strong>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，</strong>可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li>
<li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li>
<li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li>
<li>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261532635.png"/>

<p>进程互斥的四种软件实现方式（单标志法，双标志先检查，双标志后检查，Peterson算法）</p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法，TS&#x2F;TSL指令，Swap&#x2F;XCHG指令）</p>
<p>1.在双标志先检查法中，进去区的”检查“，”上锁“操作无法一气呵成，中间有可能先执行了检查就进行了进程切换，从而导致了两个进程有可能同时进入临界区的问题；</p>
<p>2.所有的解决方案都无法实现”让权等待“</p>
<blockquote>
<p>其中单标志法，双标志先检查，双标志后检查都存在着比较严重的一些问题的隐患。Peterson算法还有后面的三种硬件实现方式其实问题都不大，但是这些方式也都无法解决”让权等待“原则</p>
</blockquote>
<h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072113564.png"/>

<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072114497.png"/>

<h3 id="用信号量实现进程互斥，同步，前驱关系"><a href="#用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="用信号量实现进程互斥，同步，前驱关系"></a>用信号量实现进程互斥，同步，前驱关系</h3><h4 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol>
<li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li>
<li>设置互斥信号量mutex，初值为1</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072115578.png"/>

<p>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p>
<p><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p>
<h4 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序的进行。</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li>
<li>设置同步信号量s,初始为0</li>
<li>在“前操作”之后执行v(S)</li>
<li>在“后操作”之前执行P(S)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072117802.png"/>

<h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，</p>
<ol>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在“前操作”之后对相应的同步变量执行V操作</li>
<li>在“后操作”之前对相应的同步变量执行Р操作</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072118787.png"/>

<h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
<li>缓冲区是临界资源，各进程必须互斥地访问。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119845.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119979.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119956.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119961.png"/>

<h3 id="多生产者——多消费者"><a href="#多生产者——多消费者" class="headerlink" title="多生产者——多消费者"></a>多生产者——多消费者</h3><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123688.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123924.png"/>

<p>问题：可不可以不使用问题信号量？</p>
<p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p>
<p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p>
<p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p>
<ol>
<li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li>
<li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li>
</ol>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124996.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124492.png"/>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p>
<p>①允许多个读者可以同时对文件执行读操作;</p>
<p>②只允许一个写者往文件中写信息;</p>
<p>③任一写者在完成写操作之前不允许其他读者或写者工作;</p>
<p>④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125799.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125176.png"/>

<ul>
<li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125944.png"/>

<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。<br>其核心思想在于<strong>设置了一个计数器count用来记录当前正在访问共享文件的读进程数</strong>。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，<strong>如果需要实现“一气呵成”，自然应该想到用互斥信号量。</strong><br>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126626.png"/>

<p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<p>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p>
<blockquote>
<p>以下方式会出现死锁问题</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126279.png"/>
</blockquote>
<p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072127517.png"/>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程相当于对临界区资源进行抽象而编写的一个类。</strong></p>
<p>管程是一种特殊的软件模块，有这些部分组成:</p>
<p>1.局部于管程的共享数据结构说明; （一个类）</p>
<p>2.对该数据结构进行操作的一组过程; （类中的方法）</p>
<p>3．对局部于管程的共享数据设置初始值的语句; （类中的变量）</p>
<p>4.管程有一个名字。 （类名）</p>
<p>管程的基本特征:</p>
<p>1．局部于管程的数据只能被局部于管程的过程所访问; （类中变量有自己的作用范围）</p>
<p>**2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** <strong>这种互斥特性是由编译器来实现的。</strong></p>
<p><strong>3．每次仅允许一个进程在管程内执行某个内部过程。</strong></p>
<blockquote>
<h4 id="java中类似于管程的机制（单例模式）"><a href="#java中类似于管程的机制（单例模式）" class="headerlink" title="java中类似于管程的机制（单例模式）"></a>java中类似于管程的机制（单例模式）</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072128379.png"/>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p>
<p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p>
<h4 id="死锁，饥饿，死循环的区别"><a href="#死锁，饥饿，死循环的区别" class="headerlink" title="死锁，饥饿，死循环的区别"></a>死锁，饥饿，死循环的区别</h4><ul>
<li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li>
<li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072129588.png"/>

<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求 和 保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>)</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</p>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li>
<li><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072130399.png"/>

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061307159.png"/>

<p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081538138.png"/>

<h2 id="相对地址和绝对地址"><a href="#相对地址和绝对地址" class="headerlink" title="相对地址和绝对地址"></a>相对地址和绝对地址</h2><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong><br>编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>
<p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p>
<h2 id="三种装入模式"><a href="#三种装入模式" class="headerlink" title="三种装入模式"></a>三种装入模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061302897.png"/>

<h3 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h3><p>这种方式的灵活性很差，只适用于单道程序环境，早期还没有操作系统的阶段使用的就是这种方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061316431.png"/>

<h3 id="可重定位装入"><a href="#可重定位装入" class="headerlink" title="可重定位装入"></a>可重定位装入</h3><p>这种方式的特点是我们给这个作业&#x2F;进程分配的这些地址空间必须是连续的，并且这个作业必须一次全部装入内存</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317740.png"/>

<h3 id="动态运行时装入"><a href="#动态运行时装入" class="headerlink" title="动态运行时装入"></a>动态运行时装入</h3><p>CPU在对一个内存地址进行访问的时候会把逻辑地址和重定位寄存器当中存放的起始地址进行相加得到最终可以访问的地址</p>
<p>想让进程的数据在运行过程当中发生移动是很方便的，只需要修改重定位寄存器的值就可以</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317519.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317630.png"/>

<h2 id="程序运行逻辑"><a href="#程序运行逻辑" class="headerlink" title="程序运行逻辑"></a>程序运行逻辑</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081539943.png"/>

<p>这些目标模块文件当中已经包含了这些代码所对应的那些指令，而这些指令的编址都是逻辑地址。每一个模块的逻辑地址编址都是相互独立的，都从0开始</p>
<p>链接把这些目标模块组装起来形成一个完整的装入模块</p>
<p>在链接这一步，除了我们自己编写的这些目标模块需要链接以外，还需要把它们所调用到的一些库函数（如printf）也链接起来</p>
<h3 id="程序运行前—静态连接"><a href="#程序运行前—静态连接" class="headerlink" title="程序运行前—静态连接"></a>程序运行前—静态连接</h3><p>就是我们刚才所提到的这种方式，在形成装入模块之后就确定了这个装入模块的完整的逻辑地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061319738.png"/>

<h3 id="装入时—动态连接"><a href="#装入时—动态连接" class="headerlink" title="装入时—动态连接"></a>装入时—动态连接</h3><p>采用这种方式的话，这个进程的完整的逻辑地址是一边装入一边形成的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061320350.png"/>

<h3 id="运行时—动态连接"><a href="#运行时—动态连接" class="headerlink" title="运行时—动态连接"></a>运行时—动态连接</h3><p>需要用到某一个模块的时候再把它调入内存，装入的同时进行链接</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321161.png"/>

<h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321531.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061323512.png"/>

<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<ol>
<li><p>操作系统负责内存空间的分配与回收</p>
</li>
<li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></p>
</li>
</ol>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 </p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061326837.png"/>

<p>绝对装入是在编译的时候就产生了绝对地址，或者说在程序员写程序的时候直接就写了绝对地址。这个地址转换是由编译器而不是操作系统完成的</p>
<p>可重定位装入中地址转换的过程由装入程序负责进行，而装入程序也是操作系统的一部分</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%80%83%E7%A0%94408/" rel="tag"># 考研408</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 计算机操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/" rel="prev" title="计算机网络(3)-传输层与应用层">
      <i class="fa fa-chevron-left"></i> 计算机网络(3)-传输层与应用层
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" rel="next" title="英语语法学习笔记(1)">
      英语语法学习笔记(1) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="nav-number">2.2.</span> <span class="nav-text">操作系统的功能和目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="nav-number">2.3.</span> <span class="nav-text">操作系统的四个特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">操作系统的运行机制和体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.1.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">2.4.2.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.4.3.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8"><span class="nav-number">2.4.4.</span> <span class="nav-text">操作系统的内核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">2.5.</span> <span class="nav-text">中断和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">概念和作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">2.5.2.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AB%E4%B9%89"><span class="nav-number">2.6.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">2.6.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.6.3.</span> <span class="nav-text">系统调用和库函数的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.6.4.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81"><span class="nav-number">3.1.</span> <span class="nav-text">进程的定义，组成，组织方式，特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">进程的组织方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程的特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.2.</span> <span class="nav-text">进程的状态和转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.2.2.</span> <span class="nav-text">转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AB%E4%B9%89-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD"><span class="nav-number">3.3.3.</span> <span class="nav-text">相关原语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">3.4.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AB%E4%B9%89-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%EF%BC%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E3%80%82"><span class="nav-number">3.4.2.</span> <span class="nav-text">共享存储，消息传递，管道通信。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">线程概念和多线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="nav-number">3.5.1.</span> <span class="nav-text">线程分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">多线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B91%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">多对1模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E5%AF%B91%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">1对1模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">多对多模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1"><span class="nav-number">3.6.</span> <span class="nav-text">处理机调度的概念和层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%8C%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%8C%E5%88%9D%E7%BA%A7%E8%B0%83%E5%BA%A6%E3%80%82"><span class="nav-number">3.6.1.</span> <span class="nav-text">高级调度，中级调度，初级调度。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">1.高级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">2.中级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.6.1.2.1.</span> <span class="nav-text">补充知识：进程的七状态模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">3.低级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="nav-number">3.6.1.4.</span> <span class="nav-text">三种调度的联系和对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%8C%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">3.7.</span> <span class="nav-text">进程调度的时机，切换过程和方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="nav-number">3.7.1.</span> <span class="nav-text">进程调度时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.7.2.</span> <span class="nav-text">进程调度的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="nav-number">3.7.3.</span> <span class="nav-text">进程的切换与过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-number">3.8.</span> <span class="nav-text">调度算法的评价指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%8C%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%8C%E9%AB%98%E5%93%8D%E5%BA%94%E5%BF%85%E4%BC%98%E5%85%88"><span class="nav-number">3.9.1.</span> <span class="nav-text">先来先服务，短作业优先，高响应必优先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">补充：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%8C%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.2.</span> <span class="nav-text">时间片轮转调度，优先级调度算法，多级反馈队列调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6RR"><span class="nav-number">3.9.2.1.</span> <span class="nav-text">时间片轮转调度RR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.2.2.</span> <span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.2.3.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.9.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">3.9.3.</span> <span class="nav-text">进程同步与进程互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.9.3.1.</span> <span class="nav-text">进程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">3.9.3.2.</span> <span class="nav-text">进程互斥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.4.</span> <span class="nav-text">进程互斥的软件实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="nav-number">3.9.4.1.</span> <span class="nav-text">单标志法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="nav-number">3.9.4.2.</span> <span class="nav-text">双标志先检查法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="nav-number">3.9.4.3.</span> <span class="nav-text">双标志后检查法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.4.4.</span> <span class="nav-text">Peterson算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.5.</span> <span class="nav-text">进程互斥的硬件实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TestAndSet%E6%8C%87%E4%BB%A4"><span class="nav-number">3.9.5.1.</span> <span class="nav-text">TestAndSet指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Swap%E6%8C%87%E4%BB%A4"><span class="nav-number">3.9.5.2.</span> <span class="nav-text">Swap指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.9.6.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%9A%E9%94%81"><span class="nav-number">3.9.6.1.</span> <span class="nav-text">进程互斥：锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-1"><span class="nav-number">3.9.6.1.1.</span> <span class="nav-text">互斥锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-number">3.10.</span> <span class="nav-text">信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.10.1.</span> <span class="nav-text">整形信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.10.2.</span> <span class="nav-text">记录型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%8C%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">3.10.3.</span> <span class="nav-text">用信号量实现进程互斥，同步，前驱关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">3.10.3.1.</span> <span class="nav-text">信号量机制实现进程互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.10.3.2.</span> <span class="nav-text">信号量机制实现进程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">3.10.3.3.</span> <span class="nav-text">信号量机制实现前驱关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.4.</span> <span class="nav-text">生产者——消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">3.10.5.</span> <span class="nav-text">多生产者——多消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.6.</span> <span class="nav-text">吸烟者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E2%80%94%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.7.</span> <span class="nav-text">读者——写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD"><span class="nav-number">3.10.8.</span> <span class="nav-text">哲学家吃饭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">3.10.9.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">3.10.9.1.</span> <span class="nav-text">java中类似于管程的机制（单例模式）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.10.10.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%EF%BC%8C%E9%A5%A5%E9%A5%BF%EF%BC%8C%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.10.10.1.</span> <span class="nav-text">死锁，饥饿，死循环的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.10.10.2.</span> <span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="nav-number">3.10.10.3.</span> <span class="nav-text">什么时候会发生死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">3.10.10.4.</span> <span class="nav-text">死锁的处理策略</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80"><span class="nav-number">4.1.</span> <span class="nav-text">相对地址和绝对地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">三种装入模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="nav-number">4.2.1.</span> <span class="nav-text">绝对装入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5"><span class="nav-number">4.2.2.</span> <span class="nav-text">可重定位装入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A3%85%E5%85%A5"><span class="nav-number">4.2.3.</span> <span class="nav-text">动态运行时装入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-number">4.3.</span> <span class="nav-text">程序运行逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%89%8D%E2%80%94%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.3.1.</span> <span class="nav-text">程序运行前—静态连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E2%80%94%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.3.2.</span> <span class="nav-text">装入时—动态连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E2%80%94%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.3.3.</span> <span class="nav-text">运行时—动态连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.4.</span> <span class="nav-text">内存管理的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.1.</span> <span class="nav-text">地址转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">4.4.2.</span> <span class="nav-text">内存保护</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
