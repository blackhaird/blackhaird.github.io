<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JAVA面试题面向对象和面向过程的区别面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发 面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA面试题">
<meta property="og:url" content="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:description" content="JAVA面试题面向对象和面向过程的区别面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发 面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405131631960.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120013055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405122146852.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120017757.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120018966.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120020479.png">
<meta property="article:published_time" content="2024-05-10T05:26:38.000Z">
<meta property="article:modified_time" content="2024-05-13T11:47:36.544Z">
<meta property="article:author" content="MEIDE">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png">

<link rel="canonical" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JAVA面试题 | MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-13 19:47:36" itemprop="dateModified" datetime="2024-05-13T19:47:36+08:00">2024-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p><strong>面向过程：</strong>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象：</strong>是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1.int 是基本数据类型，Integer 是 int 的封装类，是引用类型。int 默认值是 0，而 Integer 默认值 是 null，所以 Integer 能区分出 0 和 null 的情况。一旦 java 看到 null，就知道这个引用 还没有指向某个 对象，在任何引用使用前，必须为其指定一个对象，否则会报错。 </p>
<p>2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给 另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看得见。</p>
<p>虽然定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值。</p>
<p>在编译之后 都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是1 个字节。使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这 里不是指的 是 32&#x2F;64 位系统，而是指 CPU 硬件层面），具有高效存取的特点</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof需要非基本类 i 必须是引用类型，不能是基本类</p>
<p>注意：编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错，如果 不能 确定类型，则通过编译，具体看运行时定</p>
<p>在 JavaSE 规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将 返 回 false。</p>
<h2 id="Java自动装箱和拆箱"><a href="#Java自动装箱和拆箱" class="headerlink" title="Java自动装箱和拆箱"></a>Java自动装箱和拆箱</h2><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;integer ）；调用方法：valueOf(int) 的方法 </p>
<p>拆箱就是自动将包装器类型转换为基本数据类型（integer–&gt;int ）。调用方法：intValue 的方法</p>
<p>在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之 间， </p>
<p>便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p>
<p>在某个范围内的整形数值的个数是有限的，而浮点数却不是。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重 写 （Override）从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。 子 类继承了父类原有的方法，但有时子类并不想原封不动地继承父类中的某个方法，所以在方法 名， 参数列表，返回类型（除过子类中方法的返回值是父类中方法返回值的子类时）</p>
<p>都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<ol>
<li>发生在父类与子类之间 </li>
<li>方法名，参数列表，返回类型（除过子类中方法的返回类 型 是父类中返回类型的子类）必须相同 </li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符 (public&gt;protected&gt;default&gt;private) </li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法 申 明更加宽泛的检查性异常</li>
</ol>
<p>重载 （Overload ） 在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>
<ol>
<li>重载 Overload 是一个类中多态性的一种表现 </li>
<li>重载要求同名方法的参数列表不同 （参数类型，参数个数甚至是参数顺序） </li>
<li>重载的时候，返回值类型可以相同也可以不相同。 无法返回 型别作为重载函数的区分标准</li>
</ol>
<h2 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals 与 &#x3D;&#x3D;"></a>equals 与 &#x3D;&#x3D;</h2><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即 否实指相同一个对象。比较的是真正意义上的指针操作。 </p>
<ol>
<li>比较的是操作符两端的操作数是否是同一个对象。 </li>
<li>两边的操作数必须是同一类型的（可以 是 父子类之间）才能编译通过。 </li>
<li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则 为 true，如： int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0 都是相同的（为 true），因为他们都指 向地 址为 10 的堆。</li>
</ol>
<p>equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的， 所 以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是&#x3D;&#x3D;的判断。 </p>
<p>总结： 所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的 equals object 可能为 null 则空指针</p>
<p>在阿里的代码规范中只使用 equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“&#x3D;&#x3D;” ，替换成 equals</p>
<h2 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h2><p>Java 的集合有两类，一类是 List，还有一类是 Set。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多， 用这样 的方法就会比较</p>
<p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域， 每 个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对 象的 哈希码就可以确定该对象应该存储的哪个区域</p>
<p>hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当 集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物 理 位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较 了；如 果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其他的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只 需要一两次。</p>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String 是只读字符串，它并不是基本数据类型、而是一个对象。从底层源码来看是一个final 类型 的 字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。<strong>每次对 String 的操作都 会生成 新的 String 对象</strong></p>
<p>隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append方法 <strong>拼接</strong>+后面的字符。</p>
<p>StringBuffer 和 StringBuilder 他们俩都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到</p>
<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和 StringBuilder 来进行操作。 </p>
<p> StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁， 所以来是线程安全的。</p>
<p> StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h2 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h2><p>Array(数组)是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 </p>
<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据，（因为删除数据以后，需要把后面所有的数据前移）</p>
<p>缺点：数组初始化必须指定初始化的长度，否则报错</p>
<p>List一是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</p>
<p>List有两个重要的实现类：ArrayList和LinkedList</p>
<ul>
<li><p>ArrayList:可以看作是能够<strong>自动增长容量</strong>的数组</p>
</li>
<li><p>ArrayList的toArray方法返回一个数组</p>
</li>
<li><p>ArrayList的asList方法返回一个列表</p>
</li>
<li><p>ArrayList底层的实现是Array,数组扩容实现</p>
</li>
<li><p>ArrayList Clone() 是浅复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</span><br><span class="line">缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</span><br><span class="line">高并发的情况下，线程不安全。多个线程同时操作ArrayList ，会引发不可预知的异常或错误。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>LinkList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList.当然，这些对比都是指数据量很大或者操作很频繁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开拓内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</span><br><span class="line">缺点：因为LinkedList 要移动指针，所以查询操作性能比较低。</span><br></pre></td></tr></table></figure>



<p>当需要对数据进行随机访问的时候，选用ArrayList。<br>当需要对数据进行多次增加删除修改时，采用LinkedList。<br>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用ArrayList。<br>当然，绝大多数业务的场景下，使用ArrayList 就够了，但需要注意避免ArrayList 的扩容，以及非顺序的插入。</p>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>1、两者父类不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了</span><br><span class="line">同时实现了map、Cloneable(可复制）、Serializable(可序列化）这三个接口。</span><br></pre></td></tr></table></figure>

<p>2、对外提供的接口不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable比HashMap多提供了elments()和contains()两个方法。elments()方法</span><br><span class="line">继承自Hashtable的父类Dictionnary。elements()方法用于返回此Hashtable中的</span><br><span class="line">value的枚举。</span><br><span class="line">contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致</span><br><span class="line">事实上，contansValue()就只是调用了一下contains()方法。</span><br></pre></td></tr></table></figure>

<p>3、对null的支持不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:key和value都不能为null。</span><br><span class="line">HashMap:key可以为null,但是这样的key只能有一个，因为必须保证key的唯一性；可以有</span><br><span class="line">多个key值对应的value为null</span><br></pre></td></tr></table></figure>

<p>4、安全性不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员</span><br><span class="line">自已处理多线程的安全问题。</span><br><span class="line"></span><br><span class="line">Hashtable是线程安全的，它的每个方法上都有synchronized关键字，因此可直接用于多线程中。</span><br><span class="line"></span><br><span class="line">虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为</span><br><span class="line">大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap.</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因</span><br><span class="line">为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</span><br></pre></td></tr></table></figure>

<p>5、初始容量大小和每次扩充容量大小不同 、</p>
<p>6、计算hash值的方法不</p>
<h2 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h2><p>Collection 是集合类的上级接口，子接口有 Set、 List、LinkedList、ArrayList、Vector、Stack、 Set； Collections 是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各 种 集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
<h2 id="JAVA的四种引用（强弱软虚）"><a href="#JAVA的四种引用（强弱软虚）" class="headerlink" title="JAVA的四种引用（强弱软虚）"></a>JAVA的四种引用（强弱软虚）</h2><ul>
<li><p>强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用 弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<p>可用场景： Java 源码中的中的就是使用弱引用，一旦我不需要某个引用，JVM 会自动帮我处理它，这样我就不需要做其他操作。</p>
</li>
<li><p>软引用 软引用在程序内存不足时，会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf 这个引用也是强引用，它是指向 SoftReference 这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向 new String(&quot;str&quot;）的引用，也就是 SoftReference 类中 T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用</p>
<p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入<strong>ReferenceQueue中</strong>。</p>
<p>注意哦，其他引用是被JVM 回收后才被传入中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有<br>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;())</span><br></pre></td></tr></table></figure>

<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做<br>这类动作，但是这个方式既不安全又低效</p>
</li>
</ul>
<p>上述所说的几类引用，都是指对象本身的引用，而不是指Reference 的四个子类的引用(SoftReference 等）。</p>
<h2 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h2><p>“泛型” ，顾名思义， “泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="JAVA创建对象有几种方式"><a href="#JAVA创建对象有几种方式" class="headerlink" title="JAVA创建对象有几种方式"></a>JAVA创建对象有几种方式</h2><p>java中提供了以下四种创建对象的方式：</p>
<ul>
<li><p>new创建新对象</p>
</li>
<li><p>通过反射机制</p>
</li>
<li><p>采用clone机制</p>
</li>
<li><p>通过序列化机制</p>
<p>调用ObjectInputStream 类的readObject() 方法。<br>反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对象。</p>
</li>
</ul>
<h2 id="可能两个不相等的对象有相同的hashcode"><a href="#可能两个不相等的对象有相同的hashcode" class="headerlink" title="可能两个不相等的对象有相同的hashcode"></a>可能两个不相等的对象有相同的hashcode</h2><p>有可能.在产生hash 冲突时，两个不相等的对象就会有相同的hashcode 值.当hash 冲突产生时，一般有以下几种方式来处理：</p>
<ul>
<li><p>拉链法：每个哈希表节点都有一个next 指针，多个哈希表节点可以用next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>
</li>
<li><p>再哈希：又叫双哈希法，有多个不同的Hash 函数.当发生冲突时，使用第二个，第三个….等哈希函数计算地址，直到无冲突.</p>
</li>
</ul>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><ul>
<li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象.换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象.</li>
<li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>被final 修饰的类不可以被继承</li>
<li>被final 修饰的方法不可以被重写</li>
<li>被final 修饰的变量不可以被改变.如果修饰引用，那么表示引用不可变，引用指向的内<br>容可变.</li>
<li>被final 修饰的方法，JVM 会尝试将其内联，以提高运行效率</li>
<li>被final 修饰的常量，在编译阶段会存入常量池</li>
</ul>
<p>编译器对final 域要遵守的两个重排序规则更好：</p>
<p>在构造函数内对一个final 域的写入,随后把这个被构造对象的引用赋值给一个引用变量</p>
<p>这两个操作之间不能重排序初次读一个包含final 域的对象的引用，与随后初次读这个final 域</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态变量和静态方法.也就是被static 所修饰的变量&#x2F; 方法都属于类的静态资源，</p>
<p>类实例所共享除了静态变量和静态方法之外，static 也用于静态块，多用于初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//执行相关操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外static 也多用于修饰内部类，此时称之为静态内部类.最后一种用法就是静态导包，即import static .import static 是在JDK 1.5 之后引入的新特性，<br>可以用来指定导入某个类中的静态资源，并且不需要使用类名，可以直接使用资源名，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//System.out.println(Math.sin(20))；传统做法</span></span><br><span class="line">System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="a-x3D-a-b-与-a-x3D-b"><a href="#a-x3D-a-b-与-a-x3D-b" class="headerlink" title="a&#x3D;a+b 与 a+&#x3D;b"></a>a&#x3D;a+b 与 a+&#x3D;b</h2><p>+&#x3D;操作符会进行隐式自动类型转换，此处a+&#x3D;b 隐式的将加操作的结果类型强制转换为持有结果<br>的类型，而a&#x3D;a+b 则不会自动进行类型转换.如：</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><strong>finally 的执行早于try 里面的return</strong></p>
<ol>
<li>不管有没有出现异常，finally 块中代码都会执行；</li>
<li>当try 和catch 中有return 时，finally 仍然会执行；</li>
<li>finally 是在return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally 执行前确定的；</li>
<li>finally 中最好不要包含return，否则程序会提前退出，返回值不是try 或catch 中保存的返回值。</li>
</ol>
<h2 id="Exception-与-Error-包结构"><a href="#Exception-与-Error-包结构" class="headerlink" title="Exception 与 Error 包结构"></a>Exception 与 Error 包结构</h2><p>Java 可抛出（Throwable）的结构分为三种类型：被检查的异常（CheckedException)，运行<br>时异常(RuntimeException)，错误（Error)。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>RuntimeException 及其子类都被称为运行时异常</p>
<p>常见的五种运行时异常：</p>
<ul>
<li>ClassCastException（类转换异常）</li>
<li>IndexOutOfBoundsException（数组越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArrayStoreException（数据存储异常，操作数组类型不一致）</li>
<li>BufferOverflowException</li>
</ul>
<h3 id="被检查异常"><a href="#被检查异常" class="headerlink" title="被检查异常"></a>被检查异常</h3><p>Exception 类本身，以及Exception 的子类中除了”运行时异常”之外的其他子类都属于被检查异常。</p>
<p>此类异常，要么通过throws 进行声明抛出，要么通过try-catch 进行捕获处理，否则不能通过编译。</p>
<p>例如 ：clone(）接口去克隆一个对象，而该对象对应的类没有实现Cloneable 接口，就会抛出<br>CloneNotSupportedException 异常。被检查异常通常都是可以恢复的。如：</p>
<ul>
<li>IOException</li>
<li>FileNotFoundException</li>
<li>SQLException</li>
</ul>
<p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的<br>FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对<br>象引用时没有确保对象非空而引起的NullPointerException 。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>定义: Error 类及其子类。</p>
<p>特点: 和运行时异常一样，编译器也不会对错误进行检查。</p>
<p>当资源不足、约束失败，或是或是其他程序无法继续运行的条件发生时，就产生错误。程序本身<br>无法修复这些错误的。例如，VirtualMachineError 就属于错误。出现这种错误会导致程序终止<br>运行。</p>
<p>OutOfMemoryError、ThreadDeath。</p>
<p>Java 虚拟机规范规定JVM 的内存分为好几块，比如堆，栈，程序计数器，方法区等</p>
<h2 id="OOM、SOF"><a href="#OOM、SOF" class="headerlink" title="OOM、SOF"></a>OOM、SOF</h2><p>OutOfMemoryError 异常</p>
<ul>
<li>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM）异常的可能。</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>运行时常量池溢出</li>
<li>方法区溢出</li>
</ul>
<p>SOF堆栈溢出 StackOverflow：</p>
<p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p>
<h2 id="线程、进程、程序"><a href="#线程、进程、程序" class="headerlink" title="线程、进程、程序"></a>线程、进程、程序</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h2 id="JAVA序列化中如果有写字段不想进行序列化"><a href="#JAVA序列化中如果有写字段不想进行序列化" class="headerlink" title="JAVA序列化中如果有写字段不想进行序列化"></a>JAVA序列化中如果有写字段不想进行序列化</h2><p>对于不想进行序列化的变量，使用transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化<br>时，被transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和<br>方法。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h3><p>NIO 即New IO，这个库是在JDK1.4 中才引入的。NIO 和IO 有相同的作用和目的，但实现方式不<br>同， NIO 主要用到的是块，所以NIO 的效率要比IO 高很多。在Java API 中提供了两套NIO ，一<br>套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h2 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h2><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象， 都能够调用它的任意一个方法。在java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。<br>动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的反射机制。(jdbc 就是典型的反射)</p>
<h3 id="反射的实现方式："><a href="#反射的实现方式：" class="headerlink" title="反射的实现方式："></a>反射的实现方式：</h3><p>第一步：获取Class 对象，有4 种方法：</p>
<ol>
<li><p>Class.forName(“类的路径”）</p>
</li>
<li><p>类名.class </p>
</li>
<li><p>对象名.getClass() </p>
</li>
<li><p>基本类型的包装类，可以调用包装类的Type 属性来获得该包装类的Class<br>对象</p>
</li>
<li><p>Class：表示正在运行的Java 应用程序中的类和接口注意： 所有获取对象的信息都需要Class类来实现。</p>
</li>
<li><p>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
</li>
<li><p>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限</p>
</li>
<li><p>Method：提供类或接口中某个方法的信息</p>
</li>
</ol>
<p>优点： </p>
<ul>
<li>能够运行时动态获取类的实例，提高灵活性； </li>
<li>与动态编译结合</li>
</ul>
<p>缺点： </p>
<ul>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</li>
</ul>
<p>解决方案： </p>
<ul>
<li>通过setAccessible(true)关闭JDK 的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多</li>
<li>ReflectASM 工具类，通过字节码生成的方式加快反射速度,相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li>
</ul>
<h2 id="List，Set，Map"><a href="#List，Set，Map" class="headerlink" title="List，Set，Map"></a>List，Set，Map</h2><p><strong>List（对付顺序的好帮手）：</strong> List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p>
<p><strong>Set（注重独一无二的性质）：</strong>不允许重复的集合。不会有多个元素引用相同的对象。</p>
<p><strong>Map（用来搜索的专家）：</strong> 使用键值对存储。Map 会维护与Key 有关联的值。两个Key 可以引用相同的对象，但Key 不能重复，典型的Key 是String 类型，但也可以是任何对象。</p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast 机制是Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：当某一个线程A 通过iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程A 访问集合时，就会抛出ConcurrentModificationException 异常，产生fail-fast 事件。这里的操作主要是指add、remove 和clear ，对集合元素个数进行修改。</span><br></pre></td></tr></table></figure>



<p>解决办法：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<p>可以这么理解：在遍历之前，把modCount 记下来expectModCount，后面expectModCount去和modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出ConcurrentModificationException 异常。</p>
<h2 id="Hashtable-与-HashMap"><a href="#Hashtable-与-HashMap" class="headerlink" title="Hashtable 与 HashMap"></a>Hashtable 与 HashMap</h2><ol>
<li>都实现了Map、Cloneable、Serializable</li>
<li>HashMap 继承的是AbstractMap，并且AbstractMap 也实现了Map 接口。Hashtable 继承Dictionary。</li>
<li>Hashtable 中大部分public 修饰普通方法都是synchronized 字段修饰的，是线程安全的， HashMap 是非线程安全的。</li>
<li>Hashtable 的key 不能为null ，value 也不能为null，这个可以从Hashtable 源码中的put方法看到，判断如果value 为null 就直接抛出空指针异常</li>
<li>HashMap 的key 和value 都可以为null。在计算hash 值的时候，有判断，如果key&#x3D;&#x3D;null ，则其hash&#x3D;0 ；至于value 是否为null ，根本没有判断过。</li>
<li>Hashtable 直接使用对象的hash 值。hash 值是JDK 根据对象的地址或者字符串或者数字算出来的int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li>
<li>默认情况下，初始容量不同，Hashtable 的初始长度是11，之后每次扩充容量变为之前的2n+1（ n 为上一次的长度）<strong>而HashMap 的初始长度为16</strong> ，之后每次扩充变为原来的两倍。</li>
</ol>
<p>Hashtable 是线程安全，推荐使用HashMap 代替Hashtable；如果需要线程安全<br>高并发的话，推荐使用ConcurrentHashMap 代替Hashtable。这个回答完了，面试官可能会继续问：HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p>
<h3 id="HashMap-中的-key-可以用任何类吗"><a href="#HashMap-中的-key-可以用任何类吗" class="headerlink" title="HashMap 中的 key 可以用任何类吗"></a>HashMap 中的 key 可以用任何类吗</h3><p>平时可能大家使用得最多的就是使用String 作为HashMap 的key，但是现在我们想使用某个自定义类作为HashMap 的key，那就需要注意以下几点：</p>
<ul>
<li>如果类重写了equals 方法，它也应该重写hashCode 方法。</li>
<li>类的所有实例需要遵循与equals 和hashCode 相关的规则。</li>
<li>如果一个类没有使用equals，你不应该在hashCode 中使用它。</li>
<li>咱们自定义key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode 和equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h3 id="HashMap的长度为什么是2-n次方"><a href="#HashMap的长度为什么是2-n次方" class="headerlink" title="HashMap的长度为什么是2^n次方"></a>HashMap的长度为什么是2^n次方</h3><p>为了能让HashMap 存数据和取数据的效率高，尽可能地减少hash 值的碰撞，也就是说尽量把数据能均匀地分配，每个链表或者红黑树长度尽量相等。</p>
<p>我们首先可能会想到% 取模的操作来实现。</p>
<p>下面是回答的重点哟：</p>
<blockquote>
<p>取余（%）操作中如果除数是2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说hash % length &#x3D;&#x3D; hash &amp;(length - 1) 的前提是length 是2 的n 次方）。并且，采用二进制位操作&amp; ，相对于% 能够提高运算效率。<br>这就是为什么HashMap 的长度需要2 的N 次方了。</p>
</blockquote>
<h3 id="HashMap的数组的元素类型"><a href="#HashMap的数组的元素类型" class="headerlink" title="HashMap的数组的元素类型"></a>HashMap的数组的元素类型</h3><blockquote>
<p>java.util.Map$Entry。JDK1.7的HashMap中有内部类Entry实现Entry接口</p>
<p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口，并且TreeNode是Node的子类。</p>
</blockquote>
<h3 id="HashMap的映射关系的存储索引index如何计算"><a href="#HashMap的映射关系的存储索引index如何计算" class="headerlink" title="HashMap的映射关系的存储索引index如何计算"></a>HashMap的映射关系的存储索引index如何计算</h3><p>hash &amp; table.length-1</p>
<h3 id="为什么数组还需要链表？或问如何解决hash或-index-冲突问题？"><a href="#为什么数组还需要链表？或问如何解决hash或-index-冲突问题？" class="headerlink" title="为什么数组还需要链表？或问如何解决hash或[index]冲突问题？"></a>为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</h3><blockquote>
<p>答：为了解决hash和[index]冲突问题</p>
<p>（1）两个不相同的key的hashCode值本身可能相同</p>
<p>（2）两个不相同的key的hashCode值不同，但是经过hash()运算，结果相同</p>
<p>（3）两个hashCode不相同的key，经过hash()运算，结果也不相同，但是通过 hash &amp; table.length-1运算得到的[index]可能相同</p>
<p>那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p>
</blockquote>
<h3 id="HashMap的数组什么时候扩容？"><a href="#HashMap的数组什么时候扩容？" class="headerlink" title="HashMap的数组什么时候扩容？"></a>HashMap的数组什么时候扩容？</h3><blockquote>
<p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!&#x3D;null时，两个条件同时满足会扩容</p>
<p>JDK1.8版：当要添加新Entry对象时发现</p>
<p>（1）size达到threshold</p>
<p>（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容 ， **达到64会进行树化 **因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p>
<p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p>
</blockquote>
<h2 id="HashMap-与-ConcurrentHashMap-的异同"><a href="#HashMap-与-ConcurrentHashMap-的异同" class="headerlink" title="HashMap 与 ConcurrentHashMap 的异同"></a>HashMap 与 ConcurrentHashMap 的异同</h2><ol>
<li><p>都是key-value 形式的存储数据；</p>
</li>
<li><p>HashMap 是线程不安全的，ConcurrentHashMap 是JUC 下的线程安全的；</p>
</li>
<li><p>HashMap 底层数据结构是数组+ 链表（JDK 1.8 之前）。JDK 1.8 之后是数组+ 链表+ 红黑树。当链表中元素个数达到8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</p>
</li>
<li><p>HashMap 初始数组大小为16（默认），当出现扩容的时候，以0.75 *数组大小的方式进行扩容；</p>
</li>
<li><p>ConcurrentHashMap 在JDK 1.8 之前是采用分段锁来实现的Segment + HashEntry ，Segment 数组大小默认是16 ，2 的n 次方；JDK 1.8 之后，采用Node + CAS +Synchronized 来保证并发安全进行实现</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png"/>

<h1 id="JAVA多线程与并发"><a href="#JAVA多线程与并发" class="headerlink" title="JAVA多线程与并发"></a>JAVA多线程与并发</h1><p>创建线程的常用三种方式：</p>
<ol>
<li>继承Thread 类</li>
<li>实现Runnable 接口</li>
<li>实现Callable 接口（ JDK1.5&gt;&#x3D;）</li>
<li>线程池方式创建</li>
</ol>
<p>通过继承Thread 类或者实现Runnable 接口、Callable 接口都可以实现多线程，不过实现Runnable接口与实现Callable 接口的方式基本相同，只是Callable 接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable 接口和实现Callable 接口归为一种方式。这种方式与继承Thread 方式之间的主要差别如下。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="Runnable-和Callable-接口优缺点"><a href="#Runnable-和Callable-接口优缺点" class="headerlink" title="Runnable 和Callable 接口优缺点"></a>Runnable 和Callable 接口优缺点</h3><p>优点：</p>
<ul>
<li>线程类只是实现了Runnable 或者Callable 接口，还可以继承其他类。这种方式下，多个线程</li>
<li>可以共享一个target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
<p>缺点：编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread() 方法</p>
<h3 id="Thread接口"><a href="#Thread接口" class="headerlink" title="Thread接口"></a>Thread接口</h3><p>优点：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread() 方法，直接使用this 即可获取当前线程<br>缺点：因为线程类已经继承了Thread 类，Java 语言是单继承的，所以就不能再继承其他父类了。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ol>
<li><p>使用退出标志，使线程正常退出，也就是当run 方法完成后线程终止。</p>
</li>
<li><p>使用stop 方法强行终止，但是不推荐这个方法，因为stop 和suspend 及resume 一样都是过期作废的方法。</p>
</li>
<li><p>使用interrupt 方法中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1.stop = <span class="literal">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h3><p><code>notify()</code> 方法用于唤醒在某个对象监视器上等待的单个线程。如果多个线程在等待，任何一个线程被唤醒是完全不确定的。如果需要唤醒所有等待的线程，可以使用 <code>notifyAll()</code> 方法。</p>
<ul>
<li>notify 可能会导致死锁，而notifyAll 则不会</li>
<li>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码使用notifyall，可以唤醒所有处于wait 状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li>
<li>wait() 应配合while 循环使用，不应使用if，务必在wait(）调用前后都检查条件，如果不满足，必须调用notify(）唤醒另外的线程来处理，自己继续wait(）直至条件满足再往下执行。</li>
<li>notify() 是对notifyAll(）的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是WaitSet 中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify(）下一个线程，并且自身需要重新回到WaitSet 中.</li>
</ul>
<h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h3><p>对于sleep(）方法，我们首先要知道该方法是属于Thread 类中的。而wait(）方法，则是属于Object 类中的。</p>
<p>sleep(）方法导致了程序暂停执行指定的时间，让出cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep(）方法的过程中，线程不会释放对象锁。</p>
<p>当调用wait(）方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用</p>
<p>notify(）方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</p>
<h2 id="volatile-可以保证有序性"><a href="#volatile-可以保证有序性" class="headerlink" title="volatile 可以保证有序性"></a>volatile 可以保证有序性</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile 修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，volatile 关键字会强制将修改的值立即写入主存。</p>
<p>2）禁止进行指令重排序。volatile 不是原子性操作</p>
<p><strong>保证部分有序性：</strong>当程序执行到volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p><code>由于flag 变量为volatile 变量，那么在进行指令重排序的过程的时候，不会修改其在代码中的位置，但其他的非volatile变量就无法保证其位置是否会变动</code></p>
<p>使用volatile 一般用于状态标记量和单例模式的双检锁</p>
<h3 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h3><ul>
<li>volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法和类级别的。</li>
<li>volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<h2 id="Thread类中的-start-和-run-区别"><a href="#Thread类中的-start-和-run-区别" class="headerlink" title="Thread类中的 start() 和 run() 区别"></a>Thread类中的 start() 和 run() 区别</h2><p>start(）方法被用来启动新创建的线程，而且start(）内部调用了run(）方法，</p>
<p>当你调用run(）方法的时候，只会是在原来的线程中调用，没有新的线程启动，start() 方法才会启动新线程。</p>
<h2 id="为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait,notify和notifyAll这些方法不在thread类里面？"></a>为什么wait,notify和notifyAll这些方法不在thread类里面？</h2><p>明显的原因是JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。</p>
<p>如果wait(）方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。</p>
<p>简单地说，由于wait ，notify 和notifyAll 都是锁级别的操作，所以把他们定义在Object 类中因为锁属于对象。</p>
<h2 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h2><ol>
<li>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify(）和notifyAll(）方法。</li>
<li>如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免wait 和notify 之间产生竞态条件。</li>
</ol>
<p>wait(）方法强制当前线程释放对象锁。这意味着在调用某对象的wait(）方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait(）方法。</p>
<p>在调用对象的notify(）和notifyAll(）方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify(）或notifyAll(）方法。</p>
<p>调用wait(）方法的原因通常是，调用线程希望某个特殊的状态（或变量）被设置之后再继续执行。调用notify(）或notifyAll(）方法的原因通常是，调用线程希望告诉其他等待中的线程：”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态（或变量）。</p>
<h2 id="Java-中-interrupted-和-islnterrupted方法的区别？"><a href="#Java-中-interrupted-和-islnterrupted方法的区别？" class="headerlink" title="Java 中 interrupted 和 islnterrupted方法的区别？"></a>Java 中 interrupted 和 islnterrupted方法的区别？</h2><p>interrupted() 和isInterrupted(）的主要区别是前者会将中断状态清除而后者不会。</p>
<p>Java 多线程的中断机制是用内部标识来实现的，调用Thread.interrupt(）来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted(）来检查中断状态时，中断状态会被清零。</p>
<p>而非静态方式法isInterrupted(）用来查询其他线程的中断状态且不会改变中断状态标识。</p>
<p>简单地说就是任何抛出InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有可能被其他线程调用中断来改变。</p>
<h2 id="Java中synchronized和ReentrantLock有什么不同？"><a href="#Java中synchronized和ReentrantLock有什么不同？" class="headerlink" title="Java中synchronized和ReentrantLock有什么不同？"></a>Java中synchronized和ReentrantLock有什么不同？</h2><p>相似点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，</span><br><span class="line">也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等，而进行线程阻塞和唤醒的代价是比较高的.</span><br></pre></td></tr></table></figure>



<p>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两种方式最大区别就是对于Synchronized 来说，它是java 语言的关键字，是原生语法层面的互斥，需要jvm 实现。</span><br><span class="line"></span><br><span class="line">而ReentrantLock 它是JDK 1.5 之后提供的API 层面的互斥锁，需要lock(）和unlock(）方法配合try/finally 语句块来完成。</span><br></pre></td></tr></table></figure>



<p>Synchronized 进过编译，会在同步块的前后分别形成monitorenter 和monitorexit 这两个字节码指令。在执行monitorenter 指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应地，在执行monitorexit 指令时会将锁计算器就减1，当计算器为0 时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<p>由于ReentrantLock 是java.util.concurrent 包下提供的一套互斥锁，相比<br>Synchronized ， ReentrantLock 类提供了一些高级功能，主要有以下3 项：</p>
<ol>
<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized 来说可以避免出现死锁的情况。</li>
<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized 锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true 设为公平锁，但公平锁表现的性能不是很好。</li>
<li>锁绑定多个条件，一个ReentrantLock 对象可以同时绑定多个对象。</li>
</ol>
<h2 id="保证线程的顺序执行"><a href="#保证线程的顺序执行" class="headerlink" title="保证线程的顺序执行"></a>保证线程的顺序执行</h2><p>可以用线程类的join(）方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>实际上先启动三个线程中哪一个都行， 因为在每个线程的run 方法中用join 方法限定了三个线程的执行顺序。</p>
<h2 id="SynchronizedMap和-ConcurrentHashMap有什么区别？"><a href="#SynchronizedMap和-ConcurrentHashMap有什么区别？" class="headerlink" title="SynchronizedMap和 ConcurrentHashMap有什么区别？"></a>SynchronizedMap和 ConcurrentHashMap有什么区别？</h2><p>SynchronizedMap(）和Hashtable 一样，实现上在调用map 所有方法时，都对整个map 进行同步。</p>
<p>而ConcurrentHashMap 的实现却更加精细，它对map 中的<strong>所有桶加了锁</strong>。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map 执行某些操作。</p>
<p>所以，ConcurrentHashMap 在性能以及安全性方面，明显比Collections.synchronizedMap(）更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map 时，如果其他线程试图对map 进行数据修改，也不会抛出ConcurrentModificationException。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。<br>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释得最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p>
<p>这个问题有值得一提的地方，就是远程安全也是有几个级别的：</p>
<p>（ 1）不可变<br>像String、Integer、Long 这些，都是final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<p>（ 2）绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>
<p>（ 3）相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector ，99%的情况下都会出现ConcurrentModificationException，也就是机制。</p>
<p>（ 4）线程非安全<br>ArrayList、LinkedList、HashMap 等都是线程非安全的类</p>
<h3 id="保证几个基本特征"><a href="#保证几个基本特征" class="headerlink" title="保证几个基本特征"></a>保证几个基本特征</h3><ul>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h2 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h2><p>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU 占用而不能保证使其他线程一定能占用CPU，执行yield(）的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="Java线程池中submit-和execute-方法有什么区别？"><a href="#Java线程池中submit-和execute-方法有什么区别？" class="headerlink" title="Java线程池中submit()和execute()方法有什么区别？"></a>Java线程池中submit()和execute()方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，</p>
<p> execute(）方法的返回类型是void，它定义在Executor 接口中， </p>
<p>而submit(）方法可以返回持有计算结果的Future 对象，它定义在ExecutorService 接口中，它扩展了Executor 接口，其它线程池类像ThreadPoolExecutor 和ScheduledThreadPoolExecutor 都有这些方法。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<blockquote>
<p>在Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。</p>
</blockquote>
<p>Java 6 之后synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p><strong>修饰实例方法： 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁修饰静态方法：</strong></p>
<p>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new 了多少个对象，只有一份）。所以如果一个线程A 调用一个实例对象的非静态synchronized 方法，而线程B 需要调用这个实例对象所属类的静态synchronized 方法，是允许的，不会发生互斥现象，</p>
<p>因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态方法占用的锁是当前实例对象锁。</p>
<p><strong>修饰代码块：</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<p><strong>总结：</strong>synchronized 关键字加到static 静态方法和synchronized(class）代码块上都是给Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a) 因为JVM 中，字符串常量池具有缓存功能！</p>
<h2 id="Vector是一个线程安全类"><a href="#Vector是一个线程安全类" class="headerlink" title="Vector是一个线程安全类"></a>Vector是一个线程安全类</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。</p>
<p>Vector 是用同步方法来实现线程安全的， 而和它相似的ArrayList 不是线程安全的。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li>最大线程数maximumPoolSize</li>
<li>核心线程数corePoolSize</li>
<li>活跃时间keepAliveTime</li>
<li>阻塞队列workQueue</li>
<li>拒绝策略RejectedExecutionHandler</li>
</ol>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="线程池的理解"><a href="#线程池的理解" class="headerlink" title="线程池的理解"></a>线程池的理解</h3><p>（如果问到了这样的问题，可以展开地说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ol>
<h3 id="JAVA线程池中队列常用类型有哪些"><a href="#JAVA线程池中队列常用类型有哪些" class="headerlink" title="JAVA线程池中队列常用类型有哪些"></a>JAVA线程池中队列常用类型有哪些</h3><ul>
<li><p>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出）原则对元素进行排序。</p>
</li>
<li><p>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO(先进先出）排序元素，吞吐量通常要高于ArrayBlockingQueue。</p>
</li>
<li><p>SynchronousQueue 一个不存储元素的阻塞队列。</p>
</li>
<li><p>PriorityBlockingQueue 一个具有优先级的无限阻塞队。 也是基于最小二叉堆实现 </p>
</li>
<li><p>DelayQueue ：</p>
<ul>
<li>只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</li>
<li>DelayQueue是一个没有大小限制的队列，</li>
<li>因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
</ul>
</li>
</ul>
<p>这里能说出前三种也就差不多了，如果能说全那是最好。</p>
<h3 id="线程池核心线程数设置"><a href="#线程池核心线程数设置" class="headerlink" title="线程池核心线程数设置"></a>线程池核心线程数设置</h3><p>分为CPU 密集型和IO 密集型</p>
<p><strong>CPU：</strong>这种任务消耗的主要是CPU 资源，可以将线程数设置为N（ CPU 核心数）+1，比CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU 的空闲时间。</p>
<p><strong>IO密集型：</strong>这种任务应用起来，系统会用大部分的时间来处理I&#x2F;O 交互，而线程在处理I&#x2F;O 的时间段内不会占用CPU 来处理，这时就可以将CPU 交出给其他线程使用。因此在I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是：核心线程数&#x3D;CPU 核心数量*2。</p>
<h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>主要有4 种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li>
<li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常</li>
</ol>
<h2 id="JAVA程序是如何执行的"><a href="#JAVA程序是如何执行的" class="headerlink" title="JAVA程序是如何执行的"></a>JAVA程序是如何执行的</h2><ul>
<li><p>先把Java 代码编译成字节码，也就是把.java 类型的文件编译成.class 类型的文件。这个过程的大致执行流程：</p>
<p><strong>Java 源代码-&gt; 词法分析器-&gt; 语法分析器-&gt; 语义分析器-&gt; 字符码生成器-&gt; 最终生成字节码</strong></p>
<p>其中任何一个节点执行失败就会造成编译失败；</p>
</li>
<li><p>把class 文件放置到Java 虚拟机，这个虚拟机通常指的是Oracle 官方自带的Hotspot JVM；</p>
</li>
<li><p>Java 虚拟机使用类加载器（Class Loader）装载class 文件；</p>
</li>
<li><p>类加载完成之后，会进行字节码校验，字节码校验通过之后JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以Hotspot 虚拟机来说，它本身提供了JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。</p>
<p>Java 程序执行流程图如下：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405131631960.png"/></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>从JDK1.6 版本之后，synchronized 本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p>
<p>锁的状态从低到高依次为无锁－〉偏向锁－〉轻量级锁－〉重量级锁，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
<ul>
<li><p><strong>自旋锁：</strong>由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所以没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环， 可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10 次，可以使用-XX:PreBlockSpin 设置。</p>
</li>
<li><p><strong>自适应锁：</strong>自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p>
</li>
<li><p><strong>锁消除：</strong>锁消除指的是JVM 检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
</li>
<li><p><strong>锁粗化：</strong>锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围<strong>扩展到整个操作序列</strong>之外。</p>
</li>
<li><p><strong>偏向锁：</strong>当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS 来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以通过设置-XX:+UseBiasedLocking 开启偏向锁。</p>
</li>
<li><p><strong>轻量级锁：</strong>JVM 的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM 将会使用CAS 方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败， 当前线程就尝试自旋来获得锁。<br>整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。</p>
</li>
</ul>
<p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS 了，而轻量级锁主要就是通过CAS 修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li>互斥条件：一个资源每次只能被一个线程使用</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>指定获取锁的顺序，举例如下：</p>
<ol>
<li>比如某个线程只有获得A 锁和B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</li>
<li>获得锁的顺序是一定的，比如规定，只有获得A 锁的线程才有资格获取B 锁，按顺序获取锁就可以避免死锁！！！</li>
</ol>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写－读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p>例如上图线程A 与线程B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li><p>线程A 把本地内存A 更新过的共享变量刷新到主内存中去。</p>
</li>
<li><p>线程B 到主内存中去读取线程A 之前更新过的共享变量。</p>
</li>
</ol>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确地发送消息来显式进行通信。</p>
<p>在Java 中典型的消息传递方式，就是wait() 和notify() ，或者BlockingQueue 。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>hreadLocal 可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized 的做法是用空间来换时间。</p>
<p>ThreadLocal 有一个静态内部类ThreadLocalMap ，ThreadLocalMap 又包含了一个Entry 数组，Entry 本身是一个弱引用，他的key 是指向ThreadLocal 的弱引用，Entry 具备了保存key value键值对的能力。</p>
<p>弱引用的目的是防止内存泄漏，如果是强引用那么ThreadLocal 对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC 的时候被回收。</p>
<p>但是这样还是会存在内存泄漏的问题，假如key 和ThreadLocal 对象被回收之后，entry 中就存在key 为null，但是value 有值的entry 对象，但是永远没办法被访问到，同样除非线程结束运行。</p>
<p>但是只要ThreadLocal 使用恰当，在使用完之后调用remove 方法删除Entry 对象，实际上是不会出现这个问题的。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>随着CPU 和内存的发展速度差异的问题，导致CPU 的速度远快于内存，所以现在的CPU 加入了 高速缓存，高速缓存一般可以分为L1、L2、L3 三级缓存。基于上面的例子我们知道了这导致了 缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU 的重排序导致了原子性和有序性的问题，JMM 内存模型正是对多线程操作下的一系列规范约束， 因为不可能让程序员的代码去兼容所有的CPU，通过JMM 我们才屏蔽了不同硬件和操作系统内 存的访问差异， 这样保证了Java 程序在不同的平台下达到一致的内存访问效果，同时也是保证在 高效并发的时候程序能够正确执行。</p>
<h3 id="happen-before-规则"><a href="#happen-before-规则" class="headerlink" title="happen-before 规则"></a>happen-before 规则</h3><p>虽然指令重排提高了并发的性能，但是Java 虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意地改变执行位置，主要有以下几点：</p>
<ol>
<li>单线程每个操作，happen-before 于该线程中任意后续操作</li>
<li>volatile 写happen-before 与后续对这个变量的读</li>
<li>synchronized 解锁happen-before 后续对这个锁的加锁</li>
<li>final 变量的写happen-before 于final 域对象的读，happen-before 后续对final 变量的读</li>
<li>传递性规则，A 先于B ，B 先于C，那么A 一定先于C 发生</li>
</ol>
<p>主内存可以认为就是物理内存，Java 内存模型中实际就是虚拟机内存的一部分。而工作内存就是CPU 缓存，他有可能是寄存器也有可能是L1\L2\L3 缓存，都是有可能的。</p>
<h2 id="CyclicBarrier和-CountDownLatch的区别？"><a href="#CyclicBarrier和-CountDownLatch的区别？" class="headerlink" title="CyclicBarrier和 CountDownLatch的区别？"></a>CyclicBarrier和 CountDownLatch的区别？</h2><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：<br>(1)CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>
<p>(2)CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p>
<p>(3)CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>简单说一下AQS ，AQS 全称为AbstractQueuedSychronizer ，翻译过来应该是抽象队列同步器。</p>
<p>如果说java.util.concurrent 的基础是CAS 的话，那么AQS 就是整个Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry 中并连成双向队列，前面一个线程使用ReentrantLock 好了，则双向队列实际上的第一个Entry 开始运行。</p>
<p>AQS 定义了对双向队列所有的操作，而只开放了tryLock 和tryRelease 方法给开发者使用，开发者可以根据自己的实现重写tryLock 和tryRelease 方法，以实现自己的并发功能。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>emaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个int 型整数n ，表示某段代码最多只有n 个线程可以访问，如果超出了n ，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore 构造函数中</p>
<p>传入的int 型整数n&#x3D;1，相当于变成了一个synchronized 了</p>
<h2 id="Callable-和-Future"><a href="#Callable-和-Future" class="headerlink" title="Callable 和 Future"></a>Callable 和 Future</h2><p>Callable 接口类似于Runnable，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。</p>
<p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以Callable 用于产生结果， Future 用于获取结果。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>JDK7 提供了7 个阻塞队列。分别是：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue ：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue ：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque ：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="多线程上下文切换"><a href="#多线程上下文切换" class="headerlink" title="多线程上下文切换"></a>多线程上下文切换</h2><p>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p>
<p>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe ）。“页码”信息会一直保存到CPU 的内存中，直到他们被再次使用。</p>
<p>上下文切换是存储和恢复CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h2 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h2><p>所谓后台（daemon）线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程， 并且这个线程并不属于程序中不可或缺的部分。</p>
<p>因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说， 只要有任何非后台线程还在运行，程序就不会终止。</p>
<p>必须在线程启动之前调用setDaemon(）方法，才能把它设置为后台线程。注意：后台进程在不执行finally 子句的情况下就会终止其run(）方法。</p>
<p>比如：JVM 的垃圾回收线程就是Daemon 线程，Finalizer 也是守护线程。</p>
<h2 id="乐观锁和悲观锁的理解及如何实现"><a href="#乐观锁和悲观锁的理解及如何实现" class="headerlink" title="乐观锁和悲观锁的理解及如何实现"></a>乐观锁和悲观锁的理解及如何实现</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，<strong>所以每次在拿数据的时候都会上锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java 里面的同步原语synchronized 关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>，可以使用版本号等机制。</p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
<p>在Java 中java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式CAS 实现的。</p>
<h3 id="乐观锁实现机制"><a href="#乐观锁实现机制" class="headerlink" title="乐观锁实现机制"></a>乐观锁实现机制</h3><ol>
<li><p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p>
</li>
<li><p>java 中的Compare and Swap 即CAS ，当多个线程尝试使用CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
</li>
</ol>
<p>CAS 操作中包含三个操作数—— 需要读写的内存位置<br>（V）、进行比较的预期原值（A）和拟写入的新值（B)。如果内存位置V 的值与预期原值A 相<br>匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包<br>含三个操作数：</p>
<ol>
<li>变量内存地址，V 表示</li>
<li>旧的预期值，A 表示</li>
<li>准备设置的阈值，B 表示</li>
</ol>
<p>当执行CAS 指令时，只有当V 等于A 时，才会用B 去更新V 的值，否则就不会执行更新操作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>ABA 的问题 ：</strong>指的是在CAS 更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS 更新的漏洞就叫做ABA。只是ABA 的问题大部分场景下都不影响并发的最终效果。</p>
<p>Java 中有AtomicStampedReference 来解决这个问题，他加入了预期标志和更新后标志两个字段， 更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<p><strong>循环时间长开销大：</strong>自旋CAS 的方式如果长时间不成功，会给CPU 带来很大的开销。</p>
<p><strong>只能保证一个共享变量的原子操作：</strong>只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference 来处理或者使用锁synchronized 实现。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120013055.png"/>

<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>线程独占：栈，本地方法栈，程序计数器线程共享：堆，方法区</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>又称方法栈，线程私有的，线程执行方法是会创建一个栈阵，用来存储局部变量表，操作栈，动态链接，方法出口等信息.调用方法时执行入栈，方法返回式执行出栈.</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与栈类似，也是用来保存执行方法的信息.执行Java 方法是使用栈，执行Native 方法时使用本地方<br>法栈.</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>保存着当前线程执行的字节码位置，每个线程工作时都有独立的计数器，只为执行Java 方法服务，执行Native 方法时，程序计数器为空.</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405122146852.png"/>

<p>JVM 内存管理最大的一块，对被线程共享， 目的是存放对象的实例，几乎所有的对象实例都会放在这里， 当堆没有可用空间时，会抛出OOM 异常.根据对象的存活周期不同，JVM 把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</p>
<h3 id="堆内分配与回收策略"><a href="#堆内分配与回收策略" class="headerlink" title="堆内分配与回收策略"></a>堆内分配与回收策略</h3><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>大多数情况下，对象在新生代Eden区中分配，当 Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC</p>
<h4 id="什么是Minor-GC"><a href="#什么是Minor-GC" class="headerlink" title="什么是Minor GC"></a>什么是Minor GC</h4><p>指发生在新生代的垃圾收集，因为 Java对象大多朝生夕灭，所以 Minor GC非常频繁， 一般回收速度也比较快</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p><strong>XX:PretenureSizeThreshold</strong> 当创建的对象超过指定大小时，直接把对象分配在老年代<br>大对象就是指需要大量连续内存空间的 Java 对象如字符串、数组，为了避免为大对象分配内存时<br>由于分配担保机制带来的复制而降低效率</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><ul>
<li>-XX:MaxTenuringThreshold 设定对象在Survivor区最大年龄阈值，超过阈值转移到老年代，默认15</li>
<li>对象头的 Age 属性记录年龄，对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1，对象</li>
<li>在 Survivor 中每熬过一次MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>并不一定要Age到达阈值才晋升到老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大<br>于 Survivor 空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><p>又称非堆区，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器优化后的代码等<br>数据.1.7 的永久栈和1.8 的元空间都是方法区的一种实现</p>
<h2 id="JVM内存可见性"><a href="#JVM内存可见性" class="headerlink" title="JVM内存可见性"></a>JVM内存可见性</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120017757.png"/>

<p>JMM 是定义程序中变量的访问规则，线程对于变量的操作只能在自己的工作内存中进行，而不能直接对主内存操作.由于指令重排序，读写的顺序会被打乱，因此JMM 需要提供原子性，可见性，有序性保证.</p>
<h2 id="类加载与卸载"><a href="#类加载与卸载" class="headerlink" title="类加载与卸载"></a>类加载与卸载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120018966.png"/>

<p>其中<strong>验证，准备，解析</strong>合成链接</p>
<p><strong>加载</strong>通过类的完全限定名，查找此类字节码文件，利用字节码文件创建Class 对象.</p>
<p><strong>验证</strong>确保Class 文件符合当前虚拟机的要求，不会危害到虚拟机自身安全.</p>
<p><strong>准备</strong>进行内存分配，为static 修饰的类变量分配内存，并设置初始值（0 或null).不包含final 修饰的静态变量，因为final 变量在编译时分配.</p>
<p><strong>解析</strong>将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.</p>
<p>初始化主要完成静态块执行以及静态变量的赋值.先初始化父类，再初始化当前类.只有对类主动<br>使用时才会初始化.</p>
<p>触发条件包括，创建类的实例时，访问类的静态方法或静态变量的时候，使用Class.forName 反射<br>类的时候，或者某个子类初始化的时候.</p>
<p>Java 自带的加载器加载的类，在虚拟机的生命周期中是不会被卸载的，只有用户自定义的加载器<br>加载的类才可以被卸.</p>
<h4 id="加载机制－双向委派模式"><a href="#加载机制－双向委派模式" class="headerlink" title="加载机制－双向委派模式"></a>加载机制－双向委派模式</h4><p>双亲委派模式，即加载器加载类时先把请求委托给自己的父类加载器执行，直到顶层的启动类加<br>载器. 父类加载器能够完成加载则成功返回，不能则子类加载器才自己尝试加载.*</p>
<ol>
<li>避免类的重复加载</li>
<li>避免Java 的核心API 被篡改</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120020479.png"/>

<h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><p>第一范式：列不可再分第二范式：行可以唯一区分，主键约束第三范式：表的非主属性不能依赖<br>与其他表的非主属性外键约束且三大范式是一级一级依赖的，第二范式建立在第一范式上，第<br>三范式建立第一第二范式上。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/" rel="prev" title="考研政治复习(1)-马原">
      <i class="fa fa-chevron-left"></i> 考研政治复习(1)-马原
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">JAVA面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof"><span class="nav-number">1.3.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">1.4.</span> <span class="nav-text">Java自动装箱和拆箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">重载和重写的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals-%E4%B8%8E-x3D-x3D"><span class="nav-number">1.6.</span> <span class="nav-text">equals 与 &#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashcode"><span class="nav-number">1.7.</span> <span class="nav-text">Hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="nav-number">1.8.</span> <span class="nav-text">String、StringBuffer、StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList%E5%92%8ClinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.</span> <span class="nav-text">ArrayList和linkedList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.</span> <span class="nav-text">HashMap 和 HashTable 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E5%8C%85%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%8ECollections%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.</span> <span class="nav-text">Collection包结构，与Collections的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%88%E5%BC%BA%E5%BC%B1%E8%BD%AF%E8%99%9A%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">JAVA的四种引用（强弱软虚）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="nav-number">1.13.</span> <span class="nav-text">泛型常用特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.14.</span> <span class="nav-text">JAVA创建对象有几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="nav-number">1.15.</span> <span class="nav-text">可能两个不相等的对象有相同的hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.16.</span> <span class="nav-text">深浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">1.17.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">1.18.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-x3D-a-b-%E4%B8%8E-a-x3D-b"><span class="nav-number">1.19.</span> <span class="nav-text">a&#x3D;a+b 与 a+&#x3D;b</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally"><span class="nav-number">1.20.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exception-%E4%B8%8E-Error-%E5%8C%85%E7%BB%93%E6%9E%84"><span class="nav-number">1.21.</span> <span class="nav-text">Exception 与 Error 包结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">1.21.1.</span> <span class="nav-text">运行时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">1.21.2.</span> <span class="nav-text">被检查异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">1.21.3.</span> <span class="nav-text">错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOM%E3%80%81SOF"><span class="nav-number">1.22.</span> <span class="nav-text">OOM、SOF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.23.</span> <span class="nav-text">线程、进程、程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.23.1.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.23.2.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.23.3.</span> <span class="nav-text">程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E5%86%99%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.24.</span> <span class="nav-text">JAVA序列化中如果有写字段不想进行序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">1.25.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%92%8CNIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.25.1.</span> <span class="nav-text">IO和NIO的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%8F%8D%E5%B0%84"><span class="nav-number">1.26.</span> <span class="nav-text">JAVA反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.26.1.</span> <span class="nav-text">反射的实现方式：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%EF%BC%8CSet%EF%BC%8CMap"><span class="nav-number">1.27.</span> <span class="nav-text">List，Set，Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fail-fast"><span class="nav-number">1.28.</span> <span class="nav-text">fail-fast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashtable-%E4%B8%8E-HashMap"><span class="nav-number">1.29.</span> <span class="nav-text">Hashtable 与 HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E4%B8%AD%E7%9A%84-key-%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%90%97"><span class="nav-number">1.29.1.</span> <span class="nav-text">HashMap 中的 key 可以用任何类吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2-n%E6%AC%A1%E6%96%B9"><span class="nav-number">1.29.2.</span> <span class="nav-text">HashMap的长度为什么是2^n次方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.29.3.</span> <span class="nav-text">HashMap的数组的元素类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95index%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="nav-number">1.29.4.</span> <span class="nav-text">HashMap的映射关系的存储索引index如何计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E8%BF%98%E9%9C%80%E8%A6%81%E9%93%BE%E8%A1%A8%EF%BC%9F%E6%88%96%E9%97%AE%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3hash%E6%88%96-index-%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.29.5.</span> <span class="nav-text">为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-number">1.29.6.</span> <span class="nav-text">HashMap的数组什么时候扩容？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.30.</span> <span class="nav-text">HashMap 与 ConcurrentHashMap 的异同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">JAVA多线程与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable-%E5%92%8CCallable-%E6%8E%A5%E5%8F%A3%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">Runnable 和Callable 接口优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.2.</span> <span class="nav-text">Thread接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">停止线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">notify()和notifyAll()有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.2.2.</span> <span class="nav-text">sleep() 和 wait() 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">2.3.</span> <span class="nav-text">volatile 可以保证有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-%E5%92%8C-synchronized"><span class="nav-number">2.3.1.</span> <span class="nav-text">volatile 和 synchronized</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%B1%BB%E4%B8%AD%E7%9A%84-start-%E5%92%8C-run-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">Thread类中的 start() 和 run() 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify%E5%92%8CnotifyAll%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8thread%E7%B1%BB%E9%87%8C%E9%9D%A2%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">为什么wait,notify和notifyAll这些方法不在thread类里面？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">为什么wait和notify方法要在同步块中调用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%AD-interrupted-%E5%92%8C-islnterrupted%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">Java 中 interrupted 和 islnterrupted方法的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%ADsynchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">2.8.</span> <span class="nav-text">Java中synchronized和ReentrantLock有什么不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">2.9.</span> <span class="nav-text">保证线程的顺序执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SynchronizedMap%E5%92%8C-ConcurrentHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.10.</span> <span class="nav-text">SynchronizedMap和 ConcurrentHashMap有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">2.11.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">2.11.1.</span> <span class="nav-text">保证几个基本特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">2.12.</span> <span class="nav-text">Thread类中的yield方法有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit-%E5%92%8Cexecute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.13.</span> <span class="nav-text">Java线程池中submit()和execute()方法有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.14.</span> <span class="nav-text">synchronized关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="nav-number">2.15.</span> <span class="nav-text">Vector是一个线程安全类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.16.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.16.1.</span> <span class="nav-text">常用线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.16.2.</span> <span class="nav-text">线程池的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.16.3.</span> <span class="nav-text">JAVA线程池中队列常用类型有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.16.4.</span> <span class="nav-text">线程池核心线程数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">2.16.5.</span> <span class="nav-text">线程池的拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-number">2.17.</span> <span class="nav-text">JAVA程序是如何执行的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">2.18.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">2.18.1.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">2.18.2.</span> <span class="nav-text">避免死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">2.19.</span> <span class="nav-text">线程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.19.1.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">2.19.2.</span> <span class="nav-text">消息传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">2.20.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM"><span class="nav-number">2.21.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#happen-before-%E8%A7%84%E5%88%99"><span class="nav-number">2.21.1.</span> <span class="nav-text">happen-before 规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier%E5%92%8C-CountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.22.</span> <span class="nav-text">CyclicBarrier和 CountDownLatch的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">2.23.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">2.24.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable-%E5%92%8C-Future"><span class="nav-number">2.25.</span> <span class="nav-text">Callable 和 Future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">2.26.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">2.27.</span> <span class="nav-text">多线程上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Daemon%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.28.</span> <span class="nav-text">Daemon线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.29.</span> <span class="nav-text">乐观锁和悲观锁的理解及如何实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.29.1.</span> <span class="nav-text">乐观锁实现机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">2.29.2.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">2.29.2.1.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">3.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">JVM内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.2.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">3.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.5.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">3.5.1.</span> <span class="nav-text">堆内分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">对象优先在 Eden 区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMinor-GC"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">什么是Minor GC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.5.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.5.3.</span> <span class="nav-text">长期存活的对象进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="nav-number">3.5.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9A"><span class="nav-number">3.6.</span> <span class="nav-text">方法区：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.7.</span> <span class="nav-text">JVM内存可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="nav-number">3.8.</span> <span class="nav-text">类加载与卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">3.8.1.</span> <span class="nav-text">加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8D%E5%8F%8C%E5%90%91%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.8.1.1.</span> <span class="nav-text">加载机制－双向委派模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="nav-number">3.9.</span> <span class="nav-text">数据库的三范式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
