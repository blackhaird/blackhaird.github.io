<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JAVA面试题面向对象和面向过程的区别面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发 面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA面试题">
<meta property="og:url" content="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:description" content="JAVA面试题面向对象和面向过程的区别面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发 面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png">
<meta property="article:published_time" content="2024-05-10T05:26:38.000Z">
<meta property="article:modified_time" content="2024-05-11T15:02:56.043Z">
<meta property="article:author" content="MEIDE">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png">

<link rel="canonical" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JAVA面试题 | MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-11 23:02:56" itemprop="dateModified" datetime="2024-05-11T23:02:56+08:00">2024-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p><strong>面向过程：</strong>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象：</strong>是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1.int 是基本数据类型，Integer 是 int 的封装类，是引用类型。int 默认值是 0，而 Integer 默认值 是 null，所以 Integer 能区分出 0 和 null 的情况。一旦 java 看到 null，就知道这个引用 还没有指向某个 对象，在任何引用使用前，必须为其指定一个对象，否则会报错。 </p>
<p>2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给 另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看得见。</p>
<p>虽然定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值。</p>
<p>在编译之后 都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是1 个字节。使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这 里不是指的 是 32&#x2F;64 位系统，而是指 CPU 硬件层面），具有高效存取的特点</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof需要非基本类 i 必须是引用类型，不能是基本类</p>
<p>注意：编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错，如果 不能 确定类型，则通过编译，具体看运行时定</p>
<p>在 JavaSE 规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将 返 回 false。</p>
<h2 id="Java自动装箱和拆箱"><a href="#Java自动装箱和拆箱" class="headerlink" title="Java自动装箱和拆箱"></a>Java自动装箱和拆箱</h2><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;integer ）；调用方法：valueOf(int) 的方法 </p>
<p>拆箱就是自动将包装器类型转换为基本数据类型（integer–&gt;int ）。调用方法：intValue 的方法</p>
<p>在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之 间， </p>
<p>便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p>
<p>在某个范围内的整形数值的个数是有限的，而浮点数却不是。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重 写 （Override）从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。 子 类继承了父类原有的方法，但有时子类并不想原封不动地继承父类中的某个方法，所以在方法 名， 参数列表，返回类型（除过子类中方法的返回值是父类中方法返回值的子类时）</p>
<p>都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<ol>
<li>发生在父类与子类之间 </li>
<li>方法名，参数列表，返回类型（除过子类中方法的返回类 型 是父类中返回类型的子类）必须相同 </li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符 (public&gt;protected&gt;default&gt;private) </li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法 申 明更加宽泛的检查性异常</li>
</ol>
<p>重载 （Overload ） 在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>
<ol>
<li>重载 Overload 是一个类中多态性的一种表现 </li>
<li>重载要求同名方法的参数列表不同 （参数类型，参数个数甚至是参数顺序） </li>
<li>重载的时候，返回值类型可以相同也可以不相同。 无法返回 型别作为重载函数的区分标准</li>
</ol>
<h2 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals 与 &#x3D;&#x3D;"></a>equals 与 &#x3D;&#x3D;</h2><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即 否实指相同一个对象。比较的是真正意义上的指针操作。 </p>
<ol>
<li>比较的是操作符两端的操作数是否是同一个对象。 </li>
<li>两边的操作数必须是同一类型的（可以 是 父子类之间）才能编译通过。 </li>
<li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则 为 true，如： int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0 都是相同的（为 true），因为他们都指 向地 址为 10 的堆。</li>
</ol>
<p>equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的， 所 以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是&#x3D;&#x3D;的判断。 </p>
<p>总结： 所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的 equals object 可能为 null 则空指针</p>
<p>在阿里的代码规范中只使用 equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“&#x3D;&#x3D;” ，替换成 equals</p>
<h2 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h2><p>Java 的集合有两类，一类是 List，还有一类是 Set。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多， 用这样 的方法就会比较</p>
<p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域， 每 个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对 象的 哈希码就可以确定该对象应该存储的哪个区域</p>
<p>hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当 集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物 理 位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较 了；如 果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其他的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只 需要一两次。</p>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String 是只读字符串，它并不是基本数据类型、而是一个对象。从底层源码来看是一个final 类型 的 字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。<strong>每次对 String 的操作都 会生成 新的 String 对象</strong></p>
<p>隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append方法 <strong>拼接</strong>+后面的字符。</p>
<p>StringBuffer 和 StringBuilder 他们俩都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到</p>
<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和 StringBuilder 来进行操作。 </p>
<p> StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁， 所以来是线程安全的。</p>
<p> StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h2 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h2><p>Array(数组)是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 </p>
<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据，（因为删除数据以后，需要把后面所有的数据前移）</p>
<p>缺点：数组初始化必须指定初始化的长度，否则报错</p>
<p>List一是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</p>
<p>List有两个重要的实现类：ArrayList和LinkedList</p>
<ul>
<li><p>ArrayList:可以看作是能够<strong>自动增长容量</strong>的数组</p>
</li>
<li><p>ArrayList的toArray方法返回一个数组</p>
</li>
<li><p>ArrayList的asList方法返回一个列表</p>
</li>
<li><p>ArrayList底层的实现是Array,数组扩容实现</p>
</li>
<li><p>ArrayList Clone() 是浅复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</span><br><span class="line">缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</span><br><span class="line">高并发的情况下，线程不安全。多个线程同时操作ArrayList ，会引发不可预知的异常或错误。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>LinkList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList.当然，这些对比都是指数据量很大或者操作很频繁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开拓内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</span><br><span class="line">缺点：因为LinkedList 要移动指针，所以查询操作性能比较低。</span><br></pre></td></tr></table></figure>



<p>当需要对数据进行随机访问的时候，选用ArrayList。<br>当需要对数据进行多次增加删除修改时，采用LinkedList。<br>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用ArrayList。<br>当然，绝大多数业务的场景下，使用ArrayList 就够了，但需要注意避免ArrayList 的扩容，以及非顺序的插入。</p>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>1、两者父类不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了</span><br><span class="line">同时实现了map、Cloneable(可复制）、Serializable(可序列化）这三个接口。</span><br></pre></td></tr></table></figure>

<p>2、对外提供的接口不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable比HashMap多提供了elments()和contains()两个方法。elments()方法</span><br><span class="line">继承自Hashtable的父类Dictionnary。elements()方法用于返回此Hashtable中的</span><br><span class="line">value的枚举。</span><br><span class="line">contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致</span><br><span class="line">事实上，contansValue()就只是调用了一下contains()方法。</span><br></pre></td></tr></table></figure>

<p>3、对null的支持不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:key和value都不能为null。</span><br><span class="line">HashMap:key可以为null,但是这样的key只能有一个，因为必须保证key的唯一性；可以有</span><br><span class="line">多个key值对应的value为null</span><br></pre></td></tr></table></figure>

<p>4、安全性不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员</span><br><span class="line">自已处理多线程的安全问题。</span><br><span class="line"></span><br><span class="line">Hashtable是线程安全的，它的每个方法上都有synchronized关键字，因此可直接用于多线程中。</span><br><span class="line"></span><br><span class="line">虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为</span><br><span class="line">大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap.</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因</span><br><span class="line">为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</span><br></pre></td></tr></table></figure>

<p>5、初始容量大小和每次扩充容量大小不同 、</p>
<p>6、计算hash值的方法不</p>
<h2 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h2><p>Collection 是集合类的上级接口，子接口有 Set、 List、LinkedList、ArrayList、Vector、Stack、 Set； Collections 是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各 种 集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
<h2 id="JAVA的四种引用（强弱软虚）"><a href="#JAVA的四种引用（强弱软虚）" class="headerlink" title="JAVA的四种引用（强弱软虚）"></a>JAVA的四种引用（强弱软虚）</h2><ul>
<li><p>强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用 弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<p>可用场景： Java 源码中的中的就是使用弱引用，一旦我不需要某个引用，JVM 会自动帮我处理它，这样我就不需要做其他操作。</p>
</li>
<li><p>软引用 软引用在程序内存不足时，会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf 这个引用也是强引用，它是指向 SoftReference 这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向 new String(&quot;str&quot;）的引用，也就是 SoftReference 类中 T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用</p>
<p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入<strong>ReferenceQueue中</strong>。</p>
<p>注意哦，其他引用是被JVM 回收后才被传入中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有<br>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;())</span><br></pre></td></tr></table></figure>

<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做<br>这类动作，但是这个方式既不安全又低效</p>
</li>
</ul>
<p>上述所说的几类引用，都是指对象本身的引用，而不是指Reference 的四个子类的引用(SoftReference 等）。</p>
<h2 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h2><p>“泛型” ，顾名思义， “泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="JAVA创建对象有几种方式"><a href="#JAVA创建对象有几种方式" class="headerlink" title="JAVA创建对象有几种方式"></a>JAVA创建对象有几种方式</h2><p>java中提供了以下四种创建对象的方式：</p>
<ul>
<li><p>new创建新对象</p>
</li>
<li><p>通过反射机制</p>
</li>
<li><p>采用clone机制</p>
</li>
<li><p>通过序列化机制</p>
<p>调用ObjectInputStream 类的readObject() 方法。<br>反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对象。</p>
</li>
</ul>
<h2 id="可能两个不相等的对象有相同的hashcode"><a href="#可能两个不相等的对象有相同的hashcode" class="headerlink" title="可能两个不相等的对象有相同的hashcode"></a>可能两个不相等的对象有相同的hashcode</h2><p>有可能.在产生hash 冲突时，两个不相等的对象就会有相同的hashcode 值.当hash 冲突产生时，一般有以下几种方式来处理：</p>
<ul>
<li><p>拉链法：每个哈希表节点都有一个next 指针，多个哈希表节点可以用next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>
</li>
<li><p>再哈希：又叫双哈希法，有多个不同的Hash 函数.当发生冲突时，使用第二个，第三个….等哈希函数计算地址，直到无冲突.</p>
</li>
</ul>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><ul>
<li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象.换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象.</li>
<li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>被final 修饰的类不可以被继承</li>
<li>被final 修饰的方法不可以被重写</li>
<li>被final 修饰的变量不可以被改变.如果修饰引用，那么表示引用不可变，引用指向的内<br>容可变.</li>
<li>被final 修饰的方法，JVM 会尝试将其内联，以提高运行效率</li>
<li>被final 修饰的常量，在编译阶段会存入常量池</li>
</ul>
<p>编译器对final 域要遵守的两个重排序规则更好：</p>
<p>在构造函数内对一个final 域的写入,随后把这个被构造对象的引用赋值给一个引用变量</p>
<p>这两个操作之间不能重排序初次读一个包含final 域的对象的引用，与随后初次读这个final 域</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态变量和静态方法.也就是被static 所修饰的变量&#x2F; 方法都属于类的静态资源，</p>
<p>类实例所共享除了静态变量和静态方法之外，static 也用于静态块，多用于初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//执行相关操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外static 也多用于修饰内部类，此时称之为静态内部类.最后一种用法就是静态导包，即import static .import static 是在JDK 1.5 之后引入的新特性，<br>可以用来指定导入某个类中的静态资源，并且不需要使用类名，可以直接使用资源名，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//System.out.println(Math.sin(20))；传统做法</span></span><br><span class="line">System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="a-x3D-a-b-与-a-x3D-b"><a href="#a-x3D-a-b-与-a-x3D-b" class="headerlink" title="a&#x3D;a+b 与 a+&#x3D;b"></a>a&#x3D;a+b 与 a+&#x3D;b</h2><p>+&#x3D;操作符会进行隐式自动类型转换，此处a+&#x3D;b 隐式的将加操作的结果类型强制转换为持有结果<br>的类型，而a&#x3D;a+b 则不会自动进行类型转换.如：</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><strong>finally 的执行早于try 里面的return</strong></p>
<ol>
<li>不管有没有出现异常，finally 块中代码都会执行；</li>
<li>当try 和catch 中有return 时，finally 仍然会执行；</li>
<li>finally 是在return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally 执行前确定的；</li>
<li>finally 中最好不要包含return，否则程序会提前退出，返回值不是try 或catch 中保存的返回值。</li>
</ol>
<h2 id="Exception-与-Error-包结构"><a href="#Exception-与-Error-包结构" class="headerlink" title="Exception 与 Error 包结构"></a>Exception 与 Error 包结构</h2><p>Java 可抛出（Throwable）的结构分为三种类型：被检查的异常（CheckedException)，运行<br>时异常(RuntimeException)，错误（Error)。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>RuntimeException 及其子类都被称为运行时异常</p>
<p>常见的五种运行时异常：</p>
<ul>
<li>ClassCastException（类转换异常）</li>
<li>IndexOutOfBoundsException（数组越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArrayStoreException（数据存储异常，操作数组类型不一致）</li>
<li>BufferOverflowException</li>
</ul>
<h3 id="被检查异常"><a href="#被检查异常" class="headerlink" title="被检查异常"></a>被检查异常</h3><p>Exception 类本身，以及Exception 的子类中除了”运行时异常”之外的其他子类都属于被检查异常。</p>
<p>此类异常，要么通过throws 进行声明抛出，要么通过try-catch 进行捕获处理，否则不能通过编译。</p>
<p>例如 ：clone(）接口去克隆一个对象，而该对象对应的类没有实现Cloneable 接口，就会抛出<br>CloneNotSupportedException 异常。被检查异常通常都是可以恢复的。如：</p>
<ul>
<li>IOException</li>
<li>FileNotFoundException</li>
<li>SQLException</li>
</ul>
<p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的<br>FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对<br>象引用时没有确保对象非空而引起的NullPointerException 。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>定义: Error 类及其子类。</p>
<p>特点: 和运行时异常一样，编译器也不会对错误进行检查。</p>
<p>当资源不足、约束失败，或是或是其他程序无法继续运行的条件发生时，就产生错误。程序本身<br>无法修复这些错误的。例如，VirtualMachineError 就属于错误。出现这种错误会导致程序终止<br>运行。</p>
<p>OutOfMemoryError、ThreadDeath。</p>
<p>Java 虚拟机规范规定JVM 的内存分为好几块，比如堆，栈，程序计数器，方法区等</p>
<h2 id="OOM、SOF"><a href="#OOM、SOF" class="headerlink" title="OOM、SOF"></a>OOM、SOF</h2><p>OutOfMemoryError 异常</p>
<ul>
<li>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM）异常的可能。</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>运行时常量池溢出</li>
<li>方法区溢出</li>
</ul>
<p>SOF堆栈溢出 StackOverflow：</p>
<p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p>
<h2 id="线程、进程、程序"><a href="#线程、进程、程序" class="headerlink" title="线程、进程、程序"></a>线程、进程、程序</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h2 id="JAVA序列化中如果有写字段不想进行序列化"><a href="#JAVA序列化中如果有写字段不想进行序列化" class="headerlink" title="JAVA序列化中如果有写字段不想进行序列化"></a>JAVA序列化中如果有写字段不想进行序列化</h2><p>对于不想进行序列化的变量，使用transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化<br>时，被transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和<br>方法。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h3><p>NIO 即New IO，这个库是在JDK1.4 中才引入的。NIO 和IO 有相同的作用和目的，但实现方式不<br>同， NIO 主要用到的是块，所以NIO 的效率要比IO 高很多。在Java API 中提供了两套NIO ，一<br>套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h2 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h2><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象， 都能够调用它的任意一个方法。在java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。<br>动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的反射机制。(jdbc 就是典型的反射)</p>
<h3 id="反射的实现方式："><a href="#反射的实现方式：" class="headerlink" title="反射的实现方式："></a>反射的实现方式：</h3><p>第一步：获取Class 对象，有4 种方法：</p>
<ol>
<li><p>Class.forName(“类的路径”）</p>
</li>
<li><p>类名.class </p>
</li>
<li><p>对象名.getClass() </p>
</li>
<li><p>基本类型的包装类，可以调用包装类的Type 属性来获得该包装类的Class<br>对象</p>
</li>
<li><p>Class：表示正在运行的Java 应用程序中的类和接口注意： 所有获取对象的信息都需要Class类来实现。</p>
</li>
<li><p>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
</li>
<li><p>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限</p>
</li>
<li><p>Method：提供类或接口中某个方法的信息</p>
</li>
</ol>
<p>优点： </p>
<ul>
<li>能够运行时动态获取类的实例，提高灵活性； </li>
<li>与动态编译结合</li>
</ul>
<p>缺点： </p>
<ul>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</li>
</ul>
<p>解决方案： </p>
<ul>
<li>通过setAccessible(true)关闭JDK 的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多</li>
<li>ReflectASM 工具类，通过字节码生成的方式加快反射速度,相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li>
</ul>
<h2 id="List，Set，Map"><a href="#List，Set，Map" class="headerlink" title="List，Set，Map"></a>List，Set，Map</h2><p><strong>List（对付顺序的好帮手）：</strong> List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p>
<p><strong>Set（注重独一无二的性质）：</strong>不允许重复的集合。不会有多个元素引用相同的对象。</p>
<p><strong>Map（用来搜索的专家）：</strong> 使用键值对存储。Map 会维护与Key 有关联的值。两个Key 可以引用相同的对象，但Key 不能重复，典型的Key 是String 类型，但也可以是任何对象。</p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast 机制是Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：当某一个线程A 通过iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程A 访问集合时，就会抛出ConcurrentModificationException 异常，产生fail-fast 事件。这里的操作主要是指add、remove 和clear ，对集合元素个数进行修改。</span><br></pre></td></tr></table></figure>



<p>解决办法：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<p>可以这么理解：在遍历之前，把modCount 记下来expectModCount，后面expectModCount去和modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出ConcurrentModificationException 异常。</p>
<h2 id="Hashtable-与-HashMap"><a href="#Hashtable-与-HashMap" class="headerlink" title="Hashtable 与 HashMap"></a>Hashtable 与 HashMap</h2><ol>
<li>都实现了Map、Cloneable、Serializable</li>
<li>HashMap 继承的是AbstractMap，并且AbstractMap 也实现了Map 接口。Hashtable 继承Dictionary。</li>
<li>Hashtable 中大部分public 修饰普通方法都是synchronized 字段修饰的，是线程安全的， HashMap 是非线程安全的。</li>
<li>Hashtable 的key 不能为null ，value 也不能为null，这个可以从Hashtable 源码中的put方法看到，判断如果value 为null 就直接抛出空指针异常</li>
<li>HashMap 的key 和value 都可以为null。在计算hash 值的时候，有判断，如果key&#x3D;&#x3D;null ，则其hash&#x3D;0 ；至于value 是否为null ，根本没有判断过。</li>
<li>Hashtable 直接使用对象的hash 值。hash 值是JDK 根据对象的地址或者字符串或者数字算出来的int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li>
<li>默认情况下，初始容量不同，Hashtable 的初始长度是11，之后每次扩充容量变为之前的2n+1（ n 为上一次的长度）<strong>而HashMap 的初始长度为16</strong> ，之后每次扩充变为原来的两倍。</li>
</ol>
<p>Hashtable 是线程安全，推荐使用HashMap 代替Hashtable；如果需要线程安全<br>高并发的话，推荐使用ConcurrentHashMap 代替Hashtable。这个回答完了，面试官可能会继续问：HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p>
<h3 id="HashMap-中的-key-可以用任何类吗"><a href="#HashMap-中的-key-可以用任何类吗" class="headerlink" title="HashMap 中的 key 可以用任何类吗"></a>HashMap 中的 key 可以用任何类吗</h3><p>平时可能大家使用得最多的就是使用String 作为HashMap 的key，但是现在我们想使用某个自定义类作为HashMap 的key，那就需要注意以下几点：</p>
<ul>
<li>如果类重写了equals 方法，它也应该重写hashCode 方法。</li>
<li>类的所有实例需要遵循与equals 和hashCode 相关的规则。</li>
<li>如果一个类没有使用equals，你不应该在hashCode 中使用它。</li>
<li>咱们自定义key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode 和equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h3 id="HashMap的长度为什么是2-n次方"><a href="#HashMap的长度为什么是2-n次方" class="headerlink" title="HashMap的长度为什么是2^n次方"></a>HashMap的长度为什么是2^n次方</h3><p>为了能让HashMap 存数据和取数据的效率高，尽可能地减少hash 值的碰撞，也就是说尽量把数据能均匀地分配，每个链表或者红黑树长度尽量相等。</p>
<p>我们首先可能会想到% 取模的操作来实现。</p>
<p>下面是回答的重点哟：</p>
<blockquote>
<p>取余（%）操作中如果除数是2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说hash % length &#x3D;&#x3D; hash &amp;(length - 1) 的前提是length 是2 的n 次方）。并且，采用二进制位操作&amp; ，相对于% 能够提高运算效率。<br>这就是为什么HashMap 的长度需要2 的N 次方了。</p>
</blockquote>
<h3 id="HashMap的数组的元素类型"><a href="#HashMap的数组的元素类型" class="headerlink" title="HashMap的数组的元素类型"></a>HashMap的数组的元素类型</h3><blockquote>
<p>java.util.Map$Entry。JDK1.7的HashMap中有内部类Entry实现Entry接口</p>
<p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口，并且TreeNode是Node的子类。</p>
</blockquote>
<h3 id="HashMap的映射关系的存储索引index如何计算"><a href="#HashMap的映射关系的存储索引index如何计算" class="headerlink" title="HashMap的映射关系的存储索引index如何计算"></a>HashMap的映射关系的存储索引index如何计算</h3><p>hash &amp; table.length-1</p>
<h3 id="为什么数组还需要链表？或问如何解决hash或-index-冲突问题？"><a href="#为什么数组还需要链表？或问如何解决hash或-index-冲突问题？" class="headerlink" title="为什么数组还需要链表？或问如何解决hash或[index]冲突问题？"></a>为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</h3><blockquote>
<p>答：为了解决hash和[index]冲突问题</p>
<p>（1）两个不相同的key的hashCode值本身可能相同</p>
<p>（2）两个不相同的key的hashCode值不同，但是经过hash()运算，结果相同</p>
<p>（3）两个hashCode不相同的key，经过hash()运算，结果也不相同，但是通过 hash &amp; table.length-1运算得到的[index]可能相同</p>
<p>那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p>
</blockquote>
<h3 id="HashMap的数组什么时候扩容？"><a href="#HashMap的数组什么时候扩容？" class="headerlink" title="HashMap的数组什么时候扩容？"></a>HashMap的数组什么时候扩容？</h3><blockquote>
<p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!&#x3D;null时，两个条件同时满足会扩容</p>
<p>JDK1.8版：当要添加新Entry对象时发现</p>
<p>（1）size达到threshold</p>
<p>（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容 ， **达到64会进行树化 **因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p>
<p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p>
</blockquote>
<h2 id="HashMap-与-ConcurrentHashMap-的异同"><a href="#HashMap-与-ConcurrentHashMap-的异同" class="headerlink" title="HashMap 与 ConcurrentHashMap 的异同"></a>HashMap 与 ConcurrentHashMap 的异同</h2><ol>
<li><p>都是key-value 形式的存储数据；</p>
</li>
<li><p>HashMap 是线程不安全的，ConcurrentHashMap 是JUC 下的线程安全的；</p>
</li>
<li><p>HashMap 底层数据结构是数组+ 链表（JDK 1.8 之前）。JDK 1.8 之后是数组+ 链表+ 红黑树。当链表中元素个数达到8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</p>
</li>
<li><p>HashMap 初始数组大小为16（默认），当出现扩容的时候，以0.75 *数组大小的方式进行扩容；</p>
</li>
<li><p>ConcurrentHashMap 在JDK 1.8 之前是采用分段锁来实现的Segment + HashEntry ，Segment 数组大小默认是16 ，2 的n 次方；JDK 1.8 之后，采用Node + CAS +Synchronized 来保证并发安全进行实现</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png"/>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/" rel="prev" title="考研政治复习(1)-马原">
      <i class="fa fa-chevron-left"></i> 考研政治复习(1)-马原
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">JAVA面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof"><span class="nav-number">1.3.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">1.4.</span> <span class="nav-text">Java自动装箱和拆箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">重载和重写的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals-%E4%B8%8E-x3D-x3D"><span class="nav-number">1.6.</span> <span class="nav-text">equals 与 &#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashcode"><span class="nav-number">1.7.</span> <span class="nav-text">Hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="nav-number">1.8.</span> <span class="nav-text">String、StringBuffer、StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList%E5%92%8ClinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.</span> <span class="nav-text">ArrayList和linkedList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.</span> <span class="nav-text">HashMap 和 HashTable 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E5%8C%85%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%8ECollections%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.</span> <span class="nav-text">Collection包结构，与Collections的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%88%E5%BC%BA%E5%BC%B1%E8%BD%AF%E8%99%9A%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">JAVA的四种引用（强弱软虚）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="nav-number">1.13.</span> <span class="nav-text">泛型常用特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.14.</span> <span class="nav-text">JAVA创建对象有几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="nav-number">1.15.</span> <span class="nav-text">可能两个不相等的对象有相同的hashcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.16.</span> <span class="nav-text">深浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">1.17.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">1.18.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-x3D-a-b-%E4%B8%8E-a-x3D-b"><span class="nav-number">1.19.</span> <span class="nav-text">a&#x3D;a+b 与 a+&#x3D;b</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally"><span class="nav-number">1.20.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exception-%E4%B8%8E-Error-%E5%8C%85%E7%BB%93%E6%9E%84"><span class="nav-number">1.21.</span> <span class="nav-text">Exception 与 Error 包结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">1.21.1.</span> <span class="nav-text">运行时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">1.21.2.</span> <span class="nav-text">被检查异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">1.21.3.</span> <span class="nav-text">错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOM%E3%80%81SOF"><span class="nav-number">1.22.</span> <span class="nav-text">OOM、SOF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.23.</span> <span class="nav-text">线程、进程、程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.23.1.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.23.2.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.23.3.</span> <span class="nav-text">程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E5%86%99%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.24.</span> <span class="nav-text">JAVA序列化中如果有写字段不想进行序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">1.25.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%92%8CNIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.25.1.</span> <span class="nav-text">IO和NIO的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E5%8F%8D%E5%B0%84"><span class="nav-number">1.26.</span> <span class="nav-text">JAVA反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.26.1.</span> <span class="nav-text">反射的实现方式：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%EF%BC%8CSet%EF%BC%8CMap"><span class="nav-number">1.27.</span> <span class="nav-text">List，Set，Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fail-fast"><span class="nav-number">1.28.</span> <span class="nav-text">fail-fast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashtable-%E4%B8%8E-HashMap"><span class="nav-number">1.29.</span> <span class="nav-text">Hashtable 与 HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E4%B8%AD%E7%9A%84-key-%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%90%97"><span class="nav-number">1.29.1.</span> <span class="nav-text">HashMap 中的 key 可以用任何类吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2-n%E6%AC%A1%E6%96%B9"><span class="nav-number">1.29.2.</span> <span class="nav-text">HashMap的长度为什么是2^n次方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.29.3.</span> <span class="nav-text">HashMap的数组的元素类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95index%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="nav-number">1.29.4.</span> <span class="nav-text">HashMap的映射关系的存储索引index如何计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E8%BF%98%E9%9C%80%E8%A6%81%E9%93%BE%E8%A1%A8%EF%BC%9F%E6%88%96%E9%97%AE%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3hash%E6%88%96-index-%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.29.5.</span> <span class="nav-text">为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-number">1.29.6.</span> <span class="nav-text">HashMap的数组什么时候扩容？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.30.</span> <span class="nav-text">HashMap 与 ConcurrentHashMap 的异同</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
