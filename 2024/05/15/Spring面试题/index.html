<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SpringSpring 是一个轻量级的IoC 和AOP 容器框架。是为Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML 的配置、基于注解的配置、基于Java 的配置。主要由以下几个模块组成：Spring Core ：核心类库，提供IOC 服务；Spring Context：提供框架式的Bean 访问方式">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring面试题">
<meta property="og:url" content="http://example.com/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:description" content="SpringSpring 是一个轻量级的IoC 和AOP 容器框架。是为Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML 的配置、基于注解的配置、基于Java 的配置。主要由以下几个模块组成：Spring Core ：核心类库，提供IOC 服务；Spring Context：提供框架式的Bean 访问方式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405160110946.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161629381.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161641151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161935493.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170118378.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170045709.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170101103.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170107703.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170110652.png">
<meta property="article:published_time" content="2024-05-15T05:26:38.000Z">
<meta property="article:modified_time" content="2024-05-16T17:19:49.098Z">
<meta property="article:author" content="MEIDE">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405160110946.png">

<link rel="canonical" href="http://example.com/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring面试题 | MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-15 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-15T13:26:38+08:00">2024-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-17 01:19:49" itemprop="dateModified" datetime="2024-05-17T01:19:49+08:00">2024-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 是一个轻量级的IoC 和AOP 容器框架。是为Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML 的配置、基于注解的配置、基于Java 的配置。<br>主要由以下几个模块组成：<br>Spring Core ：核心类库，提供IOC 服务；<br>Spring Context：提供框架式的Bean 访问方式，以及企业级功能（JNDI、定时任务等）；<br>Spring AOP：AOP 服务；<br>Spring DAO：对JDBC 的抽象，简化了数据访问异常的处理；<br>Spring ORM：对现有的ORM 框架的支持；<br>Spring Web：提供了基本的面向Web 的综合特性，例如多方文件上传；<br>Spring MVC：提供面向Web 应用的Model-View-Controller 实现。</p>
<h2 id="Autowired和Resource关键字的区别？"><a href="#Autowired和Resource关键字的区别？" class="headerlink" title="Autowired和Resource关键字的区别？"></a>Autowired和Resource关键字的区别？</h2><p>@Resource 和@Autowired 都是做bean 的注入时使用，其实@Resource 并不是Spring 的注解，它的包是javax.annotation.Resource ，需要导入，但是Spring 支持该注解的注入。<br>1、共同点<br>两者都可以写在字段和setter 方法上。两者如果都写在字段上，那么就不需要再写setter 方法。<br>2、不同点<br>（ 1 ）@Autowired@Autowired 为Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired；只按照byType 注入。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null 值，可以设置它的required 属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier 注解一起使用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>@Resource 默认按照ByName 自动注入，由J2EE 提供，需要导入包javax.annotation.Resource。</p>
<p>@Resource 有两个重要的属性： name 和type，而Spring 将@Resource 注解的name 属性解析为</p>
<p>bean 的名字，而type 属性则解析为bean 的类型。所以，如果使用name 属性，则使用byName的自动注入策略，而使用type 属性时则使用byType 自动注入策略。如果既不指定name 也不指定type 属性，这时将通过反射机制使用byName 自动注入策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="comment">// 下面两种@Resource 只要使用一种即可</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的setter 方法</span></span><br><span class="line">上<span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Resource 装配顺序：<br>①如果同时指定了name 和type，则从Spring 上下文中找到唯一匹配的bean 进行装配，找不到则抛出异常。<br>②如果指定了name ，则从上下文中查找名称（id）匹配的bean 进行装配，找不到则抛出异常。<br>③如果指定了type，则从上下文中找到类似匹配的唯一bean 进行装配，找不到或是找到多个，都会抛出异常。<br>④如果既没有指定name ，又没有指定type，则自动按照byName 方式进行装配；如果没有匹配， 则回退为一个原始类型进行匹配，如果匹配则自动装配。<br>@Resource 的作用相当于@Autowired，只不过@Autowired 按照byType 自动注入。</p>
<h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p><strong>构造器注入</strong>将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</p>
<p>优点： 对象初始化完成后便可获得可使用的对象。<br>缺点： 当需要注入的对象很多时，构造器参数列表将会很长； 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</p>
<h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>setter方法注入loC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。<br>优点：灵活。可以选择性地注入需要的对象。<br>缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</p>
<h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>接口注入依赖类必须实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。<br>优点接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。<br>缺点： 侵入性太强，不建议使用。<br>PS：什么是侵入行？ 如果类A 要使用别人提供的一个功能，若为了使用这功能，需要在自己的<br>类中增加额外的代码，这就是侵入性。</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>MVC：MVC 是一种设计模式<br>MVC 的原理图：</p>
<ul>
<li>M-Model 模型（完成业务逻辑：由javaBean 构成，service+dao+entity）</li>
<li>V-View 视图（做界面的展示jsp ，html…… ）</li>
<li>C-Controller 控制器（接收请求—〉调用模型—〉根据结果派发页面）</li>
</ul>
<p>springMVC 是一个MVC 的开源框架，springMVC&#x3D;struts2+spring ，springMVC 就相当于是Struts2加上spring 的整合，</p>
<p>可以简单地把springMVC 理解为是spring 的一个模块（类似AOP ，IOC 这样的模块），网络上经常会说springMVC 和spring 无缝集成，其实springMVC<br>就是spring 的一个子模块，所以根本不需要同spring 进行整合。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405160110946.png"/>

<ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView。</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View。</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<p>以下组件通常使用框架提供实现：</p>
<p>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p>
<p>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。</p>
<p>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p>
<p><strong>组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong></p>
<p>作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
<p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p>
<p>作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p><strong>3、处理器适配器HandlerAdapter</strong></p>
<p>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p><strong>4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong></p>
<p>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>
<p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong></p>
<p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>
<p><strong>6、视图View(需要工程师开发jsp…)</strong></p>
<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>
<h3 id="下边两个组件通常情况下需要开发："><a href="#下边两个组件通常情况下需要开发：" class="headerlink" title="下边两个组件通常情况下需要开发："></a>下边两个组件通常情况下需要开发：</h3><p>Handler：处理器，即后端控制器用controller表示。</p>
<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>
<h2 id="SpringMVC常用的注解"><a href="#SpringMVC常用的注解" class="headerlink" title="SpringMVC常用的注解"></a>SpringMVC常用的注解</h2><p>@RequestMapping：用于处理请求url 映射的注解，可用于类或方法上。用于类上，则表示类<br>中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http 请求的json 数据，将json 转换为java 对象。</p>
<p>@ResponseBody：注解实现将conreoller 方法返回对象转化为json 对象响应给客户。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块<br>所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的<br>重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p>
<p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP 就会使用<br>JDK 动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK 动态代理，转而使<br>用CGlib 动态代理生成一个被代理对象的子类来作为代理。</p>
<h3 id="Spring-AOP-和-Aspect-AOP-有什么区别？"><a href="#Spring-AOP-和-Aspect-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 Aspect] AOP 有什么区别？"></a>Spring AOP 和 Aspect] AOP 有什么区别？</h3><p>Spring AOP 是属于运行时增强，而AspectJ 是编译时增强。Spring AOP 基于代理（Proxying），而AspectJ 基于字节码操作（Bytecode Manipulation）。</p>
<p>Spring AOP 已经集成了AspectJ ，AspectJ 应该算得上是Java 生态系统中最完整的AOP 框架了。AspectJ 相比于Spring AOP 功能更加强大，但是Spring AOP 相对来说更简单。</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它<br>比SpringAOP 快很多。</p>
<h3 id="在SpringAOP中，关注点和横切关注的区别是什么？"><a href="#在SpringAOP中，关注点和横切关注的区别是什么？" class="headerlink" title="在SpringAOP中，关注点和横切关注的区别是什么？"></a>在SpringAOP中，关注点和横切关注的区别是什么？</h3><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<p>那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP 的位置。</p>
<p>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
<h3 id="通知-与-通知的类型"><a href="#通知-与-通知的类型" class="headerlink" title="通知 与 通知的类型"></a>通知 与 通知的类型</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的<br>代码段。<br>Spring切面可以应用五种类型的通知：</p>
<ul>
<li>before: 前置通知，在一个方法执行前被调用。</li>
<li>after: 在方法执行之后调用的通知，无论方法执行是否成功。</li>
<li>after-returning: 仅当方法成功完成后执行的通知。</li>
<li>after-throwing: 在方法抛出异常退出时执行的通知。</li>
<li>around: 在方法执行之前和之后调用的通知。</li>
</ul>
<h2 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h2><p>IOC 就是控制反转，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖IoC 容器来动态注入对象需要的外部资源。</p>
<p>最直观的表达就是，IOC 让对象的创建不用去new 了，可以由spring 自动生产，使用java的反射机制，根据配置文件在运行时动态地去创建对象以及管理对象，并调用对象的方法的。</p>
<p>Spring 的IOC 有三种注入方式：构造器注入、setter 方法注入、根据注解注入。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161629381.png"/>

<h2 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h2><p>首先说一下Servlet 的生命周期：实例化，初始init，接收请求service，销毁destroy；</p>
<p>Spring 上下文中的Bean 生命周期也类似，如下：</p>
<h3 id="实例化Bean-："><a href="#实例化Bean-：" class="headerlink" title="实例化Bean ："></a>实例化Bean ：</h3><p>对于BeanFactory 容器，当客户向容器请求一个尚未初始化的bean 时，或初始化bean 的时候需要注入另一个尚未初始化的依赖时， 容器就会调用createBean 进行实例化。对于ApplicationContext 容器，当容器启动结束后，通过获取BeanDefinition 对象中的信息，实例化所有的bean。</p>
<h3 id="设置对象属性（依赖注入）："><a href="#设置对象属性（依赖注入）：" class="headerlink" title="设置对象属性（依赖注入）："></a>设置对象属性（依赖注入）：</h3><p>实例化后的对象被封装在BeanWrapper 对象中，紧接着，Spring 根据BeanDefinition 中的信<br>息以及通过BeanWrapper 提供的设置属性的接口完成依赖注入。</p>
<h3 id="处理Aware-接口："><a href="#处理Aware-接口：" class="headerlink" title="处理Aware 接口："></a>处理Aware 接口：</h3><p>接着，Spring 会检测该对象是否实现了xxxAware 接口，并将相关的xxxAware 实例注入Bean ：</p>
<ol>
<li>如果这个Bean 已经实现了BeanNameAware 接口，会调用它实现的setBeanName(String beanId）方法，此处传递的就是Spring 配置文件中Bean 的id 值；</li>
<li>如果这个Bean 已经实现了BeanFactoryAware 接口，会调用它实现的setBeanFactory(）方法，传递的是Spring 工厂自身。</li>
<li>如果这个Bean 已经实现了ApplicationContextAware 接口，会调用<br>setApplicationContext(ApplicationContext）方法，传入Spring上下文</li>
</ol>
<h3 id="BeanPostProcessor："><a href="#BeanPostProcessor：" class="headerlink" title="BeanPostProcessor："></a>BeanPostProcessor：</h3><p>如果想对Bean 进行一些自定义的处理，那么可以让Bean 实现了BeanPostProcessor 接口，那<br>将会调用postProcessBeforeInitialization(Object obj, Strings）方法。</p>
<h3 id="InitializingBean-与init-method-："><a href="#InitializingBean-与init-method-：" class="headerlink" title="InitializingBean 与init-method ："></a>InitializingBean 与init-method ：</h3><p>如果Bean 在Spring 配置文件中配置了init-method 属性，则会自动调用其配置的初始化方法。</p>
<h3 id="BeanPostProcessor：-1"><a href="#BeanPostProcessor：-1" class="headerlink" title="BeanPostProcessor："></a>BeanPostProcessor：</h3><p>如果这个Bean 实现了BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, Strings）方法；由于这个方法是在Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>
<p><strong>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个Bean 了。</strong></p>
<h3 id="DisposableBean-："><a href="#DisposableBean-：" class="headerlink" title="DisposableBean ："></a>DisposableBean ：</h3><p>当Bean 不再需要时，会经过清理阶段，如果Bean 实现了DisposableBean 这个接口，会调用其实现的destroy(）方法；</p>
<h3 id="destroy-method-："><a href="#destroy-method-：" class="headerlink" title="destroy-method ："></a>destroy-method ：</h3><p>最后，如果这个Bean 的Spring 配置中配置了destroy-method 属性，会自动调用其配置的销<br>毁方法。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161641151.png"/>

<h2 id="Spring支持的几种bean的作用域？"><a href="#Spring支持的几种bean的作用域？" class="headerlink" title="Spring支持的几种bean的作用域？"></a>Spring支持的几种bean的作用域？</h2><p>Spring 容器中的bean 可以分为5 个范围：</p>
<ol>
<li>singleton：默认，每个容器中只有一个bean 的实例，<strong>单例的模式</strong>由<strong>BeanFactory 自身来维护</strong>。</li>
<li>prototype：<strong>为每一个bean 请求提供一个实例。</strong></li>
<li>request：<strong>为每一个网络请求创建一个实例</strong>，在请求完成以后，<strong>bean 会失效并被垃圾回收器回收</strong>。</li>
<li>session：与request 范围类似，<strong>确保每个session 中有一个bean 的实例</strong>，<strong>在session 过期后， bean 会随之失效</strong>。</li>
<li>global-session：全局作用域，global-session 和Portlet 应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet 共用全局的存储变量的话，那么这全局变量需要存储在global-session 中。全局作用域与Servlet 中的session 作用域效果相同。</li>
</ol>
<h2 id="Spring基于xml注入bean的几种方式？"><a href="#Spring基于xml注入bean的几种方式？" class="headerlink" title="Spring基于xml注入bean的几种方式？"></a>Spring基于xml注入bean的几种方式？</h2><p>（ 1 ）Set 方法注入；<br>（ 2）构造器注入：①通过index 设置参数的位置；②通过type 设置参数类型；<br>（ 3）静态工厂注入；<br>（ 4）实例工厂；</p>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><ul>
<li><p><strong>简单工厂模式：</strong></p>
<p>Spring 中的BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p>
</li>
<li><p><strong>工厂模式：</strong></p>
<p>Spring 中的FactoryBean 就是典型的工厂方法模式，实现了FactoryBean 接口的bean 是一类叫做factory 的bean。其特点是，spring 在使用getBean() 调用获得该bean 时，会自动调用该bean 的getObject() 方法，所以返回的不是factory 这个bean，而是这个bean.getOjbect() 方法的返回值。</p>
</li>
<li><p><strong>单例模式：</strong></p>
<p>在spring 中用到的单例模式有： scope&#x3D;”singleton” ，注册式单例模式，bean 存放于Map 中。bean name 当做key ，bean 当做value。</p>
</li>
<li><p><strong>原型模式：</strong></p>
<p>在spring 中用到的原型模式有： scope&#x3D;”prototype” ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。迭代器模式：在Spring 中有个CompositeIterator 实现了Iterator ，Iterable 接口和Iterator接口，这两个都是迭代相关的接口。可以这么认为，实现了Iterable 接口，则表示某对象是可被迭代的。Iterator 接口相当于是一个迭代器，实现了Iterator 接口，等于具体定义了这个可被迭代的对象是如何进行迭代的。</p>
</li>
<li><p><strong>代理模式：</strong></p>
<p>Spring 中经典的AOP，就是使用动态代理实现的，分JDK 和CGlib 动态代理。</p>
</li>
<li><p><strong>适配器模式：</strong></p>
<p>Spring 中的AOP 中AdvisorAdapter 类，它有三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapterThrowsAdviceAdapter。Spring会根据不同的AOP 配置来使用对应的Advice，与策略模式不同的是，一个方法可以同时拥有多个Advice。Spring 存在很多以Adapter 结尾的，大多数都是适配器模式。</p>
</li>
<li><p><strong>观察者模式：</strong></p>
<p>Spring 中的Event 和Listener。spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自EventObject。spring 事件监听器：ApplicationListener，该接口继承了EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。</p>
</li>
<li><p><strong>模板模式：</strong></p>
<p>Spring 中的org.springframework.jdbc.core.JdbcTemplate 就是非常经典的模板模式的应用，里面的execute 方法，把整个算法步骤都定义好了。</p>
</li>
<li><p><strong>责任链模式：</strong></p>
<p>DispatcherServlet 中的doDispatch() 方法中获取与请求匹配的处理<br>器HandlerExecutionChain ，this.getHandler() 方法的处理使用到了责任链模式。</p>
</li>
</ul>
<p>注意：这里只是列举了部分设计模式，其实里面用到了还有享元模式、建造者模等。可选择性地回答，主要是怕你回答了迭代器模式，然后继续问你，结果你一问三不知，那就尴了干了。</p>
<h2 id="Spring中ApplicationContext和BeanFactory的区别"><a href="#Spring中ApplicationContext和BeanFactory的区别" class="headerlink" title="Spring中ApplicationContext和BeanFactory的区别"></a>Spring中ApplicationContext和BeanFactory的区别</h2><h3 id="包目录不同"><a href="#包目录不同" class="headerlink" title="包目录不同"></a><strong>包目录不同</strong></h3><p>spring-beans.jar 中org.springframework.beans.factory.BeanFactory<br>spring-context.jar 中org.springframework.context.ApplicationContext</p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>BeanFactory 是不支持国际化功能的，因为BeanFactory 没有扩展Spring 中MessageResource 接口。相反，由于ApplicationContext 扩展了MessageResource 接口，因而具有消息处理的能力（ i18N ）。</p>
<h3 id="强大事件机制（Event）"><a href="#强大事件机制（Event）" class="headerlink" title="强大事件机制（Event）"></a>强大事件机制（Event）</h3><p>基本上牵涉到事件（Event）方面的设计，就离不开观察者模式ApplicationContext 的事件机制主要通过ApplicationEvent 和ApplicationListener 这两个接口来提供的，和Java swing 中的事件机制一样。即当ApplicationContext 中发布一个事件时，所有扩展了ApplicationListener的Bean 都将接收到这个事件，并进行相应的处理。</p>
<h3 id="底层资源的访问"><a href="#底层资源的访问" class="headerlink" title="底层资源的访问"></a>底层资源的访问</h3><p>ApplicationContext 扩展了ResourceLoader（资源加载器）接口，从而可以用来加载多个Resource ，而BeanFactory 是没有扩展ResourceLoader。</p>
<h3 id="对Web应用的支持"><a href="#对Web应用的支持" class="headerlink" title="对Web应用的支持"></a>对Web应用的支持</h3><p>与BeanFactory通常以编程的方式被创建，ApplicationContext能以声明的方式创建，如使用ContextLoader。当然你也可以使用 ApplicationContext的实现方式之一，以编程的方式创建ApplicationContext 实例。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><ol>
<li>BeanFactroy 采用的是延迟加载形式来注入Bean 的，即只有在使用到某个Bean 时（调用getBean())，才对该Bean 进行加载实例化。这样，我们就不能发现一些存在的spring 的配置问题。而ApplicationContext 则相反，它是在容器启动时，一次性创建了有的Bean。<br>这样，在容器启动时，我们就可以发现Spring 中存在的配置错误。</li>
<li>BeanFactory 和ApplicationContext 都支持BeanPostProcessor、BeanFactoryPostProcessor 的使用。两者之间的区别是：BeanFactory 需要手动注册，而ApplicationContext 则是自动注册。</li>
</ol>
<p>可以看到，ApplicationContext 继承了BeanFactory ，BeanFactory 是Spring 中比较原始的Factory，它不支持AOP、Web 等Spring 插件。而ApplicationContext 不仅包含了BeanFactory的所有功能，还支持Spring 的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。BeanFactory 是Spring 框架的基础设施面向Spring 本身；而ApplicationContext 面向使用Spring 的开发者，相BeanFactory 提供了更多面向实际应用的功能，几乎所有场合都可以直接使用ApplicationContext，而不是底层的BeanFactory。</p>
<h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><p>BeanFactory 类型的有XmlBeanFactory，它可以根据XML 文件中定义的内容，创建相应的Bean。<br>ApplicationContext 类型的常用容器有：</p>
<ol>
<li>ClassPathXmlApplicationContext：从ClassPath 的XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</li>
<li>FileSystemXmlApplicationContext：由文件系统中的XML 配置文件读取上文。</li>
<li>XmlWebApplicationContext：由Web 应用的XML 文件读取上下文。例如我们在SpringMVC 使用的情况。</li>
</ol>
<h2 id="Spring-框架中的单例-Bean-是线程安全的吗？"><a href="#Spring-框架中的单例-Bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的吗？"></a>Spring 框架中的单例 Bean 是线程安全的吗？</h2><p>Spring 框架并没有对单例Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例Bean 的线程安全和并发问题，需要开发者自行去搞定。</li>
<li>单例的线程安全问题，并不是Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例Bean 或多例Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的Spring Bean 并没有可变的状态，所以在某种程度上说Spring 的单例Bean 是线程安全的。如果你的Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态Bean 的作用域（Scope）由Singleton 变更为Prototype。</p>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161935493.png"/>

<ol>
<li>首先A 完成初始化第一步并将自己提前曝光出来（通过ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象B，此时就会去尝试get(B)，这个时候发现B 还没有被创建出来；</li>
<li>然后B 就走创建流程，在B 初始化的时候，同样发现自己依赖C ，C 也没有被创建出来；</li>
<li>这个时候C 又开始初始化进程，但是在初始化的过程中发现自己依赖A，于是尝试get(A)。这个时候由于A 已经添加至缓存中（一般都是添加至三级缓存<strong>singletonFactories</strong>），通过ObjectFactory 提前曝光，所以可以通过ObjectFactory#getObject() 方法来拿到A 对象。C拿到A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</li>
<li>回到B ，B 也可以拿到C 对象，完成初始化，A 可以顺利拿到B 完成初始化。到这里整个链路就已经完成了初始化过程了。</li>
</ol>
<p>关键字：三级缓存，提前曝光。</p>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="事务的隔离级别（MYSQL）"><a href="#事务的隔离级别（MYSQL）" class="headerlink" title="事务的隔离级别（MYSQL）"></a>事务的隔离级别（MYSQL）</h3><h4 id="事务的传播等级"><a href="#事务的传播等级" class="headerlink" title="事务的传播等级"></a>事务的传播等级</h4><p>Spring 事务定义了7 种传播机制：</p>
<ol>
<li>PROPAGATION_REQUIRED：默认的Spring 事务传播级别，若当前存在事务，则加入该事务，<br> 若不存在事务，则新建一个事务。</li>
<li>PAOPAGATION_REQUIRE_NEW：若当前没有事务，则新建一个事务。若当前存在事务，<strong>则新</strong><br> <strong>建一个事务，新老事务相互独立。</strong>外部事务抛出异常回滚不会影响内部事务的正常提交。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，<strong>则嵌套在当前事务中执行</strong>。如果当前没有事务，<br> 则新建一个事务，<strong>类似于REQUIRE_NEW。</strong></li>
<li>PROPAGATION_SUPPORTS：支持当前事务，若当前不存在事务，<strong>以非事务的方式执行</strong>。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务的方式执行，若当前存在事务，<strong>则把当前事务</strong><br> <strong>挂起</strong>。</li>
<li>PROPAGATION_MANDATORY：<strong>强制事务执行，</strong>若当前不存在事务，则抛出异常.</li>
<li>PROPAGATION_NEVER：<strong>以非事务的方式执行，</strong>如果当前存在事务，则抛出异常。</li>
</ol>
<p>Spring 事务传播级别一般不需要定义，默认就是PROPAGATION_REQUIRED，除非在嵌套事务的<br>  情况下需要重点了解。</p>
<h3 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h3><ul>
<li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</li>
</ul>
<h3 id="事务管理有哪些优点"><a href="#事务管理有哪些优点" class="headerlink" title="事务管理有哪些优点"></a>事务管理有哪些优点</h3><ul>
<li>它为不同的事务API（如JTA, JDBC, Hibernate, JPA, 和JDO）提供了统一的编程模型。</li>
<li>它为编程式事务管理提供了一个简单的API 而非一系列复杂的事务API（如JTA).</li>
<li>它支持声明式事务管理。</li>
<li>它可以和Spring 的多源数据访问技术很好地融合。</li>
</ul>
<h3 id="事务三要素"><a href="#事务三要素" class="headerlink" title="事务三要素"></a>事务三要素</h3><ul>
<li><strong>数据源：</strong>表示具体的事务性资源，是事务的真正处理者，如MySQL 等。</li>
<li><strong>事务管理器：</strong>像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</li>
<li><strong>事务应用和属性配置：</strong>像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</li>
</ul>
<h3 id="事务注解的本质"><a href="#事务注解的本质" class="headerlink" title="事务注解的本质"></a>事务注解的本质</h3><p>@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置的事务行为。大致来说具有两方面功能， 一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为</p>
<p>声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性增强（advice），来驱动事务完成。</p>
<p>@Transactional 注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的<br>所有方法。如果此时方法上也标注了，则方法上的优先级高。另外注意方法一定要是public 的。</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>Spring Boot 优点非常多，如：<br>一、独立运行<br>Spring Boot 而且内嵌了各种servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到<br>容器中，Spring Boot 只要打成一个可执行的jar 包就能独立运行，所有的依赖包都在一个jar 包<br>内。</p>
<p>二、简化配置<br>spring-boot-starter-web 启动器自动依赖其他组件，减少了maven 的配置。</p>
<p>三、自动配置<br>Spring Boot 能根据当前类路径下的类、jar 包来自动配置bean，如添加一个<br>spring-boot-starter- web 启动器就能拥有web 的功能，无需其他配置。</p>
<p>四、无代码生成和XML 配置<br>Spring Boot 配置过程中无代码生成，也无需XML 配置文件就能完成所有配置工作，这一切都是借<br>助于条件注解完成的，这也是Spring4.x 的核心功能之一。</p>
<p>五、应用监控<br>Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。</p>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p>启动类上面的注解是@SpringBootApplication，它也是Spring Boot 的核心注解，主要组合包含了以下3个注解：</p>
<ul>
<li>@SpringBootConfiguration：组合了@Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D;{ DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan ：Spring 组件扫描。</li>
</ul>
<h2 id="Spring-Boot有哪几种方式？"><a href="#Spring-Boot有哪几种方式？" class="headerlink" title="Spring Boot有哪几种方式？"></a>Spring Boot有哪几种方式？</h2><p>1）打包用命令或者放到容器中运行<br>2）用Maven&#x2F;Gradle 插件运行<br>3）直接执行main 方法运行</p>
<h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><p>Starters 是什么：<br>Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA 访问数据库，只要加入spring-boot-starter-data-jpa 启动器依赖就能使用了。Starters 包含了许多项目中需要用到的依赖，它们能快速持续地运行，都是一系列得到支持的管理传递性依赖。</p>
<h3 id="Starters-命名："><a href="#Starters-命名：" class="headerlink" title="Starters 命名："></a>Starters 命名：</h3><p>Spring Boot 官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的启动器不能以spring-boot 开头命名，它们都被Spring Boot 官方保留。一般一个第三方的应该这样命名，像mybatis 的mybatis-spring-boot-starter。</p>
<ul>
<li>spring-boot-starter-web 嵌入tomcat 和web 开发需要servlet 与jsp 支持</li>
<li>spring-boot-starter-data-jpa 数据库支持</li>
<li>spring-boot-starter-data-redis redis 数据库支持</li>
<li>spring-boot-starter-data-solr solr 支持</li>
<li>mybatis-spring-boot-starter 第三方的mybatis 集成starter</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170118378.png"/>

<h2 id="Spring-Boot-的核心配置文件"><a href="#Spring-Boot-的核心配置文件" class="headerlink" title="Spring Boot 的核心配置文件"></a>Spring Boot 的核心配置文件</h2><ul>
<li>pring Boot 的核心配置文件是application 和bootstrap 配置文件。</li>
<li>application 配置文件这个容易理解，主要用于Spring Boot 项目的自动化配置。</li>
<li>bootstrap 配置文件有以下几个应用场景。<ul>
<li>使用Spring Cloud Config 配置中心时，这时需要在bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li>
<li>一些固定的不能被覆盖的属性；</li>
<li>一些加密&#x2F;解密的场景；</li>
</ul>
</li>
</ul>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>基于SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML 里，解除sql 与程序代码的耦合，便于统一管理；提供XML 标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC 相比，减少了50%以上的代码量，消除了JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好地与各种数据库兼容（因为MyBatis 使用JDBC 来连接数据库，所以只要JDBC 支持的数据库MyBatis 都支持）。</li>
<li>能够与Spring 很好地集成；</li>
<li>提供映射标签，支持对象与数据库的ORM 字段关系映射；提供对象关系映射标签，支持对象关键组件维护。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1.<br>   SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL 语句的功底有一定要求。<br>2. SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h2 id="｛｝和-｛｝的区别是什么？"><a href="#｛｝和-｛｝的区别是什么？" class="headerlink" title="#｛｝和$｛｝的区别是什么？"></a>#｛｝和$｛｝的区别是什么？</h2><p>#{｝是预编译处理，${｝是字符串替换。</p>
<p>Mybatis 在处理#{｝时，会将sql 中的#{｝替换为？号，调用PreparedStatement 的set 方法来赋值；</p>
<p>Mybatis 在处理${｝时，就是把${｝替换成变量的值。使用#{｝可以有效地防止SQL 注入，提高系统安全性。</p>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用RowBounds 对象进行分页，它是针对ResultSet 结果集执行的内存分页，而非物理分页。可以在sql 内直接拼写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页，比如：MySQL 数据的时候，在原有SQL 后面拼写limit。</p>
<p>分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>
<p>第二种是使用sql 列的别名功能，将列的别名书写为对象属性名。</p>
<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一<br>赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h2 id="实现一对一有几种方式？具体怎么操作的？"><a href="#实现一对一有几种方式？具体怎么操作的？" class="headerlink" title="实现一对一有几种方式？具体怎么操作的？"></a>实现一对一有几种方式？具体怎么操作的？</h2><p>有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次， 通过在resultMap<br>里面配置association 节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去在另外一个表里面查询数据，也是<br>通过association 配置，但另外一个表的查询通过select 属性配置。</p>
<h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis 仅支持association 关联对象和collection 关联集合对象的延迟加载，association 指的就<br>是一对一，collection 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加<br>载lazyLoadingEnabled&#x3D;true|false。</p>
<blockquote>
<p>它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke(）方法发现a.getB(）是null 值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName(）方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
</blockquote>
<h2 id="Mybatis-的缓存机制："><a href="#Mybatis-的缓存机制：" class="headerlink" title="Mybatis 的缓存机制："></a>Mybatis 的缓存机制：</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170045709.png"/>

<h3 id="一级缓存localCache"><a href="#一级缓存localCache" class="headerlink" title="一级缓存localCache"></a>一级缓存localCache</h3><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL ，<br>MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的SQL 语句，会优先命中一级缓<br>存， 避免直接对数据库进行查询，提高性能。</p>
<p>每个SqlSession 中持有了Executor，每个Executor 中有一个LocalCache。当用户发起查询<br>时， MyBatis 根据当前执行的语句生成MappedStatement，在Local Cache 进行查询，如果<br>缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local<br>Cache，最后返回结果给用户。具体实现类的类关系图如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170101103.png"/>

<ol>
<li>MyBatis 一级缓存的生命周期和SqlSession 一致。</li>
<li>MyBatis 一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis 的一级缓存最大范围是SqlSession 内部，有多个SqlSession 或者分布式的环境下， 数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession 内部，如果多个SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor 装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170107703.png"/>

<p>二级缓存开启后，同一个namespace 下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程为：</p>
<p>二级缓存 —&gt; 一级缓存 —&gt; 数据库</p>
<ol>
<li>MyBatis 的二级缓存相对于一级缓存来说，实现了SqlSession 之间缓存数据的共享，同时粒度更加细，能够到namespace 级别，通过Cache 接口实现类不同的组合，对Cache 的可控性也更强。</li>
<li>MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis 的Cache 接口实现，有一定的开发成本，直接使用Redis、Memcached 等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h2 id="Mybatis设计模式"><a href="#Mybatis设计模式" class="headerlink" title="Mybatis设计模式"></a>Mybatis设计模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170110652.png"/>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/10/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="MYSQL面试题">
      <i class="fa fa-chevron-left"></i> MYSQL面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/17/%E7%BB%BC%E5%90%88%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" rel="next" title="MYSQL面试题">
      MYSQL面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-number">1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired%E5%92%8CResource%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Autowired和Resource关键字的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired"><span class="nav-number">1.1.1.</span> <span class="nav-text">@Autowired</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource"><span class="nav-number">1.1.2.</span> <span class="nav-text">@Resource</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">依赖注入方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">构造器注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setter%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.2.</span> <span class="nav-text">setter方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.3.</span> <span class="nav-text">接口注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC"><span class="nav-number">1.3.</span> <span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BE%B9%E4%B8%A4%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BC%80%E5%8F%91%EF%BC%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">下边两个组件通常情况下需要开发：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.</span> <span class="nav-text">SpringMVC常用的注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP"><span class="nav-number">1.5.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP-%E5%92%8C-Aspect-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">Spring AOP 和 Aspect] AOP 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8SpringAOP%E4%B8%AD%EF%BC%8C%E5%85%B3%E6%B3%A8%E7%82%B9%E5%92%8C%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">在SpringAOP中，关注点和横切关注的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5-%E4%B8%8E-%E9%80%9A%E7%9F%A5%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">通知 与 通知的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84IOC"><span class="nav-number">1.6.</span> <span class="nav-text">Spring的IOC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.7.</span> <span class="nav-text">Spring bean 的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96Bean-%EF%BC%9A"><span class="nav-number">1.7.1.</span> <span class="nav-text">实例化Bean ：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%89%EF%BC%9A"><span class="nav-number">1.7.2.</span> <span class="nav-text">设置对象属性（依赖注入）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86Aware-%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="nav-number">1.7.3.</span> <span class="nav-text">处理Aware 接口：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanPostProcessor%EF%BC%9A"><span class="nav-number">1.7.4.</span> <span class="nav-text">BeanPostProcessor：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InitializingBean-%E4%B8%8Einit-method-%EF%BC%9A"><span class="nav-number">1.7.5.</span> <span class="nav-text">InitializingBean 与init-method ：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanPostProcessor%EF%BC%9A-1"><span class="nav-number">1.7.6.</span> <span class="nav-text">BeanPostProcessor：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DisposableBean-%EF%BC%9A"><span class="nav-number">1.7.7.</span> <span class="nav-text">DisposableBean ：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#destroy-method-%EF%BC%9A"><span class="nav-number">1.7.8.</span> <span class="nav-text">destroy-method ：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">Spring支持的几种bean的作用域？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E5%9F%BA%E4%BA%8Exml%E6%B3%A8%E5%85%A5bean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.9.</span> <span class="nav-text">Spring基于xml注入bean的几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">Spring 框架中都用到了哪些设计模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%B8%ADApplicationContext%E5%92%8CBeanFactory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.</span> <span class="nav-text">Spring中ApplicationContext和BeanFactory的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">1.11.1.</span> <span class="nav-text">包目录不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">1.11.2.</span> <span class="nav-text">国际化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%A4%A7%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88Event%EF%BC%89"><span class="nav-number">1.11.3.</span> <span class="nav-text">强大事件机制（Event）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.11.4.</span> <span class="nav-text">底层资源的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9Web%E5%BA%94%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">1.11.5.</span> <span class="nav-text">对Web应用的支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.11.6.</span> <span class="nav-text">延迟加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">1.11.7.</span> <span class="nav-text">常用容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-Bean-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">Spring 框架中的单例 Bean 是线程安全的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">1.13.</span> <span class="nav-text">循环依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.14.</span> <span class="nav-text">Spring事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88MYSQL%EF%BC%89"><span class="nav-number">1.14.1.</span> <span class="nav-text">事务的隔离级别（MYSQL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%AD%89%E7%BA%A7"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">事务的传播等级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.14.2.</span> <span class="nav-text">Spring事务实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9"><span class="nav-number">1.14.3.</span> <span class="nav-text">事务管理有哪些优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">1.14.4.</span> <span class="nav-text">事务三要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.14.5.</span> <span class="nav-text">事务注解的本质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot"><span class="nav-number">2.</span> <span class="nav-text">SpringBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.2.</span> <span class="nav-text">核心注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">Spring Boot有哪几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Starters"><span class="nav-number">2.4.</span> <span class="nav-text">Starters</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Starters-%E5%91%BD%E5%90%8D%EF%BC%9A"><span class="nav-number">2.4.1.</span> <span class="nav-text">Starters 命名：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.</span> <span class="nav-text">Spring Boot 的核心配置文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis"><span class="nav-number">3.</span> <span class="nav-text">Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">优点和缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">3.1.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">3.1.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BD%9B%EF%BD%9D%E5%92%8C-%EF%BD%9B%EF%BD%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">#｛｝和$｛｝的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">Mybatis 是如何进行分页的？分页插件的原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86sql%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">3.5.</span> <span class="nav-text">实现一对一有几种方式？具体怎么操作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.6.</span> <span class="nav-text">Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">3.7.</span> <span class="nav-text">Mybatis 的缓存机制：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98localCache"><span class="nav-number">3.7.1.</span> <span class="nav-text">一级缓存localCache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">3.8.</span> <span class="nav-text">二级缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.9.</span> <span class="nav-text">Mybatis设计模式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
