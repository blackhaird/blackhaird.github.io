<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MEIDE&#39;S BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MEIDE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">软件工程基础概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 16:42:55" itemprop="dateCreated datePublished" datetime="2023-06-10T16:42:55+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-12 15:59:13" itemprop="dateModified" datetime="2023-06-12T15:59:13+08:00">2023-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">考试工程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><ul>
<li>软件&#x3D;程序+数据+文档</li>
<li>软件是被开发或设计的</li>
<li>软件不会磨损，但是会退化</li>
</ul>
<h2 id="软件工程的概述"><a href="#软件工程的概述" class="headerlink" title="软件工程的概述"></a>软件工程的概述</h2><p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法区开发和维护软件，以及如何把经过时间考虑而证明正确的管理技术和当前能够得到的最好技术方法结合起来的学科。</p>
<h2 id="软件工程的方法"><a href="#软件工程的方法" class="headerlink" title="软件工程的方法"></a>软件工程的方法</h2><h3 id="传统方法："><a href="#传统方法：" class="headerlink" title="传统方法："></a>传统方法：</h3><p>也称生命周期方法或结构化方法。采用结构化技术来完成软件开发的各项任务</p>
<h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>从面向对象程序设计发展起来的。有OOA面向对象分析、OOD面向对象设计、OMG对象管理组织、UML统一建模语言等概念</p>
<h3 id="面向服务方法"><a href="#面向服务方法" class="headerlink" title="面向服务方法"></a>面向服务方法</h3><p>SOA，服务提供与请求的设计模式</p>
<h3 id="面向数据的方法"><a href="#面向数据的方法" class="headerlink" title="面向数据的方法"></a>面向数据的方法</h3><p>基于数据思维，从业务逻辑的角度，强调一切业务“数据化”；从体系结构的角度，突出“面向暑假和以暑假为核心”的思想</p>
<h3 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h3><p>基于形式化数学变换的软件开发方法</p>
<h1 id="软件工程的层次"><a href="#软件工程的层次" class="headerlink" title="软件工程的层次"></a>软件工程的层次</h1><p>软件工程的定义：将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中。</p>
<ul>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程范型</li>
</ul>
<h2 id="软件工程的过程模型"><a href="#软件工程的过程模型" class="headerlink" title="软件工程的过程模型"></a>软件工程的过程模型</h2><h3 id="软件工程的三个要素"><a href="#软件工程的三个要素" class="headerlink" title="软件工程的三个要素"></a>软件工程的三个要素</h3><p>过程、方法、工具</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101647572.png"/>

<ol>
<li>支持软件工程的根基在于质量关注点（quality focus）：是对软件的组织承诺，是支持软件工程的基石</li>
<li>软件工程的基础是过程（process）层。软件过程将各个技术层次结合在一起，使得合理、及时地开发计算机软件成为可能。</li>
<li>软件工程方法（method）为构建软件提供技术上的解决方法。方法包括：沟通、需求分析、设计模型、编程、测试和技术支持。</li>
<li>软件工程工具为过程和方法提供自动化或半自动化的支持。</li>
</ol>
<h3 id="软件过程的三个阶段"><a href="#软件过程的三个阶段" class="headerlink" title="软件过程的三个阶段"></a>软件过程的三个阶段</h3><ol>
<li><p>定义阶段：<strong>“做什么”</strong>，系统和软件的关键需求被标识</p>
<p>系统和信息工程</p>
<p>软件项目计划</p>
<p>需求分析</p>
</li>
<li><p>开发阶段：<strong>“如何做”</strong>，定义数据结构、体系结构、过程细节、界面表示、算法和测试如何执行</p>
<p>软件设计</p>
<p>代码生成</p>
<p>软件测试</p>
</li>
<li><p>支持阶段：<strong>“变化”</strong>：纠正错误、随着软件环境的演化而要求的适应性修改、用户需求的变化而带来的增强性修改</p>
<p>纠错性维护</p>
<p>适应性维护</p>
<p>完善性维护</p>
<p>预防性维护</p>
</li>
</ol>
<h3 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h3><p>CMM是20世纪90年代提出的 <strong>软件能力成熟度模型</strong></p>
<ol>
<li>CMM定义了当一个组织达到不同的过程成熟度时应该具有的软件工程能力</li>
<li>CMM是一种<strong>衡量软件开发能力和成熟度的标准</strong></li>
<li>CMM模型提供了衡量一个公司软件工程实践的整体有效性的方法，且建立了<strong>五级</strong>的过程成熟度级别</li>
</ol>
<h4 id="初始级"><a href="#初始级" class="headerlink" title="初始级"></a>初始级</h4><p>软件过程是<strong>特定的和偶然的</strong>，有时甚至是混乱的，几乎没有过程定义，成功完全取决于个人能力。</p>
<h4 id="可重复级"><a href="#可重复级" class="headerlink" title="可重复级"></a>可重复级</h4><p>建立了<strong>基本的</strong>项目管理过程，能够跟踪费用、进度和功能。有适当的必要的过程规范，可以重复与疫情类似的项目的成功</p>
<h4 id="定义级"><a href="#定义级" class="headerlink" title="定义级"></a>定义级</h4><p>用于管理和工程活动的软件过程已经文档化、<strong>标准化</strong>并与整个组织的软件过程相集成。所有项目都使用统一的、文档化的、组织过程认可的版本来开发和维护软件。</p>
<p>​	包含第二级的所有特征。</p>
<h4 id="管理级"><a href="#管理级" class="headerlink" title="管理级"></a>管理级</h4><p>软件过程和产品质量的详细数据被收集，通过这些度量数据，软件过程和产品能够<strong>被定量地</strong>理解和控制，包含三级的所有特征。</p>
<h4 id="优化级"><a href="#优化级" class="headerlink" title="优化级"></a>优化级</h4><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><p>通过定量反馈进行不断的过程改进，这些反馈来自于过程或通过<strong>试验新的的想法</strong>和技术而得到。包含第四级的所有特征。</p>
<p>软件过程模型是软件开发全部过程、活动和任务的结构框架。是一种开发策略，包含过程，方法和工具三个层次以及一般性阶段，常称为：</p>
<ol>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程模型</li>
</ol>
<h3 id="过程模型两种类型"><a href="#过程模型两种类型" class="headerlink" title="过程模型两种类型"></a>过程模型两种类型</h3><ul>
<li><p>传统的软件过程模型</p>
<ol>
<li>瀑布模型（线性顺序模型）</li>
<li>V模型</li>
<li>原型</li>
<li>RAD模型</li>
<li>增量模型</li>
<li>螺旋模型</li>
<li>形式化方法模型</li>
</ol>
</li>
<li><p>敏捷的软件过程模型</p>
<ol>
<li>极限编程（XP）</li>
<li>自适应软件开发 (ASD)</li>
<li>橄榄球模型 (Scrum)</li>
<li>特征驱动开发 (PDD)</li>
</ol>
</li>
</ul>
<h3 id="传统的软件过程模型"><a href="#传统的软件过程模型" class="headerlink" title="传统的软件过程模型"></a>传统的软件过程模型</h3><h4 id="瀑布模型（waterfall-model）："><a href="#瀑布模型（waterfall-model）：" class="headerlink" title="瀑布模型（waterfall model）："></a>瀑布模型（waterfall model）：</h4><p>又被称为经典生命周期（classic life cycle），它提出了一个系统的、顺序的软件开发方法。<br>优点：</p>
<blockquote>
<ul>
<li>有利于大型软件开发过程中人员的组织、管理，从而提高了大型软件项目开发的质量和效率。</li>
<li>当需求确定、工作采用线性的方式完成的时候瀑布模型是一个很有用的过程模型。</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>过于理想，缺乏灵活性，容易产生需求偏差。</li>
<li>实际的项目很少遵守瀑布模型提出的顺序。</li>
<li>客户通常很难清楚的描述所有的需求。</li>
<li>客户必须要有耐心，因为只有在项目接近尾声的时候，他们才能得到可以执行的程序。</li>
<li>适用范围： 需求确定，工作能够采用线性的方式完成的软件。</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101712288.png"/>

<h4 id="V模型（V-model）："><a href="#V模型（V-model）：" class="headerlink" title="V模型（V-model）："></a>V模型（V-model）：</h4><p>描述了质量保证动作同沟通、建模相关动作以及早期构建相关的动作之间的关系。<br>V模型强调软件开发的协作和速度，将软件实现和验证有机地结合起来，在保证较高的软件质量情况下缩短开发周期。<br>优点：适合工程量小、人力资源少并且开发过程中改动不大的项目<br>缺点：错误发现时间迟，产生的风险代价高</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101714922.png"/>

<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><h5 id="抛弃式（一次性）原型不作为最终产品使用"><a href="#抛弃式（一次性）原型不作为最终产品使用" class="headerlink" title="抛弃式（一次性）原型不作为最终产品使用"></a>抛弃式（一次性）原型不作为最终产品使用</h5><blockquote>
<ul>
<li>降低项目中的风险，看看是否可以做些什么。（优势）</li>
<li>捕获需求，即客户是否可以喜欢GUI。（优势）</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li><p>资源可能会被浪费，因此需要控制</p>
</li>
<li><p>需要良好的项目管理</p>
</li>
<li><p>需要与客户进行良好的沟通</p>
</li>
<li><p>什么时候是停止开发原型的好时机</p>
</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101803536.png"/>

<h5 id="演化式"><a href="#演化式" class="headerlink" title="演化式"></a>演化式</h5><p>逐步改进和细化原型，将原型进化为最终系统</p>
<p>优势</p>
<blockquote>
<ul>
<li>客户可以看到他们想要的更改。</li>
<li>非常适合用户界面的接受。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在文档方面非常薄弱（即系统不断变化）。</li>
<li>需要强有力的项目控制，领导者需要监控发展。</li>
<li>什么时候是停止发展和完成项目的好时机可能会导致系统结构不良。</li>
<li>可能需要特殊的开发人员。</li>
</ul>
</blockquote>
<h6 id="演化过程模型（Evolutionary-Model）"><a href="#演化过程模型（Evolutionary-Model）" class="headerlink" title="演化过程模型（Evolutionary Model）"></a>演化过程模型（Evolutionary Model）</h6><p>演化模型是迭代的过程模型。</p>
<p>原型开发（prototyping ）：当需求很模糊的时候，原型开发可以帮助软件开发人员和利益相关者更好地理解究竟需要做什么。<br><strong>优点：</strong><br>开发者与用户充分交流，可以澄清模糊需求，需求定义比其他模型好得多<br>开发过程与用户培训过程同步<br>为用户需求的改变提供了充分的余地<br>开发风险低，产品柔性好<br>开发费用低，时间短<br>系统易维护，对用户更友好</p>
<p><strong>缺点：</strong><br>1、 没有考虑软件的整体质量和长期的可维护性。<br>2、 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>3、 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。<br>适用范围：<br>尽管原型可以用作独立的流程模型，但它更常用作一种可以在任何流模型的上下文中实现的技术。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715254.png"/>

<h5 id="增量型"><a href="#增量型" class="headerlink" title="增量型"></a>增量型</h5><p>在建立软件总体设计基础上，采用增量开发方法，使原型成为最终系统。</p>
<p>优势：</p>
<blockquote>
<p>有利于将一个更大的系统分解成多个部分，从而使组件更容易构建。<br>客户对系统的看法是分阶段的，所以没有“大爆炸”的方法。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>需要良好的沟通和协议。<br>需要良好的项目管理、控制和监控工作。</p>
</blockquote>
<h6 id="增量过程模型（Incremental-Model）"><a href="#增量过程模型（Incremental-Model）" class="headerlink" title="增量过程模型（Incremental Model）"></a>增量过程模型（Incremental Model）</h6><p><strong>增量模型融合了瀑布模型的基本成分和原型的迭代特征</strong></p>
<p>增量过程模型侧重于每一个增量都提交一个可以运行的产品。<br><strong>优点：</strong></p>
<ol>
<li>能在较短的时间内向用户提交可完成部分工作的产品。</li>
<li>逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
<li>规避技术风险</li>
<li>可并行开发构件，加快开发的进度</li>
<li>对于在业务截止日期之前完全实施的人员配置非常有用。<br><strong>缺点：</strong><br>（1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；<br>（2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。</li>
</ol>
<p><strong>适用范围：</strong><br>（1）进行已有产品升级或新版本开发，增量模型是非常适合的；<br>（2）对完成期限严格要求的产品，可以使用增量模型；<br>（3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。<br>（4）项目在既定的商业要求期限之前不可能找到足够的开发人员</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715951.png"/>

<h4 id="统一过程（Unified-Process）"><a href="#统一过程（Unified-Process）" class="headerlink" title="统一过程（Unified Process）"></a>统一过程（Unified Process）</h4><p><strong>统一过程模型</strong><br>统一过程模型是一种“用例驱动、以体系结构为核心、迭代及增量”的软件 过程框架，由 UML 方法和工具支持。它是一种增量模型，定义了五个阶段：<br>a、起始阶段，包括用户沟通和计划活动，强调定义和细化用例<br>b、细化阶段，包括用户沟通和建模活动，重点是创建分析和设计模型。<br>c、构件阶段，细化模型设计，并将设计模型转化为软件构件实现<br>d、转化阶段，将软件从开发人员传递给最终用户，并由用户完成 beta 测试和验收测试<br>e、生产阶段，持续地监控软件的运行，并提供技术支持。</p>
<p><strong>优点：</strong><br>1.任何功能开发后就进入测试过程，及早进行验证<br>2.早期风险识别，采取预防措施</p>
<p><strong>缺点：</strong></p>
<ol>
<li>需求必须在开始之前完全弄清楚，否怎有可能在架构上出现错误</li>
<li>必须有严格的过程管理，以免使过程退化为原始的试→错→改模式</li>
<li>如果不加控制的让用户过早接触没有测试完全、版本不稳定的产品可能对用户和开发团队都带来负面的影响。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101717848.png"/>

<h4 id="RAD模型"><a href="#RAD模型" class="headerlink" title="RAD模型"></a>RAD模型</h4><p>通过使用“基于构件的建造方法”赢得快速开发</p>
<ul>
<li><p>业务建模</p>
</li>
<li><p>数据建模</p>
</li>
<li><p>过程建模</p>
</li>
<li><p>应用生成</p>
</li>
<li><p>测试及反复</p>
</li>
</ul>
<p>特点：</p>
<blockquote>
<ul>
<li>强调极短的开发时 间，每一个主要功能在不到三个月的时间内完成。</li>
<li>强调复用。</li>
</ul>
</blockquote>
<p> 缺点：</p>
<blockquote>
<ul>
<li>对于大型的的项目，RAD需要足够的人力资源以建立足够的RAD组。</li>
<li>RAD要求开发者和客户承担在一个很短的时间框架下完成一个系统所必要的快速活动。</li>
<li>并非所有应用都适合RAD,不适合技术风险很高的情况</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101807461.png"/>

<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>主要适用于内部开发的大规模软件项目</p>
<ul>
<li>客户交流一建立开发者和客户之间有效的通信所需的任务。</li>
<li>计划一定义资源、进度及其他相关项目所需要的任务。</li>
<li>风险分析一评估技术的及管理的风险所需的任务。</li>
<li>工程一建立应用的一个或多个表示所需要的任务。</li>
<li>构造及发布一构造、测试、安装和提供用户支持（如文档及培训）所需的任务</li>
<li>客户评估一基于对在工程阶段产生的或在安装阶段实现的软件表示的评估，获得客户反馈所需要的任务。</li>
</ul>
<p>优点：</p>
<blockquote>
<p>随着过程进展演化，开发者和客户能够更好地理解和对待每一个级别上的<br>风险，使用原型实现作为降低风险的机制。<br>更真实地反映了现实世界。<br>如应用得当，能在风险变成问题之前降低它。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>模型的成功依赖于风险评估的专门技术，<br>是一个较新的模型，功效的确定尚需若干年时间。</p>
</blockquote>
<h3 id="敏捷的软件过程模型"><a href="#敏捷的软件过程模型" class="headerlink" title="敏捷的软件过程模型"></a>敏捷的软件过程模型</h3><h4 id="敏捷开发-敏捷宣言（Agile-development-manifesto）："><a href="#敏捷开发-敏捷宣言（Agile-development-manifesto）：" class="headerlink" title="敏捷开发-敏捷宣言（Agile development manifesto）："></a><strong>敏捷开发-敏捷宣言（Agile development manifesto）：</strong></h4><p><strong>应付变化而来的开发模型</strong></p>
<ul>
<li><strong>个体和互动 高于 流程和工具</strong>：个人和他们之间的交流胜过了开发过程和工具</li>
<li><strong>工作的软件 高于 详尽的文档</strong>：可运行的软件胜过了宽泛的文档</li>
<li><strong>客户合作 高于 合作谈判</strong>：客户合作胜过了合同谈判</li>
<li><strong>响应变化 高于 遵循计划</strong>：对变更的良好响应胜过了按部就班地遵循计划</li>
</ul>
<h4 id="极限编程（Extreme-Programming-XP-）"><a href="#极限编程（Extreme-Programming-XP-）" class="headerlink" title="极限编程（Extreme Programming (XP)）"></a>极限编程（Extreme Programming (XP)）</h4><p>极限编程是敏捷软件开发使用最广泛的一个方法。</p>
<ol>
<li><p>策划：<br>开始创造“用户故事”<br>敏捷团队评估每个故事并分配一个成本（开发周数）<br>故事被分组到一个可交付增量<br>承诺在交付日期进行<br>在第一次递增之后，“项目速度”用于帮助估计后续发行版本的发布日期和进度安排，确定是否对整个开发项目中的所有故事有过分承诺。</p>
</li>
<li><p>设计<br>遵循KIS（保持简洁）原则<br>对于困难的设计问题，建议创建“尖峰解决方案” - 一个设计原型<br>鼓励“重构”： 重构是以不改变代码外部行为而改进其内部结构的方式来修改软件系统的过程。</p>
<blockquote>
<p>重构是XP的一个重要组成部分。所谓重构是指在 不改变代码外在行为的前提下对代码做出的修改，以 改进代码的内部结构。重构是一种有纪律的、经过训 练的、有条不紊的代码整理方法，可以将整理过程中 不小心引入错误的可能性降到最低。从本质上说，重 构就是在代码写好之后改进它的设计。 重构的节奏：重新推理、小的更改、重新推理、 小的更改、重新推理…</p>
</blockquote>
</li>
<li><p>编码<br>在编码开始之前，建议对故事进行单元测试<br>鼓励“结队编程”</p>
<blockquote>
<p>结对编程是让两个人共同设计和开发代码的实践。结对者是全职合作者，轮流执行键入和监视；这提供了持续的设计和代码评审。<br>不是两个人做一个人的事情。</p>
</blockquote>
<p>连续集成<br>有助于避免兼容性和接口问题，建立能及早发现错误的“冒烟测试”</p>
<blockquote>
<p>​	持续集成的思想是任何时候，只要有一项任务完成，就集成新代码，构造系统并测试。持续集成是每日构建\每晚构建的一种极限形式，是XP的重要基础。<br>​	每日构建\每晚构建是将一个软件项目的所有最新代码取出，从头开始编译、链接，用安装软件包将链接好的程序安 装好，运行安装后的软件，使用测试工具对主要功能进行测 试，发现错误并报告错误的完整过程。<br>​	让开发人员在第一时间了解到软件的错误，并迅速排除错误，是每日构建\每晚构建最重要的目标之一。<br>​	每日构建\每晚构建必须出日志和报告，并发布构建结<br>果的有关信息，最好能够使用自动化工具发出电子邮件通知</p>
</blockquote>
</li>
<li><p>所有的单元测试每天都执行<br>“验收测试”，由客户规定技术条件，并且着眼于客户可见的、可评审的系统级的特征和功能。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730576.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730350.png"/></li>
</ol>
<h4 id="橄榄球模型（Scrum）"><a href="#橄榄球模型（Scrum）" class="headerlink" title="橄榄球模型（Scrum）"></a>橄榄球模型（Scrum）</h4><ul>
<li>待定项(backlog)——一个能为用户提供商业价值的项目需求或特性的优先級列表。待定项中可以随时加入新项(这就是变更的引入)。产品经理根据需要评估待定项并修改优先级。</li>
<li>冲刺(sprint) ——一些工作单元组成，这些工作单元是达到待定项中定义的需求所必需的，并且必须能在预定的时间段( time-box9)内(一般情况下为30天)完成。冲刺过程中不允许有变更(例如积压工作项)。因此，冲刺给开发团队成员的工作提供了短期但稳定的环境。</li>
<li>Scrum例会——Serum 团队每天召开的短会(一般情况为15分钟)，会上所有成员要回答三个问题[Noy02]:<ol>
<li>上次例会后做了什么?</li>
<li>遇到了什么困难?</li>
<li>下次例会前计划做些什么</li>
</ol>
</li>
<li>演示——交付软件，客户进行评估</li>
</ul>
<p>燃尽图：衡量在一个Sprint时间段内剩余的Sprint待办事项列表条目。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101759647.png"/>

<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="软件项目管理的定义"><a href="#软件项目管理的定义" class="headerlink" title="软件项目管理的定义"></a>软件项目管理的定义</h2><p>软件项目管理是为了使软件项目能够顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p>
<p><strong>对软件工程项目</strong>：他所涉及的范围覆盖了整个软件工程过程</p>
<p><strong>这种项目挂你在技术工作开始之前就应该开始</strong>，在软件从概念到实现的过程中<strong>继续进行</strong>，当软件工程过程最后结束时<strong>才终止</strong></p>
<h2 id="管理的四要素"><a href="#管理的四要素" class="headerlink" title="管理的四要素"></a>管理的四要素</h2><ul>
<li>人员People：成功项目的重要因素</li>
<li>产品Product：要开发的软件</li>
<li>过程Process：软件工程的框架活动，包括了任务、里程碑、工作一起质量保证点</li>
<li>项目Project：开发软件所需要的所有工作</li>
</ul>
<h2 id="项目管理小组结构"><a href="#项目管理小组结构" class="headerlink" title="项目管理小组结构"></a>项目管理小组结构</h2><ul>
<li><p>民主分散式（democratic decentralized，DD）【比以下两种缺陷要多】</p>
<p>没有固定的负责人，适合难度比较高、交付期限很长及生存期较长的项目，最适合于解决模块化程度比较低的问题，因为需要通信</p>
</li>
<li><p>控制分散式（controlled decentralized，CD）</p>
<p>CD(控制分散式）:有一个固定的负责人，若有子负责人，<strong>子负责人和总负责人的通信是垂直的</strong>，而个人间的通信是水平的，适合交付期限较长、比较简单的项目</p>
</li>
<li><p>控制集中式（controlled centralized，CC）</p>
<p>CC(控制集中式）:负责人和小组成员之间的通信是垂直的，适合解决<strong>交付期限比较严格的、简单的、模块化程度高</strong>的项目</p>
</li>
</ul>
<h3 id="小组通信路径"><a href="#小组通信路径" class="headerlink" title="小组通信路径"></a>小组通信路径</h3><p> <em>C &#x3D; (n * (n-1))&#x2F;2</em></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121025899.png"/>

<h3 id="软件范围"><a href="#软件范围" class="headerlink" title="软件范围"></a>软件范围</h3><ul>
<li>在进行项目计划之前，软件开发者和客户必须一起定义产品的目的和范围考虑可选的解决方案，标识技术和管理的约束。</li>
<li>没有这些信息，就不可能进行合理的（准确的）成本估算、有效的风险评估、适当的项目任务划分或是可管理的项目进度安排。</li>
<li>软件范围是软件项目管理的第一个活动。</li>
</ul>
<h1 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h1><h2 id="软件度量的目的"><a href="#软件度量的目的" class="headerlink" title="软件度量的目的"></a>软件度量的目的</h2><ul>
<li>改进过程</li>
<li>提高产品的质量</li>
</ul>
<h2 id="度量的作用"><a href="#度量的作用" class="headerlink" title="度量的作用"></a>度量的作用</h2><p>有效地定量地进行管理</p>
<h2 id="过程度量"><a href="#过程度量" class="headerlink" title="过程度量"></a>过程度量</h2><ul>
<li>在软件发布之前的错误数的测量</li>
<li>交付给最终用户并由最终用户报告的缺陷的测量</li>
<li>交付的工作产品（生产率）的测量</li>
<li>花费的工作量的测量</li>
<li>花费的时间的测量</li>
<li>与进度是否一致的测量</li>
</ul>
<h2 id="度量的方式"><a href="#度量的方式" class="headerlink" title="度量的方式"></a>度量的方式</h2><h3 id="物理度量方式"><a href="#物理度量方式" class="headerlink" title="物理度量方式"></a>物理度量方式</h3><p>直接测量</p>
<p>间接测量</p>
<h3 id="软件度量方式"><a href="#软件度量方式" class="headerlink" title="软件度量方式"></a>软件度量方式</h3><p>直接测量</p>
<ul>
<li>软件工程过程的直接测量包括所投入的成本和工作量。</li>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<p>间接测量</p>
<ul>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<h2 id="度量的分类"><a href="#度量的分类" class="headerlink" title="度量的分类"></a>度量的分类</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121414638.png"/>

<ul>
<li>需要注意的是：在表格中记载的工作量和成本是整个软件工程的活动（分析、设计、编码和测试）,<strong>而不仅仅是编码活动</strong></li>
<li>对于每一个项目，可以根据表格中列出的<strong>基本数据</strong>计算简单的<strong>面向规模</strong>的生产率和质量等的度量</li>
<li>根据表格可以对所有的项目计算出的有用度量：<ul>
<li>生产率&#x3D;<strong>KLOC</strong>&#x2F;PM(人月）</li>
<li>质量&#x3D;错误数&#x2F;<strong>KLOC</strong></li>
<li>成本&#x3D;元&#x2F;<strong>LOC</strong></li>
<li>文档&#x3D;文档页数&#x2F;<strong>KLOC</strong></li>
</ul>
</li>
</ul>
<h3 id="基于FP的软件度量"><a href="#基于FP的软件度量" class="headerlink" title="基于FP的软件度量"></a>基于FP的软件度量</h3><ul>
<li>每个FP的错误数（Errors per FP)</li>
<li>每个FP的缺陷数（Defects per FP)</li>
<li>每个FP的花费（$ per FP)</li>
<li>每个FP的文档页数（Pages of documentation per FP)</li>
<li>每人月完成的FP数（FP per person-month)</li>
</ul>
<h2 id="度量的计算"><a href="#度量的计算" class="headerlink" title="度量的计算"></a>度量的计算</h2><p>计算功能点，使用如下的计算公式<br>$$<br>FP &#x3D; 总计算值*[0.65+0.01*∑(Fi)]<br>$$<br>总计数值是所有加权计数项的和</p>
<p>Fi（i&#x3D;1…14）是复杂性校正值，它们应通过逐一回答如下提问来确定。</p>
<blockquote>
<p>Fi的取值0..5:<br>0没有影响	1微小影响<br>2轻度			3中度<br>4显著			5重大</p>
</blockquote>
<p>∑(Fi)是求和函数</p>
<h2 id="软件质量度量指标"><a href="#软件质量度量指标" class="headerlink" title="软件质量度量指标"></a>软件质量度量指标</h2><ul>
<li><p>正确性</p>
</li>
<li><p>可维护性</p>
</li>
<li><p>完整性</p>
<ul>
<li><p>危险性是特定类型的攻击将在一给定时间内发生的概率。<br>安全性是排除特定类型攻击的概率。</p>
</li>
<li><p>一个系统的完整性可定义为<br>$$<br>完整性&#x3D;∑[1-危险性×(1-安全性）]<br>$$<br>其中，对每一个攻击的危险性和安全性都进行累加。</p>
</li>
</ul>
</li>
<li><p>可用性</p>
</li>
</ul>
<h2 id="DRE缺陷排除效率"><a href="#DRE缺陷排除效率" class="headerlink" title="DRE缺陷排除效率"></a>DRE缺陷排除效率</h2><p>DRE是对质量保证及控制活动中滤除缺陷能力的一个测量</p>
<h1 id="软件风险"><a href="#软件风险" class="headerlink" title="软件风险"></a>软件风险</h1><h2 id="风险及风险管理"><a href="#风险及风险管理" class="headerlink" title="风险及风险管理"></a>风险及风险管理</h2><ul>
<li>风险：所有在软件开发过程中带来负面影响的问题，是一个潜在的问题</li>
<li>风险分析和管理是标识风险、评估其发生的概率、估算其影响并建立问题实际发生情形下的应急计划，是一系列帮助软件小组理解和管理部确定的步骤</li>
</ul>
<h2 id="被动的风险策略"><a href="#被动的风险策略" class="headerlink" title="被动的风险策略"></a>被动的风险策略</h2><p>被动风险策略：对风险不闻不问，直到发生了错误项项目组才赶紧采取行动，试图迅速地纠正错误。</p>
<h2 id="主动的风险策略"><a href="#主动的风险策略" class="headerlink" title="主动的风险策略"></a>主动的风险策略</h2><p>主动风险策略：在技术工作开始之前就已经启动，标识出潜在的风险，评估出现的概率及产生的影响，且按重要性加以排序。主要目标预防风险，需要建立一个应急计划，使必要时能够以可控的及有效地方式做出反应。</p>
<h2 id="风险的类型"><a href="#风险的类型" class="headerlink" title="风险的类型"></a>风险的类型</h2><h3 id="项目风险"><a href="#项目风险" class="headerlink" title="项目风险"></a>项目风险</h3><p>威胁到项目技术</p>
<p>潜在的预算、进度、人力资源、客户及需求等方面的问题</p>
<h3 id="技术风险"><a href="#技术风险" class="headerlink" title="技术风险"></a>技术风险</h3><p>威胁到要开发软件的质量和交付时间</p>
<p>潜在的设计、实现、接口、验证和维护等方面的问题</p>
<h3 id="商业风险"><a href="#商业风险" class="headerlink" title="商业风险"></a>商业风险</h3><p>威胁到要开发软件的生存能力</p>
<p>商业风险的分类</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>开发了一个没有人真正需要的优秀产品或系统</td>
<td>市场风险</td>
</tr>
<tr>
<td>开发的产品不再符合公司的整体商业策略</td>
<td>策略风险</td>
</tr>
<tr>
<td>建造了一个销售部门不知道如何去出售的产品</td>
<td>销售风险</td>
</tr>
<tr>
<td>由于重点转移或人员的变动而失去了高级管理层的支持</td>
<td>管理风险</td>
</tr>
<tr>
<td>没有得到预算或人力上的保证。</td>
<td>预算风险</td>
</tr>
</tbody></table>
<h2 id="风险管理的步骤"><a href="#风险管理的步骤" class="headerlink" title="风险管理的步骤"></a>风险管理的步骤</h2><h3 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h3><ul>
<li>风险识别的方法一建立风险条目检查表。</li>
<li>产品规模–与要建造或要修改的软件的总体规模相关的经验；</li>
<li>商业影响–与管理或市场所加的约束相关的风险；</li>
<li>客户特征–与客户的素质以及开发者和客户及时通信的能力相关的风险；</li>
<li>过程定义–与软件过程被定义的程度以及他们被开发组织所遵守的程度相关的风险；</li>
</ul>
<h3 id="风险预测"><a href="#风险预测" class="headerlink" title="风险预测"></a>风险预测</h3><p>风险预测从两个方面评估风险：风险发生的可能性或概率、风险发生所产生的后果（评估风险影响）。</p>
<h4 id="评估风险影响"><a href="#评估风险影响" class="headerlink" title="评估风险影响"></a>评估风险影响</h4><p>风险显露度（risk exposure)<br>$$<br>RE &#x3D; P * C<br>$$<br>其中，P是风险发生的概率，c是风险发生时带来的项目成本</p>
<blockquote>
<p>一个例子：计划了60个可复用构件，其中只有70%可能被使用，剩下的要重新定制开发，已知构件平均是100LOC,每个LOC的成本是14美元，假设该风险发生的概率是80%,计算风险显露度RE。</p>
</blockquote>
<p>$$<br>RE &#x3D; 80%*C<br>$$</p>
<p>$$<br>C &#x3D; 60 *(1-70%)<em>100</em>14<br>$$</p>
<h1 id="项目进度安排与跟踪"><a href="#项目进度安排与跟踪" class="headerlink" title="项目进度安排与跟踪"></a>项目进度安排与跟踪</h1><h2 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527813.png"/>

<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527622.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527818.png"/></p>
</blockquote>
<h2 id="项目进度安排方法"><a href="#项目进度安排方法" class="headerlink" title="项目进度安排方法"></a>项目进度安排方法</h2><h3 id="关键路径方法（CPM）"><a href="#关键路径方法（CPM）" class="headerlink" title="关键路径方法（CPM）"></a>关键路径方法（CPM）</h3><p>在关键路径上的活动才是按时完成任务的关键</p>
<h3 id="项目-进度计划-评估和评审技术-PERT）"><a href="#项目-进度计划-评估和评审技术-PERT）" class="headerlink" title="项目(进度计划)评估和评审技术(PERT）"></a>项目(进度计划)评估和评审技术(PERT）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530592.png"/>

<h3 id="获得值分析"><a href="#获得值分析" class="headerlink" title="获得值分析"></a>获得值分析</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534873.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530680.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121531061.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121533877.png"/>

<h1 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h1><h2 id="数据流图DFD"><a href="#数据流图DFD" class="headerlink" title="数据流图DFD"></a>数据流图DFD</h2><ul>
<li>面向数据流进行需求分析的方法</li>
<li>适合于数据处理类型软件的需求分析</li>
<li>用抽象模型的概念，按照软件内部数据传递、变换的关系，自项向下逐层分解，直到满足所有的功能要求。<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534481.png"/></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121535618.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121536102.png"/>

<h2 id="数据字典DD"><a href="#数据字典DD" class="headerlink" title="数据字典DD"></a>数据字典DD</h2><ul>
<li>数据字典对数据流图中的各种成分起注解、说明作用，给这些成分赋以实际的内容。</li>
<li>数据字典与数据流图配合，能清楚地表达数据处理的要求。</li>
<li>条目：数据流、数据元素、数据存储、数据加工、外部实体。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121537663.png"/>

<h2 id="结构化英语"><a href="#结构化英语" class="headerlink" title="结构化英语"></a>结构化英语</h2><ul>
<li>顺序结构</li>
<li>重复结构</li>
<li>判定结构</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121538728.png"/>

<h1 id="结构化设计概述"><a href="#结构化设计概述" class="headerlink" title="结构化设计概述"></a>结构化设计概述</h1><h2 id="分析模型到设计模型"><a href="#分析模型到设计模型" class="headerlink" title="分析模型到设计模型"></a>分析模型到设计模型</h2><ul>
<li>数据设计：侧重于数据结构的定义</li>
<li>体系结构设计：定义软件系统各主要成份之间的关系</li>
<li>接口设计：描述了软件内部、软件和协作系统之间以及软件同人之间如何通信</li>
<li>过程设计：则是把结构成份转换成软件的过程性描述</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>结构图反映了模块之间的层次调用关系和联系：它以特定的符号表示模块、模块间的调用关系和模块间信息的传递</p>
<h3 id="模块的调用关系"><a href="#模块的调用关系" class="headerlink" title="模块的调用关系"></a>模块的调用关系</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542806.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542853.png"/>

<ul>
<li>模块独立性，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其它的模块的接口是简单的。</li>
<li>例如，若一个模块只具有单一的功能且与其它模块没有太多的联系，则称此模块具有模块独立性。</li>
<li>一般采用两个准则度量模块独立性。即模块间藕合和模块内聚。</li>
<li>藕合是模块之间的互相连接的紧密程度的度量。</li>
<li>内聚是模块功能强度（一个模块内部各个元素彼此结合的紧密程度）的度量。</li>
<li>模块独立性比较强的模块应是高内聚低精合的模块。</li>
</ul>
<h3 id="模块间的耦合"><a href="#模块间的耦合" class="headerlink" title="模块间的耦合"></a>模块间的耦合</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121545118.png"/>

<h3 id="体系结构设计-系统结构模块"><a href="#体系结构设计-系统结构模块" class="headerlink" title="体系结构设计(系统结构模块)"></a>体系结构设计(系统结构模块)</h3><ul>
<li>传入模块</li>
<li>传出模块</li>
<li>变换模块</li>
<li>协调模块</li>
</ul>
<h3 id="模块的独立性"><a href="#模块的独立性" class="headerlink" title="模块的独立性"></a>模块的独立性</h3><table>
<thead>
<tr>
<th>模块间耦合形成</th>
<th>可读性</th>
<th>错误扩散能力</th>
<th>可修改性</th>
<th>通用性</th>
</tr>
</thead>
<tbody><tr>
<td>数据耦合</td>
<td>好</td>
<td>弱</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>控制耦合</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>公共耦合</td>
<td>不好</td>
<td>强</td>
<td>不好</td>
<td>不好</td>
</tr>
<tr>
<td>内容耦合</td>
<td>差</td>
<td>最强</td>
<td>最差</td>
<td>最差</td>
</tr>
</tbody></table>
<ul>
<li>在系统结构图中的模块</li>
<li>传入模块——从下属模块取得数据，经过某些处理，再将其传送给上级模 块。它传送的数据流叫做逻辑输入数据流。</li>
<li>传出模块——从上级模块获得数据，进行某些处理，再将其传送给下属模 块。它传送的数据流叫做理输出数据流。</li>
<li>变换模块——它从上级模块取得数据，进行特定的处理，转换成其它形式， 再传送回上级模块。它加工的数据流叫做变换数据流。</li>
<li>协调模块——对所有下属模块进行协调和管理的模块。</li>
</ul>
<h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121546537.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552195.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552021.png"/>

<h1 id="面向对象和UML"><a href="#面向对象和UML" class="headerlink" title="面向对象和UML"></a>面向对象和UML</h1><h2 id="面向对象方法-1"><a href="#面向对象方法-1" class="headerlink" title="面向对象方法"></a>面向对象方法</h2><h3 id="传统分析设计方法"><a href="#传统分析设计方法" class="headerlink" title="传统分析设计方法"></a>传统分析设计方法</h3><ul>
<li>以功能为中心的软件开发方法（结构化方法）</li>
<li>低内聚，高精合，缺乏灵活性和可维护性</li>
<li>分析与设计阶段采用的概念和表示不一致</li>
<li>以数据为中心的软件开发方法（信息建模方法）</li>
<li>对功能的处理较弱，不适合具有复杂功能的系统</li>
</ul>
<h3 id="类（抽象，分类）"><a href="#类（抽象，分类）" class="headerlink" title="类（抽象，分类）"></a>类（抽象，分类）</h3><p>类是具有共同属性和操作的对象的集合，对象是类的一个实例，类用于创建对象。</p>
<p>体现了抽象及分类原则，是人们分析问题的基本方法</p>
<ul>
<li><p>抽象：忽路事物的非本质特征，抽取共同的本质特征</p>
</li>
<li><p>分类：把具有共性的事物划分为一类</p>
</li>
</ul>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性：特殊类可以对继承来的属性和操作做出自己的解释，即在继承关系的类层次结构中可以定义同名操作或属性，形成同一操作或属性的多种形态，这样可以按不同的行为响应同一个消息。<br>多态性进一步体现了信息隐蔽的原则，可以实现接口的独立封装</p>
<h3 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555429.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555544.png"/>

<h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><h3 id="对象建模"><a href="#对象建模" class="headerlink" title="对象建模"></a>对象建模</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121557058.png"/>

<h3 id="协作图-x2F-通信图"><a href="#协作图-x2F-通信图" class="headerlink" title="协作图&#x2F;通信图"></a>协作图&#x2F;通信图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121558079.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">数学-线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 09:29:59" itemprop="dateCreated datePublished" datetime="2023-03-09T09:29:59+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 13:32:28" itemprop="dateModified" datetime="2023-03-30T13:32:28+08:00">2023-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>本视频基于【2023考研数学汤家凤线性代数基础课程】</strong></p>
<p>[第一章行列式.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==">https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==</a></p>
<p>[第二章矩阵.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==">https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==</a></p>
<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p>核心1:线性方程级</p>
<blockquote>
<table>
<thead>
<tr>
<th>工具</th>
</tr>
</thead>
<tbody><tr>
<td>行列式</td>
</tr>
<tr>
<td>矩阵</td>
</tr>
<tr>
<td>向量</td>
</tr>
</tbody></table>
</blockquote>
<p>核心2:矩阵对角比</p>
<blockquote>
<p>特征值与特征向量</p>
</blockquote>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h2><p>i,j ∈ N（自然数）且 i ≠ j</p>
<blockquote>
<p>这样就会形成两种情况</p>
<p>i &lt; j （i ，j ）即顺序</p>
<p>i &gt; j  （i，j）即逆序</p>
</blockquote>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>设<br>$$<br>i,i_2,…,i_n 为1，2，…n的一个排列i_1,i_2,…i_n含逆序个数之和称为逆序数<br>$$<br>记做<br>$$<br>\tau(i_1,i_2,…,i_n)<br>$$</p>
<blockquote>
<p>例如<br>$$<br>\tau（5,1,4,2,3）&#x3D; 6<br>$$<br>那其中这个6就成为逆序数</p>
</blockquote>
<h2 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h2><p>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n} \<br>…\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn} \<br>\end{matrix}\right|<br>&amp; 称为n阶行列式<br>$$</p>
<p>行列式计算</p>
<p>此处以三阶行列式为例<br>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; a_{13} \<br>a_{21} &amp; a_{22} &amp; a_{23} \<br>a_{31} &amp; a_{32} &amp; a_{33} \<br>\end{matrix}\right|<br>$$</p>
<p>$$<br>D&#x3D;+a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}+a_{12}a_{13}a_{21}+a_{32}-a_{13}a_{22}a_{31}<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" class="post-title-link" itemprop="url">英语语法学习笔记(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 12:24:51 / 修改时间：13:48:00" itemprop="dateCreated datePublished" datetime="2023-03-01T12:24:51+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">英语语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法概论"><a href="#语法概论" class="headerlink" title="语法概论"></a>语法概论</h1><h2 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h2><h3 id="实词"><a href="#实词" class="headerlink" title="实词"></a>实词</h3><table>
<thead>
<tr>
<th>词类</th>
<th>名称全称</th>
<th>全程简称</th>
<th>作用</th>
<th>句子成分</th>
<th>列词</th>
</tr>
</thead>
<tbody><tr>
<td>名词</td>
<td>Noun</td>
<td>n.</td>
<td>表示人或事物的名称</td>
<td>主、宾、表、同位语、补足语、定语</td>
<td>Lily、childhood</td>
</tr>
<tr>
<td>代词</td>
<td>pronoun</td>
<td>pron.</td>
<td>代替名词、数词等</td>
<td>主、宾、表、同位语、定语</td>
<td>I、we、none</td>
</tr>
<tr>
<td>数词</td>
<td>Numeral</td>
<td>num.</td>
<td>表示数目或顺序</td>
<td>主、宾、表、同位语、定语</td>
<td>one、ninth</td>
</tr>
<tr>
<td>形容词</td>
<td>Adjective</td>
<td>adj.</td>
<td>表示事物的特种</td>
<td>主、定、状、补足语</td>
<td>effective、popular</td>
</tr>
<tr>
<td>副词</td>
<td>Adverb</td>
<td>adv.</td>
<td>表示行为或状态特征（修饰动词）</td>
<td>状语、表语、补足语、定语</td>
<td>curiously、bravely</td>
</tr>
<tr>
<td>动词</td>
<td>Verb</td>
<td>v.</td>
<td>表示动词或状态</td>
<td>谓语</td>
<td>absorb、devote</td>
</tr>
</tbody></table>
<h3 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h3><table>
<thead>
<tr>
<th>词类</th>
<th>名称全称</th>
<th>全程简称</th>
<th>作用</th>
<th>句子成分</th>
<th>列词</th>
</tr>
</thead>
<tbody><tr>
<td>冠词</td>
<td>Article</td>
<td>art.</td>
<td>用在名词前，起限定作用</td>
<td></td>
<td>a、an、the</td>
</tr>
<tr>
<td>介词</td>
<td>Preposition</td>
<td>prep.</td>
<td>用在名词、代词等前，说明与其他词的关系</td>
<td></td>
<td>in、before、beyond</td>
</tr>
<tr>
<td>连词</td>
<td>Conjunction</td>
<td>conj.</td>
<td>用来连接词与词、短语与短语或句子与句子</td>
<td></td>
<td>and、when、until、if、once</td>
</tr>
<tr>
<td>感叹词</td>
<td>Interjection</td>
<td>interj.</td>
<td>表示说话时的感情或语气</td>
<td></td>
<td>oh、ah、aha、hurrah</td>
</tr>
</tbody></table>
<h2 id="句子成分"><a href="#句子成分" class="headerlink" title="句子成分"></a>句子成分</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称(英)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>主语</td>
<td>Subject</td>
<td>一句话的中心</td>
</tr>
<tr>
<td>谓语</td>
<td>Predicate</td>
<td>主语的主要情况，即表示动作，也可表示状态</td>
</tr>
<tr>
<td>宾语</td>
<td>Object</td>
<td>动作的承受者或动作针对的对象</td>
</tr>
<tr>
<td>表语</td>
<td>Predicative</td>
<td>主语的身份、性质、特征、状态等、和系动词一起构成谓语<br />【Life is not <strong>all roses</strong>】</td>
</tr>
<tr>
<td>定语</td>
<td>Attribute</td>
<td>修饰名词、代词等</td>
</tr>
<tr>
<td>状语</td>
<td>Adverbial</td>
<td>修辞动词、形容词、副词等</td>
</tr>
</tbody></table>
<h2 id="短语与从句"><a href="#短语与从句" class="headerlink" title="短语与从句"></a>短语与从句</h2><h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>动词短语</td>
<td></td>
</tr>
<tr>
<td>不定式短语</td>
<td></td>
</tr>
<tr>
<td>动名词短语</td>
<td></td>
</tr>
<tr>
<td>分词短语</td>
<td></td>
</tr>
<tr>
<td>分词短语</td>
<td></td>
</tr>
<tr>
<td>介词短语</td>
<td></td>
</tr>
<tr>
<td>名词短语</td>
<td></td>
</tr>
</tbody></table>
<h3 id="从句"><a href="#从句" class="headerlink" title="从句"></a>从句</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>名词性从句</td>
<td></td>
</tr>
<tr>
<td>状语从句</td>
<td></td>
</tr>
<tr>
<td>定语从句</td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 13:27:36" itemprop="dateCreated datePublished" datetime="2023-02-18T13:27:36+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-12 00:49:42" itemprop="dateModified" datetime="2023-05-12T00:49:42+08:00">2023-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">计算机系统概述</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87">操作系统的功能和目标</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81">操作系统的四个特征</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">操作系统的运行机制和体系结构</a><ul>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a></li>
<li><a href="#cpu">CPU</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F">程序</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8">操作系统的内核</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8">中断和异常</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8">概念和作用</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>系统调用和库函数的区别</strong></a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%84%E6%88%90%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%89%B9%E5%BE%81">进程的定义，组成，组织方式，特征</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F">进程的组织方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2">进程的状态和转换</a><ul>
<li><a href="#%E7%8A%B6%E6%80%81">状态</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2">转换</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-1">含义</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD">相关原语</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-2">含义</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1">共享存储，消息传递，管道通信。</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">线程概念和多线程模型</a><ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB">线程分类</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">多线程模型</a><ul>
<li><a href="#%E5%A4%9A%E5%AF%B91%E6%A8%A1%E5%9E%8B">多对1模型</a></li>
<li><a href="#1%E5%AF%B91%E6%A8%A1%E5%9E%8B">1对1模型</a></li>
<li><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B">多对多模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1">处理机调度的概念和层次</a><ul>
<li><a href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%88%9D%E7%BA%A7%E8%B0%83%E5%BA%A6">高级调度，中级调度，初级调度。</a><ul>
<li><a href="#1%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6">1.高级调度</a></li>
<li><a href="#2%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6">2.中级调度</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B">补充知识：进程的七状态模型</a></li>
</ul>
</li>
<li><a href="#3%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6">3.低级调度</a></li>
<li><a href="#%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%AF%B9%E6%AF%94">三种调度的联系和对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%B9%E5%BC%8F">进程调度的时机，切换过程和方式</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">进程调度时机</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B">进程的切换与过程</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">调度算法的评价指标</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">调度算法</a><ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E9%AB%98%E5%93%8D%E5%BA%94%E5%BF%85%E4%BC%98%E5%85%88">先来先服务，短作业优先，高响应必优先</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85">补充：</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">时间片轮转调度，优先级调度算法，多级反馈队列调度算法</a><ul>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6rr">时间片轮转调度RR</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">优先级调度算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级反馈队列调度算法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程同步与进程互斥</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程互斥</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的软件实现方法</a><ul>
<li><a href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95">单标志法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95">双标志先检查法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95">双标志后检查法</a></li>
<li><a href="#peterson%E7%AE%97%E6%B3%95">Peterson算法</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的硬件实现方法</a><ul>
<li><a href="#testandset%E6%8C%87%E4%BB%A4">TestAndSet指令</a></li>
<li><a href="#swap%E6%8C%87%E4%BB%A4">Swap指令</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81">进程互斥：锁</a><ul>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81-1">互斥锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6">信号量机制</a><ul>
<li><a href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F">整形信号量</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">记录型信号量</a></li>
<li><a href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">用信号量实现进程互斥，同步，前驱关系</a><ul>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">信号量机制实现进程互斥</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">信号量机制实现进程同步</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">信号量机制实现前驱关系</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者——消费者问题</a></li>
<li><a href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85">多生产者——多消费者</a></li>
<li><a href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98">吸烟者问题</a></li>
<li><a href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">读者——写者问题</a></li>
<li><a href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD">哲学家吃饭</a></li>
<li><a href="#%E7%AE%A1%E7%A8%8B">管程</a><ul>
<li><a href="#java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">java中类似于管程的机制（单例模式）</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a><ul>
<li><a href="#%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB">死锁，饥饿，死循环的区别</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁产生的必要条件</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81">什么时候会发生死锁</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">死锁的处理策略</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ol>
<li><p>作为系统资源的管理者</p>
<ul>
<li><p>文件管理</p>
</li>
<li><p>内存管理</p>
</li>
<li><p>处理及（CPU）管理</p>
</li>
<li><p>设备（计算机硬件，例如摄像头）管理</p>
</li>
</ul>
</li>
<li><p>作为用户和计算机硬件之间的接口</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181513303.png"/>


</li>
<li><p>对硬件机器的扩展</p>
</li>
</ol>
<h2 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a>操作系统的四个特征</h2><ol>
<li><p>并发</p>
<p>并发是指<strong>两个或多个事件在同一时间间隔内发生</strong>。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p>
<p><span style="color:red">易混淆的概念——并行：两个或多个事件在同一时刻同时发生</span></p>
</li>
<li><p>共享</p>
<p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p>
<table>
<thead>
<tr>
<th>两种资源共享方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>互斥共享方式</td>
<td>系统中的某些资源，虽然可以提供给多个进程使用，<br><span style="color:red">但<strong>一个时间段内只允许一个进程访问该资源</strong></span></td>
</tr>
<tr>
<td>同时共享方式</td>
<td>系统中的某些资源，<br><span style="color:red"><strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></span></td>
</tr>
</tbody></table>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p>
<p>例如：</p>
<ul>
<li><p>互斥共享方式：使用QQ和微信进行视频，但是同一个时间段内摄像头只能分配给其中一个进程</p>
</li>
<li><p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></p>
</li>
</ul>
</li>
<li><p>虚拟</p>
<p>虚拟是指把一个屋里上的实体变成若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<table>
<thead>
<tr>
<th>虚拟技术</th>
<th>例如</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空分复用技术</td>
<td>虚拟存储器技术</td>
<td></td>
</tr>
<tr>
<td>时分复用技术</td>
<td>虚拟处理器</td>
<td>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<span style="color:red"><strong>没有并发性，就谈不上虚拟性</strong></span></td>
</tr>
</tbody></table>
</li>
<li><p>异步</p>
<p>异步是指,在多道程序环境下，<strong>允许多个程序并发执行</strong>，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<ul>
<li>只有系统拥有并发性，才有可能导致异步性。</li>
</ul>
</li>
</ol>
<h2 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>特权指令</td>
<td>如内存清零指令（不允许用户程序使用）</td>
</tr>
<tr>
<td>非特权指令</td>
<td>如普通的运算指令</td>
</tr>
</tbody></table>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><table>
<thead>
<tr>
<th>两种处理器状态</th>
<th>(用程序状态字寄存器（PSW)中的某 标志位来标识当前处理器处于什么状 态。如0为用户态，1为核心态)</th>
</tr>
</thead>
<tbody><tr>
<td>用户态（目态）</td>
<td>此时CPU只能执行非特权指令</td>
</tr>
<tr>
<td>核心态（管态）</td>
<td>特权指令、非特权指令都可执行</td>
</tr>
</tbody></table>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table>
<thead>
<tr>
<th>两种程序</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内核程序</td>
<td>操作系统的内核程序是系统的管理者，即可执行特权指令，也可以执行非特权指令，运行也在核心态</td>
</tr>
<tr>
<td>应用程序</td>
<td>为了保证系统能安全运行，普通应用程序只能执行费特权指令，运行在用户态</td>
</tr>
</tbody></table>
<h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>由于内核划分功能的不同，内核分为大内核和微内核</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181514707.png"/>

<ul>
<li><p>大内核和微内核的优缺点</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181515691.png"/></li>
</ul>
<p>类比：</p>
<ul>
<li>操作系统的体系结构问题与企业的管理问题很相似。</li>
<li>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</li>
<li>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</li>
<li>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</li>
</ul>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><p><strong>中断</strong>是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li>
<li>对于不同的中断信号，会进行不同的处理。</li>
<li>有了中断，才能实现多道程序并发执行。</li>
<li>“用户态→核心态”是通过中断实现的，<strong>并且中断是唯一途径</strong>。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p> 中断型号的来源来自CPU内部称为内中断，外部称为外中断。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181520216.png"/>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181523855.png"/>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证操作系统的稳定性和安全性，防止用户进行非法操作。</p>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h3><p>编程语言（C、JAVA）中里边有很多库函数，其实他们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li>
<li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进行核心态。</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，组成，组织方式，特征"><a href="#进程的定义，组成，组织方式，特征" class="headerlink" title="进程的定义，组成，组织方式，特征"></a>进程的定义，组成，组织方式，特征</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序：就是指令序列</p>
<p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p>
<p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p>
<p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p>
<p><strong>PCB是进程存在的唯一标识。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201633291.png"/>



<h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p>
<p>相当于java中的链表和数组。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201634493.png"/>

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201635642.png"/>



<h2 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201638848.png"/>

<p>除此之外，进程还有两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640201.png"/>

<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640665.png"/>

<blockquote>
<p>注意：<strong>不能由阻塞态直接转换为运行态也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121229670.png"/>

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>进程控制就是要<strong>实现进程状态转换</strong>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</p>
<p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 <strong>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201648777.png"/>

<p>那么原语是如何实现进程状态的转换呢？</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>a.所有的进程控制原语一定都会修改进程状态标志<br>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c.某进程开始运行前必然要恢复期运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配&#x2F;回收资源</li>
</ol>
<p>具体实现如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201704327.png"/>

<h3 id="相关原语"><a href="#相关原语" class="headerlink" title="相关原语"></a>相关原语</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121237633.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121238008.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121239248.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121240249.png"/>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>进程通信就是<strong>进程间的信息交换</strong></p>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p>
<h3 id="共享存储，消息传递，管道通信。"><a href="#共享存储，消息传递，管道通信。" class="headerlink" title="共享存储，消息传递，管道通信。"></a>共享存储，消息传递，管道通信。</h3><ol>
<li><p>共享存储</p>
<p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式<br><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</p>
<p>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的（互斥访问通过操作系统提供的工具实现）<br>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201843057.png"/>
</li>
<li><p>管道通信</p>
</li>
</ol>
<blockquote>
<p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
<p>2.各进程要互斥地访问管道。</p>
<p>3.数据以字符流的形式写入管道，当管道<strong>写满时</strong>，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。</p>
<p>4.<strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></p>
<p>5．数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个，否则可能会有读错数据的情况。</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201847528.png"/>

<ol start="3">
<li><p>消息传递</p>
<p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p>
<p>类似于Http协议。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201849801.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121248665.png"/></li>
</ol>
<h2 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h2><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能<strong>串行</strong>执行一系列程序。因此，引入“线程”，来增加并发度。</p>
<ul>
<li>可以把线程理解为轻量级的进程。</li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</li>
<li>引入线程后，进程作为除CPU之外的系统资源的分配单元。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201852799.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121252713.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121253934.png"/></p>
<h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><ol>
<li>用户级线程</li>
</ol>
<ul>
<li>用户级线程由应用程序通过线程库实现。<strong>所有的线程管理工作都由应用程序负责（包括线程切换)</strong></li>
<li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预。</strong></li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li>
<li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li>
</ul>
<ol start="2">
<li>内核级线程</li>
</ol>
<ul>
<li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li>
</ul>
<p><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对1模型"><a href="#多对1模型" class="headerlink" title="多对1模型"></a>多对1模型</h4><ul>
<li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li>
<li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li>
<li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201913689.png"/>

<h4 id="1对1模型"><a href="#1对1模型" class="headerlink" title="1对1模型"></a>1对1模型</h4><ul>
<li>一对一模型:一个用户级线程映射到一个内核级线程。</li>
<li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li>
<li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201917778.png"/>

<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><ul>
<li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201918142.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121258062.png"/></p>
<h2 id="处理机调度的概念和层次"><a href="#处理机调度的概念和层次" class="headerlink" title="处理机调度的概念和层次"></a>处理机调度的概念和层次</h2><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p>
<p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p>
<p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p>
<h3 id="高级调度，中级调度，初级调度。"><a href="#高级调度，中级调度，初级调度。" class="headerlink" title="高级调度，中级调度，初级调度。"></a>高级调度，中级调度，初级调度。</h3><h4 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h4><ul>
<li><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
</li>
<li><p>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</p>
</li>
<li><p><strong>高级调度是辅存（外存）与内存之间的调度</strong>。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。<strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201923361.png"/></li>
</ul>
<h4 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h4><ul>
<li><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量</strong>。</p>
</li>
<li><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p>
</li>
<li><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></p>
</li>
<li><p>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201924752.png"/></li>
</ul>
<h5 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h5><ul>
<li><p>暂时被调到外存等待的进程状态称为挂起状态。</p>
</li>
<li><p>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201926432.png"/></li>
</ul>
<h4 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h4><ul>
<li>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的频率很高，一般几十毫秒一次。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202014458.png"/>

<h4 id="三种调度的联系和对比"><a href="#三种调度的联系和对比" class="headerlink" title="三种调度的联系和对比"></a>三种调度的联系和对比</h4><table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存（面向作业）</td>
<td>最低</td>
<td>无-创建态-就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td>外存-&gt;内存（面向进程）</td>
<td>中等</td>
<td>挂起态-就绪态（阻塞挂起-阻塞态）</td>
</tr>
<tr>
<td>低级调度（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-运行态</td>
</tr>
</tbody></table>
<h2 id="进程调度的时机，切换过程和方式"><a href="#进程调度的时机，切换过程和方式" class="headerlink" title="进程调度的时机，切换过程和方式"></a>进程调度的时机，切换过程和方式</h2><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202048883.png"/>

<p>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><ul>
<li>非剥夺调度方式，又称非抢占方式。即，<strong>只允许进程主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
</ul>
<p>优点：实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
<ul>
<li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
</ul>
<p>优点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<p><strong>优点：</strong></p>
<p>可以有限处理更紧急的进程，也可实现让哥进程按时间骗轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别:</p>
<ul>
<li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p>
</li>
<li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
</li>
</ul>
<p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p>
<p>进程切换的过程主要完成了:</p>
<ul>
<li>1.对原来运行进程各种数据的保存</li>
<li>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ul>
<p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><ul>
<li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li>
<li>系统吞吐量：单位时间内完成作业的数量。</li>
</ul>
<p>$$<br>系统吞吐量&#x3D;{总共完成了多少道作业\over总共花了多少时间}<br>$$</p>
<ul>
<li><p>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</p>
<p><span style="color:red"><strong>周转时间&#x3D;作业完成时的时间-作业提交时间</strong></span></p>
<p><span style="color:red"><strong>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</strong></span></p>
</li>
</ul>
<p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。<br>$$<br>带权周转时间&#x3D;{作业周转时间\over作业实际运行的时间}&#x3D;{作业完成的时间-作业提交时间\over作业实际运行的时间}<br>$$</p>
<p>$$<br>平均的带权周转时间&#x3D;{各个作业带权周转时间之和\over作业数}<br>$$</p>
<ul>
<li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li>
</ul>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<ul>
<li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务，短作业优先，高响应必优先"><a href="#先来先服务，短作业优先，高响应必优先" class="headerlink" title="先来先服务，短作业优先，高响应必优先"></a>先来先服务，短作业优先，高响应必优先</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>算法思想与规则</th>
<th>可抢占？</th>
<th>优点</th>
<th>缺点</th>
<th>考虑到等待时间&amp;运行时间？</th>
<th>会导致饥饿？</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务</td>
<td>FCFS</td>
<td>公平，先到先得</td>
<td>非</td>
<td>公平，实现简单</td>
<td>对短作业不利</td>
<td>有等待，无运行</td>
<td>不</td>
</tr>
<tr>
<td>短作业优先</td>
<td>SJF&#x2F;SPF</td>
<td>追求快<br />时间最短的先服务</td>
<td>默认为非抢占式版本，也有SJF的抢占式版本最短剩余时间优先算法(SRTN)</td>
<td>“最短的”平均等待&#x2F;周转时间</td>
<td>对长作业不利，可能导致饥饿；难以做到真正的短时间优先</td>
<td>有运行，无等待</td>
<td>会</td>
</tr>
<tr>
<td>高响应必优先</td>
<td>HRRN</td>
<td>作业&#x2F;进程的等待时间<br />计算<span style="color:red">响应比</span>,选择<span style="color:red">响应比最高的</span>作业&#x2F;进程优先</td>
<td>非</td>
<td>权衡折中，综合考虑等待时间和运行时间</td>
<td></td>
<td>都有</td>
<td>不</td>
</tr>
</tbody></table>
<p><span style="color:red">响应比</span> (响应比&gt;&#x3D;1) ：<br>$$<br>响应比&#x3D;{等待时间+要求服务时间\over要求服务时间}<br>$$<br>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><blockquote>
<ol>
<li><p>FCFS 由于在长作业过程中，后面的短作业需要等很长的时间，带权周转时间很大，对短作业用户体验不好。</p>
</li>
<li><p>FCFS 用于作业调度时，考虑的是那个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p>
</li>
<li><p>SJF 是用于作业调度，也可用于进程调度。用于进程调度时成为”短进程优先”(SPF，Shortest Process First)</p>
</li>
<li><p>SJF 和 SPF 是非抢占式算法，但是也有抢占式的版本–最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)</p>
</li>
<li><p>SJF 对长作业不利，可能产生饥饿现象。另外，作业&#x2F;进程真正运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p>
</li>
<li><p>SJF 如果有源源不断地有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生”饥饿”现象，如果一直得不到服务，则称为 饿死</p>
</li>
<li><p>HRRN 在每次调度室先计算各个作业&#x2F;进程的 响应比 ，选择响应比<span style="color:red">最高</span>的作业&#x2F;进程为其服务</p>
</li>
<li><ul>
<li><p>HRRN 综合考虑了等待时间和运行时间（要求服务时间）</p>
</li>
<li><p>等待时间相同时，要求服务时间端的优先（SJF 的优点）</p>
</li>
<li><p>要求服务时间相同时，等待时间长的优先（FCFS的优点）</p>
</li>
<li><p>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"><a href="#时间片轮转调度，优先级调度算法，多级反馈队列调度算法" class="headerlink" title="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"></a>时间片轮转调度，优先级调度算法，多级反馈队列调度算法</h3><h4 id="时间片轮转调度RR"><a href="#时间片轮转调度RR" class="headerlink" title="时间片轮转调度RR"></a>时间片轮转调度RR</h4><table>
<thead>
<tr>
<th>时间片轮转调度<br />（RR，Round-Robin）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td>
</tr>
<tr>
<td>算法规则</td>
<td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<span style="color:red">时间片</span>（如100ms)。若进程未在一个时间片内执行完则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度（只有作业放入内存建立了相应的进程后，<br/>才能被分配处理机时间片）</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>若进程未能在时间片内运行完，将被强行剥夺处理机使权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平；响应快，适用于分时操作系统；<br />缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>否</td>
</tr>
<tr>
<td>补充</td>
<td>时间片问题：<br />如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。<br />另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。<br />一般来说，设计时间片要让切换进程的开销占比不超过1%。</td>
</tr>
</tbody></table>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><table>
<thead>
<tr>
<th>优先级调度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场最需要根据任务的紧急程度来决定处理顺序</td>
</tr>
<tr>
<td>算法规则</td>
<td>调度时选择优先级最高的作业&#x2F;进程</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>既可用于作业调度，也可用于进程调度。甚至还会用于在之后会学习的I&#x2F;O调度中</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需任就绪队列变化时，检查是否会发生抢占。</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：用优先级区分紧总程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充</td>
<td>如下图</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251342602.png"/>

<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><table>
<thead>
<tr>
<th>多级反馈队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>对其他调度算法的折中权衡</td>
</tr>
<tr>
<td>算法规则</td>
<td>1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k级 队列队尾</td>
</tr>
<tr>
<td>优缺点</td>
<td>对各类型进程相对公平(FCFS的优点)：每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的时间就可完成(SPF的优点)；不必实现估计进程的运行时间（避免用户作假）：可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、&#x2F;O密集型进程（拓展：可以将因&#x2F;O而阻塞的进程重新放回原队列，这样&#x2F;O型进程就可以保持较高优先级)</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充理解</td>
<td>如下文</td>
</tr>
</tbody></table>
<blockquote>
<p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>P1(1) —— P2(1) —— P1(2) —— P2(1) —— P3(1) —— P2(2) —— P1(4) —— P1(1)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251358421.png"/>

<p>设置多级就绪队列，各级队列<strong>优先级从高到低</strong>，<strong>时间片从小到大</strong></p>
<p><span style="color:red">新进程</span>到达时<span style="color:red">先进入第1级队列</span>，按<span style="color:red">FCFS原则</span>排队等待被分配时间片。若用完时间片进程还<strong>未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>己经在最下级</strong>的队列，则<strong>重新放回</strong>最下级队列队尾</p>
<p>只有第<strong>k级队列为空</strong>时，才会<strong>为k+1级</strong>队头的进程<strong>分配时间片</strong><br><strong>被抢占处理机的进程重新放回原队列队尾</strong></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括<strong>分时操作系统、实时操作系统</strong>等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统。</strong>(比如UNIX使用的就是多级反馈队列调度算法)</p>
<h3 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>以下例子为管道通信为实例</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282350043.png"/>

<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></p>
<blockquote>
<p>含义</p>
</blockquote>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><ul>
<li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li>
<li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li>
<li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282351880.png"/>

<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282359512.png"/>

<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091148134.png"/>

<blockquote>
<p>turn的初值为0，即刚开始只允许0号进程进入临界区。<br>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。<br>因此，<strong>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p>
<p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→…这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。<br>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p>
</blockquote>
<h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091154224.png"/>

<p>若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091158727.png"/>

<p>若按照①⑤②⑥…的顺序执行，P0和P1将都无法进入临界区因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091200387.png"/>

<ul>
<li>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li>
<li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li>
</ul>
<h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516619.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516916.png"/>

<blockquote>
<p>关中断指令只对执行关中断指令的处理机有用</p>
</blockquote>
<h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518026.png"/>

<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518466.png"/>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="进程互斥：锁"><a href="#进程互斥：锁" class="headerlink" title="进程互斥：锁"></a>进程互斥：锁</h4><h5 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>解决临界区最简单的工具就是互斥锁（mutexlock)。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available); <span class="comment">//忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>; <span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>; <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。<br>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁（</strong>spin lock)，如TSL指令、swap指令、单标志法 </p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261531895.png"/>

<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li><strong>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，</strong>可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li>
<li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li>
<li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li>
<li>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261532635.png"/>

<p>进程互斥的四种软件实现方式（单标志法，双标志先检查，双标志后检查，Peterson算法）</p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法，TS&#x2F;TSL指令，Swap&#x2F;XCHG指令）</p>
<p>1.在双标志先检查法中，进去区的”检查“，”上锁“操作无法一气呵成，中间有可能先执行了检查就进行了进程切换，从而导致了两个进程有可能同时进入临界区的问题；</p>
<p>2.所有的解决方案都无法实现”让权等待“</p>
<blockquote>
<p>其中单标志法，双标志先检查，双标志后检查都存在着比较严重的一些问题的隐患。Peterson算法还有后面的三种硬件实现方式其实问题都不大，但是这些方式也都无法解决”让权等待“原则</p>
</blockquote>
<h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072113564.png"/>

<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072114497.png"/>

<h3 id="用信号量实现进程互斥，同步，前驱关系"><a href="#用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="用信号量实现进程互斥，同步，前驱关系"></a>用信号量实现进程互斥，同步，前驱关系</h3><h4 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol>
<li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li>
<li>设置互斥信号量mutex，初值为1</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072115578.png"/>

<p>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p>
<p><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p>
<h4 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序的进行。</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li>
<li>设置同步信号量s,初始为0</li>
<li>在“前操作”之后执行v(S)</li>
<li>在“后操作”之前执行P(S)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072117802.png"/>

<h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，</p>
<ol>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在“前操作”之后对相应的同步变量执行V操作</li>
<li>在“后操作”之前对相应的同步变量执行Р操作</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072118787.png"/>

<h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
<li>缓冲区是临界资源，各进程必须互斥地访问。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119845.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119979.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119956.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119961.png"/>

<h3 id="多生产者——多消费者"><a href="#多生产者——多消费者" class="headerlink" title="多生产者——多消费者"></a>多生产者——多消费者</h3><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123688.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123924.png"/>

<p>问题：可不可以不使用问题信号量？</p>
<p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p>
<p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p>
<p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p>
<ol>
<li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li>
<li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li>
</ol>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124996.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124492.png"/>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p>
<p>①允许多个读者可以同时对文件执行读操作;</p>
<p>②只允许一个写者往文件中写信息;</p>
<p>③任一写者在完成写操作之前不允许其他读者或写者工作;</p>
<p>④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125799.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125176.png"/>

<ul>
<li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125944.png"/>

<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。<br>其核心思想在于<strong>设置了一个计数器count用来记录当前正在访问共享文件的读进程数</strong>。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，<strong>如果需要实现“一气呵成”，自然应该想到用互斥信号量。</strong><br>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126626.png"/>

<p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<p>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p>
<blockquote>
<p>以下方式会出现死锁问题</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126279.png"/>
</blockquote>
<p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072127517.png"/>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程相当于对临界区资源进行抽象而编写的一个类。</strong></p>
<p>管程是一种特殊的软件模块，有这些部分组成:</p>
<p>1.局部于管程的共享数据结构说明; （一个类）</p>
<p>2.对该数据结构进行操作的一组过程; （类中的方法）</p>
<p>3．对局部于管程的共享数据设置初始值的语句; （类中的变量）</p>
<p>4.管程有一个名字。 （类名）</p>
<p>管程的基本特征:</p>
<p>1．局部于管程的数据只能被局部于管程的过程所访问; （类中变量有自己的作用范围）</p>
<p>**2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** <strong>这种互斥特性是由编译器来实现的。</strong></p>
<p><strong>3．每次仅允许一个进程在管程内执行某个内部过程。</strong></p>
<blockquote>
<h4 id="java中类似于管程的机制（单例模式）"><a href="#java中类似于管程的机制（单例模式）" class="headerlink" title="java中类似于管程的机制（单例模式）"></a>java中类似于管程的机制（单例模式）</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072128379.png"/>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p>
<p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p>
<h4 id="死锁，饥饿，死循环的区别"><a href="#死锁，饥饿，死循环的区别" class="headerlink" title="死锁，饥饿，死循环的区别"></a>死锁，饥饿，死循环的区别</h4><ul>
<li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li>
<li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072129588.png"/>

<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求 和 保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>)</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</p>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li>
<li><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072130399.png"/>

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061307159.png"/>

<p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081538138.png"/>

<h2 id="相对地址和绝对地址"><a href="#相对地址和绝对地址" class="headerlink" title="相对地址和绝对地址"></a>相对地址和绝对地址</h2><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong><br>编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>
<p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p>
<h2 id="三种装入模式"><a href="#三种装入模式" class="headerlink" title="三种装入模式"></a>三种装入模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061302897.png"/>

<h3 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h3><p>这种方式的灵活性很差，只适用于单道程序环境，早期还没有操作系统的阶段使用的就是这种方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061316431.png"/>

<h3 id="可重定位装入"><a href="#可重定位装入" class="headerlink" title="可重定位装入"></a>可重定位装入</h3><p>这种方式的特点是我们给这个作业&#x2F;进程分配的这些地址空间必须是连续的，并且这个作业必须一次全部装入内存</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317740.png"/>

<h3 id="动态运行时装入"><a href="#动态运行时装入" class="headerlink" title="动态运行时装入"></a>动态运行时装入</h3><p>CPU在对一个内存地址进行访问的时候会把逻辑地址和重定位寄存器当中存放的起始地址进行相加得到最终可以访问的地址</p>
<p>想让进程的数据在运行过程当中发生移动是很方便的，只需要修改重定位寄存器的值就可以</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317519.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317630.png"/>

<h2 id="程序运行逻辑"><a href="#程序运行逻辑" class="headerlink" title="程序运行逻辑"></a>程序运行逻辑</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081539943.png"/>

<p>这些目标模块文件当中已经包含了这些代码所对应的那些指令，而这些指令的编址都是逻辑地址。每一个模块的逻辑地址编址都是相互独立的，都从0开始</p>
<p>链接把这些目标模块组装起来形成一个完整的装入模块</p>
<p>在链接这一步，除了我们自己编写的这些目标模块需要链接以外，还需要把它们所调用到的一些库函数（如printf）也链接起来</p>
<h3 id="程序运行前—静态连接"><a href="#程序运行前—静态连接" class="headerlink" title="程序运行前—静态连接"></a>程序运行前—静态连接</h3><p>就是我们刚才所提到的这种方式，在形成装入模块之后就确定了这个装入模块的完整的逻辑地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061319738.png"/>

<h3 id="装入时—动态连接"><a href="#装入时—动态连接" class="headerlink" title="装入时—动态连接"></a>装入时—动态连接</h3><p>采用这种方式的话，这个进程的完整的逻辑地址是一边装入一边形成的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061320350.png"/>

<h3 id="运行时—动态连接"><a href="#运行时—动态连接" class="headerlink" title="运行时—动态连接"></a>运行时—动态连接</h3><p>需要用到某一个模块的时候再把它调入内存，装入的同时进行链接</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321161.png"/>

<h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321531.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061323512.png"/>

<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<ol>
<li><p>操作系统负责内存空间的分配与回收</p>
</li>
<li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></p>
</li>
</ol>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 </p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061326837.png"/>

<p>绝对装入是在编译的时候就产生了绝对地址，或者说在程序员写程序的时候直接就写了绝对地址。这个地址转换是由编译器而不是操作系统完成的</p>
<p>可重定位装入中地址转换的过程由装入程序负责进行，而装入程序也是操作系统的一部分</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111342928.png"/>

<h4 id="上下寄存器"><a href="#上下寄存器" class="headerlink" title="上下寄存器"></a>上下寄存器</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111342779.png"/>

<h4 id="重定位寄存器"><a href="#重定位寄存器" class="headerlink" title="重定位寄存器"></a>重定位寄存器</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111343667.png"/>

<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111344101.png"/>

<h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。<br>后来人们引入了<strong>覆盖技术，用来解决“程小超过物理内存总和”的问题</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111346095.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111346097.png"/>

<blockquote>
<p>A这个模块会依次调用B模块和C模块。注意是依次调用，B模块和C模块只可能被A模块在不同的时间段调用，不可能是同时访问B和C这两个模块</p>
</blockquote>
<p>操作系统并不知道程序的调用结构，程序的调用结构必须由程序员显性地声明，操作系统根据程序员声明的调用结构&#x2F;覆盖结构完成自动覆盖</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111350389.png"/>

<p>第二章讲处理机调度的时候讲过一个处理机调度层次的概念，分为高级调度，中级调度和低级调度。其中中级调度就是为了实现交换技术而使用的一种调度策略</p>
<p>换出外存的进程相关的PCB会保留在内存当中并且插入到挂起队列里</p>
<p>为什么进程的PCB要常驻内存呢？因为进程被换出外存之后，必须要通过某种方式记录下进程到底是放在外存的什么位置，这个信息记录在对应的PCB当中，操作系统就可以根据PCB当中记录的这些信息对这些进程进行管理</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111350777.png"/>

<p>一个本来处于就绪态的进程被换出外存，这个进程就处于就绪挂起态</p>
<p>一个本来处于阻塞态的进程被换出外存，这个进程就处于阻塞挂起态</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111351844.png"/>

<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111351402.png"/>

<p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111352995.png"/>

<p>内存当中同一时刻只能有一道用户程序，它并不支持多道程序并发运行</p>
<p>因为系统中只会运行一个用户程序，即使这个用户程序出问题了也只会影响用户程序本身，或者说即使这个用户程序越界损坏操作系统的数据，这个数据一般来说也可以通过重启计算机就可以很方便地进行修复，所以说采用单一连续分配的系统当中不一定采取内存保护</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111353659.png"/>

<p>分区大小相等：如果有一个比较大的进程进入的话，如果这些分区的大小都不能满足这个大进程的需求，那么这个大进程就不能被装入这个系统，或者说只能采用覆盖技术在逻辑上来拓展各个分区的大小，而这显然又会增加一些系统开销</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111354699.png"/>

<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111354258.png"/>

<h5 id="动态分区存在的问题"><a href="#动态分区存在的问题" class="headerlink" title="动态分区存在的问题"></a>动态分区存在的问题</h5><ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111359562.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111400729.png"/>
</li>
<li><p>分区分配：<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111400169.png"/></p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111410550.png"/>

<ol start="4">
<li>分区回收：<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111411848.png"/></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111414369.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111414421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111415359.png"/>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>这几种情况本质上可以用一句话来进行总结：在进行内存分区回收的时候，如果说回收了之后发现有一些空闲分区是相邻的，那我们就需要把这些相邻的空闲分区全部合并</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111415841.png"/>

<p>紧凑技术其实就是把各个进程挪位，把它们全部攒到一起，挪出一个更大的连续空闲区间</p>
<p>动态重定位的方式最方便实现程序或者说进程在内存当中移动位置</p>
<p>紧凑之后需要修改各个进程的起始地址，进程的起始地址信息一般存放在进程对应的PCB当中，当进程要上CPU运行之前会把进程的起始地址信息放到重定位寄存器（基址寄存器）里</p>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111416487.png"/>

<p>动态分区分配算法：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区</p>
<p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块。因此这种方法会产生很多的外部碎片</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>又称 最大适应算法（Largest Fit）</p>
<p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p>
<p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有”大进程“到达，就没有内存分区可用了</p>
<h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</p>
<p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>假如说此时系统当中的内存使用情况如下图所示，把这些空闲分区按照地址递增的次序依次进行排列，排成一个循环链表</p>
<p>如果有一个需要5MB内存空间的进程到达，就从链头的位置开始查找直到找到合适的分区进行分配。同时更新链当中的结点，包括分区的大小，还有分区的起始地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111418851.png"/>

<p>采用邻近适应算法和首次适应算法只需要按照地址递增的次序进行排列。所以即使这里内存分区的大小发生了一个比较大的变化，但是我们依然不需要像最佳适应算法和最坏适应算法一样可能要对整个链表进行重新排列，算法的开销会比较小</p>
<p>接下来假如一个需要5MB内存空间的新进程到达，按照规则从上一次查找到的位置依次再往后查找即可。以后的过程都是类似的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111419898.png"/>

<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>
<p>综合来看，四种算法中，首次适应算法的效果反而更好</p>
</blockquote>
<h3 id="基本分页存储管理的概念"><a href="#基本分页存储管理的概念" class="headerlink" title="基本分页存储管理的概念"></a>基本分页存储管理的概念</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111420967.png"/>

<p>非连续分配：为用户进程分配的可以是一些分散的内存空间</p>
<h4 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111420848.png"/>

<p>内存里存放的无非就是各个进程的数据，包括进程的代码，进程的指令等等</p>
<h4 id="页表——重要的数据结构"><a href="#页表——重要的数据结构" class="headerlink" title="页表——重要的数据结构"></a>页表——重要的数据结构</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111421980.png"/>

<blockquote>
<p>内存块就是页框(page flame)</p>
</blockquote>
<h4 id="问题1：每个页表项占多少字节"><a href="#问题1：每个页表项占多少字节" class="headerlink" title="问题1：每个页表项占多少字节"></a>问题1：每个页表项占多少字节</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111422216.png"/>

<p>这里计算机分配存储空间是以字节为单位而不是以bit为单位，所以20bit至少要用3B来存储</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111428370.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111428490.png"/>

<p>一个页表项在逻辑上是包含了页号和块号这两个信息，但是在物理上它只需要存放块号这个信息，只有块号需要占用存储空间</p>
<h4 id="问题2：如何实现地址的转换"><a href="#问题2：如何实现地址的转换" class="headerlink" title="问题2：如何实现地址的转换"></a>问题2：如何实现地址的转换</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111431445.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111431771.png"/>

<p>页内偏移量：相对于页面的起始位置而言的偏移量是多少</p>
<h5 id="如何确定一个逻辑地址对应的页号，页内偏移量？"><a href="#如何确定一个逻辑地址对应的页号，页内偏移量？" class="headerlink" title="如何确定一个逻辑地址对应的页号，页内偏移量？"></a>如何确定一个逻辑地址对应的页号，页内偏移量？</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111432887.png"/>

<h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111433183.png"/>

<h3 id="基本地址变化机构"><a href="#基本地址变化机构" class="headerlink" title="基本地址变化机构"></a>基本地址变化机构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111434511.png"/>

<p>基本地址变换机构是基本分页存储管理中用于实现逻辑地址到物理地址转换的一组硬件机构</p>
<h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>在分页存储管理当中如果要把逻辑地址转换成物理地址的话，总共需要做4件事：</p>
<p>1.知道逻辑地址对应的页号</p>
<p>2.知道逻辑地址对应的页内偏移量</p>
<p>3.知道逻辑地址对应的页面在内存当中存放的位置到底是多少</p>
<p>4.根据页面在内存当中的起始位置和页内偏移量就可以得到最终的物理地址</p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个<strong>页表寄存器</strong>（PTR),<strong>存放页表在内存中的起始地址F和页表长度M</strong>。进程未执行时，页表的始址和页表长度放在**进程控制块（PCB)**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<blockquote>
<p>注意：<strong>页面大小是2的整数幂</strong></p>
<p>设页面大小为L,逻辑地址A到物理地址E的变换过程如下：</p>
<p>操作系统会把内存分为系统区和用户区。系统区当中存放着操作系统对整个计算机软硬件进行管理的一些相关的数据结构，包括PCB</p>
<p>如果一个进程被调度需要上处理机运行，进程切换相关的那些内核程序就会把这个进程的运行环境给恢复。这些进程运行环境相关的信息本来是保存在PCB当中的，内核程序会把这些信息放到相应的一系列寄存器当中，包括页表寄存器。另外程序计数器PC也是需要恢复的，PC指向这个进程下一条需要执行的指令的逻辑地址。接下来看怎么把这个逻辑地址转换成实际的物理地址，即CPU怎么在内存当中找到接下来要执行的这一条指令</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111437646.png"/>

<p>采用分页存储管理方式的系统当中，逻辑地址结构肯定是固定不变的，在一个逻辑地址当中页号有多少位，页内偏移量有多少位操作系统都是知道的。所以只要知道了逻辑地址就可以很快地切分出页号和页内偏移量这两个部分</p>
<p>接下来会对页号的合法性进行一个检查，越界就会抛出中断由中断处理程序进行处理</p>
<blockquote>
<p>一个进程的页表长度M指的是这个进程的页表当中有M个页表项，也就意味着这个进程的页面总共有M页</p>
</blockquote>
<p>如果页号是合法的，接下来会用这个页号和页表始址来进行计算，找到这个页号对应的页表项到底是多少</p>
<p>页表当中的每一个页表项的长度是相同的。所以只要知道了页号，页表起始地址和每一个页表项的长度就可以算出我们想要访问的页号对应的页表项所存放的位置</p>
<p>既然知道了存放的内存块号，就可以用内存块号结合页内偏移量得到最终的物理地址，然后就可以顺利地访问逻辑地址所对应的内存单元了</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111441369.png"/>
</blockquote>
<p>该过程的文字描述如下</p>
<blockquote>
<ol>
<li><p>计算页号P和页内偏移量W（如果用十进制数手算，则 P&#x3D;A&#x2F;L，W&#x3D;A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号，页内偏移量）</p>
</li>
<li><p>比较页号P和页表长度M，若P ≥ M P\ge M<em>P</em>≥<em>M</em>，则产生越界中断，否则继续执行。（注意：页号从0开始的，而页表长度至少是1，因此 P&#x3D;M 时也会越界）</p>
</li>
<li><p>页表中页号P对应的页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度，页表长度，页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</p>
</li>
<li><p>计算E&#x3D;b*L+W,用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</p>
</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443343.png"/>

<h4 id="对页表项大小的进一步探讨"><a href="#对页表项大小的进一步探讨" class="headerlink" title="对页表项大小的进一步探讨"></a>对页表项大小的进一步探讨</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443247.png"/>

<p>页表项不能跨页框存储</p>
<p>如果说我们的这些页表项并不能装满整个页框的话，那在查找页表项的时候会造成一些麻烦</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443524.png"/>

<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表，又称联想寄存器（TLB,translation lookaside buffer),是一种访问速度比内存快很多的高速缓存（TLB不是内存！),用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111522029.png"/>

<blockquote>
<p>进程最先要访问的逻辑地址是(0，0)</p>
<p>首先进行越界异常的检查，该页号需要和页表寄存器当中的页表长度对比</p>
<p>接下来就会查询快表，由于快表此时的内容是空的，因此在快表中找不到页号为0对应的页表项，快表没有命中。接下来就不得不去访问内存当中存放的慢表，通过页表始址和页号计算出对应的页表项存放的位置</p>
<p>查询完慢表之后就可以知道0号页面所存放的内存块号是600，再通过内存块号和页内偏移量就可以得到最终的物理地址，最后就可以访问这个逻辑地址所对应的内存单元了</p>
<p>注意在访问了这个页表项之后同时也会把该页表项复制一份放到快表当中</p>
<p>接下来要访问的逻辑地址是(0，4)</p>
<p>同样地刚开始会进行越界异常的判断，发现没有越界</p>
<p>接下来会根据页号来查询快表以确认这个页号所对应的页表项是否在快表当中，由于刚才已经复制到了快表当中，因此这次的查询就可以命中。系统可以直接知道0号页面存放的页面是600，所以接下来就不需要查询内存当中的慢表而是直接用内存块号和页内偏移量得到最终想要访问的物理地址然后进行访存</p>
<p><strong>（0，0）前面指的是页号，后面指的是页内偏移量</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111524247.png"/>

<h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><blockquote>
<ol>
<li><p>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较</p>
</li>
<li><p>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
</li>
<li><p>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p>
</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us,访问一次内存耗时100us。若快表的命中率为90%,那么访问一个逻辑地址的平均耗时是多少？</p>
<p>(1+100)*0.9+(1+100+100)*0.1&#x3D;111us</p>
<p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是</p>
<p>（1+100)*0.9+(100+100)*0.1&#x3D; 110.9us</p>
<p>若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111528656.png"/>
</blockquote>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络(3)-传输层与应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:21:55 / 修改时间：22:36:18" itemprop="dateCreated datePublished" datetime="2023-02-01T16:21:55+08:00">2023-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层提供的服务及功能"><a href="#传输层提供的服务及功能" class="headerlink" title="传输层提供的服务及功能"></a>传输层提供的服务及功能</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011631465.png"/>

<p><strong>传输层的功能如下:</strong><br><strong>1)传输层提供应用进程之间的逻辑通信(即端到端的通信)。</strong></p>
<ul>
<li>与网络层的区别是，网络层提供的是主机之间的逻辑通信。</li>
<li>从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址。</li>
<li>但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称<code>端到端</code>的逻辑通信。</li>
<li>这里<code>“逻辑通信”</code>的意思是:传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有–条水平方向的物理连接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011642474.png"/>

<p><strong>2)复用和分用。</strong></p>
<ul>
<li>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据;</li>
<li>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>传输层的复用分用功能与网络层的复用分用功能不同。</strong></li>
<li>网络层的<code>复用</code>是指发送方不同协议的数据都可以封装成IP数据报发送出去,</li>
<li>网络层的<code>分用</code>是指接收方的网络层在剥去首部后把数据交付给相应的协议。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643998.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643442.png"/>

<p><strong>3)传输层还要对收到的报文进行差错检测(首部和数据部分)。</strong></p>
<ul>
<li>网络层只检查IP数据报的首部，不检验数据部分是否出错。</li>
</ul>
<p><strong>4)提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。</strong></p>
<ul>
<li>网络层无法同时实现两种协议(即在网络层要么只提供面向连接的服务，如虚电路;要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式)。</li>
</ul>
<h2 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a><strong>传输层的寻址与端口</strong></h2><h3 id="（1）端口的作用"><a href="#（1）端口的作用" class="headerlink" title="（1）端口的作用"></a>（1）端口的作用</h3><ul>
<li>端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li>
<li>端口是传输层<code>服务访问点</code>(TSAP)，它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，只不过<code>IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程</code>。</li>
<li><code>数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口</code>。</li>
<li>在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。</li>
<li>传输层使用的是软件端口。</li>
</ul>
<h3 id="（2）端口号的分类"><a href="#（2）端口号的分类" class="headerlink" title="（2）端口号的分类"></a>（2）端口号的分类</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011652356.png"/>

<h3 id="（3）套接字"><a href="#（3）套接字" class="headerlink" title="（3）套接字"></a>（3）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a></h3><p>在网络中通过IP地址来标识和区别不同的主机，<code>通过端口号来标识和区分一台主机中的不同应用进程</code>。在网络中采用发送方和接收方的<code>套接字(Socket)</code>组合来识别<code>端点</code>。</p>
<p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。<br>$$<br>套接字Socket&#x3D;(主机IP地址，端口号)<br>$$</p>
<h2 id="无连接UDP和面向连接TCP服务"><a href="#无连接UDP和面向连接TCP服务" class="headerlink" title="无连接UDP和面向连接TCP服务"></a>无连接UDP和面向连接TCP服务</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011702423.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>面向</th>
<th>说明</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>TCP面向连接的传输控制协议</td>
<td>面向连接（可靠）</td>
<td>传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。（监控管理）</td>
<td><strong>可靠，面向连接，时延大，适用于大文件。</strong>【TCP主要适用于可靠性更重要的场合，如文件传输协议（FTP)、超文本传输协议（HTTP)、远程登录（TELNET)等。】</td>
</tr>
<tr>
<td>UDP无连接的用户数据报协议</td>
<td>面向无连接（不可靠）</td>
<td>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。</td>
<td><strong>不可靠，无连接，时延小，适用于小文件。</strong>【UDP的应用主要包括小文件传送协议（TFTP)、DNS、SNMP和实时传输协议（RTP)。】</td>
</tr>
</tbody></table>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p>
<h4 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h4><ol>
<li>UDP是无连接的，减少开销和发送数据之前的时延。</li>
<li>UDP使用最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的，适合一次性传输少量数据的网络应用。</li>
<li>UDP无拥塞控制，适合很多实时应用。</li>
<li>UDP首部开销小，8B,TCP20B。</li>
</ol>
<p>应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011708708.png"/>

<p><strong>为什么应用开发人员宁愿在UDP之上构建应用，也不选择TCP?既然TCP提供可靠的服务，而UDP不提供，那么TCP总是首选吗?答案是否定的，因为有很多应用更适合用UDP，主要是因为UDP具有如下优点:</strong></p>
<p><strong>1)UDP无须建立连接。</strong></p>
<ul>
<li>UDP不会引入建立连接的时延。</li>
<li>试想如果DNS运行在TCP而非UDP.上，那么DNS的<code>速度</code>会慢很多。</li>
<li>HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，<code>可靠性</code>是至关重要的。</li>
</ul>
<p><strong>2)无连接状态。</strong></p>
<ul>
<li>TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。</li>
<li>而UDP不维护连接状态，也不跟踪这些参数。</li>
<li>因此，<code>某些专用应用服务器使用UDP</code>时，<code>一般都能支持更多的活动客户机</code>。</li>
</ul>
<p><strong>3)分组首部开销小。</strong></p>
<ul>
<li><code>TCP</code>有<code>20B</code>的<code>首部</code>开销，而<code>UDP</code>仅有<code>8B</code>的开销。</li>
</ul>
<p><strong>4)应用层能更好地控制要发送的数据和发送时间。</strong></p>
<ul>
<li>UDP没有拥塞控制，因此网络中的拥塞<code>不会影响主机的发送效率</code>。</li>
<li><code>某些实时应用要求以稳定的速度发送</code>，能容忍一些数据的丢失，但<code>不允许有较大的时延</code>，而UDP正好满足这些应用的需求。</li>
</ul>
<p><strong>5)UDP常用于一次性传输较少数据的网络应用</strong></p>
<ul>
<li>如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。</li>
<li>UDP也常用于多媒体应用(如IP电话、实时视频会议、流媒体等)，显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。</li>
</ul>
<p><strong>6)UDP提供尽最大努力的交付，即不保证可靠交付</strong></p>
<ul>
<li>但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成。</li>
<li><code>应用实体可以根据应用的需求来灵活设计自己的可靠性机制</code>。</li>
</ul>
<p><strong>7)UDP是面向报文的。</strong></p>
<ul>
<li><p>发送方UDP对<code>应用层交下来的报文</code>，在添加首部后就向下交付给IP层，<br><code>既不合并，也不拆分</code>，而是保留这些报文的边界;</p>
</li>
<li><p>接收方UDP对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。</p>
</li>
<li><p>因此<code>报文不可分割，是UDP数据报处理的最小单位</code>。</p>
</li>
</ul>
<h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011724860.png"/>

<p><strong>各字段意义如下：</strong></p>
<ul>
<li>1)源端口。源端口号。在需要对方回信时选用，不需要时可用全0。</li>
<li>2)目的端口。目的端口号。这在终点交付报文时必须使用到。</li>
<li>3)长度。UDP数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)。</li>
<li>4)校验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。</li>
</ul>
<h4 id="当传输层从IP层收到UDP数据报时"><a href="#当传输层从IP层收到UDP数据报时" class="headerlink" title="当传输层从IP层收到UDP数据报时"></a>当传输层从IP层收到UDP数据报时</h4><p>根据首部中的目的端口，把UDP数据报通过相应的端口.上交给应用进程</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011729465.png"/>

<p>如果接收方UDP发现收到的报文中的目的端口号不正确(即不存在对应于端口号的应用进程)，那么就丢弃该报文，并由ICMP发送“端口不可达”<code>差错报文给发送方</code>。</p>
<h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><ul>
<li>伪首部和全0字节是不发送的，仅供校验使用</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742344.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742289.png"/>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h4><ol>
<li><p>TCP是面向连接（虚连接）的传输层协议。(打call)</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。[可靠有序，不丢不重]</p>
</li>
<li><p>TCP提供全双工通信。<br> 发送缓存:准备发送的数据已发送但尚未收到确认的数据<br> 接收缓存:按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</p>
</li>
<li><p>TCP面向字节流<br> TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p>
</li>
</ol>
<p>  （流：流入到进程或从进程流出的字节序列。）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011748224.png"/>

<h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><ul>
<li><code>TCP传送的数据单元称为报文段</code>。一个TCP报文段分为TCP首部和TCP数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中</li>
<li>其首部的前20B是固定的。TCP报文段的首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度为4B的整数倍。</li>
<li>TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011749892.png"/>

<ul>
<li>1)<code>源端口和目的端口字段</code>。各占2B。端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现。</li>
<li>2)<code>序号字段</code>。占4B。TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011750146.png"/>

<ul>
<li>3)<code>确认号字段</code>。占4B,是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表明到序号N- 1为止的所有数据都已正确收到。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753161.png"/>

<ul>
<li>4)<code>数据偏移(即首部长度)</code>。占4位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位(以4B为计算单位)。因此当此字段的值为15时，达到TCP首部的最大长度60B.</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753880.png"/>

<ul>
<li>5)<code>保留字段</code>。占6位，保留为今后使用，但目前应置为0，该字段可以忽略不计。</li>
<li>6)<code>紧急位URG</code>。URG&#x3D; 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。但<code>URG需要和紧急指针配套使用</code>，即<code>数据从第一个字节到紧急指针所指字节</code>就是<code>紧急数据</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753219.png"/>

<ul>
<li>7)<code>确认位ACK</code>。只有当ACK&#x3D; 1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.</li>
<li>8)<code>推送位PSH (Push)</code>。 接收TCP收到PSH&#x3D; 1的报文段，就尽快地交付给接收应用进程而不再等到整个缓存都填满后再向上交付。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754971.png"/>

<ul>
<li>9)<code>复位位RST (Reset)</code>。RST&#x3D;1时，表明TCP连接中出现严重差错(如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</li>
<li>10)<code>同步位SYN</code>。同步SYN&#x3D; 1表示这是一个<code>连接请求或连接接收报文</code>。当<code>SYN=1, ACK=0</code>时，表明这是一个<code>连接请求</code>报文，对方若同意建立连接，则在响应报文中使用<code>SYN=1, ACK=1</code>。即SYN&#x3D; 1表示这是一个连接请求或连接接收报文。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754021.png"/>

<ul>
<li>11)<code>终止位FIN (Finish)</code>。用来释放一个连接。FIN&#x3D; 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</li>
<li>12)<code>窗口字段</code>。占2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。<br>例如，假设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的接收方方还有接收1000B数据(字节序号为701 ~1700)的接收缓存空间。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754063.png"/>

<ul>
<li>13)<code>校验和</code>。占2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6，其他的和UDP一样)。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43914604/article/details/105453096">UDP协议</a></li>
<li>14)<code>紧急指针字段</code>。占16 位，指出在本报文段中紧急数据共有多少字节(紧急数据放在本报文段数据的最前面)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011755349.png"/>

<p>15)<code>选项字段</code>。长度可变。TCP最初只规定了一种选项，即最大报文段长度(Maximum SegmentSize，MSS)。MSS是TCP报文段中的数据字段的最大长度。窗口扩大、时间戳、选择确认<br>16)<code>填充字段</code>。这是为了使整个首部长度是4B的整数倍。填充0</p>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><ul>
<li>TCP是面向连接的协议，因此每个TCP连接都有三个阶段:<code>连接建立、数据传送和连接释放</code>。</li>
<li><code>TCP连接的管理就是使运输连接的建立和释放都能正常进行</code>。</li>
</ul>
<p><strong>在TCP连接建立的过程中，要解决以下三个问题:</strong></p>
<ul>
<li>1)要使每一方都能够确知对方的存在。</li>
<li>2)要允许双方协商一些参数(如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等)。</li>
<li>3)能够对运输实体资源( 如缓存大小、连接表中的项目等)进行分配。</li>
</ul>
<p>每条TCP连接通过通信两端的<code>两个端点( 即两个套接字)</code>确定。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012046974.png"/>

<h4 id="TCP的三次握手-连接的建立"><a href="#TCP的三次握手-连接的建立" class="headerlink" title="*TCP的三次握手-连接的建立"></a>*TCP的三次握手-连接的建立</h4><ul>
<li>seq为序号字段，标明本次报文段数据部分的第一个字节的序号</li>
<li>ack是<code>确认号字段</code>，告诉对方我接下来应该接收的数据是从字节序号ack开始的数据</li>
<li>ACK是确认位,0时<code>确认号字段ack</code>无效，1时<code>确认号字段ack</code>有效</li>
<li>SYN是同步位</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012047854.png"/>

<ul>
<li>第一步:客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号 seq&#x3D; x(连接请求报文不携带数据，但要消耗一个序号)。</li>
<li>第二步:服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1,确认号字段的值为x+ 1, 并且服务器随机产生起始序号seq &#x3D; y(确认报文不携带数据,但也要消耗-一个序号)。确认报文段同样不包含应用层数据。</li>
<li>第三步:当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1,序号字段为x+1,确认号字段ack&#x3D;y+ 1。该报文段可以携带数据，若不携带数据则不消耗序号。<br>成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。</li>
</ul>
<p><strong>TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。</strong></p>
<ul>
<li>服务器端的资源是在完成第二次握手时分配的</li>
<li>而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</li>
</ul>
<h5 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h5><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。</p>
<p>攻击者发送TCP SYN,SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。</p>
<p>攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p>
<h4 id="TCP的四次挥手-连接的释放"><a href="#TCP的四次挥手-连接的释放" class="headerlink" title="*TCP的四次挥手-连接的释放"></a>*TCP的四次挥手-连接的释放</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012058140.png"/>

<ul>
<li>第一步:客户机打算关闭连接时，向其TCP发送一个连接释放报文段， 并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1, <code>seq=u, 它等于前面已传送过的数据的最后一个字节的序号加1</code> (FIN报文段即使不携带数据，也要消耗一个序号)。<br>TCP 是全双工的，即可以想象为一条TCP连接上有两条数据通路。<br>发送FIN报文时，发送FIN的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</li>
<li>第二步:服务器收到连接释放报文段后即发出确认，<code>确认号是ack=u+ 1,而这个报文段自己的序号是v,等于它前面已传送过的数据的最后一个字节的序号加1</code>。<br>此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。<br>但服务器若发送数据，客户机仍要接收，即<code>从服务器到客户机这个方向的连接并未关闭</code>。</li>
<li>第三步:若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其<code>发出FIN= 1的连接释放报文段</code>。</li>
<li>第四步:<code>客户机收到连接释放报文段后，必须发出确认</code>。在确认报文段中，ACK字段被置为1，确认号ack&#x3D;w+1,序号seq&#x3D;u+1.此时TCP连接还未释放，<code>必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态</code>。</li>
</ul>
<h4 id="TCP连接建立和释放的总结"><a href="#TCP连接建立和释放的总结" class="headerlink" title="TCP连接建立和释放的总结"></a>TCP连接建立和释放的总结</h4><ul>
<li><ol>
<li>连接建立。分为3步:<br>① SYN&#x3D;1，seq&#x3D;x。<br>② SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ack&#x3D;x+ 1。<br>③ ACK&#x3D;1，seq&#x3D;x+1, ack&#x3D;y+ 1。</li>
</ol>
</li>
<li><ol start="2">
<li>释放连接。分为4步:<br>① FIN&#x3D;1, seq&#x3D; u<br>② ACK&#x3D;1, seq&#x3D;v, ack&#x3D;u+ 1。<br>③ FIN&#x3D;1，ACK&#x3D;1, seq&#x3D;w，ack&#x3D;u+ 1。<br>④ ACK&#x3D;1, seq&#x3D;u+1, ack&#x3D;w+ 1。</li>
</ol>
</li>
</ul>
<p>关于连接和释放，ACK、 SYN、 FIN 一定等于1</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012102975.png"/>

<h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103517.png"/>

<h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103897.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103883.png"/>

<h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012104058.png"/>

<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul>
<li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为<code>接收窗口rwnd</code>, 即<code>调整TCP报文段首部中的“窗口”字段值</code>，来限制发送方向网络注入报文的速率。</li>
<li>同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<code>拥塞窗口cwnd</code>，其大小与网络的带宽和时延密切相关。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012110668.png"/>

<ul>
<li><code>例如</code>，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A。</li>
<li>rwnd 即接收方允许连续接收的最大能力，单位是字节。</li>
<li>发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存溢出。</li>
<li>当然，<code>A的发送窗口的实际大小取rwnd和cwnd中的最小值</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118546.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118055.png"/>

<p><strong>传输层和数据链路层的流量控制的区别是:</strong></p>
<ul>
<li>传输层定义<code>端到端</code>用户之间的流量控制，数据链路层定义<code>两个中间的相邻结点</code>的流量控制。</li>
<li>另外，<code>数据链路层</code>的滑动窗口协议的<code>窗口</code>大小<code>不能动态变化</code>，<code>传输层</code>的则可以<code>动态变化</code>。</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="1-什么是拥塞控制？"><a href="#1-什么是拥塞控制？" class="headerlink" title="1. 什么是拥塞控制？"></a>1. 什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">拥塞控制</a>？</h5><ul>
<li>所谓<code>拥塞控制，是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</code>。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。</li>
</ul>
<h5 id="2-拥塞控制与流量控制的区别"><a href="#2-拥塞控制与流量控制的区别" class="headerlink" title="2. 拥塞控制与流量控制的区别"></a>2. 拥塞控制与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">流量控制</a>的区别</h5><ul>
<li><code>拥塞控制</code>是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li><code>流量控制</code>往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012119412.png"/>

<ul>
<li><strong>例如：</strong></li>
<li>某个链路的传输速率为10Gb&#x2F;s,某巨型机向一台PC以1Gb&#x2F;s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行<code>流量控制</code>。</li>
<li>但若有100万台PC在此链路上以1Mb&#x2F;s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</li>
</ul>
<p><strong>为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下4种算法:<code>慢开始、拥塞避免、快重传、快恢复。</code></strong></p>
<h5 id="3-拥塞控制的4种算法"><a href="#3-拥塞控制的4种算法" class="headerlink" title="3. 拥塞控制的4种算法"></a>3. 拥塞控制的4种算法</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012121629.png"/>

<h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012122103.png"/>

<ul>
<li>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd&#x3D; 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加1,即增大一个 MSS.用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</li>
</ul>
<blockquote>
<p>例如，A向B发送数据，发送时A的拥塞窗口为2,那么A一次可以发送两个TCP报文段，经过一个RTT后(也称一个<code>传输轮次</code>)，A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。</p>
</blockquote>
<ul>
<li>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</li>
</ul>
<h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><ul>
<li>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过- -一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。</li>
<li>根据cwnd的大小执行不同的算法，可归纳如下:<br>●当cwnd &lt; ssthresh时，使用慢开始算法。<br>●当 cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>●当cwnd &#x3D; sthresh时，既可使用慢开始算法，又可使用拥塞避免算法(通常做法)。</li>
</ul>
<p><strong>网络拥塞的处理</strong></p>
<ul>
<li><p>网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生(未按时收到确认，重传计时器超时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。<br>然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
</li>
<li><p>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></p>
</li>
<li><p>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></p>
</li>
</ul>
<blockquote>
<p>在慢开始和拥塞避免算法中使用了<code>“乘法减小”和“加法增大”方法</code>。</p>
<ul>
<li><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</li>
<li><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢<br>增大，以防止网络过早出现拥塞。</li>
</ul>
</blockquote>
<h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><p><strong>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</strong></p>
<ul>
<li>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</li>
</ul>
<h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><p><strong>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</strong></p>
<ul>
<li><code>快恢复算法</code>的原理如下:</li>
<li>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</li>
<li>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</li>
<li><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</li>
</ul>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012127416.png"/>

<ul>
<li>在<code>流量控制</code>中，发送方发送数据的量由接收方决定，而在<code>拥塞控制</code>中，则由发送方自己通过检测网络状况来决定。</li>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<blockquote>
<p><code>注意：</code> <code>发送方发送窗口的实际大小</code>由<code>流量控制</code>和<code>拥塞控制</code>共同决定。<br>因此，当题目中同时出现接收端窗口(rwnd) 和拥塞窗口(cwnd) 时，发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012144530.png"/>

<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>客户&#x2F;服务器模型（Client&#x2F;Server)<br>P2P模型（Peer-to-peer)</p>
<h3 id="c-x2F-s模型（客户-x2F-服务器模型）"><a href="#c-x2F-s模型（客户-x2F-服务器模型）" class="headerlink" title="c&#x2F;s模型（客户&#x2F;服务器模型）"></a>c&#x2F;s模型（客户&#x2F;服务器模型）</h3><p>服务器：提供计算服务的设备。</p>
<ol>
<li><p>永久提供服务</p>
</li>
<li><p>永久性访问地址&#x2F;域名</p>
</li>
</ol>
<p>客户机：请求计算服务的主机。</p>
<ol>
<li><p>与服务器通信，使用服务器提供的服务</p>
</li>
<li><p>间歇性接入网络</p>
</li>
<li><p>可能使用动态IP地址</p>
</li>
<li><p>不与其他客户机直接通信</p>
</li>
</ol>
<p>应用：Web,文件传输FTP,远程登录，电子邮件</p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><ul>
<li><p>在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一一对计算机一称为<code>对等方(Peer)</code>， 直接相互通信。</p>
</li>
<li><p>P2P 模型从本质上来看仍然使用客户&#x2F;服务器方式，每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
</li>
<li><p>当前比较流行的P2P应用有PPlive、Bittorrent 和电驴等。</p>
</li>
<li><p>不存在永远在线的服务器</p>
</li>
<li><p>每个主机既可以提供服务，也可以请求服务</p>
</li>
<li><p>任意端系统&#x2F;节点之间可以直接通讯</p>
</li>
<li><p>节点间歇性接入网络</p>
</li>
<li><p>节点可能改变IP地址</p>
</li>
<li><p>可扩展性好</p>
</li>
<li><p>网络健壮性强</p>
</li>
</ul>
<p><strong>与C&#x2F;S模型相比，P2P 模型的优点主要体现如下:</strong></p>
<ul>
<li>1)减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率(例如，播放流媒体时对服务器的压力过大，而通过P2P模型，可以利用大量的客户机来提供服务)。</li>
<li>2)多个客户机之间可以直接共享文档。</li>
<li>3)可扩展性好，传统服务器有响应和带宽的限制，因此只能接受- -定 数量的请求。</li>
<li>4)网络健壮性强，单个结点的失效不会影响其他部分的结点。</li>
</ul>
<p><code>P2P模型也有缺点</code>。在获取服务的同时,还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。<br>例如，经常进行P2P下载还会对硬盘造成较大的损伤。据某互联网调研机构统计，当前P2P程序已占互联网50%~90%的流量，使网络变得非常拥塞，因此各大ISP (互联网服务2提供商，如电信、网通等)通常都对P2P应用持反对态度。</p>
<h2 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS(域名解析系统)"></a>DNS(域名解析系统)</h2><ul>
<li><code>域名系统(Domain Name System, DNS)</code>是因特网使用的命名系统，用来<code>把便于人们记忆的具有特定含义的主机名(如www.BitHachi.com)转换为便于机器处理的IP地址</code>。</li>
<li>相对于IP地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的计算机。</li>
<li>DNS系统采用客户&#x2F;服务器模型，其协议运行在<code>UDP</code>之上，使用<code>53</code>号端口。</li>
<li>从概念上可将DNS分为3部分:<code>层次域名空间、域名服务器和解析器</code>。</li>
</ul>
<p>某台主机访问网站<a target="_blank" rel="noopener" href="http://www.bithachi.cn网站为例,dns的大致流程/">www.bithachi.cn网站为例，DNS的大致流程</a></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148576.png"/>

<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul>
<li><code>因特网采用层次树状结构的命名方法</code>。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即<code>域名(Domain Name)</code>。</li>
<li><code>域(Domain)</code>是名字空间中一个可被管理的划分。</li>
<li>域还可以划分为子域，而子域还可以继续划分为子域的子域，这样就形成<br>了顶级域、二级域、三级域等。</li>
</ul>
<p><strong>在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理。</strong></p>
<ul>
<li>例如，管理CN域的中国将EDU.CN子域授权给中国教育和科研计算机网(CERNET)来管理。</li>
<li>比如我的域名bithachi.cn是一个二级域名，我可以任意分配三级域名，比如1001.bithachi.cn和1002.bithachi.cn，这两个网址是可以访问的，小项目。</li>
</ul>
<p><strong>域名空间的树状结构：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148271.png"/>

<p>每个域名都由<code>标号</code>序列组.成，而各标号之间用点<code>(“.”)</code>隔开。</p>
<p>$$<br><a target="_blank" rel="noopener" href="http://www.bithachi.cn/">www.BitHachi.cn</a>. &#x3D;&gt;(三级域名).(二级域名).(顶级域名).<br>$$<br>最后的一个点叫<strong>根</strong></p>
<p><strong>关于域名中的标号有以下几点需要注意:</strong></p>
<ul>
<li>1)标号中的英文<code>不区分大小写</code>。.</li>
<li>2)标号中除连字符(-) 外不能使用其他的标点符号。</li>
<li>3)每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符。</li>
<li>4)级别最低的域名写在最左边，级别最高的顶级域名写在最右边。</li>
</ul>
<p><code>顶级域名(Top Level Domain, TLD)</code>分为如下三大类:</p>
<ul>
<li>1)国家顶级域名(nTLD)。国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，.uk”表示英国。</li>
<li>2)通用顶级域名(gTLD)。 常见的有“.com” (公司)、“.net” (网络服务机构)、“.org”(非营利性组织)和“.gov” (国家或政府部门)等。</li>
<li>3)基础结构域名。<code>这种顶级域名只有一个，即arpa,用于反向域名解析</code>，因此又称反向域名。<code>反向域名解析与通常的正向域名解析相反，提供IP地址到域名的对应</code>，反向域名格式如：X.X.X.in-addr.arpa。很多网络服务提供商要求访问的IP地址具有反向域名解析的结果，否则不提供服务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">国家顶级域名下注册的二级域名均由该国家自行确定。</span><br></pre></td></tr></table></figure>

<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><ul>
<li><code>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型</code>。</li>
<li>域名到IP地址的解析是由运行在域名服务器上的程序完成的，<code>一个服务器所负责管辖的(或有权限的)范围称为区(不以“域”为单位)</code>，各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，每个区设置相应的<code>权限域名服务器</code>，用来保存该区中的所有主机的域名到IP地址的映射。</li>
<li>每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器。</li>
<li>DNS使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上。</li>
<li>采用分布式设计的DNS，是一个在因特网上实现分布式数据库的精彩范例。主要有4种类型的域名服务器。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012150621.png"/>

<h4 id="（1）根域名服务器"><a href="#（1）根域名服务器" class="headerlink" title="（1）根域名服务器"></a>（1）根域名服务器</h4><ul>
<li><code>根域名服务器</code>是<code>最高层次</code>的域名服务器，所有的<code>根域名服务器</code>都知道<code>所有</code>的<code>顶级域名服务器的IP地址</code>。</li>
<li>根域名服务器也是最重要的域名服务器，不管是哪个<code>本地域名服务器</code>，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先要求助于<code>根域名服务器</code>。</li>
<li>因特网上有<code>13个根域名服务器</code>，尽管我们将这13个根域名服务器中的每个都视为单个服务器，但<code>每个“服务器”实际上是冗余服务器的集群</code>，以提供安全性和可靠性。</li>
<li>需要注意的是，<code>根域名服务器</code>用来<code>管辖顶级域(如.com)</code>， 通常它并不直接把待查询的域名直接转换成IP地址，而是<code>告诉本地域名服务器</code>下一步应当找哪个<code>顶级域名服务器</code>进行查询。</li>
</ul>
<h4 id="（2）顶级域名服务器"><a href="#（2）顶级域名服务器" class="headerlink" title="（2）顶级域名服务器"></a>（2）顶级域名服务器</h4><ul>
<li>这些域名服务器负责<code>管理在该顶级域名服务器注册的所有二级域名</code>。</li>
<li>收到DNS查询请求时,就给出相应的回答(可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址)。</li>
</ul>
<h4 id="（3）授权域名服务器-权限域名服务器"><a href="#（3）授权域名服务器-权限域名服务器" class="headerlink" title="（3）授权域名服务器(权限域名服务器)"></a>（3）授权域名服务器(权限域名服务器)</h4><ul>
<li><code>每台主机</code>都必须在<code>授权域名服务器</code>处登记。为了更加可靠地工作，一台主机最好至少有两个授权域名服务器。</li>
<li>实际上，许多<code>域名服务器</code>都<code>同时</code>充当<code>本地域名服务器</code>和<code>授权域名服务器</code>。</li>
<li><code>授权域名服务器</code>总能将其管辖的<code>主机名</code>转换为该主机的<code>IP地址</code>。</li>
</ul>
<h4 id="（4）本地域名服务器"><a href="#（4）本地域名服务器" class="headerlink" title="（4）本地域名服务器"></a>（4）本地域名服务器</h4><ul>
<li>本地域名服务器对域名系统非常重要。</li>
<li>每个因特网服务提供者(ISP)， 或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。</li>
<li><code>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</code>。</li>
<li>事实上，我们在Windows系统中配置<code>“本地连接”</code>时，就需要填写DNS地址，这个地址就是<code>本地DNS (域名服务器)的地址</code>。</li>
</ul>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><ul>
<li><code>域名解析是指把域名映射成为IP地址或把IP地址映射成域名的过程。前者称为正向解析，后者称为反向解析。</code></li>
<li>当客户端需要域名解析时，通过本机的DNS客户端构造一个<code>DNS请求报文</code>，以<code>UDP数据报</code>方式发往<code>本地域名服务器</code>。</li>
<li>域名解析有两种方式:<code>递归查询</code>和<code>递归与迭代</code>相结合的查询。</li>
</ul>
<h4 id="递归查询方式"><a href="#递归查询方式" class="headerlink" title="递归查询方式"></a>递归查询方式</h4><ul>
<li><strong>递归查询的过程如下图所示</strong>， 由于该方法给根域名服务造成的负载过大，所以在实际中几乎不使用。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152913.png"/>

<p><strong>常用递归与迭代相结合的查询方式如下图所示，该方式分为两个部分。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152357.png"/>

<p><strong>(1)<code>主机</code>向<code>本地域名服务器</code>的查询采用的是<code>递归</code>查询</strong></p>
<ul>
<li>也就是说，如果<code>本地主机</code>所询问的<code>本地域名服务器</code>不知道被查询域名的IP 地址，那么<code>本地域名服务器</code>就以<code>DNS客户</code>的身份，向<code>根域名服务器</code>继续发出<code>查询请求报文</code>(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。</li>
<li>在这种情况下，<code>本地域名服务器</code>只需向<code>根域名服务器查询</code>一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的[见图6.6(a)中的步骤③~⑥]。</li>
<li>在步骤⑦中，<code>本地域名服务器</code>从<code>根域名服务器</code>得到了所需的<code>IP地址</code>,最后在步骤⑧中，<code>本地域名服务器</code>把查询结果告诉<code>主机</code>m.xyz.com.</li>
</ul>
<p><strong>(2)<code>本地域名服务器</code>向<code>根域名服务器</code>的查询采用<code>迭代</code>查询</strong></p>
<ul>
<li>当<code>根域名服务器</code>收到<code>本地域名服务器</code>发出的<code>迭代查询请求报文</code>时，要么给出所要查询的IP地址，要么告诉<code>本地域名服务器</code>:“你下一步应当向哪个<code>顶级域名服务器</code>进行查询”。</li>
<li>然后让<code>本地域名服务器</code>向这个<code>顶级域名服务器</code>进行后续的查询，如图6.6(b)所示。</li>
<li>同样，<code>顶级域名服务器</code>收到查询报文后，要么给出所要查询的IP地址，要么告诉<code>本地域名服务器</code>下一步应向哪个·权限域名服务器·查询。</li>
<li>最后，知道所要<code>解析的域名的IP地址</code>后，把这个<code>结果返回</code>给发起查询的<code>主机</code>。</li>
</ul>
<p><strong><code>下面举例说明域名解析的过程:</code></strong><br><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012153295.png"/>

<blockquote>
<ul>
<li>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<code>高速缓存</code>。</li>
<li>当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速<br>缓存中。这样，当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问。</li>
<li>因为<code>主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息</code>。</li>
</ul>
</blockquote>
<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><ul>
<li>文件传输协议( File Transfer Protocol, FTP)是因特网上使用得最广泛的<code>文件传输协议。</code></li>
<li>FTP提供<code>交互式的访问</code>，允许客户指明文件的类型与格式，并允许文件具有<code>存取权限</code>。</li>
<li>它屏蔽了各计算机系统的细节，因而适合于在异构网络中的<code>任意计算机之间传送文件</code>。</li>
</ul>
<p><strong>FTP提供以下功能:</strong><br>①提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力。<br>②<code>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</code>。<br>③以<code>匿名FTP</code>的方式提供<code>公用文件共享</code>的能力。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154629.png"/>

<h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><ul>
<li>FTP采用客户&#x2F;服务器（C&#x2F;S）的工作方式，它使用TCP可靠的传输服务。</li>
<li>一个FTP服务器进程可同时为多个客户进程提供服务。</li>
<li>依照FTP协议提供服务，进行文件传送的计算机就是<code>FTP服务器</code>。</li>
<li>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是<code>FTP客户端</code>。</li>
<li><code>FTP的服务器进程</code>由两大部分组成:<br><code>一个主进程，负责接收新的请求;</code><br><code>若干从属进程，负责处理单个请求。</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154870.png"/>

<hr>

<p><strong>其工作步骤如下:</strong><br>①打开熟知端口21 (控制端口)，使客户进程能够连接上。<br>②等待客户进程发连接请求。<br>③启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。<br>④回到等待状态，继续接收其他客户进程的请求。</p>
<hr>

<ul>
<li>FTP服务器必须在整个会话期间保留用户的状态信息。<br>特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。</li>
</ul>
<h3 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h3><ul>
<li>FTP在工作时使用两个<code>并行的TCP连接</code>:<br>一个是<code>控制连接(端口号21)</code>，<br>一个是<code>数据连接(端口号20)</code>。</li>
<li>使用两个不同的端口号可使协议更加简单和更容易实现。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155883.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155920.png"/>

<p><strong>1.控制连接</strong></p>
<ul>
<li>服务器监听21号端口，等待客户连接，建立在这个端口.上的连接称为控制连接，<code>控制连接用来传输控制信息(如连接请求、传送请求等)</code>，并且<code>控制信息都以7位ASCII格式传送</code>。</li>
<li>FTP客户发出的<code>传送请求</code>，<code>通过控制连接发送给服务器端的控制进程,但控制连接并不用来传送文件。</code></li>
<li>在传输文件时还可以使用控制连接(如客户在传输中途发一个中止传输的命令)，因此控制连接在整个会话期间一直保持打开状态。</li>
</ul>
<p><strong>2.数据连接</strong></p>
<ul>
<li><code>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。</code></li>
<li><code>数据连接</code>用来<code>连接客户端和服务器端的数据传送进程</code>，<code>数据传送进程</code>实际<code>完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</code></li>
</ul>
<hr>
<ul>
<li>因为FTP使用了一个分离的控制连接，所以<code>也称FTP的控制信息是带外(Out-of-band) 传送的。</code></li>
<li>使用FTP时，<code>若要修改服务器上的文件，则需要先将此文件传送到本地主机,然后再将修改后的文件副本传送到原服务器</code>。</li>
<li>网络文件系统(NFS)允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</li>
</ul>
<h2 id="SMTP-POP3-IMAP-MIME…"><a href="#SMTP-POP3-IMAP-MIME…" class="headerlink" title="SMTP,POP3,IMAP,MIME…."></a>SMTP,POP3,IMAP,MIME….</h2><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><ul>
<li>一个电子邮件分为<code>信封和内容</code>两大部分，邮件<code>内容</code>又<code>分为首部和主体</code>两部分。</li>
<li>RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。</li>
<li>用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。</li>
<li><code>邮件内容的首部包含一些首部行</code>，<code>每个首部行由一个关键字后跟冒号再后跟值组成。</code>有些关键字是必需的，有些则是可选的。最重要的关键字是To:和Subject。</li>
<li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。<br>电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名<br>如<a href="mailto:&#x61;&#98;&#x63;&#64;&#x63;&#x73;&#x6b;&#97;&#111;&#121;&#x61;&#110;&#46;&#99;&#x6f;&#x6d;">&#x61;&#98;&#x63;&#64;&#x63;&#x73;&#x6b;&#97;&#111;&#121;&#x61;&#110;&#46;&#99;&#x6f;&#x6d;</a>,其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的 。这也就保证了<a href="mailto:&#x61;&#98;&#x63;&#64;&#x63;&#115;&#107;&#97;&#x6f;&#121;&#x61;&#x6e;&#x2e;&#x63;&#x6f;&#x6d;">&#x61;&#98;&#x63;&#64;&#x63;&#115;&#107;&#97;&#x6f;&#121;&#x61;&#x6e;&#x2e;&#x63;&#x6f;&#x6d;</a> 这个邮件<br>地址在整个因特网上是唯一的。</li>
<li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。</li>
<li>还有一个必填的关键字是From,但它通常由邮件系统自动填入。</li>
<li>首部与主体之间用一个空行进行分割。典型的邮件内容如下:</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157298.png"/>

<h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><ul>
<li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157757.png"/>

<hr>

<ul>
<li>一个 电子邮件系统应具有三个最主要的组成构件：<br>用户代理(User Agent)<br>邮件服务器<br>电子邮件使用的协议，如SMTP、POP3 (或IMAP)等。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157575.png"/>

<p><code>用户代理(UA):</code>用户与电子邮件系统的接口。</p>
<ul>
<li>用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的功能。</li>
<li>通常情况下，用户代理就是一个运行在PC.上的程序，常见的有Outlook、Foxmail 和Thunderbird等。</li>
</ul>
<p><code>邮件服务器:</code>组成电子邮件系统的核心。</p>
<ul>
<li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况(已交付、被拒绝、丢失等)。</li>
<li>邮件服务器采用客户&#x2F;服务器方式工作，但它能够同时充当客户和服务器。</li>
<li>例如，当邮件服务器A向邮件服务器B发送邮件时，A就作为SMTP客户，而B是SMTP服务器;反之，当B向A发送邮件时，B就是SMTP客户，而A就是SMTP服务器。</li>
</ul>
<p><strong>邮件发送协议和读取协议</strong>:</p>
<ul>
<li><code>邮件发送协议</code>用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用的是<code>SMTP</code>;</li>
<li><code>邮件读取协议</code>用于用户代理从邮件服务器读取邮件，如<code>POP3</code>。</li>
<li>SMTP采用的是“推”(Push)的通信方式，即在用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP客户端主动将邮件“推”送到SMTP服务器端。</li>
<li>POP3采用的是“拉”(Pull)的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
</ul>
<h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158446.png"/>

<ul>
<li>发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定 时间对邮件缓存扫描一次。<br>如发现有邮件，就使用SMTP的熟知端口号(25) 与接收方邮件服务器的SMTP服务器建立TCP连接。</li>
<li>连接建立后，接收方SMTP服务器发出220 Service ready (服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li>
<li>SMTP不使用中间邮件服务器。<br>TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远。<br>接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158231.png"/>

<p><strong>邮件发送</strong></p>
<ul>
<li>连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL 命令后面有发件人的地址。如MAIL FROM: <a href="mailto:hoopdog@hust.edu.cn">hoopdog@hust.edu.cn</a>。</li>
<li>若SMTP服务器已准备好接收邮件，则回答250 OK。</li>
<li>接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令，格式为RCPTTO: &lt;收件人地址&gt;。<br>每发送一个 RCPT命令，都应有相应的信息从SMTP服务器返回，如250 OK或550 No such user here (无此用户)。<br>RCPT命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。</li>
<li>获得0K的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。<br>正常情况下，SMTP服务器回复信息是354 Start mail input; end with . 。表示回车换行。此时SMTP客户端就可开始传送邮件内容，并用. (两个回车，中间一个点)表示邮件内容的结束。</li>
</ul>
<p><strong>释放连接</strong></p>
<ul>
<li>邮件发送完毕后，SMTP客户应发送QUIT命令。</li>
<li>SMTP服务器返回的信息是221 (服务关闭)，表示SMTP同意释放TCP连接。邮件传送的全部过程就此结束。</li>
</ul>
<h4 id="MIME—多用途网络邮件扩充"><a href="#MIME—多用途网络邮件扩充" class="headerlink" title="MIME—多用途网络邮件扩充"></a>MIME—多用途网络邮件扩充</h4><ul>
<li>由于SMTP只能传送一定长度的ASCII码，许多其他非英语国家的文字(如中文、俄文，甚至带重音符号的法文或德文)就无法传送，且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充( Multipurpose Internet MailExtensions，MIME)。</li>
<li>MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。也就是说，MIME邮件可在现有的电子邮件程序和协议下传送。MIME与SMTP的关系如图</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012159989.png"/>

<p><strong>MIME主要包括以下三部分内容:</strong></p>
<ul>
<li>①5个新的邮件首部字段，包括MIME版本、内容 描述、内容标识、内容传送编码和内容类型。</li>
<li>②定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>③定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ul>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200877.png"/>

<ul>
<li>邮局协议( Post Office Protocol, POP) 是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3。</li>
<li>POP3 采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
<li>POP也使用客户&#x2F;服务器的工作方式，在传输层使用TCP,端口号为110。接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序。</li>
<li>POP有两种工作方式:<code>“下载并保留”和“下载并删除”。</code><br>在<code>“下载并保留”</code>方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件;<br>使用<code>“下载并删除”</code>方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。</li>
</ul>
<h4 id="IMAP-因特网报文存取协议"><a href="#IMAP-因特网报文存取协议" class="headerlink" title="IMAP-因特网报文存取协议"></a>IMAP-因特网报文存取协议</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200164.png"/>

<ul>
<li>另一个邮件接收协议是<code>因特网报文存取协议(IMAP)</code>,它比POP复杂得多，IMAP为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此<code>IMAP服务器维护了会话用户的状态信息</code>。</li>
<li>IMAP的另一特性是<code>允许用户代理只获取报文的某些部分</code>，例如可以只读取一个报文的首部,或一个多部分MIME报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。</li>
</ul>
<h3 id="万维网的电子邮件"><a href="#万维网的电子邮件" class="headerlink" title="万维网的电子邮件"></a>万维网的电子邮件</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012201443.png"/>

<ul>
<li>随着万维网的流行，目前出现了很多基于万维网的电子邮件，如Hotmail、Gmail 等。</li>
<li>这种电子邮件的特点是，用户浏览器与Hotmail或Gmail的邮件服务器之间的邮件发送或接收使用的是HTTP，而<code>仅在不同邮件服务器之间传送邮件时才使用SMTP.</code></li>
</ul>
<h2 id="万维网（www）和HTTP协议"><a href="#万维网（www）和HTTP协议" class="headerlink" title="*万维网（www）和HTTP协议"></a>*万维网（www）和HTTP协议</h2><h3 id="万维网WWW协议"><a href="#万维网WWW协议" class="headerlink" title="万维网WWW协议"></a>万维网WWW协议</h3><p>URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置</p>
<p>HTTP用来将这些资源传送给用户</p>
<p>HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012202965.png"/>

<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>服务器通过TCP 80端口来监听HTTP请求</p>
<p><strong>注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分</strong>，其他音频视频等待用户下一步请求之后再传输</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203168.png"/>

<h4 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203522.png"/>

<h4 id="HTTP的连接方式-持久连接和非持久连接"><a href="#HTTP的连接方式-持久连接和非持久连接" class="headerlink" title="HTTP的连接方式-持久连接和非持久连接"></a>HTTP的连接方式-持久连接和非持久连接</h4><p>非持久连接在TCP三次握手的<strong>第三次握手时发生</strong>，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。<br>缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始</p>
<p>持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012204214.png"/>

<h4 id="持久连接的两种方式——非流水线和流水线"><a href="#持久连接的两种方式——非流水线和流水线" class="headerlink" title="持久连接的两种方式——非流水线和流水线"></a>持久连接的两种方式——非流水线和流水线</h4><p>非流水线就是发一个，确认一个，才能再发下一个<br>流水线就是一个个连着发，然后多个确认<br>和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下</p>
<h4 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h4><p>开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样</p>
<p>请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取&#x2F;删除等等<br>URL就是之间说的资源标识符<br>版本是指使用的是什么版本的HTTP协议</p>
<p>CRLF相当于我们程序里面的<code>；</code>，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205051.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205842.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据库原理知识点总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-20 16:28:28 / 修改时间：18:15:53" itemprop="dateCreated datePublished" datetime="2022-12-20T16:28:28+08:00">2022-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">数据库原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><p><strong>数据库技术</strong>是信息系统的核心和基础</p>
<h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><p>数据库的4个基本概念：</p>
<ol>
<li><p>数据（data）:数据库中存储的基本对象</p>
</li>
<li><p>数据库（DataBase、DB）:<strong>长期存储在计算机内、有组织的、可共享的大量数据的集合</strong></p>
</li>
<li><p>数据库管理系统（DataBase Management System、DBMS）:科学地<strong>组织</strong>和<strong>存储</strong>数据、高效地<strong>获取</strong>和<strong>维护</strong>数据。</p>
<ol>
<li><p>数据定义功能（DDL）</p>
</li>
<li><p>数据组织、存储和管理 </p>
</li>
<li><p>数据操纵功能（DML）</p>
</li>
<li><p>数据库的事物管理和运行管理 </p>
</li>
<li><p>数据库的建立和维护功能</p>
</li>
</ol>
</li>
<li><p>数据库系统（DataBase System 、DBS）:</p>
<ul>
<li><p>数据库</p>
</li>
<li><p>数据库管理系统</p>
</li>
<li><p>应用程序</p>
</li>
<li><p>数据库管理员</p>
</li>
</ul>
</li>
</ol>
<h3 id="数据库技术的产生和发展"><a href="#数据库技术的产生和发展" class="headerlink" title="数据库技术的产生和发展"></a>数据库技术的产生和发展</h3><p>数据管理：对数据进行<strong>分类、组织、编码、存储、检索和维护</strong></p>
<p>数据管理技术的发展过程：</p>
<ul>
<li><strong>人工管理阶段</strong>（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%89%B9%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">批处理</a>，20世纪50年代中之前）</li>
<li><strong>文件系统阶段</strong>（联机实时处理、批处理，20世纪50年代末—60年代中）</li>
<li><strong>数据库系统阶段</strong>（联机实时处理、分布处理、批处理，20世纪60年代末—现在）</li>
</ul>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ol>
<li>数据结构化</li>
<li>数据的共享性高、冗余度低且易扩充</li>
<li>数据独立性高 </li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
<p>数据的最小存取单位是<strong>数据项</strong>，用<strong>数据模型</strong>来描述</p>
<h4 id="数据库的三级模式与两层映像"><a href="#数据库的三级模式与两层映像" class="headerlink" title="数据库的三级模式与两层映像"></a><strong>数据库的三级模式与两层映像</strong></h4><p><strong>内模式</strong>：对应于物理层数据抽象，它是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<p><strong>模式</strong>：对应于逻辑层数据抽象，它是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
<p><strong>外模式</strong>：对应于视图层数据抽象，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</p>
<p>为了能够在系统内部实现3个抽象层次的数据之间的联系和转换，数据库管理系统提出了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。正是这两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>映像</th>
</tr>
</thead>
<tbody><tr>
<td><strong>逻辑独立性</strong></td>
<td>是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变</td>
<td>外模式&#x2F;模式映像</td>
</tr>
<tr>
<td><strong>物理独立性</strong></td>
<td>是指用户的应用程序与数据库的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用改变</td>
<td>模式&#x2F;内模式映像</td>
</tr>
</tbody></table>
<p><strong>数据管理系统提供的数据控制功能</strong>：</p>
<ol>
<li>数据的安全性保护</li>
<li>数据的完整性保护</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ol>
<p>数据的安全性保护：保护数据以防止不合法的使用造成数据的泄密和破坏</p>
<p>数据的完整性保护：保护数据的正确性、有效性和相容性</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>常用的数据模型：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型</p>
<h3 id="数据模型分类"><a href="#数据模型分类" class="headerlink" title="数据模型分类"></a>数据模型分类</h3><p>概念模型：也称信息模型，用于数据库设计，E-R模型、OO模型</p>
<p>逻辑模型：层次模型、网状模型、<strong>关系模型</strong>、面向对象数据模型、对象关系数据数据模型、半结构化数据模型。DBMS实现</p>
<p>物理模型：用来描述数据的物理存储结构和存储方式、在磁盘或磁带上的存储方式和存取方法</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>表示方法：<strong>实体—联系方法</strong> <strong>：E-R图</strong> E-R方法也称为E-R模型</p>
<p>实体：客观存在并可相互区别的事物称为实体</p>
<p>属性：实体所具有的某一特性称为属性</p>
<p><span style="color:red"><strong>码：唯一标识实体的属性集称为 码</strong></span></p>
<p><strong>实体之间的联系</strong>：<strong>一对一、一对多、多对多</strong></p>
<p>用<strong>E-R图</strong>来描述现实世界的概念模型</p>
<h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><ol>
<li><p>数据结构：描述数据库的组成对象，以及对象之间的联系，<strong>对系统静态特性的描述</strong></p>
</li>
<li><p>数据操作：对数据库中各种对象的实例允许执行的<strong>操作的集合</strong>，包括<strong>操作</strong>及有关的<strong>操作规则</strong>，<strong>对系统动态特性的描述</strong></p>
<p>数据操作的类型：<strong>查询</strong>，<strong>更新</strong>（插入、删除、修改）</p>
</li>
<li><p>数据的完整性约束条件</p>
</li>
</ol>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><p>层次模型用<strong>树形结构</strong>来表示各类实体以及实体间的联系， 典型代表：IMS</p>
<p>特点：只能直接处理一对多的实体联系</p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）数据结构比较简单清晰 <br>（2）查询效率高，性能优于关系模型 ，不低于网状模型（3）提供良好的完整性支持</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）多对多联系表示不自然 <br>（2）插入和删除限制多 <br>（3）查询子女结点必须通过双亲节点 <br>（4）层次命令趋于程序化</td>
</tr>
</tbody></table>
<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>网状数据库系统采用<strong>网状模型</strong>作为数据库的组织方式，典型代表：DBTG（亦称CODASYL系统）</p>
<p>层次模型是网状模型的一个特例，用网状模型<strong>间接</strong>表示多对多联系（将多对多联系直接分解成一对多联系）</p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）更为直观地描述现实世界，如一个结点可以有多个双亲 <br>（2）具有良好的性能，存取效率较高</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）结构复杂 <br>（2）DDL、DML语言复杂 <br>（3）记录之间联系是通过存取路径实现，用户必须了解系统结构的细节</td>
</tr>
</tbody></table>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="*关系模型"></a>*关系模型</h3><p>关系数据库系统采用<strong>关系模型</strong>作为数据的组织方式</p>
<p>用户观点下，关系模型中数据的逻辑结构是一张<strong>二维表</strong>，它由行和列组成</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>关系</td>
<td>一个关系对应通常说的一张表</td>
</tr>
<tr>
<td>元组</td>
<td>表中的一行即为一个元组</td>
</tr>
<tr>
<td>属性</td>
<td>表中的一列即为一个属性</td>
</tr>
<tr>
<td><strong>码</strong></td>
<td><strong>唯一标识实体的属性集称为码</strong></td>
</tr>
<tr>
<td><strong>主码</strong></td>
<td><strong>也称码键，表中的某个属性组，它可以唯一确定一个元组</strong></td>
</tr>
<tr>
<td>域</td>
<td>是一组具有相同数据类型的值的集合，属性的取值范围来自某个域</td>
</tr>
<tr>
<td>分量</td>
<td>元组中的一个属性值</td>
</tr>
</tbody></table>
<p>数据操作是集合操作，操作对象和操作结果都是<strong>关系</strong></p>
<h4 id="关系模式：对关系的描述"><a href="#关系模式：对关系的描述" class="headerlink" title="关系模式：对关系的描述"></a><strong>关系模式：对关系的描述</strong></h4><p>关系必须是规范化的：关系的每一个分量必须是一个不可分的数据项，<strong>不允许表中还有表</strong></p>
<p>关系的完整性约束：</p>
<ol>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义完整性</strong></li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li><p>建立在严格的数学概念的基础上</p>
</li>
<li><p>概念单一（实体和各类联系都用关系表示，对数据的检索结果也是关系）</p>
</li>
<li><p>关系模型的存取路径对用户透明（更高的数据独立性，更好的安全保密性，简化程序员的工作和数据库开发建立的工作）</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>存取路径对用户透明，查询效率往往不如格式化数据模型 </li>
<li>为提高性能，需对用户的查询请求进行优化，增加开发数据库管理系统的难度</li>
</ol>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><p>数据库系统通常采用<strong>三级模式</strong>结构，数据库系统内部的系统结构</p>
<p>最终用户角度：（1）单用户结构 （2）主从式结构 （3）分布式结构 （4）客户—服务器结构 （5）浏览器—应用服务器 &#x2F; 数据库服务器多层结构</p>
<h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><p>型：对某一类数据的结构和属性的说明</p>
<p>值：是型的一个具体赋值</p>
<p><strong>模式：数据库逻辑结构和特征的描述</strong></p>
<p>实例：模式的一个具体值</p>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>外模式（子模式）</strong></td>
<td>数据库用户使用的<strong>局部</strong>数据的逻辑结构和特征的描述，数据库用户的数据视图<br><strong>一个数据库可以有多个外模式</strong><br /><strong>模式与外模式：</strong>一对多，外模式通常是模式的子集<br /><strong>外模式与应用：</strong>一对多，一个应用程序中只能使用一个外模式<br />用途：（1）保护数据库安全性 （2）每个用户只能看见和访问所对应的外模式中的数据</td>
</tr>
<tr>
<td><strong>模式</strong></td>
<td>数据库中全体数据的<strong>逻辑结构和特征</strong>的描述，所有用户的公共数据视图<br><strong>一个数据库只有一个模式</strong></td>
</tr>
<tr>
<td><strong>内模式（存储模式）</strong></td>
<td>数据物理结构和存储方式的描述，数据在数据库内部的表示方式<br /><strong>一个数据库只有一个内模式</strong></td>
</tr>
</tbody></table>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>为了能够在系统内部实现3个抽象层次的数据之间的联系和转换，数据库管理系统提出了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。正是这两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>映像</th>
</tr>
</thead>
<tbody><tr>
<td><strong>逻辑独立性</strong></td>
<td>每一个外模式，数据库系统都有一个外模式 &#x2F; 模式映像，定义外模式与模式之间的对应关系<br>是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变</td>
<td>外模式&#x2F;模式映像</td>
</tr>
<tr>
<td><strong>物理独立性</strong></td>
<td>定义数据全局逻辑结构与存储结构之间的对应关系<br />数据库中模式 &#x2F; 内模式映像是<strong>唯一的</strong><br />是指用户的应用程序与数据库的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用改变</td>
<td>模式&#x2F;内模式映像</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>（1）数据库 （2）数据库管理系统 （3）应用程序 （4）数据库管理员 （5）硬件平台及数据库 （6）软件 （7）人员</p>
<h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>单一的数据结构：关系，逻辑结构：二维表</p>
<p>域：一组具有相同数据类型的值的集合</p>
<p>笛卡尔积：可表示为一张二维表，表中的每列对应一个域</p>
<p><strong>关系：笛卡尔积的有限子集</strong></p>
<p><strong>码：唯一标识实体的属性集称为码</strong></p>
<p><strong>主码：表中的某个属性组，它可以唯一确定一个元组</strong></p>
<hr>

<p>一个关系的候选码可以有多个，但主码只能有一个</p>
<p>（1）候选码：<strong>若关系中的某一属性组的值能唯一地标识一个元组</strong>，则称该属性组为候选码。简单的情况：候选码只包含一个属性</p>
<p>（2）全码：关系模式的所有属性组是这个关系模式的候选码，称为全码</p>
<p>（3）主码：若一个关系有多个候选码，则选定其中一个为主码</p>
<p>（4）主属性：候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性</p>
<p>（5）三类关系：</p>
<hr>

<p>1.基本关系（基本表或基表）：实际存在的表，实际存储数据的逻辑表示</p>
<p>2.查询表：查询结果对应的表</p>
<p>3.视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模式是型，关系是值，关系模式是对关系的描述：1.元组集合的结构 2.完整性约束条件</p>
<p>关系模式可以形式化地表示为：R (U,D,DOM,F)</p>
<p>R：关系名，U：组成该关系的属性名集合，D：U中属性所来自的域 DOM：属性向域的映像集合 F：属性间数据的依赖关系的集合</p>
<p>关系模式是对关系的描述，静态的稳定的</p>
<p>关系是关系模式在某一时刻的状态或内容，动态的、随时间不断变化的</p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p>
<h3 id="关系模型和存储结构"><a href="#关系模型和存储结构" class="headerlink" title="关系模型和存储结构"></a>关系模型和存储结构</h3><p>关系数据库的物理组织：交给操作系统 or 申请若干个大文件</p>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><p><strong>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积</strong></p>
<p><span style="color:red">5种基本操作：<strong>选择、投影、并、差、笛卡尔积</strong></span></p>
<p>更新操作：插入、删除、修改</p>
<p>关系操作特点：操作的对象和结果都是集合，<strong>一次一集合</strong>的方式</p>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询，运算对象和运算结果都是<strong>关系</strong></p>
<p><strong>关系代数中的连接操作是由选择和笛卡尔积操作组合而成</strong></p>
<h2 id="关系模型中的三类完整性约束"><a href="#关系模型中的三类完整性约束" class="headerlink" title="*关系模型中的三类完整性约束"></a>*关系模型中的三类完整性约束</h2><p>关系代数语言：用<strong>对关系的运算</strong>来表达查询要求 ISBL</p>
<p>关系演算语言：用<strong>谓词</strong>来表达查询要求（元组关系演算语言和域关系演算语言） APLHA QUEL</p>
<p>具有关系代数和关系演算双重特点的语言：SQL（Structured Query Language）结构化查询语言</p>
<p>关系模型必须满足的完整性约束条件称为关系的两个<strong>不变性</strong>，应该由关系系统自动支持</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性规则：若属性A是基本关系R的主属性，则属性A不能取空值</p>
<p>例如：选修（学号，课程号，成绩）</p>
<p>“学号，课程号”为主码，这两个属性都不能取空值</p>
<p>关系模型中以主码作为唯一标识符，<strong>主码中的属性即主属性不能取空值</strong></p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>定义：指如果属性（或属性组）F是关系R的外码，且对应了关系S的主码K（R和S可以是同一个关系），那么对于R中的每个元组中的F上的值，必须满足：<br>（1） 要么F取空值<br>（2） 要么等于S中某个元组的主码的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">	学生（学号，姓名）</span><br><span class="line">	课程（课程号，课程名）</span><br><span class="line">	选修（学号，课程号，成绩）</span><br></pre></td></tr></table></figure>

<p>选修表中的学号就称为选修表的一个外码，它对应的是学生表中的学号。</p>
<p>并且称选修关系为<code>参照关系</code>，而学生关系为<code>被参照关系</code>。</p>
<p>显然，在选修关系中的学号，必须是学生表里真正存在的学号，且选修表里的课程号，也必须是课程表里真正存在的课程号。这就是参照完整性的一个典型表现了。</p>
<p>参照完整性规则的说明：</p>
<ul>
<li>关系R和S不一定是不同的关系</li>
<li>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li>
<li>外码并不一定要与相应的主码同名</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所设计的数据必须满足的语义要求</p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="*关系代数"></a>*关系代数</h2><p>更具体的请看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dreaming_coder/article/details/108043502">https://blog.csdn.net/dreaming_coder/article/details/108043502</a></p>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询，运算对象和运算结果都是<strong>关系</strong></p>
<p>关系代数的运算符</p>
<p>（1）集合运算符（从行的角度进行）：并 差 交 笛卡尔积</p>
<p>（2）专门的关系运算符（涉及行和列）： 选择 投影 连接 除</p>
<p>选择 σ：从行的角度进行的运算</p>
<p>投影 π：从列的角度进行运算，不仅消除某些列，而且还可能取消某些元组（避免重复行）</p>
<p>连接：1.等值连接 2.自然连接</p>
<p><strong>一般的连接操作都是从行的角度进行运算。自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</strong></p>
<p>自然连接是一种特殊的等值连接：1.两个关系中进行比较的分量必须是相同的属性组 2.在结果中把重复的属性列去掉</p>
<p>外连接：把悬浮元组也保存在结果关系中，而在其他属性上填空值，就叫外连接</p>
<p>除运算：同时从行和列角度进行运算</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,rating from s where s.id = c.studentid and rating&gt;60;</span><br></pre></td></tr></table></figure>


<p>$$<br>π_{sname , rating} (σ_{rating&gt;60}(s⋈c ))<br>$$</p>
<h1 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h1><p>SQL：结构化查询语言，关系数据库的标准语言</p>
<p>SQL可分为<strong>数据定义、数据查询、数据更新、数据控制</strong>四大部分</p>
<p>SQL特点：（1）综合统一 （2）高度非过程化 （3）面向<strong>集合</strong>的操作方式 （4）独立的语言 嵌入式语言 （5）语言简洁，易学易用</p>
<p>数据查询：SELECT</p>
<p>数据定义：CREATE、DROP、ALTER</p>
<p>数据操纵：INSERT、UPDATE、DELETE</p>
<p>数据控制：GRANT、REVOKE</p>
<p>基本表、存储文件、视图</p>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>模式（CREATE SCHEMA，DROP SCHEMA）</p>
<p>表（CREATE TABLE，DROP TABLE，ALTER TABLE）</p>
<p>视图（CREATE VIEW， DROP VIEW）</p>
<p>索引（CREATE INDEX， DROP INDEX，ALTER INDEX）</p>
<h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>定义模式实际上定义了一个命名空间</p>
<p>定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
<p>删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</p>
<h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><p>定义基本表：CREATE TABLE</p>
<p>SQL中域的概念用<strong>数据类型</strong>来实现</p>
<p>每一个基本表都属于一个模式，一个模式包含多个基本表</p>
<p>设置搜索路径：SET search_path TO “S-T”,PUBLIC;</p>
<p>修改：ALTER TABLE （ADD、 DROP COLUMN、DROP CONSTRAINT、 ALTER COLUMN）</p>
<p>删除：DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]</p>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><p>建立索引的目的：加快查询速度</p>
<p>B+树索引具有动态平衡的优点，HASH索引具有查找速度快的特点</p>
<p>用户建立索引，系统维护、使用索引</p>
<p>建立：CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;</p>
<p>修改：ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
<p>删除：DROP INDEX &lt;索引名&gt;</p>
<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>记录数据库中所有定义信息：关系模式、视图、索引、完整性约束、各类用户对数据库的操作权限、统计信息</p>
<p>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新<strong>数据字典</strong>中的相应信息</p>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>SELECT FROM WHERE GROUP BY HAVING ORDER BY</p>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>（1）选择表中的若干列</p>
<p>查询经过计算的值：使用列<strong>别名</strong>改变查询结果的列标题</p>
<p>（2）选择表中的若干元组</p>
<p>DISTINCT 去掉重复的行</p>
<p>比较大小 确定范围 确定集合 字符匹配 涉及空值的查询 多重条件查询</p>
<p>%：任意长度的字符串</p>
<p>_：任意单个字符</p>
<p>（3）ORDER BY子句</p>
<p>可以按一个或多个属性列排序</p>
<p>（4）聚集函数</p>
<p>COUNT、SUM、AVG、MAX、MIN</p>
<p>（5）GROUP BY子句</p>
<p>HAVING必须在GROUP BY里面，而WHERE是整个查询的结果</p>
<p><strong>WHERE子句是不能用聚集函数作为条件表达式</strong></p>
<p><strong>HAVING短语与WHERE子句作用对象不同</strong>，WHERE子句作用与基表或视图，从中选择满足条件的元组，HAVING短语作用于组，从中选择满足条件的组</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询：同时涉及两个以上的表的查询</p>
<p>（1）等值与非等值连接</p>
<p>连接操作的执行过程：嵌套循环法、排序合并法、索引连接</p>
<p>（2）自身连接</p>
<p>一个表与其自己进行连接</p>
<p>（3）外连接</p>
<p>左外连接，保留左边的内容</p>
<p>（4）多表连接</p>
<p>多表连接：两个以上的表进行连接</p>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>一个SELECT-FROM-WHERE子句称为一个查询块</p>
<p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<p>SQL语言允许多层嵌套查询，子查询不能使用ORDER BY子句</p>
<p>不相关子查询 相关子查询</p>
<p>（1）带有IN谓词的子查询</p>
<p>（2）带有比较运算符的子查询</p>
<p>（3）带有ANY（SOME）或ALL谓词的子查询</p>
<p>使用ANY或ALL谓词时必须同时使用比较运算</p>
<p>（4）带有EXISTS谓词的子查询</p>
<p>不返回如何数据，只产生逻辑值</p>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>并操作、交操作、差操作</p>
<h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><p>如果子查询中没有聚集函数，派生表可以不指定属性列</p>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>（1）插入元组</p>
<p>INSERT INTO &lt;表名&gt; VALUES</p>
<p>（2）插入子查询结果</p>
<p>INSERT INTO &lt;表名&gt; 子查询</p>
<p>实体完整性、参照完整性、用户定义的完整性（NOT NULL约束，UNIQUE约束，值域约束）</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>（1）修改某一个元组的值</p>
<p>（2）修改多个元组的值</p>
<p>（3）带子查询的修改语句</p>
<p>实体完整性、主码不允许修改、用户定义的完整性（NOT NULL约束，UNIQUE约束，值域约束）</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>（1）删除某一个元组的值</p>
<p>（2）删除多个元组的值</p>
<p>（3）带子查询的删除语句</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>虚表，是一个或几个基本表（或视图）导出的表</p>
<p>只存放视图的定义，不存放视图对应的数据</p>
<p>基表中的数据发生变化 ，从视图中查询出的数据也随之改变</p>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p>（1）建立视图</p>
<p>CREATE VIEW xxx AS xxx [WITH CHECK OPTION];</p>
<p>基于多个基表的视图、基于视图的视图、带表达式的视图、分组视图</p>
<p>（2）删除视图</p>
<p>DROP VIEW &lt;视图名&gt; [CASCADE]</p>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图消解法</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>允许对<strong>行列子集视图</strong>进行更新</p>
<p>对其他类型视图的更新不同系统由不同限制</p>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>视图能够<strong>简化</strong>用户操作</p>
<p>视图使用户能以<strong>多种角度</strong>看待同一数据</p>
<p>视图对重构数据库提供了一定的逻辑独立性</p>
<p>视图能够对机密数据提供安全保护</p>
<p>适当利用视图可以更清晰的表达查询</p>
<h1 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h1><p>数据库的安全性是指保护数据库以防止不合法使用所造成的<strong>数据泄漏、更改或破坏</strong></p>
<h2 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h2><h3 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h3><p>（1）非授权用户对数据库的恶意存取和破坏</p>
<p>（2）数据库中重要或敏感的数据被泄漏</p>
<p>（3）安全环境的脆弱性</p>
<h3 id="安全标准简介"><a href="#安全标准简介" class="headerlink" title="安全标准简介"></a>安全标准简介</h3><p>（1）TCSEC标准：安全策略，责任，保证，文档</p>
<p>D级 最小保护，C1 自主安全保护，C2 受控的存取保护（自主存取控制）</p>
<p>B1 标记安全保护（强制存取控制）， B2 结构化保护， B3 安全域， A1 验证设计</p>
<p>（2）CC标准</p>
<h2 id="数据安全性控制"><a href="#数据安全性控制" class="headerlink" title="数据安全性控制"></a>数据安全性控制</h2><p>数据库安全控制的常用方法：<strong>用户标识和鉴定、存取控制、视图、审计、数据加密</strong></p>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><p>静态口令鉴别：密码</p>
<p>动态口令鉴别：验证码，一次一密</p>
<p>生物特征鉴别：指纹，眼角膜，FaceID</p>
<p>智能卡鉴别</p>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>自主存取控制 C2</p>
<p>强制存取控制 B1</p>
<h3 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h3><p>通过SQL的GRANT语句和REVOKE语句实现</p>
<p>用户权限组成：数据对象和操作类型</p>
<p>定义存取权限称为<strong>授权</strong></p>
<p>关系数据库系统中存取控制对象：</p>
<p>（1）数据库模式</p>
<p>模式（CREATE SCHEMA）基本表（CREATE TABLE ，ALTER TABLE） 视图（CREATE VIEW） 索引（CREATE INDEX）</p>
<p>（2）数据</p>
<p>基本表和视图（SELECT INSERT UPDATE DELETE REFERENCES ALL PRIVILEGES）</p>
<p>属性列（SELECT INSERT UPDATE REFERENCES ALL PRIVILEGES）</p>
<h3 id="授权：授予与回收"><a href="#授权：授予与回收" class="headerlink" title="授权：授予与回收"></a>授权：授予与回收</h3><p>GRANT：将对指定操作对象的指定操作权限授予指定的用户</p>
<p>不允许循环授权</p>
<p>REVOKE：收回权限</p>
<h3 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h3><p>数据库角色：被命名的一组与数据库操作相关的权限</p>
<h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p>
<p>主体是系统中的活动实体，客体是系统中的被动实体，受主体操纵</p>
<p>敏感度标记：<strong>绝密（TS）&gt;&#x3D; 机密（S）&gt;&#x3D; 可信（C）&gt;&#x3D; 公开（P）</strong></p>
<p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p>
<p>强制存取控制规则</p>
<p>（1）主体的许可证级别大于或等于客体的密级时，该主体才能<strong>读</strong>取相应的客体</p>
<p>（2）主体的许可证级别小于或等于客体的密级时，该主体才能<strong>写</strong>相应的客体</p>
<p>实现强制存取控制首先要实现自主存取控制</p>
<h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护，间接地实现支持存取谓词的用户权限定义</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>审计：启用一个专用的审计日志，将用户对数据库的所有操作记录在上面，审计员利用审计日志，监控数据库中的各种行为，找到非法存取数据的人、时间和内容</p>
<p>用户级审计、系统级审计</p>
<h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>数据加密是防止数据库中数据在<strong>存储和传输</strong>中失密的有效手段</p>
<p>加密方法：存储加密和传输加密</p>
<h2 id="其他安全性"><a href="#其他安全性" class="headerlink" title="其他安全性"></a>其他安全性</h2><p>推理控制、隐蔽信道、数据隐私保护</p>
<h1 id="第五章-数据完整性"><a href="#第五章-数据完整性" class="headerlink" title="第五章 数据完整性"></a>第五章 数据完整性</h1><p><strong>数据库的完整性：保护数据的正确性、有效性和相容性</strong></p>
<p>为维护数据库的完整性。数据库管理系统必须：（1）提供定义完整性约束条件的机制 （2）提供完整性检查的方法 （3）违约处理</p>
<h2 id="实体完整性-1"><a href="#实体完整性-1" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>实体完整性定义：关系模型的实体完整性，单属性构成的码：列级约束条件，表级约束条件，多个属性构成的码：表级约束条件</p>
<p>全表扫描，建立<strong>索引</strong>加快速度 B+树索引</p>
<h2 id="参照完整性-1"><a href="#参照完整性-1" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>FOREIGN KEY短语定义外码，REFERENCES短语指明这些外码参照表的哪些主码</p>
<p>违约处理：拒绝执行、级联操作、设置为空值</p>
<h2 id="用户定义的完整性-1"><a href="#用户定义的完整性-1" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><p>用户定义完整性：针对某一具体应用的数据必须满足的语义要求</p>
<p>（1）属性上的约束条件：列值非空，列值唯一，检查列值是否满足一个条件表达式</p>
<p>（2）元组上的约束条件：CHECK短语定义元组上的约束条件，即元组级的限制</p>
<h2 id="完整性约束命名字句"><a href="#完整性约束命名字句" class="headerlink" title="完整性约束命名字句"></a>完整性约束命名字句</h2><p>CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</p>
<p>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>通过声明性断言来指定更具一般性的约束</p>
<p>CREATE ASSERTION &lt;断言名&gt; &lt;CHECK子句&gt;</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>CREATE TRIGGER</p>
<p>触发器又叫做<strong>事件-条件-动作</strong>规则</p>
<p>触发器由触发事件激活</p>
<p>执行顺序：（1）执行该表上的BEFORE触发器 （2）激活触发器的SQL语句 （3）执行该表上的AFTER触发器</p>
<p>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</p>
<h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><p>关系数据库逻辑设计—关系数据库的规范化理论</p>
<p><strong>第一范式（1NF）：每个分量必须是不可分开的数据项</strong>，无重复的列</p>
<p>数据依赖是一个关系内部属性与属性之间的一种约束关系，可分为<strong>函数依赖</strong>和<strong>多值依赖</strong></p>
<p><strong>数据冗余、更新异常、插入异常、删除异常</strong></p>
<p>原因：由存在于模式中的某些数据依赖引起</p>
<p>解决方法：用规范化理论改造关系模式来消除不合适的数据依赖（分解）</p>
<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>X函数确定Y，Y函数依赖于X，记作X—&gt;Y</strong></p>
<p>函数依赖是指关系模式R的所有关系实例均要满足的约束条件，是语义范畴的概念</p>
<p>X—&gt;Y，但 Y 不属于 X，则称X—&gt;Y是<strong>非平凡的函数依赖</strong></p>
<p>X—&gt;Y，但 Y 属于 X（Y是X的子集），则称X—&gt;Y是<strong>平凡的函数依赖</strong>，平凡函数依赖必成立</p>
<p>若X—&gt;Y，则X称为这个函数依赖的<strong>决定因素</strong></p>
<ol>
<li>**完全函数依赖 **</li>
<li><strong>部分函数依赖</strong></li>
<li><strong>传递函数依赖</strong></li>
</ol>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><ol>
<li>候选码 </li>
<li>主码 </li>
<li>主属性 </li>
<li>非主属性 </li>
<li>全码 </li>
<li>外码</li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一级别的关系模式的集合</p>
<p><strong>1NF 包含 2NF 包含 3NF 包含 BCNF 包含 4NF 包含 5NF</strong></p>
<p>一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong></p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具，规范化实质上是概念的单一化</p>
<p>一个关系模式不属于2NF，会产生插入异常、删除异常、修改复杂的问题</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第二范式（2NF）</strong></td>
<td><strong>关系模式R属于1NF，并且每一个非主属性都完全函数依赖于任何一个候选码（即不存在非主属性部分函数依赖于候选码），则R属于2NF</strong></td>
</tr>
<tr>
<td><strong>第三范式（3NF）</strong></td>
<td><strong>关系模式R&lt;U,F&gt;属于1NF，若R中不存在非主属性Z对码X的传递函数依赖，则称R&lt;U,F&gt;属于3NF</strong></td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td><strong>在关系模式R&lt;U,F&gt;中，如果每一个决定属性集都包含候选码，则R属于BCNF</strong></td>
</tr>
</tbody></table>
<p>关系模式的规范化：一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式集合</p>
<h4 id="关系数据库的规范化是数据库逻辑设计的工具"><a href="#关系数据库的规范化是数据库逻辑设计的工具" class="headerlink" title="关系数据库的规范化是数据库逻辑设计的工具"></a>关系数据库的规范化是数据库逻辑设计的工具</h4><p>1NF—&gt;2NF：消除非主属性对码的部分函数依赖</p>
<p>2NF—&gt;3NF：消除非主属性对码的传递函数依赖</p>
<p>3NF—&gt;BCNF：消除主属性对码的部分和传递函数依赖</p>
<p>BCNF—&gt;4NF：消除非平凡且非函数依赖的多值依赖</p>
<p>1NF—&gt;BCNF：消除决定因素非码的非平凡函数依赖</p>
<p>不能说规范化程度越高的关系模式就越好</p>
<h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><p>需求分析和概念设计独立于任何数据库管理系统，逻辑设计和物理设计与选用的数据库管理系统密切相关</p>
<p>需求分析阶段：综合各个用户的应用需求</p>
<p>概念设计阶段：<strong>概念模式</strong>（信息时间模型），用E-R图来描述</p>
<p>逻辑设计阶段：<strong>逻辑模式、外模式</strong></p>
<p>物理设计阶段：<strong>内模式</strong></p>
<p>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模式，形成数据库<strong>逻辑模式</strong></p>
<p>根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的<strong>外模式</strong></p>
<p>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库<strong>内模式</strong></p>
<h3 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h3><p><strong>需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护</strong></p>
<p>需求分析和概念结构设计独立于任何数据库管理系统</p>
<p>逻辑设计和物理设计与选用的数据库管理系统密切相关</p>
<h3 id="数据库设计过程中的各级模式"><a href="#数据库设计过程中的各级模式" class="headerlink" title="数据库设计过程中的各级模式"></a>数据库设计过程中的各级模式</h3><p>需求分析：综合各个用户的应用需求</p>
<p>概念设计阶段：E-R图</p>
<p>逻辑设计阶段：逻辑模式 外模式</p>
<p>物理设计阶段：内模式</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求分析就是分析用户的需求</p>
<p>分析方法：结构化分析方法</p>
<p>数据字典是关于数据库中的数据描述，即元数据</p>
<p>数据字典的内容：数据项、数据结构、数据流、数据存储、处理过程</p>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><h3 id="7-3-1-概念模型"><a href="#7-3-1-概念模型" class="headerlink" title="7.3.1 概念模型"></a>7.3.1 概念模型</h3><p>描述概念模型的工具 E-R模型</p>
<h3 id="7-3-2-E-R模型"><a href="#7-3-2-E-R模型" class="headerlink" title="7.3.2 E-R模型"></a>7.3.2 E-R模型</h3><p>实体之间的联系：一对一（1:1）、一对多（1:n）、多对多（m:n）</p>
<p>联系的度：参与联系的实体型的数目</p>
<p>E-R图提供了表示实体型、属性和联系的方法</p>
<h3 id="7-3-3-概念结构设计"><a href="#7-3-3-概念结构设计" class="headerlink" title="7.3.3 概念结构设计"></a>7.3.3 概念结构设计</h3><p>两条准则：（1）属性必须是不可分的数据项，不能包含其他属性 （2）属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系</p>
<p>E-R图的集成一般需要两步</p>
<p>（1）合并</p>
<p>子系统E-R图之间的冲突主要有三类：属性冲突、命名冲突、结构冲突</p>
<p>（2）修改和重构</p>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><h3 id="7-4-1-E-R图向关系模型的转换"><a href="#7-4-1-E-R图向关系模型的转换" class="headerlink" title="7.4.1 E-R图向关系模型的转换"></a>7.4.1 E-R图向关系模型的转换</h3><p>（1）1:1联系转换为一个独立的关系模式</p>
<p>（2）1:1联系与任意一端合并</p>
<p>（3）1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</p>
<p>（4）一个m:n联系转换为一个关系模式，取m，n端的码作为独立关系的组合码，再加自有属性</p>
<p>（5）三个或三个以上实体间的一个<strong>多元联系</strong>转换为一个关系模式</p>
<p>（6）具有相同码的关系模式可合并</p>
<h3 id="7-4-2-数据模型的优化"><a href="#7-4-2-数据模型的优化" class="headerlink" title="7.4.2 数据模型的优化"></a>7.4.2 数据模型的优化</h3><p>无通用规则，数据库逻辑设计的结果不是唯一的</p>
<h3 id="7-4-3-设计用户子模式"><a href="#7-4-3-设计用户子模式" class="headerlink" title="7.4.3 设计用户子模式"></a>7.4.3 设计用户子模式</h3><p>（1）使用更符合用户习惯的别名 （2）针对不同级别的用户定义不同的视图，以保证系统的安全性 （3）简化用户对系统的使用</p>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><p>数据库在物理设备上的<strong>存储结构与存取方法</strong>称为数据库的物理结构，它依赖于选定的数据库管理系统</p>
<p>数据库管理系统常用存取方法：B+树索引存取方法、Hash索引存取方法、聚簇存取方法</p>
<p>确定数据库物理结构主要确定数据的<strong>存放位置</strong>和<strong>存储结构</strong></p>
<p>确定数据的存放位置和存储结构要综合考虑<strong>存取时间、存储空间利用率和维护代价</strong></p>
<h1 id="单元测试笔记"><a href="#单元测试笔记" class="headerlink" title="单元测试笔记"></a>单元测试笔记</h1><h2 id="单元测试2"><a href="#单元测试2" class="headerlink" title="单元测试2"></a>单元测试2</h2><p>关系代数中的连接操作是由<strong>选择和笛卡尔积</strong>操作组合而成</p>
<p>关系数据模型的基本数据结构是<strong>关系</strong></p>
<p>关系R中能唯一标识一个元组的是它的 <strong>主码、全码、候选码</strong></p>
<p>关系是动态的、随时间变化的，关系模式是静态的、稳定的</p>
<h2 id="单元测试4"><a href="#单元测试4" class="headerlink" title="单元测试4"></a>单元测试4</h2><p>安全性控制的防范对象是<strong>非法用户</strong>，防止他们对数据库数据的存取</p>
<p>数据库安全审计系统提供了一种<strong>事后检查</strong>的安全机制。</p>
<p>在数据库的安全性控制中，授权对象的约束粒度越小，授权子系统就越灵活</p>
<h2 id="单元测试5"><a href="#单元测试5" class="headerlink" title="单元测试5"></a>单元测试5</h2><p>实体完整性规则检查的内容包括：检查主码值是否唯一,如果不唯一就拒绝插入或修改，检查主码的各个属性值是否为空,只要有一个为空就拒绝插入或修改</p>
<p>触发器只能定义在基本表上</p>
<h2 id="单元测试6"><a href="#单元测试6" class="headerlink" title="单元测试6"></a>单元测试6</h2><p>算法：按以下步骤求候选键：<br>1.只在FD右部出现的属性，不属于候选码;<br>2.只在FD左部出现的属性，一定存在于某候选码当中;<br>3.外部属性一定存在于任何候选码当中;<br>4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码</p>
<p>关系模式R的整个属性组是码,则R满足的最高范式至少是<strong>3NF</strong></p>
<p>关系规范化中的删除异常是指<strong>不该删除的数据被删除</strong></p>
<p>关系数据库的规范化理论主要解决的问题是<strong>如何构造合适的数据逻辑结构</strong></p>
<p>在关系数据库设计中,设计关系模式是数据库设计中<strong>逻辑结构设计阶段</strong>的任务</p>
<h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><p>子模式（外模式）DDL用来描述数据库的局部逻辑结构</p>
<p>SQL中的视图提高了数据库系统的安全性</p>
<p>候选码：若关系中的某一属性组的值能够唯一确定一个元组，则该属性组为候选码</p>
<p>主码：若一个关系有多个候选码，选定一个作为主码</p>
<p>外码：设关系R的一个属性组F，F不是关系R的主码，若F与关系S的主码相对应，则称F是关系R的外码</p>
<p>一个关系的候选码可以有多个，但主码只有一个</p>
<p>每一个实体对应一个关系模式</p>
<p>每个m：n联系对应一个关系模式</p>
<p>概念结构设计的方法有四种：自顶向下、自底向上、逐步扩张、混合策略</p>
<p>设计步骤：（1）进行数据抽象，设计局部E-R模型，即设计局部示图 （2）集成各局部E-R模型，形成全局E-R模型，即视图的集成</p>
<p>在数据库中，产生数据不一致的根本原因是未对数据进行完整性控制</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络(2)-数据链路层与网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-11 14:32:53" itemprop="dateCreated datePublished" datetime="2022-12-11T14:32:53+08:00">2022-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-01 22:35:46" itemprop="dateModified" datetime="2023-02-01T22:35:46+08:00">2023-02-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>结点</strong>：主机、路由器</p>
<p><strong>链路</strong>：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p>
<p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p>
<p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p>
<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。（简单来说就是将网络层的数据报进行再次封装搬运给物理层</p>
<p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。<strong>其主要作用是加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：<strong>标头（Head）和数据（Data）</strong>。<br>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。<br><strong>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。</strong>因此，整个<strong>”帧”最短为64字节，最长为1518字节</strong>。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做<strong>MAC地址</strong>。长度为6字节，共48比特，通常用十六进制表示法，地址的每个字节被表示为一对十六进制数</p>
<p>每个适配器具有一个<strong>唯一的MAC地址</strong>，不随位置发生变化（就像人的身份证，而IP则像人的邮政地址）</p>
<h3 id="广播的概念"><a href="#广播的概念" class="headerlink" title="广播的概念"></a>广播的概念</h3><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121916196.png"/>

<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>
<h2 id="数据链路层的功能概述"><a href="#数据链路层的功能概述" class="headerlink" title="数据链路层的功能概述"></a>数据链路层的功能概述</h2><p>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。有连接一定有确认！</p>
<p>功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）。</p>
<p>功能三：组帧。</p>
<p>功能四：流量控制。限制发送方哦~</p>
<p>功能五：差错控制（帧错&#x2F;位错）。</p>
<p>因为物理层可能会把数据弄丢，所以数据链路层需要进行一些设置来使得物理层可以可靠的传输数据</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121818959.png"/>

<h2 id="ARP协议（地址解析协议）"><a href="#ARP协议（地址解析协议）" class="headerlink" title="ARP协议（地址解析协议）"></a>ARP协议（地址解析协议）</h2><p><strong>ARP协议</strong>：完成主机或路由器IP地址到MAC地址的映射【解决下一跳走哪的问题】（专门用于寻找MAC地址的协议）</p>
<p>每个节点的ARP模块都在它的RAM中有一个ARP表，包含IP地址到MAC地址的映射关系，每个表项还包含TTL字段，表示表项过期时间（ARP表是自动创建的，如果某节点与子网断开连接，它的表项最终会从留在子网中的节点的表中删除。通常一个表项的过期时间是20分钟）</p>
<p>主机向其ARP模块提供一个IP地址，ARP模块返回IP地址对应的MAC地址<br>（注释：在OSI七层模型中，ARP属于链路层模型，所以这里也先简单介绍一下，构建知识体系）</p>
<h3 id="ARP协议使用过程："><a href="#ARP协议使用过程：" class="headerlink" title="ARP协议使用过程："></a>ARP协议使用过程：</h3><p>检查<strong>ARP高速缓存</strong>，有对应表项则写入<strong>MAC帧</strong>，没有则用目的MAC地址为<strong>FF-FF-FF-FF-FF</strong>的帧封装并<span style="color:red"><strong>广播ARP请求分组</strong></span>，<strong>同一局域网</strong>中所有主机都能收到该请求。目的主机收到请求后就会向源主机<span style="color:green"><strong>单播一个ARP响应分组</strong></span>，源主机收到后将此映射<strong>写入ARP缓存</strong>（10-20min更新一次）。</p>
<h3 id="ARP协议4中典型情况："><a href="#ARP协议4中典型情况：" class="headerlink" title="ARP协议4中典型情况："></a>ARP协议4中典型情况：</h3><ol>
<li>主机A发给<strong>本网络</strong>上的主机B：用ARP找到主机B的硬件地址；</li>
<li>主机A发给<strong>另一网络</strong>上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址；</li>
<li>路由器发给<strong>本网络</strong>的主机A：用ARP找到主机A的硬件地址；</li>
<li>路由器发给<strong>另一网络</strong>的主机B：用ARP找到本网络上的一个路由器的硬件地址。</li>
</ol>
<h2 id="封装成帧、帧定界、帧同步"><a href="#封装成帧、帧定界、帧同步" class="headerlink" title="封装成帧、帧定界、帧同步"></a>封装成帧、帧定界、帧同步</h2><p><strong>透明传输</strong>就是为了防止<strong>特殊的数据无法正常传输</strong>的的情况的发生，比如说在封装成帧的过程中，可能出现数据中的某些标记符与开始&#x2F;结束标记符恰巧重复的情况，如果不加以处理，那么会导致无法判定帧的开始于结束。</p>
<p><strong>封装成帧</strong>：就是在一段数据的前后部分添加<strong>首部和尾部</strong>，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据资许加控制信息，他们的一个重要作用：<strong>帧定界</strong>（确定赖的界限）。</p>
<p><strong>帧同步</strong>：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p>
<p><strong>组帧的四种方法</strong>：1.字符计数法，2.字符（节）填充法，3.零比特填充法，4.违规编码法。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121823925.png"/>

<h2 id="透明传输的概念"><a href="#透明传输的概念" class="headerlink" title="透明传输的概念"></a>透明传输的概念</h2><p>透明传输：是<strong>指不管所传数据是什么样的比特组合，都应当能够在链路上传送</strong>。因此，链路层就“看不见”有什么妨碍数据的东西。</p>
<p>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p>
<h2 id="透明传输的实现方法"><a href="#透明传输的实现方法" class="headerlink" title="透明传输的实现方法"></a>透明传输的实现方法</h2><h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><p>就是在帧的首部做计数，这个字符记录了当前帧有多少个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧</span><br><span class="line">比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121853613.png"/>



<h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p>就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，<strong>开始和结束的对应的字符不一样</strong><br>但有可能出现数据内某段比特流数据正好<strong>与标记字段重复</strong>，从而导致误判断的情况</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121855920.png"/>

<p><strong>解决方法：添加转义字符。即对于那些与标记字符重复的数据流，在它们的前面添加一段转义字符，这样接收方在解析帧时，看到这些转义字符就不会认为那些特殊的数据当成帧的开始&#x2F;结束了。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121902833.png"/>

<h3 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121902052.png"/>

<h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><p>因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就<strong>不会与数据冲突</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121903762.png"/>



<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><h3 id="何为差错"><a href="#何为差错" class="headerlink" title="何为差错"></a>何为差错</h3><p>数据链路层的差错检测的是<strong>比特</strong>的错误<br>需要注意的是，即使采用差错检测比特，也还是可能有未检出比特差错的情况。<br>因此，主要是选择一个差错检测方案，使得这种事件发生的概率很小</p>
<p>概括来说，传输中的差错都是由于噪声引起的。</p>
<p><strong>全局性</strong> ：1.由于线路本身电气特性所产生的<strong>随机噪声</strong>（热噪声）,是信道固有的，随机存在的。<br>                    解决办法：提高信噪比来减少或避免干扰。（对传感器下手）</p>
<p><strong>局部性</strong> ：2.外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。<br>                    解决办法：通常利用编码技术来解决。</p>
<p>链路层为网络层提供服务：<strong>无确认无连接服务，有确认无连接服务，有确认面向连接服务。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121906841.png"/>

<h4 id="为什么要在数据链路层进行差错控制？"><a href="#为什么要在数据链路层进行差错控制？" class="headerlink" title="为什么要在数据链路层进行差错控制？"></a>为什么要在数据链路层进行差错控制？</h4><p>因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费</p>
<h3 id="检错编码（奇偶校验码，循环冗余码CRC）"><a href="#检错编码（奇偶校验码，循环冗余码CRC）" class="headerlink" title="检错编码（奇偶校验码，循环冗余码CRC）"></a>检错编码（奇偶校验码，循环冗余码CRC）</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>奇偶校验：只需包含1个附加比特。</p>
<p>对于偶校验，选择一个值，使得所有比特中1出现偶数次。</p>
<p>对于奇校验，选择一个值，使得所有比特中1出现奇数次。接收方通过检测1出现的次数判断是否出现差错。如果出现偶数个比特差错，则检验不出</p>
<p><strong>缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121909365.png"/>



<h4 id="循环冗余编码（CRC）"><a href="#循环冗余编码（CRC）" class="headerlink" title="循环冗余编码（CRC）"></a>循环冗余编码（CRC）</h4><p>发送方和接收方协商一个r+1比特的生成多项式(G)，要起其最高比特位为1。发送方通过在d比特的数据后附加r比特，使得整个(d+r)比特的值能够被G整除。接收方用G去除(d+r)比特，如果余数非0，则出现差错</p>
<p>可能难以理解，这边举个实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：要发送的数据是1101011011,采用CRC校验，生成多项式是10011,那么最终发送的数据应该是？</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121919348.png"/>

<p>进行异或算法：<strong>同0异1</strong></p>
<p>TIPS：多项式N位，阶为N-1。</p>
<p><strong>接收方收到数据后进行检测</strong></p>
<p>把收到的每一个帧都除以同样的除数，然后检查得到的余数R。</p>
<p>1.余数为0,判定这个帧没有差错，接受。</p>
<p>2.余数为不为0,判定这个帧有差错（无法确定到位）,丢弃。FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。</p>
<p>在数据链路层仅仅使用循环穴余检验CRC差错检测技术，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”。“可靠传输”：数据链路层发送端发送什么，接收端就收到什么。链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。</p>
<h3 id="纠错编码（海明码）"><a href="#纠错编码（海明码）" class="headerlink" title="纠错编码（海明码）"></a>纠错编码（海明码）</h3><h4 id="第一步-确认校验码位数r"><a href="#第一步-确认校验码位数r" class="headerlink" title="第一步 确认校验码位数r"></a>第一步 确认校验码位数r</h4><p>海明码不等式：<br>$$<br>2^r \geq k+r+1 (r为冗余信息位，k为信息位)<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若要发送的数据：D=101101</span><br><span class="line">数据的位数k=6</span><br><span class="line">满足不等式的最小r为4,</span><br><span class="line">也就是D=101101的海明码应该有6+4=10位，</span><br><span class="line">其中原数据6位，效验码4位。</span><br></pre></td></tr></table></figure>

<h4 id="第二步-确定校验码和数据的位置"><a href="#第二步-确定校验码和数据的位置" class="headerlink" title="第二步 确定校验码和数据的位置"></a>第二步 确定校验码和数据的位置</h4><p>注释：<br>1.为什么是10为数据位？因为4位校验码+6位信息位&#x3D;10位<br>2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121935057.png"/>

<h4 id="第三步-求出校验码的值"><a href="#第三步-求出校验码的值" class="headerlink" title="第三步 求出校验码的值"></a>第三步 求出校验码的值</h4><p>注释</p>
<ol>
<li><p>先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注</p>
</li>
<li><p>然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位</p>
</li>
</ol>
<p>这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121937540.png"/>

<p>然后计算异或值，比如说这里D1&#x3D;1,D2&#x3D;0,D4&#x3D;1,D5&#x3D;0,就是p1要同时和<strong>0</strong>,<strong>1</strong>，<strong>0</strong>,<strong>1</strong>进行异或之后得到0，为了标识我加粗原始计算数据<br>举例：<strong>0</strong>和<strong>1</strong>异或得1,1和<strong>0</strong>异或得1,1和<strong>1</strong>异或得0，那么p1和0异或得0，p1就是0了</p>
<p>3.其他同理，按顺序计算出P2,P3,P4,然后填入表格</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121940537.png"/>

<h4 id="第四步-检测并纠错"><a href="#第四步-检测并纠错" class="headerlink" title="第四步 检测并纠错"></a>第四步 检测并纠错</h4><p>就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121941617.png"/>

<h2 id="数据链路层的流量控制和可靠传输"><a href="#数据链路层的流量控制和可靠传输" class="headerlink" title="数据链路层的流量控制和可靠传输"></a>数据链路层的流量控制和可靠传输</h2><p>流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费<br>可靠传输是发送端发送什么，接收端就要受到什么</p>
<h3 id="停止等待协议（Stop-and-Wait）"><a href="#停止等待协议（Stop-and-Wait）" class="headerlink" title="停止等待协议（Stop-and-Wait）"></a>停止等待协议（Stop-and-Wait）</h3><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。所以就需要有停止-等待协议</p>
<p>注释：丢包-物理线路故障、设备故障、病毒攻击、路由信息<br>错误等原因，会导致数据包的丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方）,一方接收数据(接收方）。</span><br><span class="line"></span><br><span class="line">因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。</span><br><span class="line"></span><br><span class="line">“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</span><br></pre></td></tr></table></figure>

<h4 id="停止等待协议—无差错情况"><a href="#停止等待协议—无差错情况" class="headerlink" title="停止等待协议—无差错情况"></a>停止等待协议—无差错情况</h4><p>注释：因为一次就一个，所以用0和1标记ack（确认序号）就行</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121944092.png"/>

<h4 id="停止等待协议—有差错情况"><a href="#停止等待协议—有差错情况" class="headerlink" title="停止等待协议—有差错情况"></a>停止等待协议—有差错情况</h4><p>使用一个超时计时器，每发一帧就开始计时，设置时间略长于一个RTT（往返时延）。</p>
<p>发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延：<br>$$<br>RTT &#x3D; 传播时延*2+处理时间（有时可直接忽略）<br>$$<br><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121946606.png"/></p>
<h5 id="ACK丢失"><a href="#ACK丢失" class="headerlink" title="ACK丢失"></a>ACK丢失</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121947459.png"/>

<h5 id="ACK迟到"><a href="#ACK迟到" class="headerlink" title="ACK迟到"></a>ACK迟到</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121948655.png"/>

<p>停止等待协议的特点</p>
<ol>
<li>简单</li>
<li>信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121949044.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121950756.png"/>

<h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3><p>因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率</p>
<p>注释：<br>累计确认：就是收到一个确认帧，那么<strong>它和它之前的所有帧</strong>都默认已收到，反之，如果某个确认帧没收到，那么<strong>它和它之后的所有帧</strong>都默认丢失（即使收到了也丢掉），进行重传</p>
<h4 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h4><ol>
<li><p>上层的调用</p>
<p>上层要发送数据时，发送方先检查发送窗口是否已满，<strong>如果未满</strong>，则产生一个帧并将其发送；<strong>如果窗口已满</strong>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）。</p>
</li>
<li><p>收到一个ACK</p>
<p>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧</p>
</li>
<li><p>超时时间</p>
<p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认赖的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>此图发送2帧时丢失，<strong>所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK</strong>，</p>
<p>直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧，</p>
<p>如果所示，GBN的形式就像排队，接收端为所有帧“预定”了接收位置，如果接收端发送的数据因为某些原因没有接收到，即使收到了这一帧后面所有的帧，<strong>这些“排在后面的”帧也要被丢弃</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121958226.png"/>

<p>发送窗口不能无限大，与使用的编号的比特数有关，二进制表示。<br>很简单，就是1比特编号0和1,<br>同理2比特编号0-3，二进制表示就是00，01，10，11。<br>如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了<br>GBN的优缺点也显而易见，优点是相对于上面的停止等待协议，明显提高了信道利用率，缺点是因为重传机制的原因，导致已经收到数据却需要强行丢弃，进而造成浪费</p>
<h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h3><p>吸取了GBN协议的教训，我们打算尝试只重传错误的帧，这样的话就不用浪费资源把已经收到的帧再重传一次了。</p>
<p>在GBN中，仅有接收端有一个窗口来存放数据帧，在SR中，两者都有窗口了。</p>
<p>和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（注释：缓存不可能无限大）</p>
<p><strong>注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口；它可以继续接受窗口范围内排在2帧后面的数据帧，直至最后2帧收到后一次性确认窗口内的所有已经收到的帧，再移动窗口。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122003758.png"/>

<p>同样的，因为编号的问题，发送窗口不能无限大<br>当发送窗口最后和接受窗口<strong>大小相同</strong>时，利用率比较高</p>
<h2 id="介质访问控制技术"><a href="#介质访问控制技术" class="headerlink" title="介质访问控制技术"></a>介质访问控制技术</h2><p>虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率</p>
<p>就是让节点之间的通信不会进行相互干扰</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122017412.png"/>

<h3 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</strong></p>
<p>充分利用传输介质带宽，<strong>系统效率较高</strong>；由于技术比较成熟，实现也比较<strong>容易</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122018650.png"/>

<h3 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h3><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。</p>
<p>TDM的缺点就是利用率低，所以又衍生出了STDM</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122025593.png"/>

<h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><p>STDM的原则是先到先走，满了就发，相对于TDM提高了利用率</p>
<p>每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。<strong>STDM帧不是固定分配时隙，而是按需动态分配时隙。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122028591.png"/>

<h3 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h3><p>每个节点分配一种不同的编码，每个节点使用其唯一的编码来对发送的数据进行编码（如果精心选择编码，不同节点能同时传输）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122029336.png"/>

<h2 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h2><p>所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快</p>
<h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>帧到达节点时，立刻传输。如果发生碰撞，节点将立即(在完全传输碰撞帧后)以概率p重传。否则，等待一个帧传输时间，再以概率p重传。信道有效传输速率实际不是R bps，而是时隙ALOHA的一半</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122033941.png"/>

<p>时隙ALOHA协议<br>时间被划分为时隙，每个节点的时间同步，帧的传输只在时隙的开始时进行。如果发生碰撞，在下一个时隙开始时以概率p重传，否则等待一个时隙再以概率p重传…（信道有效传输速率实际不是R bps，而是0.37R bps）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122033818.png"/>

<h3 id="CSMA协议-载波侦听多路访问"><a href="#CSMA协议-载波侦听多路访问" class="headerlink" title="CSMA协议(载波侦听多路访问)"></a>CSMA协议(载波侦听多路访问)</h3><p><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>
<p><code>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</code></p>
<p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122040654.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>1-坚持CSMA</td>
<td>发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听</td>
<td>立即发送，利用率高</td>
<td>如果多台设备同时监听，那么会发生冲突</td>
</tr>
<tr>
<td>非坚持CSMA</td>
<td>发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听</td>
<td>冲突发生的几率减少</td>
<td>因为需要等待，所以利用率不高</td>
</tr>
<tr>
<td>p-坚持CSMA</td>
<td>发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听</td>
<td>冲突减少的同时效率也比较高</td>
<td>即使发生冲突也要坚持发送数据，资源被浪费</td>
</tr>
</tbody></table>
<h3 id="CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）"><a href="#CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）" class="headerlink" title="CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）"></a>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞。</p>
<p>先侦听信道，如果没有其它节点在使用信道，则传输数据。但是有碰撞检测，如果发生碰撞，会停止传输剩下的数据，等待一个随机时间(通常比传输一帧短)后，再进行尝试。</p>
<p>知道自己发生碰撞的最长时间是2τ（两倍的<strong>传播时延</strong>），就是一去一回</p>
<p><strong>CS</strong>:载波侦听&#x2F;监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据</p>
<p><strong>MA</strong>:多点接入，表示许多计算机以多点接入的方式连接在一根总线上。【总线型网络】</p>
<p><strong>CD</strong>:碰撞检测（冲突检测）,“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。【半双工网络】</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301070108864.png"/>

<p>帧的传输时延至少要两倍于信号在总线中的传播时延</p>
<p>以太网规定最短帧长为64B,凡是长度小于64B的都是由于冲突而异常终止的无效帧<br>$$<br>帧长(bit)&#x2F;数据传输速率 \ge 2τ<br>$$</p>
<p>$$<br>最小帧长&#x3D;总线传播时延<em>数据传输速率</em>2<br>$$</p>
<p>$$<br>2τ*数据传输速率<br>$$</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301070108022.png"/>

<h3 id="CSMA-x2F-CA协议（载波监听多点接入-x2F-碰撞避免）"><a href="#CSMA-x2F-CA协议（载波监听多点接入-x2F-碰撞避免）" class="headerlink" title="CSMA&#x2F;CA协议（载波监听多点接入&#x2F;碰撞避免）"></a>CSMA&#x2F;CA协议（载波监听多点接入&#x2F;碰撞避免）</h3><ul>
<li>发送数据前，先检测信道是否空闲。</li>
<li>空闲则发出RTS(request to send),RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</li>
<li>接收端收到RTS后，将响应CTS(clear to send)。</li>
<li>发送端收到CTS后，开始发送数据帧（同时预约信道：发送方告知其他站点自己要传多久数据）。</li>
<li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧。</li>
<li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）。</li>
</ul>
<ol>
<li>预约信道</li>
<li>.ACK帧</li>
<li>RTS&#x2F;CTS帧（可选）</li>
</ol>
<h4 id="CSMA-x2F-CD-与-CSMA-x2F-CA的区别"><a href="#CSMA-x2F-CD-与-CSMA-x2F-CA的区别" class="headerlink" title="CSMA&#x2F;CD 与 CSMA&#x2F;CA的区别"></a>CSMA&#x2F;CD 与 CSMA&#x2F;CA的区别</h4><p>相同点：</p>
<p>CSMA&#x2F;CD与CSMA&#x2F;CA机制都从属于CSMA的思路，其核心是先听再说。换言之，两个在接入信道之前都须要 进行监听。当发现信道空闲后，才能进行接入。</p>
<p>不同点：</p>
<ol>
<li><p>传输介质不同：CSMA&#x2F;CD用于总线式以太网【有线】，而CSMA&#x2F;CA用于无线局域网【无线】。</p>
</li>
<li><p>载波检测方式不同：因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测（ED)、载波检测（CS)和能量载波混合检测三种检测信道空闲的方式。</p>
</li>
<li><p>CSMA&#x2F;CD检测冲突，CSMA&#x2F;CA避免冲突，二者出现冲突后都会进行有上限的重传。</p>
</li>
</ol>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><p>主要包括两大类，一个是<strong>轮询协议</strong>，另一个是<strong>令牌传递协议</strong></p>
<h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p>即选出一个代表，由他控制所有的传输，但会存在以下问题</p>
<ul>
<li>轮询开销：在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销</li>
<li>等待延迟：就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应</li>
<li>单点故障：很好理解，就是代表挂了</li>
</ul>
<h3 id="令牌传输协议"><a href="#令牌传输协议" class="headerlink" title="令牌传输协议"></a>令牌传输协议</h3><p>在节点之间没有收发数据的需求时，令牌在节点之间循环。</p>
<p>发送数据的流程</p>
<ol>
<li>当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&gt;占用）</li>
<li>再将令牌与数据帧结合，让其在节点构成的环之间流动</li>
<li>不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌</li>
<li>最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍<br>问题基本和轮询协议相同</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301070107881.png"/>

<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的概念"><a href="#局域网的概念" class="headerlink" title="局域网的概念"></a>局域网的概念</h3><p>局域网（Local Area Network):简称LAN,是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<ol>
<li><p>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p>
</li>
<li><p>特点2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb&#x2F;s~10Gb&#x2F;s)。</p>
</li>
<li><p>特点3：通信延迟时间短，误码率低，可靠性较高。</p>
</li>
<li><p>特点4：各站为平等关系，共享传输信道。</p>
</li>
<li><p>特点5：多采用分布式控制和广播式通信，能进行广播和组播。</p>
</li>
</ol>
<p>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</p>
<h3 id="局域网额网络拓扑结构"><a href="#局域网额网络拓扑结构" class="headerlink" title="局域网额网络拓扑结构"></a>局域网额网络拓扑结构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071403070.png"/>

<h3 id="局域网的传播介质"><a href="#局域网的传播介质" class="headerlink" title="局域网的传播介质"></a>局域网的传播介质</h3><table>
<thead>
<tr>
<th>局域网</th>
<th>常用介质</th>
</tr>
</thead>
<tbody><tr>
<td>有线局域网</td>
<td>双绞线，同轴电缆，光纤</td>
</tr>
<tr>
<td>无线局域网</td>
<td>电磁波</td>
</tr>
</tbody></table>
<h3 id="局域网介质访问方法"><a href="#局域网介质访问方法" class="headerlink" title="局域网介质访问方法"></a>局域网介质访问方法</h3><ol>
<li>CSMA&#x2F;CD常用于<strong>总线型局域网</strong>，也用于树型网络</li>
<li>令牌总线常用于<strong>总线型局域网</strong>，也用于树型网络它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</li>
<li>令牌环用于<strong>环形局域网</strong>，如令牌环网</li>
</ol>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><ol>
<li>以太网 以太网是应用最为广泛的局域网，包括标准以太网（10Mbps)、快速以太网（100Mbps)、千兆以太网（1000Mbps)和10G以太网，它们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA&#x2F;CD.</li>
<li>令牌环网物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。已是“明日黄花”。</li>
<li>FDDI网（Fiber Distributed Data Interface)物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。</li>
<li>ATM网（Asynchronous Transfer Mode)较新型的单元交换技术，使用53字节固定长度的单元进行交换。</li>
<li>无线局域网（Wireless Local Area Network;WLAN)采用IEEE802.11标准。</li>
</ol>
<h3 id="IEEE802标准"><a href="#IEEE802标准" class="headerlink" title="IEEE802标准"></a>IEEE802标准</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071409987.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071408948.png"/>

<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网（Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。以太网络使用<strong>CSMA&#x2F;CD(载波监听多路访问及冲突检测）</strong>技术。</p>
<p>以太网在局域网各种技术中占统治性地位：</p>
<ol>
<li>造价低廉（以太网网卡不到100块）;</li>
<li>是应用最广泛的局域网技术；</li>
<li>比令牌环网、ATM网便宜，简单；</li>
<li><strong>满足网络速率要求：10Mb&#x2F;s~10Gb&#x2F;s</strong></li>
</ol>
<h3 id="以太网两个标准："><a href="#以太网两个标准：" class="headerlink" title="以太网两个标准："></a>以太网两个标准：</h3><p>DIX EthernetV2:第一个局域网产品（以太网）规约。</p>
<p>IEEE802.3:IEEE802委员会802.3工作组制定的第一个IEEE的以太网标准。（帧格式有一丢丢改动）</p>
<h3 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h3><p>无连接：发送方和接收方之间无“握手过程”。</p>
<p>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</p>
<p>以太网只实现无差错接收，不实现可靠传输。</p>
<h3 id="以太网的发展"><a href="#以太网的发展" class="headerlink" title="以太网的发展"></a>以太网的发展</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071411204.png"/>

<h3 id="以太网适配器和MAC地址"><a href="#以太网适配器和MAC地址" class="headerlink" title="以太网适配器和MAC地址"></a>以太网适配器和MAC地址</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071412168.png"/>



<h3 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h3><p>注释：</p>
<ol>
<li>这里的mac层指的是数据链路层</li>
<li>之前说过数据链路层将上一层ip数据包加头加尾<br>头就是目标地址（6字节），源地址（6字节），类型（2字节）<br>尾就是FCS（帧检验序列），（4字节）</li>
<li>前导码<strong>不是MAC帧的一部分</strong>，目的是使时钟同步</li>
<li>为什么数据长度时46~1500？<br>因为有最小传输字节64字节，mac占用6+6+2+4&#x3D;18，所以数据最小为64-18&#x3D;46，1500则是规定的默认最大字节，没有理由</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071413876.png"/>

<h3 id="其他以太网"><a href="#其他以太网" class="headerlink" title="其他以太网"></a>其他以太网</h3><h4 id="10BASE-T以太网："><a href="#10BASE-T以太网：" class="headerlink" title="10BASE-T以太网："></a>10BASE-T以太网：</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071414584.png"/>

<h4 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071415991.png"/>



<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071415479.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071415763.png"/>

<h3 id="两种无线局域网"><a href="#两种无线局域网" class="headerlink" title="两种无线局域网"></a>两种无线局域网</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071416831.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071417439.png"/>

<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>广域网（WAN,WideAreaNetwork),通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。<br>广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网（Interne是世界范围内最大的广域网。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071418972.png"/>

<h2 id="PPP协议（Point-to-Point-Protocol）"><a href="#PPP协议（Point-to-Point-Protocol）" class="headerlink" title="PPP协议（Point-to-Point Protocol）"></a>PPP协议（Point-to-Point Protocol）</h2><p>PPP协议是目前<strong>使用最广泛</strong>的数据链路层协议，拨号基本都是PPP协议<br>PPP协议<strong>仅支持全双工</strong>链路</p>
<h3 id="PPP协议需要满足的要求"><a href="#PPP协议需要满足的要求" class="headerlink" title="PPP协议需要满足的要求"></a>PPP协议需要满足的要求</h3><ul>
<li><strong>简单</strong>：对于链路层的帧，无需纠错，无需序号，无需流量控制。</li>
<li><strong>封装成帧</strong>：帧定界符</li>
<li><strong>透明传输</strong>：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充。</li>
<li><strong>多种网络层协议</strong>：封装的IP数据报可以采用多种协议。</li>
<li><strong>多种类型链路</strong>：串行&#x2F;并行，同步&#x2F;异步，电&#x2F;光….</li>
<li><strong>差错检测</strong>：错就丢弃。</li>
<li><strong>检测连接状态</strong>：链路是否正常工作。</li>
<li><strong>最大传送单元</strong>：数据部分最大长度MTU。</li>
<li><strong>网络层地址协商</strong>：知道通信双方的网络层地址。</li>
<li><strong>数据压缩协商</strong>：</li>
</ul>
<h3 id="PPP协议不需要满足的要求"><a href="#PPP协议不需要满足的要求" class="headerlink" title="PPP协议不需要满足的要求"></a>PPP协议不需要满足的要求</h3><ul>
<li><strong>纠错</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>序号</strong></li>
<li><strong>不支持多点线路</strong></li>
</ul>
<h3 id="PPP协议组成成分以及功能"><a href="#PPP协议组成成分以及功能" class="headerlink" title="PPP协议组成成分以及功能"></a>PPP协议组成成分以及功能</h3><ol>
<li>一个将IP数据报封装到串行链路（同步串行&#x2F;异步串行）的方法。</li>
<li>链路控制协议LCP:建立并维护数据链路连接。<strong>身份验证</strong></li>
<li>网络控制协议NCP:PPP支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>
</ol>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081709387.png"/>

<h2 id="HDLC协议（High-Level-Data-Link-Control）"><a href="#HDLC协议（High-Level-Data-Link-Control）" class="headerlink" title="HDLC协议（High-Level Data Link Control）"></a>HDLC协议（High-Level Data Link Control）</h2><p>高级数据链路控制（High-Level Data Link Control或简称HDLC),是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织（ISO)根据IBM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的.数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p>
<p><strong>采用全双工通信</strong></p>
<p>所有帧采用<strong>CRC检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高。</p>
<h3 id="HDLC的三种站"><a href="#HDLC的三种站" class="headerlink" title="HDLC的三种站"></a>HDLC的三种站</h3><ol>
<li>主站的主要功能是发送命令（包括数据信息）帧、接收响应帧，并负责对整个链路的控制系统的初启流程的控制、差错检测或恢复等。</li>
<li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li>
<li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li>
</ol>
<h4 id="三种数据操作方式："><a href="#三种数据操作方式：" class="headerlink" title="三种数据操作方式："></a>三种数据操作方式：</h4><ol>
<li>正常响应方式</li>
<li>异步平衡方式</li>
<li>异步响应方式</li>
</ol>
<h3 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081713486.png"/>

<h2 id="PPP协议和HDLC协议对比"><a href="#PPP协议和HDLC协议对比" class="headerlink" title="PPP协议和HDLC协议对比"></a>PPP协议和HDLC<strong>协议对比</strong></h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081713039.png"/>

<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>使用网桥时，由于网桥会根据mac地址进行过滤，所以<strong>不会形成冲突域</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081714389.png"/>

<h4 id="两种网桥"><a href="#两种网桥" class="headerlink" title="两种网桥"></a>两种网桥</h4><h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><p>通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时<strong>数据对应的地址</strong>和<strong>网桥自己的接口</strong>，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了</p>
<h5 id="原路由网桥"><a href="#原路由网桥" class="headerlink" title="原路由网桥"></a>原路由网桥</h5><p>在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>网桥接口越来越多，网桥就变成了交换机<br>交换机的任务是接收入链路层帧并将它们转发到出链路<br>交换机自身对节点透明：某节点向另一节点寻址一个帧，顺利地将该帧发送进LAN，而不知道这个帧经过了某个交换机的接收与转发</p>
<p>1）交换机转发与过滤<br>过滤：交换机决定一个帧是应该转发还是应该丢弃<br>转发：决定一个帧应该被导向哪个接口</p>
<p>2）自学习(即插即用)<br>交换机表是自动、动态、自治地建立的，没有来自网络管理员或配置协议的任何干预。换句话说，交换机是自学习的<br>交换机表初始为空<br>源地址为DD-DD-DD-DD-DD-DD的帧从接口x到达时，如果不存在则新建一项；存在则更新当前时间<br>如果一段时间后，在x接口没有来自DD-DD-DD-DD-DD-DD的帧，则将该表项删除</p>
<h4 id="直通式交换机"><a href="#直通式交换机" class="headerlink" title="直通式交换机"></a>直通式交换机</h4><p>查完目的地址（6B)就立刻转发。<br>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</p>
<h4 id="存储转发式交换机"><a href="#存储转发式交换机" class="headerlink" title="存储转发式交换机"></a>存储转发式交换机</h4><p>将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<br>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</p>
<h3 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081716097.png"/>

<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>各层次的传输单元</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>报文</td>
</tr>
<tr>
<td>传输层</td>
<td>报文段</td>
</tr>
<tr>
<td>网络层</td>
<td>IP数据报，分组（如果IP数据报太大就切割成分组）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧</td>
</tr>
<tr>
<td>物理层</td>
<td>比特流</td>
</tr>
</tbody></table>
<p>网络层的主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层的传输单位是*<strong>数据报</strong></p>
<h2 id="路由选择与分组转发"><a href="#路由选择与分组转发" class="headerlink" title="路由选择与分组转发"></a>路由选择与分组转发</h2><p>路由器主要完成两个功能:是<code>路由选择 (确定哪一 条路径)</code>，二是<code>分组转发 (当一个分组 到达时所采取的动作)</code>。</p>
<ul>
<li>1)<strong>路由选择</strong>。指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑<br>的变化情况，动态地改变所选择的路由。</li>
<li>2)分组转发。指路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li>
</ul>
<p><code>路由表</code>是根据<code>路由选择算法</code>得出的，而<code>转发表</code>是从<code>路由表</code>得出的。<br><code>路由表</code>则需要对<code>网络拓扑变化的计算最优化</code>,<code>转发表</code>的结构应当使<code>查找过程最优化</code>。<br>在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</p>
<h2 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h2><p>所谓<code>异构网络互联</code>，是指将两个以上的不同的计算机网络，通过一定的方法， 用一种或多种通信处理设备(即中间设备)相互连接起来，以构成更大的网络系统。中间设备又称<code>中间系统</code>或<code>中继系统</code>。<br>根据所在的层次，<code>中继系统</code>分为以下4种:</p>
<ul>
<li>1)物理层中继系统:中继器，集线器(Hub)。</li>
<li>2)数据链路层中继系统:网桥或交换机。</li>
<li>3)网络层中继系统:路由器。</li>
<li>4)网络层以上的中继系统:网关。</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><code>网络互联</code>通常是指用<code>路由器</code>进行网络互联和路由选择。<br><code>路由器</code>是一一台专用计算机，用于在互联网中进行&#96;路由选择。</p>
<ul>
<li>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为<code>拥塞</code>。</li>
<li><code>判断网络是否进入拥塞状态的方法</code>是，观察网络的<code>吞吐量与网络负载的关系</code>:如果随着<code>网络负载的增加</code>，<code>网络的吞吐量明显小于正常的吞吐量</code>，那么网络就可能已进入“<code>轻度拥塞”</code>状态;如果<code>网络的负载继续增大</code>，而网络的<code>吞吐量下降到零</code>，那么网络就可能已进入<code>死锁状态</code>。</li>
<li><code>拥塞控制的作用是确保子网能够承载所达到的流量</code>，这是一一个全局性的过程，涉及各方面的行为:主机、路由器及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞。</li>
<li><code>流量控制</code>和<code>拥塞控制</code>的<code>区别</code>:</li>
<li>·<code>流量控制</code>往往是指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li><code>拥塞控制</code>必须确保通信子网能够传送待传送的数据，是一一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。</li>
<li><code>拥塞控制的方法有两种</code>:<br>1)·<code>开环控制</code>。在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。这是一种<code>静态</code>的预防方法。一旦整个系统启动并运行，中途就不再需要修改。开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度决策等。所有这些手段的共性是，在做决定时不考虑当前网络的状态。<br>2)<code>闭环控制</code>。事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。闭环控制是基于反馈环路的概念，是一种<code>动态</code>的方法。</li>
</ul>
<h2 id="传输单元名词解析"><a href="#传输单元名词解析" class="headerlink" title="传输单元名词解析"></a>传输单元名词解析</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081723792.png"/>

<ul>
<li>这里探讨的电路交换、报文交换、分组交换，我们可以把这三种交换方式的交换数据单位看成一个整体去理解，不要过分去细究以上几种传输单元名词与这三种交换方式的关系。</li>
</ul>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>就类似于打电话，两端建立起有效通路</p>
<ul>
<li>在进行数据传输前，两个结点之间必须先建立一条专用 (双方独占)的物理通信路径(由通信双方之间的交换设备和链路逐段连接而成)，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束后才被释放。</li>
<li>因此，电路交换技术分为三个阶段:<code>连接建立、数据传输和连接释放</code>。</li>
<li>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输的过程中，<code>用户始终占用端到端的固定传输带宽</code>。</li>
</ul>
<p>电路交换技术的<strong>优点如下</strong><br>1)<code>通信时延小</code>。由于通信线路为通信双方用户专用，数据直达，因此传输数据的时延非常小。当传输的数据量较大时，这-优点非常 明显。<br>2)<code>有序传输</code>。双方通信时按发送顺序传送数据，不存在失序问题。<br>3)<code>没有冲突</code>。不同的通信双方拥有不同的信道，不会出现争用物理信道的问题。<br>4)<code>适用范围广</code>。电路交换既适用于传输模拟信号，又适用于传输数字信号。<br>5)<code>实时性强</code>。通信双方之间的物理通路一旦建立， 双方就可以随时通信。<br>6)<code>控制简单</code>。电路交换的交换设备(交换机等)及控制均较简单。</p>
<p>电路交换技术的<strong>缺点如下</strong><br>1)<code>建立连接时间长</code>。电路交换的平均连接建立时间对计算机通信来说太长。<br>2)<code>线路独占，使用效率低</code>。电路交换连接建立后，物理通路被通信双方独占，即使通信线<br>路空闲，也不能供其他用户使用，因而信道利用率低。<br>3)<code>灵活性差</code>。只要在通信双方建立的通路中的任何一点出了故障，就必须重新拨号建立新<br>的连接，这对十分紧急和重要的通信是很不利的。<br>4)<code>难以规格化</code>。电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互<br>进行通信，也难以在通信过程中进行<code>差错控制</code>。</p>
<p>注意，电路建立后，除源结点和目的结点外，电路上的任何结点都采取<code>“直通方式”</code>接收数<br>据和发送数据，即不会存在存储转发所耗费的时间。</p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101259668.png"/>

<ul>
<li>数据交换的单位是报文，报文携带有源地址，目标地址，数据等信息。</li>
<li><code>报文交换的主要特点是</code>：存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。 中文名报文交换，外文名Message switching。</li>
<li>报文交换技术的<code>优点</code>如下:<br>1)<code>无须建立连接</code>。报文交换不需要为通信双方预先建立一条专用的通信线路，不存在建立<br>连接时延，用户可以随时发送报文。<br>2)<code>动态分配线路</code>。当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择<br>一条合适的空闲线路，将报文发送出去。<br>3)<code>提高线路可靠性</code>。如果某条传输路径发生故障，那么可重新选择另一条路径传输数据，<br>因此提高了传输的可靠性。<br>4)<code>提高线路利用率</code>。通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地<br>部分占有这条物理通道，因而大大提高了通信线路的利用率。<br>5)<code>提供多目标服务</code>。一个报文可以同时发送给多个目的地址，这在电路交换中是很难实现的。</li>
<li>报文交换技术的<code>缺点</code>如下:<br>1)由于数据进入交换结点后要经历存储、转发这一过程，因此会引起<code>转发时延</code>(包括接收<br>报文、检验正确性、排队、发送时间等)。<br>2)报文交换对报文的大小没有限制，这就要求<code>网络结点需要有较大的缓存空间</code>。</li>
</ul>
<p>注意:报文交换主要使用在早期的电报通信网中，现在较少使用，通常被较先进的<strong>分组交换</strong>方式所取代。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101300956.png"/>

<ul>
<li>同报文交换一样，分组交换也采用存储转发方式，但解决了报文交换中大报文传输的问题。分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息(如源地址、目的地址和编号信息等)，构成分组(Packet)。 网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。到达目地之后的数据分组再重新组合起来，形成一条完整的数据。</li>
<li>分组交换的<code>优点</code>如下:<br>1)<code>无建立时延</code>。不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。<br>2)<code>线路利用率高</code>。通信双方不是固定占有- -条通信线路，而是在不同的时间一-段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。<br>3)<code>简化了存储管理(相对于报文交换)</code>。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。<br>4)<code>加速传输</code>。分组是逐个传输的，可以使后-一个分组的存储操作与前一一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组所 需的缓冲区比传输一次报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的概率及时间也必然少得多。<br>5)<code>减少了出错概率和重发数据量</code>。因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。</li>
<li>分组交换的<code>缺点</code>如下:<br>1)<code>存在传输时延</code>。尽管分组交换比报文交换的传输时延少，但相对于电路交换仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。<br>2)<code>需要传输额外的信息量</code>。每个小数据块都要加上源地址、目的地址和分组编号等信息，从而构成分组，因此使得传送的信息量增大了5%~10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。<br>3)<code>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组</code>，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</li>
<li><code>分组交换</code>根据其<code>通信子网向端点系统提供的服务</code>，还可进一步分为<code>面向连接的虚电路</code>方式和<br><code>无连接的数据报方式</code>。这两种服务方式都由网络层提供。要注意<code>数据报方式</code>和<code>虚电路方式</code>是<code>分组 交换的两种方式</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101301443.png"/>

<h4 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h4><p><strong>无连接</strong>：无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。<br><strong>每个分组携带源和目的地址</strong><br><strong>路由器根据分组的目的地址转发分组</strong>：基于路由协议&#x2F;算法构建转发表；检索转发表；每个分组独立选路。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101305131.png"/>

<p>作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有<code>序号的数据单元</code>，并在网络层加上地址等控制信息后形成数据报分组(即网络层PDU)。<code>中 间结点存储分组</code>很短一段时间，找到<code>最佳的路由</code>后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按·<code>不同的顺序到达目的结点</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101307025.png"/>

<h4 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101308057.png"/>

<ul>
<li>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的<code>虚电路号</code>分配给该虛电路，以区别于本系统中的其他虚电路。在传送数据时，<code>每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号</code>，以区别于其他虚电路上的分组。在虚电路网络中的每个结点上都维持–张<code>虚电路表</code>，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。<code>数据的传输是双向进行的</code>，上述信息是在虚电路的建立过程中确定的。</li>
<li><code>虚电路之所以是“虚”的，是因为这条电路不是专用的·</code>，每个结点到其他结点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。</li>
</ul>
<h4 id="数据报服务和虛电路服务的比较"><a href="#数据报服务和虛电路服务的比较" class="headerlink" title="数据报服务和虛电路服务的比较"></a>数据报服务和虛电路服务的比较</h4><table>
<thead>
<tr>
<th></th>
<th>数据报服务</th>
<th>虚电路服务</th>
</tr>
</thead>
<tbody><tr>
<td>连接的建立</td>
<td>不需要</td>
<td>必须有</td>
</tr>
<tr>
<td>目的地址</td>
<td>每个分组都有完整的目的地址</td>
<td>仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td>
</tr>
<tr>
<td>路由选择</td>
<td>每个分组独立地进行路由选择和转发</td>
<td>属于同一条虚电路的分组按照同一路由转发</td>
</tr>
<tr>
<td>分组顺序</td>
<td>不保证分组的有序到达</td>
<td>保证分组的有序到达</td>
</tr>
<tr>
<td>可靠性</td>
<td>不保证可靠通信，可靠性由用户主机来保证</td>
<td>可靠性由网络保证</td>
</tr>
<tr>
<td>对网络故障的适应性</td>
<td>出故障的结点丢失分组，其他分组的路径选择发生变化时可以正常传输</td>
<td>所有经过故障结点的虚电路均不能正常工作</td>
</tr>
<tr>
<td>差错处理和流量控制</td>
<td>由用户主机进行流量控制，不保证数据报的可靠性</td>
<td>可有分组交换网负责，也可由用户主机负责</td>
</tr>
</tbody></table>
<h2 id="报文交换与分组交换的时间消耗比较"><a href="#报文交换与分组交换的时间消耗比较" class="headerlink" title="报文交换与分组交换的时间消耗比较"></a>报文交换与分组交换的时间消耗比较</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301122005748.png"/>

<h2 id="电路交换、报文交换、分组交换的交换方式比较"><a href="#电路交换、报文交换、分组交换的交换方式比较" class="headerlink" title="电路交换、报文交换、分组交换的交换方式比较"></a>电路交换、报文交换、分组交换的交换方式比较</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301122006956.png"/>

<h2 id="路由算法分类与路由表"><a href="#路由算法分类与路由表" class="headerlink" title="路由算法分类与路由表"></a>路由算法分类与路由表</h2><p><code>路由器转发分组</code>是通过<code>路由表</code>转发的，而<code>路由表</code>是通过<code>各种算法</code>得到的。从能否随网络的通<br>信量或拓扑自适应地进行调整变化来划分，<code>路由算法</code>可分为两大类：<code>静态路由与动态路由</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301142205301.png"/>

<h3 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h3><table>
<thead>
<tr>
<th>路由算法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>静态路由算法（非自适应路由算法）</td>
<td>管理员手工配置路由信息<br>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。<br />路由更新慢，不适用大型网络。</td>
</tr>
<tr>
<td>动态路由算法（自适应路由算法）</td>
<td>路由器间彼此交换信息，按照路由算法优化出路由表项。<br />路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。<br />算法复杂，增加网络负担。</td>
</tr>
</tbody></table>
<h4 id="动态路由的两种算法：链路状态路由算法和距离向量路由算法"><a href="#动态路由的两种算法：链路状态路由算法和距离向量路由算法" class="headerlink" title="动态路由的两种算法：链路状态路由算法和距离向量路由算法"></a>动态路由的两种算法：链路状态路由算法和距离向量路由算法</h4><table>
<thead>
<tr>
<th>动态路由算法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>全局性</td>
<td>链路状态路由算法OSPF<br />所有路由器掌握完整的网络拓扑和链路费用信息</td>
</tr>
<tr>
<td>分散性</td>
<td>距离向量路由算法RIP<br />路由器只掌握物理相连的邻居及链路费用</td>
</tr>
</tbody></table>
<ul>
<li>链路状态路由算法和距离向量路由算法的<code>比较</code></li>
<li><code>在距离-向量路由算法中</code>，每个结点仅与它的直接<code>邻居</code>交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计。</li>
<li><code>在链路状态路由算法中</code>，每个结点通过<code>广播</code>的方式与所有<code>其他结点</code>交谈，但它仅告诉它们与它直接相连的链路的费用。</li>
<li>相较之下，距离-向量路由算法有可能遇到路由环路等问题。</li>
</ul>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>(1)因特网规模很大出现一些问题和消耗</p>
<p>(2)许多单位不想让外界知道自己的路由选择协议，但还想连入因特网</p>
<p><strong>自治系统AS</strong>:在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。</p>
<p>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</p>
<table>
<thead>
<tr>
<th>路由选择协议</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内部网关协议IGP</td>
<td>一个AS内使用的RIP、OSPF</td>
</tr>
<tr>
<td>外部网关协议EGP</td>
<td>AS之间使用的BGP</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161941137.png"/>

<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h3 id="IP数据报的三种传输方式"><a href="#IP数据报的三种传输方式" class="headerlink" title="IP数据报的三种传输方式"></a>IP数据报的三种传输方式</h3><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p>一对一</p>
<p>单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式。</p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>一对多</p>
<p>广播是指发送数据包到同一广播域或子 网内的所有设备的一种数据传输方式， 是一种点对多点传输方式。</p>
<h4 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h4><p>一对特定多</p>
<p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种<strong>点对多点</strong>传输方式。</p>
<ul>
<li>为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制。</li>
<li>使用多个单播传送来仿真组播总是可能的，但这会引起主机上大量的处理开销和网络上太多的交通量。</li>
<li><code>人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收</code>。</li>
</ul>
<p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一《自不同的物理网络（如果有组播路由器的支持）。运行组播协议的路由器</p>
<h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3><p>如何才能发给同一组主机相同的数据呢？这就需要了解一下IP组播地址，他就是干这个的。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161953518.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161959346.png"/>

<h3 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h3><h4 id="IGMP-国际组管理协议"><a href="#IGMP-国际组管理协议" class="headerlink" title="IGMP-国际组管理协议"></a>IGMP-国际组管理协议</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161959297.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162000044.png"/>

<h4 id="IGMP工作的两个阶段"><a href="#IGMP工作的两个阶段" class="headerlink" title="IGMP工作的两个阶段"></a>IGMP工作的两个阶段</h4><ol>
<li><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>
</li>
<li><p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。 只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机 应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p>
</li>
</ol>
<p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p>
<h3 id="组播路由"><a href="#组播路由" class="headerlink" title="组播路由"></a>组播路由</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162009778.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162010848.png"/>

<h3 id="组播路由选择选择协议常用的三种路由算法"><a href="#组播路由选择选择协议常用的三种路由算法" class="headerlink" title="组播路由选择选择协议常用的三种路由算法"></a>组播路由选择选择协议常用的三种路由算法</h3><ol>
<li><p>基于链路状态的路由选择</p>
</li>
<li><p>基于距离-向量的路由选择</p>
</li>
<li><p>协议无关的组播（稀疏&#x2F;密集）</p>
</li>
</ol>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><ul>
<li>支持移动性的因特网体系结构与协议共称为移动IP,它是为了满足移动结点(计算机、服务、网段等)在移动中保持其连接性而设计的。</li>
<li>更确切地说，移动IP技术是指<code>移动结点以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变。</code></li>
<li>移动IP的目标是把分组自动地投递给移动结点。一个移动结点是把其连接点从一个网络或子网改变到另-一个网络或子网的主机。</li>
<li>使用移动IP，<code>一个移动结点可以在不改变其IP地址的情况下改变其驻留位置。</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162013000.png"/>

<h3 id="移动IP相关术语"><a href="#移动IP相关术语" class="headerlink" title="移动IP相关术语"></a>移动IP相关术语</h3><p>移动IP技术是移动结点（计算机&#x2F;服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p>
<ul>
<li><strong>移动结点</strong>具有永久IP地址的移动设备。</li>
<li><strong>归属代理（本地代理）</strong>一个移动结点拥有的就“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</li>
<li><strong>外部代理（外地代理）</strong>在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</li>
<li><strong>永久地址（归属地址&#x2F;主地址）</strong>移动站点在归属网络中的原始地址。</li>
<li><strong>转交地址（辅地址）</strong>移动站点在外部网络使用的临时地址。</li>
</ul>
<h3 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162016144.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162016198.png"/>

<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162018903.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162018688.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162019444.png"/>

<h2 id="三个设备之间的区别"><a href="#三个设备之间的区别" class="headerlink" title="三个设备之间的区别"></a>三个设备之间的区别</h2><ul>
<li>路由器可以互联两个不同网络层协议的网段。</li>
<li>网桥可以互联两个物理层和链路层不同的网段。</li>
<li>集线器不能互联两个物理层不同的网段。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>能否隔离冲突域</th>
<th>能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td>物理层设备【傻瓜】<br />（中继器、集线器）</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>链路层设备【路人】<br />（网桥、交换机）</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>网络层设备【大佬】<br />（路由器）</td>
<td>能</td>
<td>能</td>
</tr>
</tbody></table>
<h2 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162021091.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络(1)-概述与物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-06 15:07:47" itemprop="dateCreated datePublished" datetime="2022-11-06T15:07:47+08:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-21 11:53:04" itemprop="dateModified" datetime="2022-12-21T11:53:04+08:00">2022-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><p>计算机网络：是一个将分散的、具有独立功能的计算机系统</span>，通过<span style="color:red">通信设备与线路</span>连接起来，有功能完善的<span style="color:red">软件</span>实现<span style="color:green">资源共享和信息传递</span>的系统</p>
<p>计算机网络是<span style="color:red">互联的，自治的</span>的计算机集合。</p>
<ul>
<li>互联：互联互通 通信链路</li>
<li>自治：无主从关系</li>
</ul>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ol>
<li><p>数据通信（连通性）</p>
<p>数据通信是计算机网络最基本和最重要的功能，实现联网计算机之间的各种信息传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理</p>
</li>
<li><p>资源共享（硬件，软件，数据）</p>
<ul>
<li>资源共享可以是软件共享、数据共享和硬件共享</li>
<li>计算机网络中的资源互通有无，分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</li>
</ul>
</li>
<li><p>分布式处理（多台计算机各自承担同一工作任务的不同部分）</p>
<ul>
<li>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其它计算机系统，让它帮你处理，从而利用空闲计算机资源以提高整个系统的利用率</li>
</ul>
</li>
<li><p>提高可靠性</p>
<ul>
<li>计算机网络中的各台计算机可以通过网络互为替代机，当一台计算机崩了，可以让另一台计算机来完成它的工作</li>
</ul>
</li>
<li><p>负载均衡</p>
<ul>
<li>将工作任务均衡的分配给计算机网络中的各台计算机</li>
</ul>
</li>
<li><p>…</p>
</li>
</ol>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><p><strong>组成部分</strong>：硬件、软件、协议</p>
<ul>
<li>硬件主要由主机(也称端系统)，通信链路(如双绞线、光纤)、交换设备(如路由、交换机等)和通信处理机(如网卡)等组成</li>
<li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件(如网络操作系统、邮件收发程序、FTP程序、聊天程序等)。</li>
<li>协议是计算机网络的核心，协议规定了网络传输数据时所遵循的规范。就如同我们现实生活中的法律一样，网络世界也必须遵循一定的规则。</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ol>
<li><p>边缘部分 用户直接使用（C&#x2F;S方式、P2P方式）</p>
<ul>
<li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信(如传输数据、音频或视频)和资源共享</li>
</ul>
</li>
<li><p>核心部分 为边缘部分服务</p>
<p>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</p>
</li>
</ol>
<p><strong>功能组成</strong>：</p>
<ol>
<li>通信子网 实现数据通信</li>
<li>资源子网 实现资源共享&#x2F;数据处理</li>
</ol>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ol>
<li>按分布范围分：<code>广域网WAN</code> <code>城域网MAN</code> <code>局域网WAN</code> <code>个人区域网PAN</code>（广域网是交换技术，局域网是广播技术）</li>
<li>按使用者分：<code>公用网</code> <code>专用网</code></li>
<li>按交换技术分：<code>电路交换</code> <code>报文交换</code> <code>分组交换</code></li>
<li>按拓扑结构分：<code>总线型</code> <code>星型</code> <code>环形</code> <code>网状型</code></li>
<li>按传输技术分：<code>广播式网络：共享公共通信信道</code> <code>点对点网络：</code></li>
</ol>
<h1 id="计算机网络的标准化工作"><a href="#计算机网络的标准化工作" class="headerlink" title="计算机网络的标准化工作"></a>计算机网络的标准化工作</h1><h2 id="标准化的分类"><a href="#标准化的分类" class="headerlink" title="标准化的分类"></a>标准化的分类</h2><p>法定标准：由权威机构制定的正式的、合法的标准 <strong><span style="color:red">OSI</span></strong></p>
<p>事实标准：某些公司的产品在竞争中占据了主流 <strong><span style="color:red">TCP&#x2F;IP</span></strong></p>
<h2 id="标准化工作"><a href="#标准化工作" class="headerlink" title="标准化工作"></a>标准化工作</h2><p>RFC(Request For Comments) 因特网标准的形式</p>
<p>RFC要上升为因特网正式标准的四个阶段</p>
<p>因特网草案（Internet Draft）：这个阶段还不是RFC文档</p>
<p>建议标准（Proposed Standard）：从这个阶段开始成为RFC文档</p>
<p><del>草案标准（Draft Standard）：近年已取消</del></p>
<p>因特网标准（Internet Standard）</p>
<h2 id="标准化工作的相关组织"><a href="#标准化工作的相关组织" class="headerlink" title="标准化工作的相关组织"></a>标准化工作的相关组织</h2><p><strong>国际标准化组织ISO</strong> OSI参考模型、HDLC协议</p>
<p><strong>国际电信联盟ITU</strong> 指定通信标准</p>
<p><strong>国际电气电子工程师协会IEEE</strong> 学术机构、IEEE802系列标准、5G</p>
<p><strong>Internet工程任务组IETF</strong> 负责因特网相关标准的制定 RFC</p>
<h1 id="速率相关性能指标"><a href="#速率相关性能指标" class="headerlink" title="速率相关性能指标"></a>速率相关性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率即数据率或称数据传输率或比特率</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>表示</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td>比特</td>
<td>1&#x2F;0</td>
<td>位</td>
</tr>
</tbody></table>
<p>连接在计算机网络上的主机在数字信道上传送数据位数的速率</p>
<p>单位是<code>b/s</code> <code>kb/s</code> <code>Mb/s</code> <code>Gb/s</code> <code>Tb/s</code></p>
<p><span style="color:red">注意：速率单位的转化是10^3 ，而存储单位的转化是1024<br>其中的，存储容量1Byte（字节）&#x3D;8bit（比特）<br>1KB&#x3D;2^10B&#x3D;1024B&#x3D;1024*8b</span></p>
<table>
<thead>
<tr>
<th>名称</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>千</td>
<td>1kb&#x2F;s&#x3D;10^3b&#x2F;s</td>
</tr>
<tr>
<td>兆</td>
<td>1Mb&#x2F;s&#x3D;10^3kb&#x2F;s&#x3D;10^6b&#x2F;s</td>
</tr>
<tr>
<td>吉</td>
<td>1Gb&#x2F;s&#x3D;10^3Mb&#x2F;s&#x3D;10^6kb&#x2F;s&#x3D;10^9b&#x2F;s</td>
</tr>
<tr>
<td>太</td>
<td>1Tb&#x2F;s&#x3D;10^3Gb&#x2F;s&#x3D;10^6Mb&#x2F;s&#x3D;10^9kb&#x2F;s&#x3D;10^12b&#x2F;s</td>
</tr>
</tbody></table>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><ol>
<li><p>“带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz)。</p>
</li>
<li><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b&#x2F;s,kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s。<br><strong>网络设备所支持的最高速度</strong></p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235333.png"/>

<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>表示在<span style="color:red">单位时间内通过某个网络（或信道、接口）的数据量</span>。单位b&#x2F;s,kb&#x2F;s,Mb&#x2F;s等。</p>
<p>速率就是实际网速，带宽是理论网速，吞吐量是一个或多个设备的综合速率，比如说1000m宽带的路由器连着三部手机，每部手机都是10mb&#x2F;s看片，那么速率就是10mb&#x2F;s，带宽是宽带的1000m，路由器吞吐量是30mb&#x2F;s，即三者之和</p>
<h1 id="时延、时延带宽积、RTT和利用率"><a href="#时延、时延带宽积、RTT和利用率" class="headerlink" title="时延、时延带宽积、RTT和利用率"></a>时延、时延带宽积、RTT和利用率</h1><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>指数据（报文&#x2F;分组&#x2F;比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>计算公式</th>
</tr>
</thead>
<tbody><tr>
<td>发送时延</td>
<td>数据从主机到信道上所用的时间</td>
<td>发送的数据长度&#x2F;信道速率（发送速率）</td>
</tr>
<tr>
<td>传播时延</td>
<td>数据在信道上传播所花费的时间</td>
<td>信道长度&#x2F;电磁波在信道上传播的速率</td>
</tr>
<tr>
<td>排队时延</td>
<td>数据在路由器前等待前面数据处理的时间</td>
<td>无计算方式</td>
</tr>
<tr>
<td>处理时延</td>
<td>数据在路由器中处理需求的时间</td>
<td>无计算方式</td>
</tr>
</tbody></table>
<p>使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延</p>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>公式：时延带宽积（bit）&#x3D;传播时延（s）x带宽（b&#x2F;s）</p>
<p>时延带宽积又称为<span style="color:red">比特为单位的链路长度</span></p>
<p>意思是链路上有多少比特的数据</p>
<h2 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h2><p>发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多</p>
<p>RTT&#x3D;<strong>传播时延</strong>x2+处理时间(有时可能直接忽略)</p>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>信道利用率&#x3D;有数据通过<strong>时间</strong>&#x2F;（有+无）数据通过<strong>时间</strong></p>
<h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p>网络利用率&#x3D;所有信道利用率加权求平均值</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235459.png"/>

<h1 id="分层结构，协议，接口，服务"><a href="#分层结构，协议，接口，服务" class="headerlink" title="分层结构，协议，接口，服务"></a>分层结构，协议，接口，服务</h1><p>网络为什么要分层：</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行<span style="color:red">激活</span></li>
<li>要告诉网络如何识别目的主机</li>
<li>发起通信的计算机要查明目的的主机是否开机，并且与网络连接是否正常</li>
<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作</li>
<li>确保差错和意外可以解决。</li>
<li>等等</li>
</ol>
<h2 id="正式认识分层结构"><a href="#正式认识分层结构" class="headerlink" title="正式认识分层结构"></a>正式认识分层结构</h2><ol>
<li>实体：第n层中的活动元素称为<span style="color:red">n层实体</span>。一层的实体叫<span style="color:red">对等实体</span></li>
<li>协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。</li>
<li>接口（访问服务店SAP）：上层使用下层服务的入口</li>
<li>服务：下层为相邻上层提供的功能调用</li>
</ol>
<p><strong>SDU服务数据单元：为完成用户所要求的功能而应传送的数据。</strong><br><strong>PCI协议控制信息：控制协议操作的信息。</strong><br><strong>协议数据单元：对等层次之间传送的数据单位。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235911.png"/>

<ul>
<li><p>网络体系结构是从功能上描述计算机网络结构。</p>
</li>
<li><p>计算机网络体系结构简称网络体系结构是分层结构。</p>
</li>
<li><p>每层遵循某个&#x2F;些网络协议以完成本层功能。</p>
</li>
<li><p>计算机网络体系结构是计算机网络的各层及其协议的集合。</p>
</li>
<li><p>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</p>
</li>
<li><p>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</p>
</li>
<li><p>体系结构是抽象的，而实现是指能运行的一些软件和硬件。</p>
</li>
</ul>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>计算机网络分层结构：</p>
<p>7层OSI参考模型（法定标准）</p>
<p>4层TCP&#x2F;IP参考模型（事实标准）</p>
<p>5层体系结构</p>
<h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><p>ISO&#x2F;OSI参考模型</p>
<p>1-3通信子网（数据通信） 5-7资源子网（数据处理）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>7.应用层</td>
<td>Application Layer</td>
<td>直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等</td>
</tr>
<tr>
<td>6.表示层</td>
<td>Presentation Layer</td>
<td>把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息</td>
</tr>
<tr>
<td>5.会话层</td>
<td>Session Layer</td>
<td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接</td>
</tr>
<tr>
<td>4.传输层</td>
<td>Transport Layer</td>
<td>负责端到端通讯，可靠传输，不可靠传输 ，差错控制，流量控制，复用分用</td>
</tr>
<tr>
<td>3.网络层</td>
<td>Network Layer</td>
<td>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。<br />负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制<br />路由选择、流量控制、差错控制、拥塞控制</td>
</tr>
<tr>
<td>2.数据链路层</td>
<td>Data Link Layer</td>
<td>主要任务是把网络层传下来的数据报组装成帧。数据链路层&#x2F;链路层的传输单位是帧。<br />帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)<br />成帧、差错控制、流量控制、访问（接入）控制</td>
</tr>
<tr>
<td>1.物理层</td>
<td>Physical Layer</td>
<td>主要任务是在物理媒体上实现比特流的透明传输。物理层传输单位是比特。<br />定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快<br />透明传输、定义接口特性、定义传输模式、定义传输速率、比特同步</td>
</tr>
</tbody></table>
<h2 id="OSI流程简介"><a href="#OSI流程简介" class="headerlink" title="OSI流程简介"></a>OSI流程简介</h2><p>网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）<br>数据链路层不仅需要加头部，还需要加尾部<br>物理层什么都不加，只管发送数据（比特流）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235931.png"/>

<h2 id="TCP-x2F-IP参考模型"><a href="#TCP-x2F-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h2><p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235958.png"/>面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。</p>
<p>而面向无连接没有这么多阶段，它直接进行数据传输。</p>
<table>
<thead>
<tr>
<th></th>
<th>ISO&#x2F;OSI参考模型</th>
<th>TCP&#x2F;IP模型</th>
</tr>
</thead>
<tbody><tr>
<td>网络层</td>
<td>无连接+面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>传输层</td>
<td>面向连接</td>
<td>无连接+面向连接</td>
</tr>
</tbody></table>
<h2 id="五层参考模型及其传输过程简介"><a href="#五层参考模型及其传输过程简介" class="headerlink" title="五层参考模型及其传输过程简介"></a>五层参考模型及其传输过程简介</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000036.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000126.png"/>

<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111430252.png"/>

<h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。<br>这就叫做”实体层”，逼格高一点的叫法就是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%89%A9%E7%90%86%E5%B1%82&spm=1001.2101.3001.7020">物理层</a>。它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。<br>至于0和1的信号是什么，还轮不到物理层还决定。</p>
<p>物理层解决如何在连接各种计算机的传输媒体上<span style="color:red">传输数据比特流</span>，而不是指具体的传输媒体。</p>
<p>物理层主要任务：确定与传输媒体<span style="color:blue">接口</span>有关的一些特性  ——定义标准</p>
<p><strong>1.机械特性：</strong>定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</p>
<p><strong>2.电气特性：</strong>规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</p>
<p><strong>3.功能特性：</strong>指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</p>
<p>**4.规程特性（过程特性）:**定义各条物理线路的工作规程和时序关系。</p>
<h2 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000151.png"/>

<h3 id="三种通讯方式-单工，半双工，全双工"><a href="#三种通讯方式-单工，半双工，全双工" class="headerlink" title="三种通讯方式 (单工，半双工，全双工)"></a>三种通讯方式 (单工，半双工，全双工)</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>定义</th>
<th>需要信道条数</th>
</tr>
</thead>
<tbody><tr>
<td>单工通信</td>
<td>Simplex</td>
<td>只有一个方向的通信而没有反方向的交互</td>
<td>一条</td>
</tr>
<tr>
<td>半双工通信</td>
<td>half-duplex</td>
<td>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收</td>
<td>两条</td>
</tr>
<tr>
<td>全双工通信</td>
<td>duplex</td>
<td>通信双方可以同时发送和接受信息</td>
<td>两条</td>
</tr>
</tbody></table>
<h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><table>
<thead>
<tr>
<th>传输方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>串行传输</td>
<td>速度慢，省钱，适合远距离</td>
</tr>
<tr>
<td>并行传输</td>
<td>速度快，耗钱，适合近距离</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000718.png"/>

<h3 id="数据、信号、信源、信宿、信道"><a href="#数据、信号、信源、信宿、信道" class="headerlink" title="数据、信号、信源、信宿、信道"></a>数据、信号、信源、信宿、信道</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000730.png"/>

<h2 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h2><h3 id="码元（Symbol）"><a href="#码元（Symbol）" class="headerlink" title="码元（Symbol）"></a>码元（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Symbol&spm=1001.2101.3001.7020">Symbol</a>）</h3><p>定义：码元是指用一个<span style="color:red"><strong>固定时长的信号波形（数字脉冲）</strong></span>,代表不同<strong>离散数值</strong>的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<strong>k进制码元</strong>，而该时长称为<strong>码元宽度</strong>。当<strong>码元的离散状态</strong>有M个时（M大于2),此时码元为<strong>M进制码元</strong>。</p>
<p>1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p>
<p>个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000819.png"/>

<h3 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h3><p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。分为<strong>码元传输速率</strong>和<strong>信息传输速率</strong></p>
<ol>
<li><p>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为<strong>脉冲个数或信号变化的次数</strong>）,单位是**波特（Baud)**。1波特表示数字通信系统每秒传输一码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</p>
<p><strong>1s传输多少个码元： 1Baud &#x3D; 1bit&#x2F;s</strong></p>
</li>
<li><p>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数）,单位是比特&#x2F;秒（b&#x2F;s)。</p>
<p><strong>1s传输多少个比特</strong></p>
</li>
<li><p>关系：若一个码元携带nbit的信息量，则MBaud的码元传输速率所对应的信息传输速率为<br>$$<br>M*n(bit&#x2F;s)<br>$$</p>
</li>
</ol>
<p>码元可以理解为几个比特的<strong>集合</strong>，所以信息传输速率（网速）&#x3D;码元传输速率x码元所带信息量（多少比特）<br>码元所带信息量（比特数）&#x3D;log2（码元进制数）</p>
<h3 id="带宽（Band-Width）"><a href="#带宽（Band-Width）" class="headerlink" title="带宽（Band Width）"></a>带宽（Band Width）</h3><p>带宽：表示在单位时间内从网络中的某一点到另一点所能通过的<strong>“最高数据率”</strong>，常用来表示网络的通信线路所能传输数据的能力。单位是b&#x2F;s。</p>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>某一数字通信系统传输的是四进制码元，4s传输了8000个码元，求系统的码元传输速率是多少？信息传输速率是多少？</p>
<p>若另一通信系统传输的是十六进制码元，6s传输了7200个码元，求他的码元传输速率是多少？信息传输速率是多少？并指出哪个系统传输速率快？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2000Baud,4000b/s;</span><br><span class="line">1200Baud,4800b/s;</span><br><span class="line">十六进制更快</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000852.png"/>

<p>系统传输的是比特流，通常比较的是信息传输速率，所以传输十六进制码元的通信系统传输速率较快，如果用该系统去传输四进制码元会有更高的码元传输速率。</p>
<h2 id="奈式准则（Nyquist）"><a href="#奈式准则（Nyquist）" class="headerlink" title="奈式准则（Nyquist）"></a>奈式准则（Nyquist）</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="（1）失真"><a href="#（1）失真" class="headerlink" title="（1）失真"></a>（1）失真</h4><p>一般而言，由于各方面的影响，信号在信道上传输是不稳定的，会产生误差，即失真。</p>
<p>影响失真程度的因素：</p>
<ol>
<li>码元传输速率  </li>
<li>信号传输距离 </li>
<li>噪声干扰</li>
<li>#传输媒体质量</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000920.png"/>

<h4 id="（2）失真的一种现象-码间串扰"><a href="#（2）失真的一种现象-码间串扰" class="headerlink" title="（2）失真的一种现象-码间串扰"></a>（2）失真的一种现象-码间串扰</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211001129.png"/>

<h3 id="香农准则内容"><a href="#香农准则内容" class="headerlink" title="香农准则内容"></a>香农准则内容</h3><p>奈氏准则：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2WBaud,W是信道带宽，单位是Hz。<br>$$<br>理想低通信道下的极限数据传输率&#x3D;2Wlog_2V(b&#x2F;s)<br>$$</p>
<ol>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的<strong>频带越宽</strong>（即能通过的信号高频分量越多）,就可以用更高的速率进行码元的有效传输。</li>
<li><strong>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</strong></li>
<li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</li>
</ol>
<p>通过下面实例来理解：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211002121.png"/>

<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。信噪比&#x3D;信号的平均功率&#x2F;噪声的平均功率，常记为S&#x2F;N,并用分贝（dB)作为度量单位，即：<br>$$<br>信噪比(dB) &#x3D; 10log_10(S&#x2F;N)<br>$$<br>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<br>$$<br>信道的极限传输速率&#x3D;Wlog_2(1+S&#x2F;N)(b&#x2F;s)<br>$$<br>其中<strong>S&#x2F;N</strong>就是所谓信噪比</p>
<p>S:是信道所传信号的平均功率</p>
<p>N:是信道内的高斯噪声功率</p>
<ol>
<li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li>
<li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</li>
<li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。</li>
<li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li>
<li>从香农定理可以看出，若信道带宽W或信噪比S&#x2F;N没有上限（不可能）,那么信道的极限信息传输速率也就没有上限。</li>
</ol>
<h2 id="基带信号和宽带-x2F-带通信号（Base-band，pass-band）"><a href="#基带信号和宽带-x2F-带通信号（Base-band，pass-band）" class="headerlink" title="基带信号和宽带&#x2F;带通信号（Base band，pass band）"></a>基带信号和宽带&#x2F;带通信号（Base band，pass band）</h2><ul>
<li>根据原始电信号的特征，基带信号可分为数字基带信号和模拟基带信号（相应地，信源也分为数字信源和模拟信源）其由信源决定</li>
<li>宽带信号的定义是传输速度达到200kbps或以上,不管模拟信号还是数字信号只要满足就可算作宽带信号。</li>
</ul>
<p>计算机网络中用的基带信号是<strong>数字信号</strong></p>
<table>
    <tr>
        <td rowspan=2>
          信道上传送的信号
        </td>
        <td>基带信号</td>
        <td>将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。
来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信
            号。基带信号就是发出的<b>直接表达了要传输的信息的信号</b>，比如我们说话的声波就是
基带信号。</td>
    </tr>
    <tr>
        <td>宽带信号</td>
        <td>将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。
把<b>基带信号经过载波调制后</b>，把信号的<b>频率范围搬移到较高的频段以使在信道中传输</b>（即仅
在一段频率范围内能够通过信道)。</td>
    </tr>
</table>

<ul>
<li>在传输距离较<strong>近</strong>时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生变化）</li>
<li>在传输距离较<strong>远</strong>时，计算机网络采用<strong>宽带传输</strong>方式（远距离衰诚大，即使信号变化大也能最后过滤出来基带信号）</li>
</ul>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><ul>
<li><p>数据无论是数字的，还是模拟的，为了传输的目的都必须转变成信号。</p>
</li>
<li><p>把数据变换为数字信号的过程称为<strong>编码</strong>，把数据变换为模拟信号的过程称为<strong>调制</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111339740.png"/></li>
</ul>
<h3 id="编码（数据-gt-数字信号）"><a href="#编码（数据-gt-数字信号）" class="headerlink" title="编码（数据-&gt;数字信号）"></a>编码（数据-&gt;数字信号）</h3><p>将数据转化为<strong>数字信号</strong></p>
<ul>
<li><p>数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111318395.png"/>
</li>
<li><p>模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111321773.png"/></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>简述</th>
<th>缺陷</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单极性不归零编码</strong></td>
<td>只使用一个电压值，高电平表示1，低电平表示0</td>
<td>高1，低0</td>
<td>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步</td>
</tr>
<tr>
<td><strong>双极性不归零编码</strong></td>
<td>用幅值相等的正负电平表示二进制数1和0</td>
<td>正电1，负电0</td>
<td></td>
</tr>
<tr>
<td><strong>单极性归零编码</strong></td>
<td>发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平</td>
<td>变化1，其他时间为0<br>（反向不归零即相反）</td>
<td>信号电平在一个码元之内都要恢夏到零的这种编码成编码方式。<br>接收方根据跳变调整本方的时钟基准，这就为双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响</td>
</tr>
<tr>
<td><strong>双极性归零编码</strong></td>
<td>正负零三个电平，信号本身携带同步信息</td>
<td>正1，负0，默认平时</td>
<td></td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111322473.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>曼彻斯特编码</strong></td>
<td>【以太网的编码方式】单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0<br>这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0</td>
<td>高跳低1，低跳高0</td>
</tr>
<tr>
<td><strong>差分曼彻斯特编码</strong></td>
<td>抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。</td>
<td>逢1跳变</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111351400.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111328328.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>4B&#x2F;5B编码</strong></td>
<td>比特流中插入额外的比特以打破一连串的0或1,就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B&#x2F;5B。编码效率为80%。<br>只采用16种对应16种不同的4位码，其他的16种作为控制码（帧的开始和结束，线路的状态信息等）或保留。</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111353763.png"/>

<h3 id="调制（数据-gt-模拟信号）"><a href="#调制（数据-gt-模拟信号）" class="headerlink" title="调制（数据-&gt;模拟信号）"></a>调制（数据-&gt;模拟信号）</h3><p>常用的调制方法：调频(AM)，调频(FM)，调相(PM)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111355023.png"/>



<h3 id="模拟数据-编码-为数字信号"><a href="#模拟数据-编码-为数字信号" class="headerlink" title="模拟数据 编码 为数字信号"></a>模拟数据 <code>编码</code> 为数字信号</h3><p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制(PCM),在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WV文件中均有应用。它主要包括三步：抽样、量化、编码。</p>
<ul>
<li><strong>抽样</strong>：对模拟信号周期性扫描，把时间上 <strong>连续</strong> 的信号变成时间上 <strong>离散</strong> 的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样</li>
</ul>
<p>$$<br>  f_{采样频率} \geq 2f_{信号最高频率 } （采样频率越大，则采取到的数据更接近原数据）<br>$$</p>
<ul>
<li><p><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把<strong>连续</strong>的<strong>电平幅值</strong>转换为<strong>离散</strong>的<strong>数字量</strong>。</p>
</li>
<li><p><strong>编码</strong>：把量化的结果转换为与之对应的<strong>二进制编码</strong></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111428000.png"/>

<h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据<code>调制</code>为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式：模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<p>简单的说就是将信号放大，避免在传输过程中失真太严重</p>
<h2 id="传输介质及其分类"><a href="#传输介质及其分类" class="headerlink" title="传输介质及其分类"></a>传输介质及其分类</h2><p>传输介质也称传输媒体&#x2F;传输媒介，它就是数据传输系统中在<strong>发送设备和接收设备之间的物理通路。</strong></p>
<p><strong>传输媒体并不是物理层</strong>。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111624253.png"/>

<h2 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>双绞线价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于<strong>模拟传输</strong>，要用放<strong>大器放大衰减的信号</strong>；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111625815.png"/>

<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>基本分为两类：50Ω同轴电缆和75Ω同轴电缆。其中，<strong>50Ω同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆</strong>，它在局域网中得到广泛应用；7<strong>5Ω同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111626179.png"/>

<h3 id="双绞线和同轴电缆的差别"><a href="#双绞线和同轴电缆的差别" class="headerlink" title="双绞线和同轴电缆的差别"></a>双绞线和同轴电缆的差别</h3><p>由于外导体屏蔽层的作用，同轴电缆抗干扰特性比双绞线好，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示1,无光脉冲表示0。而可见光的频率大约是108MHz,因此光纤通信系统的带宽远远大于目前其他各种传输媒体的带宽。</p>
<p><span style="color:gray">光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲；在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</span></p>
<p>光纤主要由<strong>纤芯（实心的！)和包层构成</strong>，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现<strong>全反射</strong>，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111630018.png"/>

<h4 id="单模与多模"><a href="#单模与多模" class="headerlink" title="单模与多模"></a>单模与多模</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111631155.png"/>



<h4 id="光纤的特点"><a href="#光纤的特点" class="headerlink" title="光纤的特点"></a>光纤的特点</h4><p>1.传输损耗小，中继距离长，对远距离传输特别经济。</p>
<p>2.抗雷电和电磁干扰性能好。</p>
<p>3.无串音干扰，保密性好，也不易被窃听或截取数据。</p>
<p>4.体积小，重量轻。</p>
<h2 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111632000.png"/>



<h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p><strong>诞生原因</strong>：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p>
<p><strong>中继器的功能</strong>：对信号进行<strong>再生和还原</strong>，<strong>对衰减的信号进行放大</strong>，保持与原数据相同，以增加信号传输的距离，延长网络的长度。（备注：放大器放大衰减的模拟信号）</p>
<p>中继器的两端：两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类网络</strong>的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。中继器两端的网段一定要是同一个协议。（中继器不会存储转发）</p>
<p><strong>5-4-3规则</strong>：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111636007.png"/>



<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p><strong>集线器的功能</strong>：对信号进行<strong>再生放大转发</strong>，对<strong>衰减的信号进行放大</strong>，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111637092.png"/>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">软件设计师笔记(11)-数据库设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 20:07:03" itemprop="dateCreated datePublished" datetime="2022-10-22T20:07:03+08:00">2022-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-10-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-%E4%B8%8B%E5%8D%88%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-10-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-%E4%B8%8B%E5%8D%88%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">软件设计师笔记(10)-数据流图(下午题）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-20 22:03:27" itemprop="dateCreated datePublished" datetime="2022-10-20T22:03:27+08:00">2022-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
