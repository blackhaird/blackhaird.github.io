<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MEIDE&#39;S BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MEIDE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/07/golang%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/07/golang%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">golang面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-07 21:15:39" itemprop="dateCreated datePublished" datetime="2024-06-07T21:15:39+08:00">2024-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-13 10:21:22" itemprop="dateModified" datetime="2024-06-13T10:21:22+08:00">2024-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Golang面试题"><a href="#Golang面试题" class="headerlink" title="Golang面试题"></a>Golang面试题</h1><h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><p>总结来说，进程侧重于资源隔离，线程侧重于共享资源并发执行，协程则是在单个进程内的轻量级并发，具有更低的切换开销和更高的灵活性。</p>
<p>进程：资源分配和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CPU&spm=1001.2101.3001.7020">CPU</a>调度的基本单位</p>
<p>线程：CPU调度的基本单位，线程除了有一些自己的必要的堆栈空间之外，其它的资源都是共享的线程中的，共享的资源包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.所有线程共享相同的虚拟地址空间，即它们可以访问同样的代码段、数据段和堆栈段。</span><br><span class="line">2.文件描述符：进程打开的文件描述符是进程级别的资源，所以同一个进程中的线程可以共享打开的文件描述符，这意味着它们可以同时读写同一个文件。</span><br><span class="line">3.全局变量：全局变量是进程级别的变量，因此可以被同一个进程中的所有线程访问和修改。</span><br><span class="line">4.静态变量：静态变量也是进程级别的变量，在同一个进程中的线程之间共享内存空间。</span><br><span class="line">5.进程ID、进程组ID</span><br></pre></td></tr></table></figure>

<p>独占的资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、线程ID</span><br><span class="line">2、寄存器组的值</span><br><span class="line">3、线程堆栈</span><br><span class="line">4、错误返回码</span><br><span class="line">5、信号屏蔽码</span><br><span class="line">6、线程的优先级</span><br></pre></td></tr></table></figure>

<p>协程：用户态的线程，可以通过用户程序创建、删除。协程切换时不需要切换内核态。</p>
<p>协程与线程的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.线程是操作系统的概念，而协程是程序级的概念。线程由操作系统调度执行，每个线程都有自己的执行上下文，包括程序计数器、寄存器等。而协程由程序自身控制。</span><br><span class="line">2.多个线程之间通过切换执行的方式实现并发。线程切换时需要保存和恢复上下文，涉及到上下文切换的开销。而协程切换时不需要操作系统的介入，只需要保存和恢复自身的上下文，切换开销较小。</span><br><span class="line">3.线程是抢占式的并发，即操作系统可以随时剥夺一个线程的执行权。而协程是合作式的并发，协程的执行权由程序自身决定，只有当协程主动让出执行权时，其他协程才会得到执行机会。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程的优点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个新线程的代价要比创建一个新进程小的多</span><br><span class="line">2.线程之间的切换相较于进程之间的切换需要操作系统做的工作很少</span><br><span class="line">3.线程占用的资源要比进程少很多</span><br><span class="line">4.能充分利用多处理器的可并行数量</span><br><span class="line">5.等待慢速 IO操作结束以后，程序可以执行其他的计算任务</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.性能损失（ 一个计算密集型线程是很少被外部事件阻塞的，无法和其他线程共享同一个处理器，当计算密集型的线程的数量比可用的处理器多，那么就有可能有很大的性能损失，这里的性能损失是指增加了额外的同步和调度开销，二可用资源不变。）</span><br><span class="line">2.健壮性降低（线程之间是缺乏保护性的。在一个多线程程序里，因为时间上分配的细微差距或者是共享了一些不应该共享的变量而造成不良影响的可能影响是很大的。）</span><br><span class="line">3.缺乏访问控制（ 因为进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响 。）</span><br><span class="line">4.编程难度提高（编写和 调试一个多线程程序比单线程困难的多。）</span><br></pre></td></tr></table></figure>

<p>有栈协程和无栈协程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有栈协程：把局部变量放入到新开的空间上，golang的实现，类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核</span><br><span class="line"></span><br><span class="line">无栈协程：直接把局部变量放入系统栈上，js、c++、rust那种await、async实现，主要原理就是闭包+异步，换句话说，其实就是协程的上下文都放到公共内存中，协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多。</span><br></pre></td></tr></table></figure>

<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="GO的基础数据类型"><a href="#GO的基础数据类型" class="headerlink" title="GO的基础数据类型"></a>GO的基础数据类型</h2><p>1、布尔型</p>
<p>　　bool，值为true(真)或false（假）。</p>
<p>2、整数型</p>
<p>　　int8 有符号 8 位整型 (-128 到 127) 长度：8bit</p>
<p>　　int16 有符号 16 位整型 (-32768 到 32767)</p>
<p>　　int32 有符号 32 位整型 (-2147483648 到 2147483647)</p>
<p>　　int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p>
<p>　　uint8 无符号 8 位整型 (0 到 255) 8位都用于表示数值：</p>
<p>　　uint16 无符号 16 位整型 (0 到 65535)</p>
<p>　　uint32 无符号 32 位整型 (0 到 4294967295)</p>
<p>　　uint64 无符号 64 位整型 (0 到 18446744073709551615) </p>
<p>　　int 、uint 根据底层平台，表示32或64位整数。</p>
<p>　　uintptr 无符号整型，用于存放一个指针</p>
<p>3、浮点型</p>
<p>　　float32  32位浮点型数</p>
<p>　　float64  64位浮点型数</p>
<p>　　complex64  32 位实数和虚数</p>
<p>　　complex128  64 位实数和虚数</p>
<p>4、字符型</p>
<p>　　byte 单个字符，类似于uint8</p>
<p>5、字符串类型</p>
<p>　　string 字符串</p>
<p>6、rune类型<br>　　类似 int32　　（Go语言的字符串的字节使用UTF-8编码标识Unicode文本，中文字符不是占用2个自己而是占用3个字节，rune用于获取真实的字节占用数）</p>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><h3 id="值类型："><a href="#值类型：" class="headerlink" title="值类型："></a><strong>值类型</strong>：</h3><ul>
<li>包括基本数据类型，如<code>int</code>、<code>float</code>、<code>bool</code>、<code>string</code>。</li>
<li>也包括复合数据类型，如数组和结构体（struct）。</li>
<li>变量直接存储值。</li>
<li>内存通常在栈上分配，栈在函数调用完毕后会被释放。</li>
</ul>
<h3 id="引用类型："><a href="#引用类型：" class="headerlink" title="引用类型："></a><strong>引用类型</strong>：</h3><ul>
<li>包括 切片（Slice）、映射（Map）、通道（Channel）和接口（Interface）。</li>
<li>变量存储的是指向实际数据的引用。</li>
<li>内存分配在堆上，生命周期由垃圾收集器管理。</li>
</ul>
<h3 id="内存分配中的堆和栈："><a href="#内存分配中的堆和栈：" class="headerlink" title="内存分配中的堆和栈："></a>内存分配中的堆和栈：</h3><ul>
<li><code>栈</code>（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li><code>堆</code>（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</li>
</ul>
<h2 id="值传递-和-引用传递"><a href="#值传递-和-引用传递" class="headerlink" title="值传递 和 (引用传递)"></a>值传递 和 (引用传递)</h2><p>Go里面没有<code>引用传递</code>，Go语言是<code>值传递</code></p>
<ul>
<li>值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li>
<li>引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li>
</ul>
<p>在 Go 语言中，<strong>函数的参数传递只有值传递</strong>，而且传递的实参都是原始数据的一份拷贝。如果拷贝的内容是值类型的，那么在函数中就无法修改原始数据；如果拷贝的内容是指针（或者可以理解为引用类型 <code>map</code>、<code>chan</code> 等），那么就可以在函数中修改原始数据，这里是拷贝了<strong>指针</strong>，传递的是<strong>指针副本</strong>，也就是值传递，只是看起来像引用传递</p>
<h2 id="golang-中-make-和-new-的区别？（必问）"><a href="#golang-中-make-和-new-的区别？（必问）" class="headerlink" title="golang 中 make 和 new 的区别？（必问）"></a>golang 中 make 和 new 的区别？（必问）</h2><p>在Go语言中，<code>make</code>和<code>new</code>都是用于内存分配的内建函数，但它们在分配内存和初始化内存方面有所不同：</p>
<ol>
<li>分配内存的区别：<ul>
<li><code>new</code>可以分配<strong>任意类型的内存</strong>，并返回<strong>一个指向该类型的指针</strong>。</li>
<li><code>make</code><strong>专门用于分配<code>slice</code>、<code>map</code>和<code>channel</code>这三种内建类型</strong>，并返回<strong>一个引用类型本身</strong>。</li>
</ul>
</li>
<li>初始化的区别：<ul>
<li><code>new</code>分配内存后，对于值类型，分配的是<strong>零值填充的内存空间</strong>，可直接使用。而对于引用类型，虽然也会分配内存并返回一个指向该内存的指针，但这块内存代表的是定义的那个引用类型，它的零值是<code>nil</code>，需要进一步初始化。例如 new(int) 之后，对应内存空间会有一个0；而<code>new(map[string]int)</code>，对应内存空间是nil，而不是<code>&#123;&quot;&quot;:0&#125;</code></li>
<li><code>make</code>分配内存后，内存会被初始化，即分配的是有初始值的内存空间。</li>
</ul>
</li>
<li>返回类型的区别：<ul>
<li><code>new</code>返回的是<strong>指针类型</strong>。</li>
<li><code>make</code>返回的是与<strong>参数相同类型的值</strong>，而不是指针。</li>
</ul>
</li>
<li>语法上的区别：<ul>
<li><code>new</code>的语法是 <code>func new(Type) *Type</code>。</li>
<li><code>make</code>的语法是 <code>func make(t Type, size ...IntegerType) Type</code>。</li>
</ul>
</li>
</ol>
<h2 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h2><ol>
<li>类型：<ul>
<li>数组是值类型，这意味着当你将<strong>一个数组赋值给另一个数组时，实际上是创建了数组的一个副本</strong>。因此，<strong>数组在函数参数传递时可能会导致性能问题，因为需要复制整个数组</strong>。</li>
<li>切片是<strong>引用类型</strong>，当你将一个切片赋值给另一个切片时，<strong>两个切片会引用同一个底层数组</strong>。这意味着对其中<strong>一个切片的修改也会影响到另一个切片</strong>。同理当切片作为函数参数传递修改时，<strong>会影响原数据</strong>。</li>
</ul>
</li>
<li>长度和容量：<ul>
<li>数组的长度是固定的，它在声明时就被确定，并且数组的每个元素类型必须相同。数组的长度是其类型的一部分，<strong>因此<code>[3]int</code>和<code>[4]int</code>是不同的类型</strong>。</li>
<li><strong>切片的长度是动态的</strong>，可以在运行时改变。<strong>切片还有一个容量属性，</strong>它表示切片底层数组中剩余的元素个数。<strong>切片的长度可以大于或等于其容量</strong>。</li>
</ul>
</li>
<li>底层数据结构：<ul>
<li><strong>数组是一组固定长度的元素序列，它的底层就是数组本身</strong>。</li>
<li>切片的底层是一个数组，<strong>切片是对数组的抽象和封装</strong>，提供了更加灵活的操作方式。切片包含了指向底层<strong>数组的指针、长度和容量等属性</strong>。</li>
</ul>
</li>
</ol>
<h2 id="for-range-，元素地址会发生变化吗"><a href="#for-range-，元素地址会发生变化吗" class="headerlink" title="for range ，元素地址会发生变化吗"></a>for range ，元素地址会发生变化吗</h2><p> 在 for a,b :&#x3D; range c 遍历中，</p>
<p> a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，并且a，b 的<strong>内存地址始终不变</strong>。由于有这个特性，<strong>for 循环里面如果开协程做并发</strong>，<strong>不要直接把 a 或者 b 的地址传给协程</strong>。</p>
<ul>
<li>解决办法：在每次循环时，创建一个临时变量传给协程。</li>
</ul>
<h2 id="go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？"><a href="#go-defer，多个-defer-的顺序，defer-在什么时机会修改返回值？" class="headerlink" title="go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？"></a>go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？</h2><p>作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;</p>
<p>避坑指南：<strong>defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。</strong></p>
<p>多个 defer 调用顺序是 <strong>LIFO（后入先出）</strong>，<strong>defer后的操作可以理解为压入栈中</strong></p>
<p>defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，修改时机：<strong>有名返回值或者函数返回指针</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Cassie_zkq/article/details/108567205">Go语言defer用法大总结</a></p>
<p>defer是Go语言中的一个关键字（延迟调用），一般用于释放资源和连接、关闭文件、释放锁等。和defer类似的有java的finally和C++的析构函数，这些语句一般是一定会执行的（某些特殊情况后文会提到），不过析构函数析构的是对象，而defer后面一般跟函数或方法。</p>
<p>所有的defer语句会放入栈中，在入栈的时候会进行相关的值拷贝（也就是下面的“对应的参数会实时解析”）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="defer声明时，对应的参数会实时解析"><a href="#defer声明时，对应的参数会实时解析" class="headerlink" title="defer声明时，对应的参数会实时解析"></a>defer声明时，对应的参数会实时解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i = 1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//defer后面的语句最后才会执行，后面会讲当defer存在时return的执行逻辑。辨析：defer后面跟无参函数、有参函数和方法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;<span class="comment">//无返回值函数</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1、a =&quot;</span>, a) <span class="comment">//方法</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> &#123; fmt.Println(<span class="string">&quot;2、a =&quot;</span>, v)&#125; (a) <span class="comment">//有参函数</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;3、a =&quot;</span>, a)&#125; () <span class="comment">//无参函数</span></span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3、a = 2</span></span><br><span class="line"><span class="comment">2、a = 1</span></span><br><span class="line"><span class="comment">1、a = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>解释：<br>方法中的参数a，有参函数中的参数v，会请求参数，直接把参数代入，所以输出的都是1。</p>
<p>a++变成2之后，3个defer语句以后声明先执行的顺序执行，无参函数中使用的a现在已经是2了，故输出2。</p>
<h3 id="可读取函数返回值（return返回机制）"><a href="#可读取函数返回值（return返回机制）" class="headerlink" title="可读取函数返回值（return返回机制）"></a>可读取函数返回值（return返回机制）</h3><p>defer、return、返回值三者的执行逻辑应该是：</p>
<ol>
<li>return最先执行，return负责将结果写入返回值中；</li>
<li>接着defer开始执行一些收尾工作；</li>
<li>最后函数携带<strong>当前返回值</strong>（可能和最初的返回值不相同）退出。</li>
</ol>
<p><strong>当defer语句放在return后面时，就不会被执行。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2:&quot;</span>, i) </span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer1:&quot;</span>, i) </span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;return:&quot;</span>, a()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">defer1: 1</span></span><br><span class="line"><span class="comment">defer2: 2</span></span><br><span class="line"><span class="comment">return: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>解释：<br>返回值由变量 i 赋值，相当于 返回值&#x3D;i&#x3D;0。</p>
<p>第二个defer中 i++ &#x3D; 1， </p>
<p>第一个defer中 i++ &#x3D; 2，所以最终i的值是2。</p>
<p>但是返回值已经被赋值了，即使后续修改i也不会影响返回值。最终返回值返回，所以main中打印0。</p>
<h3 id="函数返回值为地址"><a href="#函数返回值为地址" class="headerlink" title="函数返回值为地址"></a>函数返回值为地址</h3><p>此时的返回值是一个指针（地址），</p>
<p>这个指针&#x3D;&amp;i，相当于指向变量i所在的地址，</p>
<p>两个defer语句都对i进行了修改，</p>
<p>那么返回值指向的地址的内容也发生了改变，所以最终的返回值是2。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2:&quot;</span>, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer1:&quot;</span>, i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;return:&quot;</span>, *(c()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">defer1: 1</span></span><br><span class="line"><span class="comment">defer2: 2</span></span><br><span class="line"><span class="comment">return: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最初返回值r的值是1，虽然defer语句中函数的参数名也叫r（这里我记作r’），但传参的时候相当于r‘=r（值传递），函数内的语句相当于r’=r‘+5，所以返回值r并没有被修改，最终的返回值仍是1。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">          r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="defer与闭包"><a href="#defer与闭包" class="headerlink" title="defer与闭包"></a>defer与闭包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> pp() &#123;</span><br><span class="line">	fmt.Println(t.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">		<span class="keyword">defer</span> t.pp()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>解释：<br>for结束时t.name&#x3D;“c”，接下来执行的那些defer语句中用到的t.name的值均为”c“。</p>
<p>修改代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(t Test)</span></span> &#123;</span><br><span class="line">	fmt.Println(t.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">		<span class="keyword">defer</span> pp(t)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>defer语句中的参数会实时解析，所以在碰到defer语句的时候就把该时的t代入了。</p>
<p>再次修改代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span></span> pp() &#123;</span><br><span class="line">	fmt.Println(t.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">		tt := t</span><br><span class="line">		<span class="built_in">println</span>(&amp;tt)</span><br><span class="line">		<span class="keyword">defer</span> tt.pp()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0xc000010200</span></span><br><span class="line"><span class="comment">0xc000010210</span></span><br><span class="line"><span class="comment">0xc000010220</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>:&#x3D;用来声明并赋值，连续使用2次a:&#x3D;1就会报错，</p>
<p>但是在for循环内，可以看出每次tt:&#x3D;t时，tt的地址都不同，说明他们是不同的变量，所以并不会报错。</p>
<p>每次都有一个<strong>新的变量</strong>tt:&#x3D;t，所以每次在执行defer语句时，对应的tt不是同一个（for循环中实际上生成了3个不同的tt），所以输出的结果也不相同。</p>
<h3 id="defer用于关闭文件和互斥锁"><a href="#defer用于关闭文件和互斥锁" class="headerlink" title="defer用于关闭文件和互斥锁"></a>defer用于关闭文件和互斥锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unc ReadFile(filename <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span> ReadAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="“解除”对所在函数的依赖"><a href="#“解除”对所在函数的依赖" class="headerlink" title="“解除”对所在函数的依赖"></a>“解除”对所在函数的依赖</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	username <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *User)</span></span> Close() &#123;</span><br><span class="line">	fmt.Println(this.username, <span class="string">&quot;Closed !!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := &amp;User&#123;<span class="string">&quot;jack&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">defer</span> u1.Close()</span><br><span class="line">	u2 := &amp;User&#123;<span class="string">&quot;lily&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">defer</span> u2.Close()</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Done !</span></span><br><span class="line"><span class="comment">lily Closed !!!</span></span><br><span class="line"><span class="comment">jack Closed !!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>解释：<br>defer后面跟无参函数，u1.Close()和u2.Close()要等sleep和fmt.Println(“Done !”)之后才可以执行，</p>
<p>也就是在函数最终返回之前执行。</p>
<p>修改代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	username <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *User)</span></span> Close() &#123;</span><br><span class="line">	fmt.Println(this.username, <span class="string">&quot;Closed !!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(u *User)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> u.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := &amp;User&#123;<span class="string">&quot;jack&quot;</span>&#125;</span><br><span class="line">	f(u1)</span><br><span class="line">	u2 := &amp;User&#123;<span class="string">&quot;lily&quot;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">defer</span> u2.Close() &#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jack Closed !!!</span></span><br><span class="line"><span class="comment">lily Closed !!!</span></span><br><span class="line"><span class="comment">Done !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这样的使用方式，似乎不太合理，但却有存在的必要性。</p>
<p>大多数情况下，可以用于 u1,u2 之类非常消耗内存，或者cpu，其后执行时间过程且没有太多关联的情况。</p>
<p>既保留了defer的功能特性，也满足范围精确控制的条件！</p>
<h3 id="defer与panic"><a href="#defer与panic" class="headerlink" title="defer与panic"></a>defer与panic</h3><p>在panic语句后面的defer语句不被执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicDefer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer after panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: panic</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.panicDefer()</span><br><span class="line">    E:/godemo/testdefer.go:17 +0x39</span><br><span class="line">main.main()</span><br><span class="line">    E:/godemo/testdefer.go:13 +0x20</span><br><span class="line">Process finished with exit code 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 defer 语句没有执行。<br>（2）在panic语句前的defer语句会被执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferPanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer before panic&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">defer before panic</span><br><span class="line">panic: panic</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.deferPanic()</span><br><span class="line">    E:/godemo/testdefer.go:19 +0x95</span><br><span class="line">main.main()</span><br><span class="line">    E:/godemo/testdefer.go:14 +0x20</span><br><span class="line">Process finished with exit code 2</span><br></pre></td></tr></table></figure>

<p>defer 语句输出了内容。<br>Go中的panic类似其它语言中的抛出异常，panic后面的代码不再执行(panic语句前面的defer语句会被执行)。</p>
<h2 id="调用os-Exit时defer不会被执行"><a href="#调用os-Exit时defer不会被执行" class="headerlink" title="调用os.Exit时defer不会被执行"></a>调用os.Exit时defer不会被执行</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当调用os.Exit()方法退出程序时，defer并不会被执行，上面的defer并不会输出。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="uint-类型溢出问题"><a href="#uint-类型溢出问题" class="headerlink" title="uint 类型溢出问题"></a><code>uint </code>类型溢出问题</h3><p>超过最大存储值，例如<code>uint8</code>最大是255</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a uint8 = 255</span><br><span class="line">var b uint8 = 1</span><br><span class="line">a + b` 发生溢出， 结果为`0</span><br></pre></td></tr></table></figure>

<h3 id="rune-类型"><a href="#rune-类型" class="headerlink" title="rune 类型"></a>rune 类型</h3><p><strong><code>rune</code>类型是Go语言中用于表示<code>Unicode</code>字符的整数类型，它是<code>int32</code>的别名。</strong></p>
<p>用于表示一个 Unicode 码点（Unicode Code Point）。Unicode 码点是Unicode标准中为每个字符分配的唯一整数，它可以涵盖世界上几乎所有的字符和符号。</p>
<p>Go 语言中的 <code>rune</code> 主要是为了方便处理UTF-8编码的文本，特别是多字节字符，比如中文、日文、韩文等非ASCII字符。在UTF-8编码下，单个字符可能由1到4个字节组成，而一个 <code>rune</code> 能够容纳任何有效的Unicode码点，确保能够完整地表示所有这些字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;你好，世界！&quot;</span></span><br><span class="line">runes := []<span class="type">rune</span>(s)</span><br><span class="line"><span class="comment">// 对 runes 进行遍历或操作</span></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;索引: %d, 字符: %c, Unicode 编码: %U\n&quot;</span>, i, r, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">索引: 0, 字符: 你, Unicode 编码: U+4F60</span></span><br><span class="line"><span class="comment">索引: 1, 字符: 好, Unicode 编码: U+597D</span></span><br><span class="line"><span class="comment">索引: 2, 字符: ，, Unicode 编码: U+FF0C</span></span><br><span class="line"><span class="comment">索引: 3, 字符: 世, Unicode 编码: U+4E16</span></span><br><span class="line"><span class="comment">索引: 4, 字符: 界, Unicode 编码: U+754C</span></span><br><span class="line"><span class="comment">索引: 5, 字符: ！, Unicode 编码: U+FF01</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a><code>int</code>类型</h3><p>go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节。如果是64位操作系统，int类型的大小就是8个字节。</p>
<h2 id="golang-中解析-tag-是怎么实现的？反射原理是什么？-中高级题目"><a href="#golang-中解析-tag-是怎么实现的？反射原理是什么？-中高级题目" class="headerlink" title="golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级题目)"></a>golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级题目)</h2><p><strong>Tag 实现流程概要：</strong></p>
<ol>
<li>获取结构体类型的反射对象。</li>
<li>遍历结构体的所有字段。</li>
<li>对于每个字段，调用 <code>StructField.Tag.Get()</code> 方法并传入想要获取的 tag 键名，比如 <code>&quot;json&quot;</code> 或 <code>&quot;xml&quot;</code>。</li>
<li>返回并处理 tag 中的值。</li>
</ol>
<h3 id="反射的原理，基于接口来实现："><a href="#反射的原理，基于接口来实现：" class="headerlink" title="反射的原理，基于接口来实现："></a><strong>反射的原理，基于接口来实现：</strong></h3><p>在Go语言中，所有的类型都实现了空接口<code>interface&#123;&#125;</code>，这使得它们都可以被转换为反射类型<code>Type</code>和反射值<code>Value</code>。反射过程涉及到几个步骤：</p>
<ol>
<li><strong>类型转换</strong>：将普通类型隐式转换为接口类型。这个转换过程是自动进行的，当一个变量被赋值给接口类型的值时，就会进行这个转换。</li>
<li><strong>获取反射对象</strong>：通过转换得到的接口值，可以调用标准库<code>reflect</code>包中的函数来获取对应的反射类型<code>Type</code>和反射值<code>Value</code>。</li>
<li><strong>操作反射对象</strong>：通过反射类型和反射值，可以获取到原始类型的各种信息，包括字段、方法、标签等，并且可以对这些信息进行读取和修改操作。</li>
</ol>
<h2 id="Golang-调用函数传入结构体时，应该传值还是指针？"><a href="#Golang-调用函数传入结构体时，应该传值还是指针？" class="headerlink" title="Golang 调用函数传入结构体时，应该传值还是指针？"></a>Golang 调用函数传入结构体时，应该传值还是指针？</h2><p>分情况：</p>
<ol>
<li><strong>结构体的大小：</strong>如果结构体非常大，使用<strong>指针传递会更有效率</strong>，因为这样只会复制指针值（一般是8字节），而不是复制整个结构体。<strong>如果结构体小</strong>，值传递和指针传递的性能差异可能可以忽略不计。</li>
<li><strong>是否需要修改原始结构体</strong>：如果你需要在函数中<strong>修改原始结构体</strong>，你应该使用指针传递。如果你使用值传递，<strong>函数会接收结构体的一个副本</strong>，你在函数中对结构体的修改不会影响到原始的结构体。</li>
</ol>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><strong>Go语言中的slice是一个结构体，包含指针、长度和容量三个部分</strong>。它的特性包括：</p>
<ul>
<li><strong>指针</strong>：Slice包含一个指针，该指针指向底层数组，即实际存储数据的数组。</li>
<li>**长度<code>len</code>**：Slice的长度表示当前Slice使用到的元素个数。</li>
<li>**容量<code>cap</code>**：Slice的容量表示底层数组的大小，也就是Slice可以扩展的最大长度。</li>
<li><strong>动态性</strong>：Slice是<strong>灵活的，其长度可以改变</strong>，不像数组那样固定。</li>
<li><strong>传递效率</strong>：作为函数参数时，<strong>Slice传递的是引用，而不是像数组那样传递副本</strong>，这使得Slice在函数调用中更加高效。</li>
</ul>
<p>在使用Slice时，需要注意以下几点：</p>
<ul>
<li>Slice可以通过内置的<code>make</code>、<code>new</code>函数或直接对数组进行切片操作来创建。</li>
<li>修改Slice的元素会影响到底层数组，反之亦然。</li>
<li>当Slice的容量大于其长度时，可以通过append等操作来扩展Slice的长度，而不会改变底层数组的大小。</li>
<li>当Slice的长度达到容量时，再次进行append操作将会导致底层数组的重新分配和复制，这可能会影响性能。</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>Go语言中的<code>select</code>语句是一种多路复用的控制结构，它用于同时处理多个通道（channel）上的事件。其底层数据结构和特性如下：</p>
<ol>
<li><strong>数据结构</strong>：<code>select</code>的底层实现与操作系统中的I&#x2F;O多路复用机制类似，如<code>poll</code>和<code>epoll</code>。在Go语言中，<code>select</code>用于监听通道的发送和接收操作，当通道准备好进行相应的操作时，会触发<code>select</code>中对应的<code>case</code>分支执行。</li>
<li>特性：<ul>
<li><strong>通道操作</strong>：<code>select</code>语句只能用于通道操作，而且是单协程操作，每个<code>case</code>必须是单个通道发送或接收的操作。</li>
<li><strong>非抢占式</strong>：<code>select</code>语句会监听所有指定的通道上的操作，一旦其中一个通道准备好，就会执行相应的代码块。这与<code>switch</code>语句的顺序执行不同，<code>select</code>的<code>case</code>执行顺序是随机的。</li>
<li><strong>避免死锁</strong>：在使用<code>select</code>时需要注意避免死锁的情况，例如至少要有一个通道准备好，否则<code>select</code>会阻塞，直至有一个通道已准备好为止。如果存在<code>default</code>分支，那么<code>select</code>就不会阻塞，而是执行<code>default</code>分支，但<code>default</code>会略影响性能。</li>
<li><strong>超时控制</strong>：<code>select</code>可以配合<code>default</code>分支实现超时控制，如果在指定的时间内没有任何通道准备好，<code>default</code>分支会被执行。</li>
<li><strong>无穿透执行</strong>：<code>select</code>语句中没有类似<code>switch</code>中的<code>fallthrough</code>用法，即执行完一个<code>case</code>后不会继续执行下一个<code>case</code>。</li>
</ul>
</li>
</ol>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>每个 defer 语句都对应一个<code>_defer</code> 实例，多个实例使用指针连接起来形成一个单连表，保存在 <code>goroutine</code> 数据结构中，每次插入<code>_defer</code> 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。</p>
<p><strong>defer 的规则总结</strong>：</p>
<ul>
<li>延迟函数的参数是 defer 语句出现的时候就已经确定了的。</li>
<li>延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。</li>
<li>延迟函数可能操作主函数的返回值。</li>
<li>建议申请资源后立即使用 defer 关闭资源。</li>
</ul>
<h2 id="单引号，双引号，反引号的区别"><a href="#单引号，双引号，反引号的区别" class="headerlink" title="单引号，双引号，反引号的区别"></a>单引号，双引号，反引号的区别</h2><p><strong>单引号</strong>，表示<code>byte</code>类型或<code>rune</code>类型，对应 <code>uint8</code>和<code>int32</code>类型，默认是 <code>rune</code> 类型。<code>byte</code>用来强调数据是<code>raw data</code>，而不是数字；而<code>rune</code>用来表示<code>Unicode</code>的<code>code point</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> v <span class="type">rune</span> = <span class="string">&#x27;你&#x27;</span></span><br><span class="line">	<span class="keyword">var</span> v1 <span class="type">rune</span> = <span class="string">&#x27;k&#x27;</span></span><br><span class="line">	<span class="keyword">var</span> v2 <span class="type">byte</span> = <span class="string">&#x27;k&#x27;</span></span><br><span class="line">	fmt.Println(v, v1, v2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">20320 107 107</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>双引号</strong>，里面可以是单个字符也可以是字符串，对应<code>string</code>类型，实际上是字符数组。可以用索引号访问某字节，也可以用<code>len()</code>函数来获取字符串所占的字节长度。双引号里的字符串可以转义，但是不能换行，可以利用<code>\n</code>来实现换行。</p>
<p><strong>反引号</strong>中的字符串表示其原生的意思，里面的内容不会被转义，可以换行。</p>
<h2 id="Go-支持默认参数或可选参数吗？"><a href="#Go-支持默认参数或可选参数吗？" class="headerlink" title="Go 支持默认参数或可选参数吗？"></a>Go 支持默认参数或可选参数吗？</h2><p>不支持。但是可以利用结构体参数，或者<code>...</code>传入参数切片数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以传入任意数量的整型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体打印时，-v-和-v-的区别"><a href="#结构体打印时，-v-和-v-的区别" class="headerlink" title="结构体打印时，%v 和 %+v 的区别"></a>结构体打印时，<code>%v</code> 和 <code>%+v</code> 的区别</h2><p><code>%v</code>输出结构体各成员的值；</p>
<p><code>%+v</code>输出结构体各成员的<strong>名称</strong>和<strong>值</strong>；</p>
<p><code>%#v</code>输出结构体名称和结构体各成员的名称和值</p>
<h2 id="Go-语言中如何表示枚举值"><a href="#Go-语言中如何表示枚举值" class="headerlink" title="Go 语言中如何表示枚举值"></a>Go 语言中如何表示枚举值</h2><ul>
<li>使用常量定义枚举值</li>
<li>使用自定义类型定义枚举</li>
<li>使用 <code>iota</code> 自增枚举值</li>
</ul>
<h2 id="空-struct-的用途"><a href="#空-struct-的用途" class="headerlink" title="空 struct{} 的用途"></a>空 struct{} 的用途</h2><p>在Go语言中，空的 <code>struct &#123;&#125;</code> 类型通常被用作占位符或者信号。它不占用任何内存空间，也不包含任何字段，可以避免任何多余的内存分配。</p>
<ol>
<li><p>实现集合类型：Go语言本身没有直接的集合类型（类似于Set），但我们可以使用map来替代，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Set map[int]struct&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map的key是不允许重复的，这和Set集合性质相符，再将struct{}作为Value，即可用Map实现Set。</li>
</ul>
</li>
<li><p><strong>实现空通道</strong>：在Go的并发编程中，我们经常会遇到<strong>通知型channel</strong>，它们不需要传递任何数据，只是用于协调Goroutine的运行。这种情况下，使用空结构体作为通道元素类型非常合适，因为它不会增加额外的内存开销。</p>
</li>
<li><p><strong>实现方法接收者</strong>：有时我们需要使用结构体类型的变量作为方法接收者，但结构体本身不包含任何字段属性。这种情况下，使用空结构体作为接收者是比较合适的，因为它不会占用额外的内存空间。</p>
</li>
</ol>
<h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h3 id="Map相关"><a href="#Map相关" class="headerlink" title="Map相关"></a>Map相关</h3><h4 id="map-使用需要注意点"><a href="#map-使用需要注意点" class="headerlink" title="map 使用需要注意点"></a>map 使用需要注意点</h4><ol>
<li><strong>初始化</strong>：在使用map之前，需要先进行初始化，否则会导致编译错误。初始化一个map可以使用字面量语法，如<code>m := make(map[string]int)</code>或<code>m := map[string]int&#123;&#125;</code>。</li>
<li><strong>并发安全</strong>：在高并发场景下，<strong>应当考虑使用<code>sync.Map</code>或者其他并发安全措施来保护map，因为原生的map类型不是并发安全的。</strong></li>
<li><strong>删除和添加操作</strong>：频繁的删除和添加元素会导致哈希表的频繁重建，这可能会影响程序的性能。因此，在设计数据结构时，应尽量避免在map中频繁地进行这些操作。</li>
<li><strong>迭代效率</strong>：遍历大的map可能很慢，尤其是在map结构发生变化时。如果需要遍历map，应尽量在map结构稳定时进行，以提高迭代效率。</li>
<li><strong>作为集合使用</strong>：由于Go语言中没有内置的集合类型，map经常被用作集合。当使用map作为集合时，<strong>通常不需要关心值，只需要键即可</strong>。</li>
</ol>
<h4 id="map并发安全"><a href="#map并发安全" class="headerlink" title="map并发安全"></a>map并发安全</h4><p>在Go语言中，内置的map类型<strong>并非并发安全</strong>。</p>
<ol>
<li><strong>读写冲突</strong>：当有多个<code>goroutine</code>同时对同一个map进行读写操作时，可能会发生冲突，导致程序崩溃或者数据不一致。</li>
<li><strong>写操作的广义定义</strong>：在map的并发操作中，“写”不仅仅是指插入新的键值对，还包括更新或删除已有的键值对。</li>
<li><strong>并发读安全</strong>：虽然map支持多个<code>goroutine</code>同时进行读取操作，但是在涉及到写操作时，就需要特别小心。</li>
<li><strong>性能优化场景</strong>：官方文档提到，在某些特定的场景下，如键值对只被写入一次但多次读取，或者多个<code>goroutine</code>读写不同的键集合时，原生map的性能可能优于使用<code>Mutex</code>或<code>RWMutex</code>的情况。</li>
<li>解决方案：<ul>
<li>如果需要在并发环境中使用map，可以考虑使用sync包中的<code>sync.Map</code>，它是一个并发安全的map实现。</li>
<li>可以使用读写锁（如<code>sync.RWMutex</code>）来保护对map的访问。</li>
</ul>
</li>
</ol>
<h4 id="map-循环是有序的还是无序的"><a href="#map-循环是有序的还是无序的" class="headerlink" title="map 循环是有序的还是无序的"></a>map 循环是有序的还是无序的</h4><p> <strong>无序的</strong></p>
<ul>
<li><strong>哈希函数</strong>：map使用哈希函数来计算键的存储位置，这个过程是无序的。</li>
<li><strong>内部结构</strong>：map的内部结构是一系列桶（bucket），每个桶是一个链表，链表中的元素是无序的。</li>
<li><strong>随机化</strong>：Go语言的map在迭代时会生成一个随机数作为遍历的起始位置，这是为了防止哈希碰撞攻击，并且确保每次迭代的顺序都是不同的。</li>
</ul>
<h4 id="map-中删除一个-key，它的内存会释放么？"><a href="#map-中删除一个-key，它的内存会释放么？" class="headerlink" title="map 中删除一个 key，它的内存会释放么？"></a>map 中删除一个 key，它的内存会释放么？</h4><p> <strong>不会立即释放</strong>。</p>
<p>在Go语言中，当你从map中删除一个键值对时，该操作并不会立即释放掉这个键值对所占用内存。这是因为map的底层实现是由若干个<code>bmap</code>（桶）构成的，桶只会扩容，不会缩容 ，map内存空间本身并不会立即归还给操作系统。</p>
<p><strong>如果删除的元素是值类型，如int、float、bool、string以及数组和struct，这些类型的内存通常不会自动释放。如果删除的元素是引用类型，如切片、映射和通道等，虽然它们所指向的实际数据结构可能会被释放，但map中的键值对所占用的内存同样不会立即释放。</strong></p>
<p>总的来说，Go语言的垃圾收集器会在合适的时机回收未使用的内存。这意味着，即使从map中删除了元素，内存也可能不会立即得到释放，而是等待下一次垃圾收集周期进行处理。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhw21w/article/details/129434340">参考教程</a></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406081522409.png"/>



<h4 id="nil-map-和空-map-有何不同"><a href="#nil-map-和空-map-有何不同" class="headerlink" title="nil map 和空 map 有何不同"></a>nil map 和空 map 有何不同</h4><p><strong>nil map是指未初始化的map，而空map是指已初始化但不含任何键值对的map</strong>。具体区别表现在以下几个方面：</p>
<ol>
<li><strong>初始化状态</strong>：<ul>
<li><strong>nil map</strong>：是指map变量被声明但未被初始化，此时它的值是nil。</li>
<li><strong>空map</strong>：是指map已被初始化，但没有包含任何键值对，即它的长度为0。</li>
</ul>
</li>
<li><strong>内存分配</strong>：<ul>
<li><strong>nil map</strong>：由于未初始化，所以不会为map分配实际的内存空间。</li>
<li><strong>空map</strong>：虽然不包含任何元素，但是已经分配了哈希表所需的内存空间。</li>
</ul>
</li>
<li><strong>操作限制</strong>：<ul>
<li><strong>nil map</strong>：不能进行任何map的操作，如添加、删除或读取键值对，否则会引发panic。</li>
<li><strong>空map</strong>：可以进行正常的map操作，包括添加、删除和读取键值对</li>
</ul>
</li>
</ol>
<h4 id="map-的数据结构是什么？是怎么实现扩容"><a href="#map-的数据结构是什么？是怎么实现扩容" class="headerlink" title="map 的数据结构是什么？是怎么实现扩容"></a>map 的数据结构是什么？是怎么实现扩容</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhw21w/article/details/129434340">详细讲解</a></p>
<p><strong>Go语言中的map使用哈希表（<code>hmap</code>）作为其数据结构，并且采用渐进式的方式进行扩容</strong>。</p>
<p>Go语言的map是一种高效的键值对集合类型，它的底层实现是哈希表（<code>hmap</code>）。哈希表由多个桶（<code>buckets</code>）组成，每个桶用来存储具有相同哈希值的键值对。当map需要存储更多的元素时，就会触发扩容操作。这个过程涉及到以下关键步骤：</p>
<ul>
<li><strong>重新分配内存</strong>：在扩容时，Go会为哈希表分配一个新的、更大的内存区域。</li>
<li><strong>渐进式搬迁</strong>：由于一次性搬迁大量的键值对会严重影响性能，Go map采用了渐进式搬迁的策略。这意味着在每次扩容时，只有部分数据会被迁移到新的内存地址。</li>
<li><strong>控制搬迁数量</strong>：为了减少扩容对性能的影响，每次搬迁的键值对数量是有限的，通常最多只会搬迁2个桶。</li>
<li><strong>保持数据访问</strong>：在扩容过程中，旧的桶（oldbuckets）仍然保持可用状态，以便在搬迁过程中可以继续访问和修改数据。</li>
<li><strong>哈希冲突处理</strong>：为了解决哈希冲突的问题，Go map使用了拉链法，即在同一个桶内通过链表来存储具有相同哈希值的键值对。</li>
</ul>
<h4 id="golang-哪些类型不可以作为map-key"><a href="#golang-哪些类型不可以作为map-key" class="headerlink" title="golang 哪些类型不可以作为map key"></a>golang 哪些类型不可以作为map key</h4><p>任何可比较（comparable）和相等（equal）的类型都可以作为map的键。</p>
<p>注意，<strong>空接口（interface{}）可以作为map的键</strong>，但需要谨慎使用，因为它可以包含任何类型的值。</p>
<p><strong>不能作为map key 的类型包括：</strong></p>
<ul>
<li>slices</li>
<li>maps</li>
<li>functions</li>
</ul>
<h4 id="Map赋值和复制"><a href="#Map赋值和复制" class="headerlink" title="Map赋值和复制"></a>Map赋值和复制</h4><p>当你把一个map赋值给另一个map时，<strong>实际上是复制了原map的引用，而不是复制了整个map的内容。这意味着新旧两个map共享相同的底层数据结构，修改其中一个map会影响到另一个。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ma := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any)</span><br><span class="line">ma[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">mb := ma</span><br><span class="line">mb[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br><span class="line">fmt.Println(ma)</span><br><span class="line"><span class="comment">// 输出：map[one:hello two:world]</span></span><br><span class="line"><span class="comment">// 表示修改mb会影响ma</span></span><br></pre></td></tr></table></figure>

<p>如果要复制一个完全独立的副本，需要遍历目标Map来创建。</p>
<h3 id="context相关"><a href="#context相关" class="headerlink" title="context相关"></a>context相关</h3><h4 id="context-结构是什么样的？context-使用场景和用途"><a href="#context-结构是什么样的？context-使用场景和用途" class="headerlink" title="context 结构是什么样的？context 使用场景和用途"></a>context 结构是什么样的？context 使用场景和用途</h4><p> <code>context.Context</code> 是 <code>Golang</code> 中用于<strong>处理并发编程的上下文控制</strong>，<strong>提供了截止日期、取消信号和请求相关值的传递机制</strong>。它的结构定义包括以下几个关键方法：</p>
<ol>
<li><strong>Deadline</strong>: 此方法返回一个截止日期和一个布尔值，表示上下文是否设置了截止日期。</li>
<li><strong>Done</strong>: 这是一个通道，当上下文被取消或超时时，会向该通道发送一个信号。</li>
<li><strong>Err</strong>: 该方法返回上下文中发生的错误。</li>
<li><strong>Value</strong>: 这个函数用于存储和检索与上下文相关的键值对，是实现共享数据存储的地方，是协程安全的</li>
</ol>
<p><strong>其主要的应用 ：</strong></p>
<p>1：上下文控制，2：多个 <code>goroutine</code> 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</p>
<h4 id="context-Context-结构的核心特征"><a href="#context-Context-结构的核心特征" class="headerlink" title="context.Context 结构的核心特征"></a><code>context.Context</code> 结构的核心特征</h4><ol>
<li>Context 的创建：<ul>
<li>使用 <code>context.Background()</code> 创建一个顶级上下文，<strong>没有特定的取消信号和截止时间。</strong></li>
<li>使用 <code>context.TODO()</code> 创建一个临时上下文，<strong>通常用于表明代码路径尚未完成，需要后续填充适当的上下文。</strong></li>
<li>使用 <code>context.WithCancel(parentCtx)</code> <strong>创建一个可以从父上下文中派生出来的新上下文，并带有可主动取消的功能。</strong></li>
<li>使用 <code>context.WithDeadline(parentCtx, deadline)</code> <strong>创建一个在指定截止时间到达时自动取消的上下文。</strong></li>
<li>使用 <code>context.WithTimeout(parentCtx, timeout)</code> <strong>创建一个在指定超时时间过后自动取消的上下文。</strong></li>
<li>使用 <code>context.WithValue(parentCtx, key, value)</code> <strong>创建一个携带键值对的上下文，用于传递请求级别信息。</strong></li>
</ul>
</li>
<li>Context 的传递：<ul>
<li><strong>Context 应该作为参数传递给可能长时间运行或涉及到 Goroutine 启动的函数，以便在适当的时候能够取消操作或传播相关信息。</strong></li>
</ul>
</li>
<li>取消通知：<ul>
<li>通过调用 <code>ctx.Done()</code> 方法可以获得一个只读的 channel，当上下文被取消时，该 channel 会被关闭。</li>
<li>通过检查 <code>&lt;-ctx.Done()</code> 可以得知上下文是否已被取消，这是一种非阻塞的方式检测取消信号。</li>
</ul>
</li>
<li>截止时间：<ul>
<li>可以通过 <code>ctx.Deadline()</code> 查询上下文的截止时间，如果没有设定则返回 <code>time.Time&#123;&#125;</code>（零值）。</li>
</ul>
</li>
<li>Context 的取消：<ul>
<li>创建子上下文时获得的取消函数（如 <code>cancelFunc</code>）可用于主动取消上下文及所有从该上下文衍生出的子上下文。</li>
</ul>
</li>
</ol>
<h3 id="channel-相关"><a href="#channel-相关" class="headerlink" title="channel 相关"></a>channel 相关</h3><p>channel(通道)用于goroutine(协程)之间的通信。它提供了一种在不同协程之间传递数据的机制。channel是一种类型安全的、阻塞的、先进先出（FIFO）的数据结构，确保发送的数据按照发送的顺序接收。Go语言提供通过通信来共享内存，而不是通过共享内存来通信</p>
<h4 id="channel-是否线程安全？"><a href="#channel-是否线程安全？" class="headerlink" title="channel 是否线程安全？"></a>channel 是否线程安全？</h4><ul>
<li><strong>Channel 的线程安全性</strong>：channel 是线程安全的，这意味着多个 goroutine 可以同时对同一个 channel 进行读写操作，而不会产生数据竞争或冲突。这是因为 channel 在内部实现了必要的同步机制，如互斥锁，来确保对数据的访问是原子化的和同步的。</li>
<li><strong>Channel 的操作</strong>：在使用 channel 时，你可以利用 <code>for range</code> 循环来持续地从 channel 中读取数据，直到它被关闭。这种方式比手动使用锁来控制数据的访问要简单和高效得多。</li>
</ul>
<h4 id="go-channel-的底层实现原理-（数据结构）"><a href="#go-channel-的底层实现原理-（数据结构）" class="headerlink" title="go channel 的底层实现原理 （数据结构）"></a>go channel 的底层实现原理 （数据结构）</h4><p>Go 内部对 channel 的实现采用了名为hchan的结构体。包含了如下几个重要的字段：</p>
<p>结构体包含了如下几个重要的字段：</p>
<ul>
<li><code>elemtype</code>: 存储 channel 中元素的数据类型信息。</li>
<li><code>buf</code>: 一个指向存储 channel 数据的数组的指针，用于实现缓冲 channel。</li>
<li><code>elemsize</code>: 元素的大小（以字节为单位）。</li>
<li><code>closed</code>: 标志位，指示 channel 是否已经被关闭。</li>
<li><code>recvx</code> 和 <code>sendx</code>：分别代表接收和发送索引，用于记录下一个接收和发送的位置。</li>
<li><code>recvq</code> 和 <code>sendq</code>：分别指向等待接收和发送的 goroutine 队列，当 channel 满或者空时，相应的 goroutine 会进入相应队列等待。</li>
<li><code>lock</code>：互斥锁，用于保证对 channel 内部数据结构的同步访问。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// 循环数组中的元素数量，长度</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// 循环数组的大小，容量</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// channel分为无缓冲和有缓冲channel两种</span></span><br><span class="line">  <span class="comment">// 有缓冲的channel使用ring buffer（环形缓冲区）来缓存写入的数据，本质是循环数组</span></span><br><span class="line">  <span class="comment">// 为什么是循环数组？普通数组容量固定、更适合指定的空间，且弹出元素时，元素需要全部前移</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// 指向底层循环数组的指针（环形缓冲区）</span></span><br><span class="line">  elemsize <span class="type">uint16</span>         <span class="comment">// 元素的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span>         <span class="comment">// 是否关闭的标志，0：未关闭，1：已关闭</span></span><br><span class="line">  elemtype *_type <span class="comment">// channel中的元素类型</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和当前写的下标位置</span></span><br><span class="line">  sendx    <span class="type">uint</span>   <span class="comment">// 下一次写的位置</span></span><br><span class="line">  recvx    <span class="type">uint</span>   <span class="comment">// 下一次读的位置</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 尝试读/写channel时被阻塞的goroutine</span></span><br><span class="line">  recvq    waitq  <span class="comment">// 读等待队列</span></span><br><span class="line">  sendq    waitq  <span class="comment">// 写等待队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 互斥锁，保证读写channel时的并发安全问题</span></span><br><span class="line">  lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406082034686.png"/>

<h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><ul>
<li>无缓冲 channel：发送和接收操作都是同步的，也就是说，发送操作会阻塞，直到有接收者准备好；同样地，接收操作也会阻塞，直到有发送者发送数据。</li>
<li>有缓冲 channel：在缓冲区未满的情况下，发送操作可以立即完成；同理，在缓冲区非空的情况下，接收操作也可以立即完成。当缓冲区已满或空时，channel 的同步机制会启用等待队列，将 goroutine 插入到相应队列中，直至满足发送或接收条件。</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>Go runtime 在创建 channel 时会分配一块内存来存储元素，并根据 channel 的缓冲大小调整这块内存的大小。</li>
<li>在进行数据传输时，runtime 会确保 goroutine 间的同步，并通过 CAS（Compare and Swap）等原子操作来更新 channel 内部的状态，从而实现线程安全的数据交换。</li>
</ul>
<h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><ul>
<li>Go 的运行时调度器密切关注 channel 上的活动，当一个 goroutine 因为 channel 操作被阻塞时，调度器会将该 goroutine 放入等待队列，并唤醒另一个可能已经准备好的 goroutine 继续执行。</li>
</ul>
<h4 id="nil-channel、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样"><a href="#nil-channel、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样" class="headerlink" title="nil channel、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样"></a>nil channel、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样</h4><p>针对 Go 语言中的 channel，在不同状态下（nil、已关闭、有数据）进行读、写、关闭操作会有以下表现：</p>
<ol>
<li><h4 id="nil-channel："><a href="#nil-channel：" class="headerlink" title="nil channel："></a><strong>nil channel</strong>：</h4><ul>
<li>读取：尝试从 nil channel 读取数据会<strong>导致永远阻塞</strong>，除非通过另一个 goroutine 向其发送数据或关闭 channel。</li>
<li>写入：向 nil channel 发送数据也会造成永远阻塞，必须先创建并初始化 channel 才能进行发送操作。</li>
<li>关闭：试图关闭 nil channel 会直接导致 panic 错误。</li>
</ul>
</li>
<li><p><strong>已关闭的 channel</strong>：</p>
<ul>
<li>读取：从已关闭的 channel 读取数据，如果 channel 中还有剩余数据，那么会成功读取并返回数据；当 channel 中所有数据都被读取完毕时，<strong>再次读取会返回对应类型的零值</strong>，并且 <code>ok</code> 标志位为 <code>false</code>，<strong>表示 channel 已关闭且无数据可读。</strong></li>
<li>写入：向已关闭的 channel 发送数据会导致 <strong>panic 错误</strong>。</li>
<li>关闭：<strong>对已关闭的 channel 再次调用 close 操作也是非法的，会导致 panic 错误。</strong></li>
</ul>
</li>
<li><p><strong>有数据的 channel</strong>：</p>
<ul>
<li>读取：如果有数据，从 channel 中读取数据会成功，返回数据值，且 <code>ok</code> 标志位为 <code>true</code>。</li>
<li>写入：如果 channel 是非缓冲的（无缓冲 channel），只有当有接收方正在读取数据时才能成功发送；如果是缓冲的 channel，只要缓冲未满就能成功发送数据。</li>
<li>关闭：可以关闭有数据的 channel，关闭后不能再向其发送数据，但仍然可以从 channel 中读取剩余数据，直到数据被完全读取完。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>无论是 nil channel 还是已关闭的 channel，都不能进行写入操作。</li>
<li>对 nil channel 进行读取和关闭操作会导致阻塞或 panic。</li>
<li>对已关闭的 channel 进行读取取决于是否有剩余数据，写入和关闭都会导致 panic。</li>
<li>有数据的 channel 可以正常进行读写操作，关闭后不再接受新的数据，但仍能读取旧数据，直到清空。</li>
</ul>
<h4 id="向-channel-发送数据和从-channel-读数据的流程"><a href="#向-channel-发送数据和从-channel-读数据的流程" class="headerlink" title="向 channel 发送数据和从 channel 读数据的流程"></a>向 channel 发送数据和从 channel 读数据的流程</h4><ol>
<li>向channel发送数据：<ul>
<li>首先，检查channel中是否有空间存放数据。对于带缓冲的channel，如果缓冲区未满，则可以直接将数据存入缓冲区；如果缓冲区已满，则发送方会被阻塞，直到接收方从channel中读取数据并释放缓冲区空间。对于不带缓冲的channel，发送方会立即被阻塞，直到接收方准备好接收数据。</li>
<li>当有空间可以存放数据时，发送方将数据存入channel，此时数据被视为已发送但尚未被接收。</li>
<li>如果channel在发送数据后被关闭，那么发送操作会立即返回，不再阻塞。</li>
</ul>
</li>
<li>从channel读取数据：<ul>
<li>首先，检查channel中是否有数据可供读取。对于带缓冲的channel，如果缓冲区不为空，则可以直接从中读取数据；如果缓冲区为空，则接收方会被阻塞，直到发送方将数据发送到channel中。对于不带缓冲的channel，接收方会立即被阻塞，直到发送方将数据发送到channel中。</li>
<li>当有数据可供读取时，接收方从channel中取出数据，此时数据被视为已接收但尚未被处理。</li>
<li>如果channel在读取数据后被关闭，那么接收操作会立即返回，不再阻塞。</li>
</ul>
</li>
</ol>
<h1 id="GPM调度模型"><a href="#GPM调度模型" class="headerlink" title="GPM调度模型"></a>GPM调度模型</h1><h2 id="什么是GPM调度模型"><a href="#什么是GPM调度模型" class="headerlink" title="什么是GPM调度模型?"></a>什么是GPM调度模型?</h2><p>Go 语言的 GPM 调度模型是 Go 运行时特有的并发调度模型，用于管理和调度 Goroutines（Go 语言的轻量级线程）。</p>
<p>GPM 模型由三部分组成：Goroutine（G）、M（Machine）、和 P（Processor）。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Geffin/article/details/113996403">实战参考</a></p>
<ul>
<li><strong>G</strong>: 表示 Goroutine，每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，<strong>每个 G 需要绑定到 P 才能被调度执行</strong>。【协程（用户态线程）】</li>
<li><strong>P</strong>: Processor，表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;&#x3D; P 的数量），P 的数量由用户设置的 <strong>GOMAXPROCS</strong> 决定，但是不论 GOMAXPROCS 设置为多大，<strong>P 的数量最大为 256</strong>。【处理器（处理G携程）】</li>
<li><strong>M</strong>: Machine，OS 线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，<strong>M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</strong>通过runtime&#x2F;debug包中的SetMaxThreads函数设置【物理线程（内核态线程）】<ul>
<li>有一个M阻塞会开启一个新的M</li>
<li>如果有M空闲会回收或睡眠</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130157639.png"/>

<p>调度流程简述：</p>
<ul>
<li>有一个全局队列和本地队列，其中本地队列的容量一般不超过256</li>
<li>当创建一个新的 Goroutine 时，它会被放入某个 P 的本地队列中。</li>
<li>若本地队列已满或者不存在，则会将 Goroutine 放入全局队列。</li>
<li>M 通过与其关联的 P 获取待执行的 Goroutine，然后执行它。</li>
<li>若 M 闲置，会去全局队列或者从其他 P 抢夺 Goroutine 来执行（Work Stealing）。</li>
<li>当 Goroutine 因 I&#x2F;O 操作阻塞时，对应的 M 会释放其与 P 的关联，并让出 CPU 给其他 Goroutine 执行，待阻塞解除后重新参与调度。</li>
</ul>
<h3 id="调度器策略"><a href="#调度器策略" class="headerlink" title="调度器策略"></a>调度器策略</h3><h4 id="复用线程"><a href="#复用线程" class="headerlink" title="复用线程"></a>复用线程</h4><p>避免频繁的创建、销毁线程，而是对线程的复用</p>
<h5 id="work-stealing机制"><a href="#work-stealing机制" class="headerlink" title="work stealing机制"></a>work stealing机制</h5><p>先从全局队列拿，全局队列没有G的话，再从其他线程绑定的P的本地队列中“窃取”</p>
<h5 id="hand-off机制"><a href="#hand-off机制" class="headerlink" title="hand off机制"></a>hand off机制</h5><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程M执行（此时的P带剩余的G）。</p>
<ol>
<li>当前p本地队列有待执行g </li>
<li>没有空闲的p和m, 全局g队列为空 (此时意味这全局繁忙) </li>
<li>需要处理网络 I&#x2F;O</li>
</ol>
<h4 id="利用并行"><a href="#利用并行" class="headerlink" title="利用并行"></a>利用并行</h4><p>GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的CPU核进行并行。</p>
<h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><p>在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
<h4 id="全局G队列"><a href="#全局G队列" class="headerlink" title="全局G队列"></a>全局G队列</h4><p>在新的调度器M中依然有全局G队列，当P的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过work stealing机制从其他P的本地队列偷取G。</p>
<h3 id="抢占式调度是如何抢占的"><a href="#抢占式调度是如何抢占的" class="headerlink" title="抢占式调度是如何抢占的"></a>抢占式调度是如何抢占的</h3><p>抢占式调度的过程通常包括以下几个步骤：</p>
<ol>
<li><strong>时间片分配</strong>：系统为每个任务分配一个固定的时间片（time quantum），即任务可以连续执行的最长时间。</li>
<li><strong>上下文保存</strong>：当任务的时间片用完时，调度器会暂停该任务的执行，并保存其当前的执行状态（如寄存器值、程序计数器等）到任务的上下文中。</li>
<li><strong>重新调度</strong>：调度器选择下一个要运行的任务。这个选择过程可能基于多种因素，如任务的优先级、等待时间、资源需求等。</li>
<li><strong>上下文恢复</strong>：调度器加载新选中任务的上下文，恢复其执行状态，然后继续执行。</li>
<li><strong>重复过程</strong>：这个过程周期性地重复，确保所有任务都有机会被执行。</li>
</ol>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130217381.png"/>

<h2 id="Go语言调度模型G、M、P的数量多少合适？"><a href="#Go语言调度模型G、M、P的数量多少合适？" class="headerlink" title="Go语言调度模型G、M、P的数量多少合适？"></a>Go语言调度模型G、M、P的数量多少合适？</h2><ol>
<li>G（Goroutine）：<ul>
<li>Goroutine 的数量理论上没有严格的上限，但在实践中，大量的并发 Goroutine 会消耗内存（每个 Goroutine 都有自己的栈空间），并且过多的 Goroutine 可能导致上下文切换的开销增大，降低性能。</li>
<li><strong>一般建议控制 Goroutine 的数量不要过于庞大</strong>，尤其是活跃 Goroutine 数量。通过合理设计程序，避免不必要的并发，<strong>使用 Channel 和 WaitGroup 等同步机制来控制并发水平。</strong></li>
</ul>
</li>
<li>P（Processor）：<ul>
<li>P 的数量代表了并发执行的 Goroutine 的最大数量，它的默认值由 <code>GOMAXPROCS</code> 环境变量或者 <code>runtime.GOMAXPROCS()</code> 函数设置，如果不设置，<strong>默认为 CPU 核心数。</strong></li>
<li>一般来说，<strong>P 的数量设为与物理 CPU 核心数相匹配是比较合理的做法</strong>，这样可以充分利用多核优势。不过，在某些场景下，比如 CPU 密集型应用且核心数量较多时，可以尝试减小 P 的数量来观察效果，有时可能会因为减少上下文切换而提升性能。</li>
<li><strong>如果应用存在大量 I&#x2F;O 密集型操作，适度增加 P 的数量（不超过 CPU 核心数）</strong>可能有利于提高系统的整体吞吐量，因为 I&#x2F;O 阻塞时，<strong>M 可以释放并服务于其他 P。</strong></li>
</ul>
</li>
<li>M（Machine&#x2F;OS Thread）：<ul>
<li><strong>M 的数量理论上可以大于 P，多余的部分会处于休眠状态，等待被唤醒并关联到一个 P 上执行 Goroutine。</strong></li>
<li>Go 运行时会自动管理 M 的数量，确保有足够的 M 来运行所有关联到 P 的 Goroutine。</li>
<li>在默认情况下，<strong>Go 调度器会根据 P 和 G 的数量以及系统资源动态调整 M 的数量，以达到较好的资源利用率。</strong></li>
</ul>
</li>
</ol>
<p>总结来说，大部分情况下无需特别关注 M 的数量，<strong>只需合理设置 P 的数量以匹配系统资源和应用需求</strong>。<strong>而对于 G 的数量，应尽量控制在合理的范围内，以避免内存浪费和过度的上下文切换。</strong>通过观察和测量实际应用的性能，可以进一步微调 P 和 G 的数量来优化程序的并发处理能力。</p>
<h2 id="GMP模型中，M-发生系统调用了-G-和-P-会怎么样"><a href="#GMP模型中，M-发生系统调用了-G-和-P-会怎么样" class="headerlink" title="GMP模型中，M 发生系统调用了, G 和 P 会怎么样"></a>GMP模型中，M 发生系统调用了, G 和 P 会怎么样</h2><p>在Go语言的GMP调度模型中，当一个系统线程M（Machine）遇到需要执行系统调用时，会发生以下情况：</p>
<ol>
<li><strong>M与P解绑</strong>：M在执行系统调用前会先尝试释放与之关联的处理器P（Processor）。这是因为系统调用很可能会导致M阻塞，为了不让P闲置，M会把P交给调度器，让其他可运行的M来使用P继续执行Goroutine（G），从而提高CPU利用率。</li>
<li><strong>G的调度</strong>：正在执行的Goroutine（G）会因为M的阻塞而暂停执行。这个G会被放回到P的本地队列或者全局队列中，等待下一个可用的M来获取并继续执行。如果G正在进行系统调用，当系统调用完成后，G需要重新获取P才能继续执行。</li>
<li><strong>P的重分配</strong>：释放的P可以被重新分配给其他空闲的M，或者如果有新的M创建，也可以分配给新M，使得这些M能够带着P去执行Goroutine队列中的任务。</li>
<li><strong>M的恢复</strong>：当M完成系统调用并解除阻塞后，它会尝试从调度器那里重新获取一个P，然后继续执行Goroutines。如果当前没有可用的P，M可能会进入休眠状态，直到有P可用时被唤醒。</li>
</ol>
<p>这样的设计确保了即使某个M因为系统调用而阻塞，也不会影响到整个程序的并发执行能力，提高了系统的响应速度和吞吐量。</p>
<h4 id="M-系统调用结束以后会怎么样"><a href="#M-系统调用结束以后会怎么样" class="headerlink" title="M 系统调用结束以后会怎么样"></a>M 系统调用结束以后会怎么样</h4><p>当M（Machine，代表操作系统线程）完成系统调用并结束阻塞状态后，它会尝试恢复执行Go的goroutine。具体步骤如下：</p>
<ol>
<li><strong>尝试获取P（Processor）</strong>：M会首先尝试从调度器中获取一个空闲的P。P包含了执行环境和本地的任务队列，对于Goroutine的执行至关重要。</li>
<li><strong>获取G并执行</strong>：<ul>
<li>如果M成功获取到了P，它会查看P的本地队列是否有待执行的Goroutine（G）。如果有，M会从P的本地队列中取出一个G并开始执行。</li>
<li>如果P的本地队列为空，M可能会从全局队列中取出Goroutine来执行，或者如果全局队列也为空，M可能会尝试从其他P的本地队列中“偷取”Goroutine来避免空闲。</li>
</ul>
</li>
<li><strong>无P可获取</strong>：如果此时没有空闲的P可以分配给M，M会进入休眠状态或者被回收。M进入休眠意味着它不会占用CPU资源，而是等待条件满足时被唤醒，比如有新的任务到来或已有任务完成，从而可以重新获取P并开始执行Goroutine。</li>
<li><strong>维持平衡</strong>：Go的运行时系统（runtime）会持续监控M、P、G的状态，以确保资源的有效利用和负载均衡。<strong>例如，sysmon监控线程会定期检查是否有阻塞过久的M，并可能采取行动促进其恢复工作。</strong></li>
</ol>
<h4 id="M0-amp-G0"><a href="#M0-amp-G0" class="headerlink" title="M0 &amp; G0"></a>M0 &amp; G0</h4><p><strong>M0和G0会放在全局空间</strong></p>
<h5 id="M0"><a href="#M0" class="headerlink" title="M0"></a>M0</h5><ul>
<li>启动程序后编号为0的主线程</li>
<li>在全局变量runtime.m0中，不需要再heap上分配</li>
<li>负责执行初始化操作和启动第一个G</li>
<li>在启动第一个G之后就与其他M一样了</li>
</ul>
<h5 id="G0"><a href="#G0" class="headerlink" title="G0"></a>G0</h5><ul>
<li>每次启动一个M，都会第一个创建的G，就是G0</li>
<li>G0仅用于负责调度G</li>
<li>G0不指向任何可执行的函数</li>
<li>每个M都会有一个自己的G0</li>
<li>在调度或系统调用时会使用M会切换到G0，来调度</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130225105.png"/>

<p>G的9种状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    _Gidle = <span class="literal">iota</span> <span class="comment">// 0 </span></span><br><span class="line">    <span class="comment">// 没有执行代码，没有栈的所有权，存储在运行队列中</span></span><br><span class="line">    _Grunnable <span class="comment">// 1 </span></span><br><span class="line">    <span class="comment">// 可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</span></span><br><span class="line">    _Grunning <span class="comment">// 2 </span></span><br><span class="line">    <span class="comment">// 正在执行系统调用，拥有栈的所有权，没有执行用户代码，</span></span><br><span class="line">    <span class="comment">// 被赋予了内核线程 M 但是不在运行队列上</span></span><br><span class="line">    _Gsyscall <span class="comment">// 3 </span></span><br><span class="line">    <span class="comment">// 由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，</span></span><br><span class="line">    <span class="comment">// 但是可能存在于 Channel 的等待队列上</span></span><br><span class="line">    _Gwaiting <span class="comment">// 4  </span></span><br><span class="line">    <span class="comment">//_Gmoribund_unused 当前未使用，但在 gdb 中硬编码脚本</span></span><br><span class="line">     _Gmoribund_unused <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 表示当前goroutine没有被使用，没有执行代码，可能有分配的栈</span></span><br><span class="line">    _Gdead <span class="comment">// 6  </span></span><br><span class="line">    <span class="comment">//_Genqueue_unused当前未使用</span></span><br><span class="line">    _Genqueue_unused <span class="comment">// 7</span></span><br><span class="line">    <span class="comment">// 栈正在被拷贝，没有执行代码，不在运行队列上</span></span><br><span class="line">    _Gcopystack <span class="comment">// 8 </span></span><br><span class="line">    <span class="comment">// 由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</span></span><br><span class="line">    _Gpreempted <span class="comment">// 9 </span></span><br><span class="line">    <span class="comment">// GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</span></span><br><span class="line">    	_Gscan          = <span class="number">0x1000</span></span><br><span class="line">    	_Gscanrunnable  = _Gscan + _Grunnable  <span class="comment">// 0x1001</span></span><br><span class="line">		_Gscanrunning   = _Gscan + _Grunning   <span class="comment">// 0x1002</span></span><br><span class="line">		_Gscansyscall   = _Gscan + _Gsyscall   <span class="comment">// 0x1003</span></span><br><span class="line">		_Gscanwaiting   = _Gscan + _Gwaiting   <span class="comment">// 0x1004</span></span><br><span class="line">		_Gscanpreempted = _Gscan + _Gpreempted <span class="comment">// 0x1009</span></span><br><span class="line">    </span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h2 id="M去抢占G的时候会有一个自旋和非自旋的状态"><a href="#M去抢占G的时候会有一个自旋和非自旋的状态" class="headerlink" title="M去抢占G的时候会有一个自旋和非自旋的状态"></a>M去抢占G的时候会有一个自旋和非自旋的状态</h2><h2 id="OOM问题"><a href="#OOM问题" class="headerlink" title="OOM问题"></a>OOM问题</h2><h5 id="内存溢出-out-of-memory，简称OOM"><a href="#内存溢出-out-of-memory，简称OOM" class="headerlink" title="内存溢出(out of memory，简称OOM)"></a>内存溢出(out of memory，简称OOM)</h5><p>内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，简单点说就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出出现out of memory异常。</p>
<h5 id="内存泄露-memory-leak"><a href="#内存泄露-memory-leak" class="headerlink" title="内存泄露(memory leak)"></a>内存泄露(memory leak)</h5><p>内存泄露是指程序在申请内存后，无法释放已申请的内存空间，简单点说就是你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。</p>
<p>若线程发生OOM，那么他在GPM模型中会被Kill掉</p>
<p>goroutine 发生 OOM</p>
<h1 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h1><h2 id="锁的基本概念"><a href="#锁的基本概念" class="headerlink" title="锁的基本概念"></a>锁的基本概念</h2><p>锁（通常是指 <code>sync.Mutex</code>互斥锁 或 <code>sync.RWMutex</code>读写互斥锁）在 Go 语言中主要用于保护共享资源（如变量、数据结构）免受并发访问时的数据竞争。当多个 <code>goroutine</code> 并发访问和修改相同的资源，并且这些修改操作不能原子性完成时，就需要使用锁来确保每次只有一个 <code>goroutine</code> 能够访问和修改资源。</p>
<h2 id="golang有哪些类型的锁"><a href="#golang有哪些类型的锁" class="headerlink" title="golang有哪些类型的锁"></a>golang有哪些类型的锁</h2><p>在 Go 语言中，标准库 <code>sync</code> 包提供了以下几种类型的锁来实现同步控制：</p>
<ol>
<li><p><strong>互斥锁（Mutex）</strong>: <code>sync.Mutex</code> 是最基本的互斥锁类型，它在同一时刻只允许一个 Goroutine 访问受保护的资源。提供了 <code>Lock()</code> 和 <code>Unlock()</code> 方法，分别用于获取和释放锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读写互斥锁（RWMutex）</strong>: <code>sync.RWMutex</code> 是更为灵活的锁，它可以允许多个 Goroutine 同时读取数据，但写入数据时会独占锁，阻止其他 Goroutine 的读写。提供了 <code>RLock()</code>（读取锁）和 <code>RUnlock()</code>（释放读取锁），以及 <code>Lock()</code>（写入锁）和 <code>Unlock()</code>（释放写入锁）方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rwmu sync.RWMutex</span><br><span class="line">rwmu.RLock()</span><br><span class="line"><span class="comment">// 读取共享资源</span></span><br><span class="line">rwmu.RUnlock()</span><br><span class="line"></span><br><span class="line">rwmu.Lock()</span><br><span class="line"><span class="comment">// 写入共享资源</span></span><br><span class="line">rwmu.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>互斥锁（Once）</strong>: <code>sync.Once</code> 用于确保某个操作（通常是一个初始化操作）只执行一次，即使在并发环境下也是如此。它通过内部的互斥锁机制实现，并提供了 <code>Do(f func())</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 只执行一次的初始化操作</span></span><br><span class="line">    data = expensiveInitialization()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>条件变量（Cond）</strong>: <code>sync.Cond</code> 用于在满足特定条件时唤醒等待的 Goroutine，它基于互斥锁实现，提供了 <code>L</code> 字段（一个互斥锁）以及 <code>Wait()</code>, <code>Signal()</code> 和 <code>Broadcast()</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cond sync.Cond</span><br><span class="line">cond.L = &amp;sync.Mutex&#123;&#125;</span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="comment">// 某条件不满足</span></span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 在被 Signal() 或 Broadcast() 唤醒后，重新检查条件</span></span><br><span class="line">cond.L.Unlock()</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>原子操作（Atomic）</strong>: 虽然不是传统意义上的锁，但 <code>sync/atomic</code> 包提供了原子操作，如原子增加、减少、交换和比较交换等，可用于实现无锁数据结构和细粒度的同步控制，这些操作在硬件层面上保证了并发安全。</p>
</li>
</ol>
<p>请注意，Go 语言的并发设计鼓励使用 channels（通道）进行通信来代替共享内存，但以上锁机制在某些场景下仍然是必要的，例如实现传统的锁模式或者对现有 C&#x2F;C++ 库进行封装时。</p>
<h4 id="Go-如何实现原子操作？"><a href="#Go-如何实现原子操作？" class="headerlink" title="Go 如何实现原子操作？"></a>Go 如何实现原子操作？</h4><p>原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。</p>
<p>在 Go 语言中，原子操作通过 <code>sync/atomic</code> 包来实现。<code>sync/atomic</code> 包提供了对整型值、指针以及其他一些类型进行原子操作的支持，这些操作在多线程或多 Goroutine 环境下是线程安全的，即在操作过程中不会被打断，保证了操作的完整性。</p>
<p>以下是一些 <code>sync/atomic</code> 包提供的原子操作函数示例：</p>
<ol>
<li>整数类型的原子操作：<ul>
<li><code>SwapInt32/64</code>：交换（替换）一个 32&#x2F;64 位整数变量的值，返回旧值。</li>
<li><code>CompareAndSwapInt32/64</code>：比较并交换，只有当当前值等于预期值时才将整数变量设置为新值，返回旧值。</li>
<li><code>AddInt32/64</code>：原子地将指定值加到整数变量上，并返回新的值。</li>
<li><code>LoadInt32/64</code>：原子地读取整数变量的值。</li>
<li><code>StoreInt32/64</code>：原子地将值存储到整数变量中。</li>
</ul>
</li>
<li>指针类型的原子操作：<ul>
<li><code>SwapPointer</code>：交换指针变量的值，返回旧值。</li>
<li><code>CompareAndSwapPointer</code>：比较并交换指针变量的值。</li>
</ul>
</li>
<li>其他类型：<ul>
<li>对于无符号整数类型（<code>uint32</code>、<code>uint64</code>）和 <code>uintptr</code> 类型也有类似的原子操作。</li>
<li><code>AtomicXXX</code> 函数家族还提供了对 <code>bool</code> 类型、<code>Value</code> 类型（用于封装任意类型，通过接口实现）的原子操作支持。</li>
</ul>
</li>
</ol>
<h2 id="悲观锁、乐观锁是什么？Mutex-是悲观锁还是乐观锁？"><a href="#悲观锁、乐观锁是什么？Mutex-是悲观锁还是乐观锁？" class="headerlink" title="悲观锁、乐观锁是什么？Mutex 是悲观锁还是乐观锁？"></a>悲观锁、乐观锁是什么？<code>Mutex</code> 是悲观锁还是乐观锁？</h2><p>悲观锁和乐观锁是处理数据并发访问的两种不同策略：</p>
<ul>
<li><strong>悲观锁</strong>：假设数据经常发生冲突，因此在数据处理前<strong>先进行加锁</strong>。传统的关系型数据库通常使用这种类型的锁，如行锁、表锁等。它确保了操作的原子性、一致性、隔离性和持久性，<strong>但可能会降低并发性能，因为其他线程必须等待锁被释放才能访问数据。</strong></li>
<li><strong>乐观锁</strong>：假设数据通常不会发生冲突，因此不会在数据处理一开始就加锁，而是<strong>在数据提交更新时检查是否有冲突</strong>。<strong>如果有冲突，则重新尝试或返回错误信息。</strong>这种方式在冲突少的情况下能提高吞吐量，<strong>适用于读多写少的场景</strong>。</li>
</ul>
<p>具体到Go语言中，<code>sync.Mutex</code>是一种典型的<strong>悲观锁</strong>实现，它在多个goroutine访问共享资源时强制加锁，确保同一时间只有一个goroutine能够访问该资源。而atomic包中的函数则提供了一种乐观锁的实现方式，它们通常在无冲突或冲突较少的情况下表现得更为高效。</p>
<h3 id="Mutex-有几种模式？"><a href="#Mutex-有几种模式？" class="headerlink" title="Mutex 有几种模式？"></a>Mutex 有几种模式？</h3><ul>
<li><strong>正常模式（Normal Mode）</strong>：这是 Mutex 的默认模式。在这个模式下，当一个 goroutine 试图获取锁时，<strong>会先自旋几次尝试通过原子操作获取锁。如果在自旋过程中未能获取到锁，该 goroutine 将进入等待队列，</strong>按照<strong>先入先出（FIFO）</strong>的顺序排队等待。然而，当锁被释放时，排在队列首位的等待者并不总是能立即获得锁，<strong>它还需要与后续进入的正在自旋的 goroutine 竞争锁的所有权。</strong></li>
<li><strong>饥饿模式（Starvation Mode）</strong>：当一个 goroutine 等待获取锁的时间超过一定阈值（例如 1ms），<strong>它会将 Mutex 切换到饥饿模式</strong>。在这种模式下，锁的所有权会直接从解锁的 goroutine 传递给等待队列中排在最前面的 goroutine，而不是让新来的 goroutine 竞争获取，<strong>这样可以防止长时间等待的 goroutine 饥饿。</strong></li>
</ul>
<p>此外，Mutex 还具有适应能力，能够根据当前的使用情况自动切换模式。如果持有锁的 goroutine 的总等待时间小于一定的阈值（如 1ms），或者等待队列为空，Mutex 会被置于正常模式。这种设计旨在在保持高性能的同时，减少长时间等待的风险。</p>
<h3 id="除了-mutex-以外还有那些方式安全读写共享变量"><a href="#除了-mutex-以外还有那些方式安全读写共享变量" class="headerlink" title="除了 mutex 以外还有那些方式安全读写共享变量"></a>除了 mutex 以外还有那些方式安全读写共享变量</h3><p>可以通过<strong>Channel和原子操作</strong>来安全地读写共享变量</p>
<ul>
<li><strong>Channel</strong>：Goroutine之间可以通过Channel进行通信，无缓冲的Channel确保了发送和接收操作是同步的。</li>
<li><strong>原子操作</strong>：Go语言中的原子操作可以用于对共享变量进行无锁（lock-free）的读写。例如可以用个数为 1 的信号量（semaphore）实现互斥</li>
</ul>
<h2 id="goroutine-的自旋占用资源如何解决"><a href="#goroutine-的自旋占用资源如何解决" class="headerlink" title="goroutine 的自旋占用资源如何解决"></a>goroutine 的自旋占用资源如何解决</h2><p>自旋锁是一种互斥锁的实现方式，当线程尝试获得一个锁时，如果发现这个锁已经被其他线程占用，它会不断地重复尝试获取锁，而不是放弃 CPU 的控制权。这个过程被称为自旋，它能够有效地减少线程切换的开销，提高锁的性能。 自旋锁同时避免了进程上下文的调度开销，因此对于短时间内的线程阻塞场景是有效的。</p>
<p>以下是一些解决方案：</p>
<ul>
<li><strong>减少自旋次数</strong>：可以通过调整 Mutex 的自旋次数来减少 goroutine 的自旋时间。例如，<strong>可以将自旋次数从默认的多次减少到一次或两次。</strong></li>
<li><strong>使用超时机制</strong>：可以在 Mutex 上设置超时时间，当超过该时间后，goroutine 将放弃自旋并进入阻塞状态等待锁释放。这可以避免 goroutine 长时间占用 CPU 资源。</li>
<li><strong>使用其他同步原语</strong>：除了 Mutex 外，<strong>还可以使用其他的同步原语</strong>，如 Channel、WaitGroup 等来实现并发控制。这些原语可以更有效地利用系统资源，避免 goroutine 的自旋操作。</li>
<li><strong>优化代码逻辑</strong>：通过优化代码逻辑，减少 goroutine 之间的竞争和冲突，从而降低自旋操作的频率和持续时间。</li>
</ul>
<h1 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a>并发相关</h1><h2 id="怎么控制并发数"><a href="#怎么控制并发数" class="headerlink" title="怎么控制并发数"></a>怎么控制并发数</h2><ol>
<li><strong>使用goroutine</strong>：Go语言的并发模型基于goroutine，每个goroutine都是一个独立的执行单元。通过创建多个goroutine来实现并发操作，可以有效地控制并发数。你可以根据需要创建适量的goroutine，以实现对并发数的控制。</li>
<li><strong>使用channel</strong>：Channel是Go语言中用于在不同goroutine之间传递数据的一种机制。通过使用channel，可以实现对并发数的限制。你可以创建一个带缓冲区的channel，并限制其容量，从而控制同时运行的goroutine数量。当channel满时，新的goroutine会等待直到有可用的空位。</li>
<li><strong>使用sync包中的WaitGroup</strong>：WaitGroup是Go语言提供的一个同步原语，用于等待一组goroutine的完成。通过使用WaitGroup，你可以控制并发数，确保所有goroutine都完成后再继续执行后续操作。</li>
<li><strong>使用context包</strong>：Context包提供了一种优雅的方式来控制并发任务的取消和超时。通过使用context，你可以设置超时时间或手动取消任务，从而控制并发数。</li>
<li><strong>使用第三方库</strong>：有一些第三方库提供了更高级的并发控制功能，如<code>golang.org/x/sync/semaphore</code>、<code>golang.org/x/sync/errgroup</code>等。这些库提供了更灵活的并发控制选项，可以根据具体需求选择适合的库进行使用。</li>
</ol>
<h2 id="多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-和-recover-捕获？"><a href="#多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-和-recover-捕获？" class="headerlink" title="多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 和 recover 捕获？"></a>多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 和 recover 捕获？</h2><p>可以。Go语言，可以使用多值返回来返回错误。<strong>不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：</strong>defer, panic, recover Go中，<strong>对异常处理的原则是：多用error包，少用panic</strong></p>
<h3 id="goroutine-池"><a href="#goroutine-池" class="headerlink" title="goroutine 池"></a>goroutine 池</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/finghting321/article/details/106492915">golang的协程池</a></p>
<h4 id="为什么需要协程池？"><a href="#为什么需要协程池？" class="headerlink" title="为什么需要协程池？"></a>为什么需要协程池？</h4><p>虽然go语言自带“高并发”的标签，其并发编程就是由groutine实现的，因其消耗资源低（大约2KB左右，线程通常2M左右），性能高效，开发成本低的特性而被广泛应用到各种场景，例如服务端开发中使用的HTTP服务，在golang <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/net/http/server.go">net&#x2F;http</a>包中，每一个被监听到的tcp链接都是由一个groutine去完成处理其上下文的，由此使得其拥有极其优秀的并发量吞吐量。</p>
<p>但是，如果无休止的开辟Goroutine依然会出现高频率的调度Groutine，那么依然会浪费很多上下文切换的资源，导致做无用功。所以设计一个Goroutine池限制Goroutine的开辟个数在大型并发场景还是必要的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单携程池</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 有关Task任务相关定义及操作 */</span></span><br><span class="line"><span class="comment">//定义任务Task类型,每一个任务Task都可以抽象成一个函数</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	f <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> <span class="comment">//一个无参的函数类型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过NewTask来创建一个Task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTask</span><span class="params">(f <span class="keyword">func</span>()</span></span> <span class="type">error</span>) *Task &#123;</span><br><span class="line">	t := Task&#123;</span><br><span class="line">		f: f,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;t</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行Task任务的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span></span> Execute() &#123;</span><br><span class="line">	t.f() <span class="comment">//调用任务所绑定的函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 有关协程池的定义及操作 */</span></span><br><span class="line"><span class="comment">//定义池类型</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	EntryChannel <span class="keyword">chan</span> *Task <span class="comment">//对外接收Task的入口</span></span><br><span class="line">	worker_num   <span class="type">int</span>        <span class="comment">//协程池最大worker数量,限定Goroutine的个数</span></span><br><span class="line">	JobsChannel  <span class="keyword">chan</span> *Task <span class="comment">//协程池内部的任务就绪队列</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个协程池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(<span class="built_in">cap</span> <span class="type">int</span>)</span></span> *Pool &#123;</span><br><span class="line">	p := Pool&#123;</span><br><span class="line">		EntryChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> *Task),</span><br><span class="line">		worker_num:   <span class="built_in">cap</span>,</span><br><span class="line">		JobsChannel:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Task),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//协程池创建一个worker并且开始工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> worker(work_ID <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//worker不断的从JobsChannel内部任务队列中拿任务</span></span><br><span class="line">	<span class="keyword">for</span> task := <span class="keyword">range</span> p.JobsChannel &#123;</span><br><span class="line">		<span class="comment">//如果拿到任务,则执行task任务</span></span><br><span class="line">		task.Execute()</span><br><span class="line">		fmt.Println(<span class="string">&quot;worker ID &quot;</span>, work_ID, <span class="string">&quot; 执行完毕任务&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让协程池Pool开始工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Run() &#123;</span><br><span class="line">	<span class="comment">//1,首先根据协程池的worker数量限定,开启固定数量的Worker,</span></span><br><span class="line">	<span class="comment">//  每一个Worker用一个Goroutine承载</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.worker_num; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;开启固定数量的Worker:&quot;</span>, i)</span><br><span class="line">		<span class="keyword">go</span> p.worker(i)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//2, 从EntryChannel协程池入口取外界传递过来的任务</span></span><br><span class="line">	<span class="comment">//   并且将任务送进JobsChannel中</span></span><br><span class="line">	<span class="keyword">for</span> task := <span class="keyword">range</span> p.EntryChannel &#123;</span><br><span class="line">		p.JobsChannel &lt;- task</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//3, 执行完毕需要关闭JobsChannel</span></span><br><span class="line">	<span class="built_in">close</span>(p.JobsChannel)</span><br><span class="line">	fmt.Println(<span class="string">&quot;执行完毕需要关闭JobsChannel&quot;</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//4, 执行完毕需要关闭EntryChannel</span></span><br><span class="line">	<span class="built_in">close</span>(p.EntryChannel)</span><br><span class="line">	fmt.Println(<span class="string">&quot;执行完毕需要关闭EntryChannel&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个Task</span></span><br><span class="line">	t := NewTask(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建一个Task:&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//创建一个协程池,最大开启3个协程worker</span></span><br><span class="line">	p := NewPool(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//开一个协程 不断的向 Pool 输送打印一条时间的task任务</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			p.EntryChannel &lt;- t</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//启动协程池p</span></span><br><span class="line">	p.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="go-playground-x2F-pool"><a href="#go-playground-x2F-pool" class="headerlink" title="go-playground&#x2F;pool"></a>go-playground&#x2F;pool</h4><p>上面的协程池虽然简单，但是对于每一个并发任务的状态，pool的状态缺少控制，我们可以看看<a target="_blank" rel="noopener" href="https://github.com/go-playground/pool">go-playground&#x2F;pool</a>的源码实现，“源码面前，如同裸奔”。先从每一个需要执行的任务入手，该库中对并发单元做了如下的结构体，可以看到除工作单元的值，错误，执行函数等，还用了三个分别表示，取消，取消中，写 的三个并发安全的原子操作值来标识其运行状态。</p>
<p>依赖包下载： go get “gopkg.in&#x2F;go-playground&#x2F;pool.v3”</p>
<p><a target="_blank" rel="noopener" href="https://github.com/go-playground/pool">GitHub源码参考</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gopkg.in/go-playground/pool.v3&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendMail</span><span class="params">(<span class="type">int</span> <span class="type">int</span>)</span></span> pool.WorkFunc &#123;</span><br><span class="line">	fn := <span class="function"><span class="keyword">func</span><span class="params">(wu pool.WorkUnit)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="comment">// sleep 1s 模拟发邮件过程</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 模拟异常任务需要取消</span></span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span> == <span class="number">17</span> &#123;</span><br><span class="line">			wu.Cancel()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> wu.IsCancelled() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;send to&quot;</span>, <span class="type">int</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化groutine数量为20的pool</span></span><br><span class="line">	p := pool.NewLimited(<span class="number">20</span>)</span><br><span class="line">	<span class="keyword">defer</span> p.Close()</span><br><span class="line">	batch := p.Batch()</span><br><span class="line">	<span class="comment">// 设置一个批量任务的过期超时时间</span></span><br><span class="line">	t := time.After(<span class="number">10</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			batch.Queue(SendMail(i)) <span class="comment">// 往批量任务中添加workFunc任务</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 通知批量任务不再接受新的workFunc, 如果添加完workFunc不执行改方法的话将导致取结果集时done channel一直阻塞</span></span><br><span class="line">		batch.QueueComplete()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// // 获取批量任务结果集, 因为 batch.Results 中要close results channel 所以不能将其放在LOOP中执行</span></span><br><span class="line">	r := batch.Results()</span><br><span class="line">LOOP:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-t:</span><br><span class="line">			<span class="comment">// 超时通知</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;超时通知&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span> LOOP</span><br><span class="line">		<span class="keyword">case</span> email, ok := &lt;-r:</span><br><span class="line">			<span class="comment">// 读取结果集</span></span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="keyword">if</span> err := email.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">&quot;读取结果集错误，error info:&quot;</span>, err.Error())</span><br><span class="line">				&#125;</span><br><span class="line">				fmt.Println(<span class="string">&quot;错误结果集:&quot;</span>, email.Value())</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span> LOOP</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>go-playground&#x2F;pool相比简单的协程池， 对pool, worker的状态有了很好的管理。但是在第一个实现的简单groutine池和go-playground&#x2F;pool中，都是先启动预定好的groutine来完成任务执行，在并发量远小于任务量的情况下确实能够做到groutine的复用，如果任务量不多则会导致任务分配到每个groutine不均匀，甚至可能出现启动的groutine根本不会执行任务从而导致浪费，而且对于协程池也没有动态的扩容和缩小。接下来了解下<a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">ants</a>的设计和实现。</p>
<h4 id="ants库"><a href="#ants库" class="headerlink" title="ants库"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/Geffin/article/details/113996403">ants库</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">ants</a>是一个受<a target="_blank" rel="noopener" href="https://github.com/valyala/fasthttp">fasthttp</a>启发的高性能协程池，fasthttp号称是比go原生的net&#x2F;http快10倍，其原因之一就是采用了各种池化技术， ants相比之前两种协程池，其模型更像是之前接触到的数据库连接池，需要从空余的worker中取出一个来执行任务, 当无可用空余worker的时候再去创建，而当pool的容量达到上线之后，剩余的任务阻塞等待当前进行中的worker执行完毕将worker放回pool, 直至pool中有空闲worker。 ants在内存的管理上做得很好，除了定期清除过期worker(一定时间内没有分配到任务的worker)，ants还实现了一种适用于大批量相同任务的pool, 这种pool与一个需要大批量重复执行的函数锁绑定，避免了调用方不停的创建，更加节省内存。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/panjf2000/ants">ants源码参考</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/panjf2000/ants&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMail</span><span class="params">(i <span class="type">int</span>, wg *sync.WaitGroup)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cnt <span class="type">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">			fmt.Println(<span class="string">&quot;send mail to &quot;</span>, i)</span><br><span class="line">			cnt++</span><br><span class="line">			<span class="keyword">if</span> cnt &gt; <span class="number">5</span> &amp;&amp; i == <span class="number">1</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;退出协程ID:&quot;</span>, i)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//申请一个协程池对象</span></span><br><span class="line">	pool, _ := ants.NewPool(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//关闭协程池</span></span><br><span class="line">	<span class="keyword">defer</span> pool.Release()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 向pool提交任务</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		pool.Submit(sendMail(i, &amp;wg))</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中提到， ants的吞吐量能够比原生groutine高出N倍，内存节省10到20倍。</p>
<h1 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h1><h2 id="go-gc-是怎么实现的？（必问）"><a href="#go-gc-是怎么实现的？（必问）" class="headerlink" title="go gc 是怎么实现的？（必问）"></a>go gc 是怎么实现的？（必问）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaodaoge_it/article/details/121890145">一文弄懂 Golang GC、三色标记、混合写屏障机制</a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><strong>赋值器</strong>:说白了就是你写的程序代码，在程序的执行过程中，可能会改变对象的引用关系，或者创建新的引用。</p>
<p><strong>回收器</strong>:垃圾回收器的责任就是去干掉那些程序中不再被引用得对象</p>
<p><strong>STW</strong>:全称是stop the word，GC期间某个阶段会停止所有的赋值器，中断你的程序逻辑，以确定引用关系。</p>
<blockquote>
<p>举个栗子，有一个大院，孩子特别多，老师希望他们以班长为起点手牵手在一起，但总有几个不听话的孩子，没有牵手，你为了找出这些不听话的孩子，你会以班长为起点，一个一个的往后捋。但是如果有一个名叫张三的孩子，之前在队尾，后来在你数到队伍中间的时候，又跑到了队头和班长牵手去了，当你数完后，因为没有统计到张三，你就认为张三没有听话，没有奖励小红花，岂不让孩子比窦娥还冤…，所以这种情况下，你需要先让孩子们不动【映射到程序的概念，即STW停止程序运行】，然后再统计。</p>
</blockquote>
<p><strong>root对象</strong>:根对象是指赋值器不需要通过其他对象就可以直接访问到的对象，通过Root对象, 可以追踪到其他存活的对象。常见的root对象有：</p>
<ul>
<li><strong>全局变量</strong>：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li>
<li><strong>执行栈</strong>：每个 goroutine (包括main函数)都拥有自己的执行栈，这些执行栈上包含<strong>栈上的变量及堆内存指针</strong>。【堆内存指针即在gorouine中申请或者引用了在堆内存的变量】</li>
</ul>
<h3 id="Go的GC发展演变史"><a href="#Go的GC发展演变史" class="headerlink" title="Go的GC发展演变史"></a>Go的GC发展演变史</h3><h4 id="v-1-3-标记清除法"><a href="#v-1-3-标记清除法" class="headerlink" title="v 1.3-标记清除法"></a>v 1.3-标记清除法</h4><p>标记清除法主要包含两个步骤：</p>
<ul>
<li><strong>标记</strong></li>
<li><strong>清除</strong></li>
</ul>
<p>示例如下：</p>
<ol>
<li>开启STW，停止程序的运行，图中是本次GC涉及到的root节点和相关对象。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091631848.png"/>

<ol start="2">
<li><p>从根节点出发，标记所有可达对象。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091633161.png"/>
</li>
<li><p>停止STW，然后回收所有未被标记的对象</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091633218.png"/>

<p>标记清除法的<strong>最大弊端就是在整个GC期间需要STW，将整个程序暂停</strong>。因为如果不进行STW的话，会出现已经被标记的对象A，引用了新的未被标记的对象B，但由于对象A已经标记过了，不会再重新扫描A对B的可达性，从而将B对象当做垃圾回收掉。</p>
<p>说实话这种全程STW的GC算法真的是如过街老鼠，人见人打…好家伙，让我程序停下来，专门去做垃圾回收这件事，在追求高性能的今天，很难有人可以接受这种性能损耗。</p>
<p>所以Golang团队这个时期就开始专注于如何能提升GC的性能，这里希望各位道友能明白Golang团队对GC算法优化的方向是什么，或者目标是什么，那就是让GC和用户程序可以互不干扰，并发进行。所以才有了后面的三色标记法。</p>
</li>
</ol>
<h4 id="v1-5-三色标记法"><a href="#v1-5-三色标记法" class="headerlink" title="v1.5 三色标记法"></a>v1.5 三色标记法</h4><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091634260.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091634242.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091634946.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091634749.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406091635828.png"/>

<p>对于上述的三色标记法来讲,仍然需要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。</p>
<h5 id="如果三色标记法不被STW保护"><a href="#如果三色标记法不被STW保护" class="headerlink" title="如果三色标记法不被STW保护"></a>如果三色标记法不被STW保护</h5><p>条件1:一个白色对象被黑色对象引用(白色被挂在黑色下）</p>
<p>条件2:灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色）</p>
<p>如果两个条件同时满足，那么就会出现对象丢失的现象</p>
<p>从而引申出 <strong>强三色不变式</strong> 和 <strong>弱三色不变式</strong></p>
<h5 id="强三色不变式"><a href="#强三色不变式" class="headerlink" title="强三色不变式"></a>强三色不变式</h5><p>强制性的不允许黑色对象引用白色对象 (破坏条件1)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111718917.png"/>

<h5 id="弱三色不变式"><a href="#弱三色不变式" class="headerlink" title="弱三色不变式"></a>弱三色不变式</h5><p>黑色对象可以引用白色对象， </p>
<p>白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象 （破坏条件2）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111716801.png"/>



<h5 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h5><p>go的栈和java的栈不一样，go会直接在栈上创建对象，只有逃逸时才会把栈上的对象写到堆上</p>
<h6 id="插入屏障-（不在栈上使用）"><a href="#插入屏障-（不在栈上使用）" class="headerlink" title="插入屏障 （不在栈上使用）"></a>插入屏障 （不在栈上使用）</h6><p>具体操作：在A对象引用B对象的时候，B对象被标记为灰色。（将B挂在A下游，B必须被标记为灰色）</p>
<p>满足：强三色不变式.(不存在黑色对象引用白色对象的情况了，因为白色会强制变成灰色）</p>
<p>1. </p>
<blockquote>
<p>对象9因为在栈内存中 不涉及插入屏障，所以创建的对象不会被标记为灰色</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111729757.png"/>

<ol start="2">
<li><p>继续循环上述流程进行三色标记，直到没有灰色节点</p>
</li>
<li><p>在准备回收白色前，重新遍历扫描一次栈空间。<br>此时加STW暂停保护栈，防止外界干扰（有新的白色被黑色添加）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111732320.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111732730.png"/>
</li>
<li><p>清除白色对象</p>
</li>
</ol>
<p>插入写屏障的不足：结束时需要STW来重新扫描栈，大约需要10~100ms</p>
<h6 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h6><p>具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。（不是删除对象 是删除对这个对象的引用）<br>满足：弱三色不变式.(保护灰色对象到白色对象的路径不会断）</p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111737887.png"/></li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111737490.png"/></li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111738503.png"/></li>
</ol>
<p>删除屏障的不足：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h4 id="v1-8-混合写屏障机制"><a href="#v1-8-混合写屏障机制" class="headerlink" title="v1.8 混合写屏障机制"></a>v1.8 混合写屏障机制</h4><p>为了解决插入屏障和删除屏障的所存在的不足，混合写屏障孕育而生</p>
<p>GoV1.8的三色标记法+混合写屏障机制 具体操作：</p>
<ol>
<li><p>GC开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需STW)</p>
</li>
<li><p>GC期间，任何在栈上创建的新对象，均为黑色。</p>
</li>
<li><p>被删除的对象标记为灰色。</p>
</li>
<li><p>被添加的对象标记为灰色。</p>
</li>
</ol>
<p>满足：变形的弱三色不变式.(结合了插入、删除写屏障两者的有点）</p>
<p>优先扫描栈，将栈全部标记为黑</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111746429.png"/>



<h5 id="通过几个场景"><a href="#通过几个场景" class="headerlink" title="通过几个场景"></a>通过几个场景</h5><ol>
<li><p>对象被一个堆对象删除引用，成为栈对象的下游</p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111750411.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111751598.png"/></li>
</ol>
</li>
<li><p>对象被一个栈对象删除引用，成为另一个栈对象的下游</p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111753932.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111753551.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111754493.png"/></li>
</ol>
</li>
<li><p>对象被一个堆对象删除引用，成为另一个堆对象的下游</p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111757264.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111757045.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111758102.png"/></li>
</ol>
</li>
<li><p>对象从一个栈对象删除引用，成为另一个堆对象的下游</p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111801669.png"/></li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111801396.png"/></li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406111802063.png"/></li>
</ol>
</li>
</ol>
<h3 id="go-是-gc-算法是怎么实现的？（中高级）"><a href="#go-是-gc-算法是怎么实现的？（中高级）" class="headerlink" title="go 是 gc 算法是怎么实现的？（中高级）"></a>go 是 gc 算法是怎么实现的？（中高级）</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362668622">Go语言GC实现原理及源码分析</a></p>
<h3 id="gc中STW的时机是什么？各个阶段都要解决什么？"><a href="#gc中STW的时机是什么？各个阶段都要解决什么？" class="headerlink" title="gc中STW的时机是什么？各个阶段都要解决什么？"></a>gc中STW的时机是什么？各个阶段都要解决什么？</h3><p>在 Go 中，GC 回收工作中需要停止所有的 goroutine，这个过程称为 STW（Stop-The-World）。Go 的 GC 会在以下几种情况下触发 STW：</p>
<ul>
<li>手动调用：通过 runtime.GC() 函数手动触发。</li>
<li>内存分配：当程序运行时分配的内存超过一定阈值时，GC 会自动触发。</li>
<li>定时器：GC 也可以定期触发，以确保程序不会长时间运行而出现内存问题。</li>
</ul>
<p>在 GC 的标记和清理两个阶段中，STW 的解决方式略有不同。</p>
<ol>
<li><p><strong>标记</strong></p>
<p>在标记阶段，Go 的 GC 使用三色标记算法进行回收。为了使标记阶段尽可能短且高效，Go 采用了并发标记和增量标记两种策略来减少 STW 的影响。</p>
<ul>
<li>并发标记：在标记阶段，并发地标记和清除对象。这允许同时执行垃圾回收和程序代码，从而最大限度地减少 STW 时间。</li>
<li>增量标记：增量标记可以将标记阶段拆分成多个小步骤，垃圾回收器可以在每个小步骤之间恢复程序运行，这样可以更好地控制 STW 时间。</li>
</ul>
</li>
<li><p><strong>清理</strong></p>
<p>在清理阶段，Go 的 GC 采用了三色标记-清除算法进行垃圾回收。为了尽可能地减少 STW 时间和避免内存碎片问题，Go 引入了两个概念：<strong>根对象和写屏障</strong>。</p>
<ul>
<li>根对象：GC 将所有全局变量、栈、寄存器和程序计数器等标识为根对象，并将其作为垃圾回收的起点。这些对象是一定会被访问到的，因此可以保证它们不会被回收。</li>
<li>写屏障：当程序向一个指针类型的变量赋值时，会触发一个写屏障。写屏障可以用于检测对象是否从白色变为黑色，如果是，则需要将该对象加入到待清理列表中。</li>
</ul>
<p>因此，在清理阶段期间，GC 只需要扫描根对象和待清理列表来确定哪些对象需要被释放即可，在这个过程中不需要遍历整个堆。这样可以显著减少 STW 时间和避免内存碎片问题。</p>
</li>
</ol>
<h3 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h3><p>分为系统触发和主动触发。</p>
<p>1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。</p>
<p>2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。</p>
<p>3）gcTriggerCycle：如果没有开启 GC，则启动 GC。</p>
<p>4）手动触发的 runtime.GC 方法。</p>
<h2 id="说说-sync-singleflight-工具"><a href="#说说-sync-singleflight-工具" class="headerlink" title="说说 sync/singleflight 工具"></a>说说 <code>sync/singleflight</code> 工具</h2><p> <code>sync/singleflight</code> 是 Go 语言标准库中的一个<strong>并发控制工具</strong>，它提供了一种避免多个 Goroutine 同时执行相同的工作（例如远程调用或昂贵的计算）的功能，这被称<strong>为“单飞”模式</strong>。当有多个 Goroutine 同时请求相同的任务时，SingleFlight 会确保这些请求合并为一个，仅执行一次，并将结果广播给所有等待的 Goroutine。</p>
<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><h2 id="谈谈内存泄露，什么情况下内存会泄露？"><a href="#谈谈内存泄露，什么情况下内存会泄露？" class="headerlink" title="谈谈内存泄露，什么情况下内存会泄露？"></a>谈谈内存泄露，什么情况下内存会泄露？</h2><p>go 中的内存泄漏一般都是 <strong>goroutine 泄漏</strong>，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一只处于阻塞状态，不能被 GC。</p>
<p><strong>内存泄露有下面一些情况</strong></p>
<ol>
<li><p><strong>Goroutine泄漏</strong>：如果Goroutine在执行时被阻塞而无法退出，就会导致Goroutine的内存泄露，<strong>一个Goroutine的最低栈大小为2KB</strong>，在高并发的场景下，对内存的消耗也是非常恐怖的。</p>
</li>
<li><p><strong>互斥锁未释放</strong>或者造成<strong>死锁</strong>会造成内存泄漏</p>
</li>
<li><p><strong>资源未关闭</strong>：</p>
<ul>
<li>如果程序打开了文件、数据库连接、网络连接或其他资源，但在使用完毕后没有及时调用对应的关闭方法（如 <code>Close()</code> 或 <code>Release()</code>），则这些资源所占用的内存在程序运行期间将无法被释放。</li>
</ul>
</li>
<li><p><strong>循环引用</strong>：</p>
<ul>
<li>若两个或多个对象之间形成循环引用，即使它们已经不再被其他任何变量引用，但由于彼此之间的强引用关系，垃圾回收器无法识别它们为可回收对象，这也会导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>不正确使用channel:</strong></p>
<ul>
<li>从空channel读取数据，导致接收方 Goroutine 被阻塞并无法退出，间接引发内存泄漏。</li>
<li>向已满的channel写入数据，导致发送方 Goroutine 被阻塞并无法退出，间接引发内存泄漏。</li>
</ul>
</li>
<li><p>字符串的截取引发<strong>临时性</strong>的内存泄漏</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">	str1 := str0[:<span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切片截取引起子切片内存泄露</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	s1 := s0[:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数数组传参引发内存泄漏【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。】</p>
</li>
</ol>
<h2 id="怎么定位排查内存泄漏问题？"><a href="#怎么定位排查内存泄漏问题？" class="headerlink" title="怎么定位排查内存泄漏问题？"></a>怎么定位排查内存泄漏问题？</h2><ol>
<li><strong>使用 go tool pprof</strong> &#x2F; -gcflags&#x3D;-m</li>
</ol>
<ul>
<li><p><code>pprof</code> 是 <strong>Go 自带的性能分析工具</strong>，可以帮助分析程序运行时的 CPU、内存和阻塞调用等情况。</p>
</li>
<li><p>具体做法是开启 pprof 服务（可以在代码中嵌入或者通过 HTTP 方式开启），然后使用命令行工具抓取内存快照：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:port/debug/pprof/heap</span><br></pre></td></tr></table></figure>

<p>获取 heap 快照后，可以使用 top、list、web 等命令分析内存分配详情，找出可能的内存泄漏点。</p>
</li>
</ul>
<ol start="2">
<li><strong>编写和运行单元测试</strong><ul>
<li>编写针对可能存在问题的模块或功能的单元测试，结合内存分析工具观察测试过程中的内存使用情况，通过重复执行测试，观察内存是否持续增长，以此来定位潜在的内存泄漏。</li>
</ul>
</li>
<li><strong>监控 Goroutine 数量</strong><ul>
<li>如果内存泄漏伴随着 Goroutine 数量的异常增长，可能是 Goroutine 泄漏或资源没有正确释放导致的。使用 <code>runtime.NumGoroutine()</code> 监控 Goroutine 数量，同时结合 pprof 查看 Goroutine 栈信息。</li>
</ul>
</li>
</ol>
<h4 id="golang-的内存逃逸，什么情况下会发生（必问）"><a href="#golang-的内存逃逸，什么情况下会发生（必问）" class="headerlink" title="golang 的内存逃逸，什么情况下会发生（必问）"></a>golang 的内存逃逸，什么情况下会发生（必问）</h4><p><strong>内存逃逸：</strong>本该<strong>分配到栈上的变量，跑到了堆上</strong>，这就导致了内存逃逸。</p>
<p>栈是高地址到低地址，栈上的变量，函数结束后变量会跟着回收掉，不会有额外性能的开销。变量从栈逃逸到堆上，如果要回收掉，需要进行 gc，那么 gc 一定会带来额外的性能开销。编程语言不断优化 gc 算法，主要目的都是为了减少 gc 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。</p>
<p>内存逃逸在 Go 语言中通常发生在以下几种情况：</p>
<ol>
<li><p>函数返回局部变量的指针：</p>
<ul>
<li>当函数内部创建了一个变量，并且函数返回的是指向这个局部变量的指针或引用时，由于返回的指针允许外部代码在函数结束后还能继续访问该变量，所以该变量必须在堆上分配，以保证其生命周期超过函数作用域。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130233118.png"/></li>
<li><p>外部引用：</p>
<ul>
<li>函数内部引用了外部作用域的变量，并且这个外部变量有可能在函数执行完毕后仍被函数内部生成的对象所引用，这时编译器无法确定何时可以释放外部变量，故外部变量及其被引用的部分可能会在堆上分配。</li>
</ul>
</li>
<li><p>闭包引用外部变量：</p>
<ul>
<li>在闭包（匿名函数）中捕获了外部作用域的变量，如果闭包在其定义的函数返回后还能访问这些变量，那么这些变量的生命周期会延长至闭包被释放，因此它们可能会从栈上逃逸到堆上。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130236407.png"/></li>
<li><p>动态类型和接口转换：</p>
<ul>
<li>当一个变量需要存储在 interface{} 类型中时，编译器无法预知其具体类型和大小，可能会导致逃逸到堆上。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130235531.png"/></li>
<li><p>切片扩容：</p>
<ul>
<li>当切片（slice）在函数内部初始化后，由于 append 操作可能会导致其底层数组超出当前容量，编译器为了确保在函数返回后切片仍能正确工作，会将底层数组分配在堆上。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130234973.png"/></li>
<li><p>栈空间不足以容纳变量：</p>
<ul>
<li>如果局部变量过大，超过编译器预设的栈空间大小限制，那么即使该变量的生命周期并未超出函数作用域，也会分配在堆上。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406130233239.png"/></li>
<li><p>发送指针或包含指针的值到 channel：</p>
<ul>
<li>当将一个局部变量的指针或者其他含有指针的复合类型值发送到 channel 中时，由于编译器无法得知何时 channel 的接收端会接收到数据，因此不能确定何时可以释放这些变量，因此可能导致内存逃逸。</li>
</ul>
</li>
</ol>
<h2 id="Go-是如何分配内存的？"><a href="#Go-是如何分配内存的？" class="headerlink" title="Go 是如何分配内存的？"></a>Go 是如何分配内存的？</h2><p>这篇文章主要介绍Go内存分配和Go内存管理，会轻微涉及内存申请和释放，以及Go垃圾回收。从非常宏观的角度看，Go的内存管理就是下图这个样子，我们今天主要关注其中标红的部分。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406100018475.png"/>

<ul>
<li>栈在高地址，从高地址向低地址增长</li>
<li>堆在低地址，从低地址向高地址增长</li>
</ul>
<p>栈和堆相比有这么几个好处：</p>
<ul>
<li>栈的内存管理简单，分配比堆上快。</li>
<li>栈的内存不需要回收，而堆需要进行回收，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。</li>
<li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了。</li>
</ul>
<p>当我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心，这小节看下堆内存管理到底完成了什么。分别是分配内存块，回收内存块和组织内存块。</p>
<h3 id="Go语言的内存分配机制："><a href="#Go语言的内存分配机制：" class="headerlink" title="Go语言的内存分配机制："></a><strong>Go语言的内存分配机制</strong>：</h3><ul>
<li>Go语言的内存管理主要涉及到堆内存的管理。Go语言抛弃了C&#x2F;C++中的开发者管理内存的方式，<strong>实现了主动申请与主动释放管理，增加了逃逸分析和垃圾回收（GC），将开发者从内存管理中释放出来，让开发者有更多的精力去关注软件设计，而不是底层的内存问题¹。</strong></li>
<li>Go语言每次以 <code>heapArena</code> 为单位向虚拟内存申请内存空间，每次申请的内存单位为64MB。所有的 <code>heapArena</code> 组成了 <code>mheap</code>（Go的堆内存）。Go语言是一个一个内存块（<code>heapArena</code>）申请内存。</li>
<li>Go的堆对象的分配内存<strong>采用线性分配或者链表分配的性能不高并且会出现内存碎片</strong>，<strong>Go语言中采用了分级分配的策略。将一个 <code>heapArena</code> 中划分成许多大小相等的小格子，空间大小相同的格子划分为一个等级⁴。</strong></li>
</ul>
<h3 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h3><ul>
<li>TCMalloc (Thread-Caching Malloc，线程缓存的malloc）是Google开发的内存分配算法库，最初作为Google性能工具库 perftools 的一部分，提供高效的多线程内存管理实现，用于替代操作系统的内存分配相关的函数（malloc、free，new，new []等），具有减少内存碎片、适用于多核、更好的并行性支持等特性⁷。</li>
<li>TCMalloc将内存空间分成了不同尺寸大小的块，申请内存时会分配一个合适大小的内存块，这些空闲块通过链表维护。有些尺寸小的块是线程自主使用，不够用的时候才会从共有块中申请。</li>
<li>TCMalloc特别对多线程做了优化，对于小对象的分配基本上是不存在锁竞争，而大对象使用了细粒度、高效的自旋锁（spinlock）。分配给线程的本地缓存，在长时间空闲的情况下会被回收，供其他线程使用，这样提高了在多线程情况下的内存利用率，不会浪费内存。</li>
</ul>
<p>掌握TCMalloc的理念，无需去关注过多的源码细节，就可以为掌握Go的内存管理打好基础，基础打好了，后面知识才扎实。</p>
<blockquote>
<p>在Linux操作系统中，其实有不少的内存管理库，比如glibc的ptmalloc，FreeBSD的jemalloc，Google的tcmalloc等等，为何会出现这么多的内存管理库？本质都是在多线程编程下，追求更高内存管理效率：更快的分配是主要目的。</p>
</blockquote>
<p>我们前面提到引入虚拟内存后，让内存的并发访问问题的粒度从多进程级别，降低到多线程级别。然而同一进程下的所有线程共享相同的内存空间，它们申请内存时需要加锁，如果不加锁就存在同一块内存被2个线程同时访问的问题。</p>
<p>TCMalloc的做法是什么呢？为每个线程预分配一块缓存，线程申请小内存时，可以从缓存分配内存，这样有2个好处：</p>
<ol>
<li>为线程预分配缓存需要进行1次系统调用，后续线程申请小内存时直接从缓存分配，都是在用户态执行的，没有了系统调用，缩短了内存总体的分配和释放时间，这是快速分配内存的第二个层次。</li>
<li>多个线程同时申请小内存时，从各自的缓存分配，访问的是不同的地址空间，从而无需加锁，把内存并发访问的粒度进一步降低了，这是快速分配内存的第三个层次。</li>
</ol>
<h3 id="Channel-分配在栈上还是堆上？"><a href="#Channel-分配在栈上还是堆上？" class="headerlink" title="Channel 分配在栈上还是堆上？"></a>Channel 分配在栈上还是堆上？</h3><p> 在 Go 语言中，Channel（信道）本身是一个引用类型，它的实例始终分配在堆上。</p>
<h4 id="Go-哪些对象分配在堆上，哪些对象分配在栈上？"><a href="#Go-哪些对象分配在堆上，哪些对象分配在栈上？" class="headerlink" title="Go 哪些对象分配在堆上，哪些对象分配在栈上？"></a>Go 哪些对象分配在堆上，哪些对象分配在栈上？</h4><ol>
<li>栈上分配：<ul>
<li>局部变量（包括简单类型如整数、浮点数、布尔值等）在函数内部创建且其生命周期仅限于函数内部时，通常会被分配在栈上。</li>
<li>小的、生命周期短的结构体或数组等，如果编译器通过逃逸分析确定它们不会被函数外部访问或其生命周期没有超出函数范围，也可能被分配在栈上。</li>
</ul>
</li>
<li>堆上分配：<ul>
<li>所有通过 <code>new</code> 或 <code>make</code> 函数创建的对象都会分配在堆上，因为它们的生命周期不受函数调用栈的限制。</li>
<li>如果一个局部变量被指针引用并且这个指针可能会被函数外部持有，或者传递给其他goroutine，那么这个局部变量将会逃逸到堆上。</li>
<li>当局部变量的大小超过了编译器设置的栈空间大小限制时，也会被分配在堆上。</li>
<li>切片（slice）、通道（channel）、映射（map）等动态大小的数据结构，无论其生命周期如何，都在堆上分配。</li>
<li>结构体或数组即使在函数内部创建，如果它们作为函数返回值的一部分，或者被捕获在闭包中，也会发生逃逸，分配在堆上。</li>
</ul>
</li>
</ol>
<p>准确地说，变量存储在堆上还是栈上，是由逃逸分析、作用域、生命周期以及变量的类型和大小等因素共同决定的，和具体的语法没有很大的关系。变量的生命周期和存储位置由以下几个因素决定：</p>
<ol>
<li>作用域和生命周期：<ul>
<li>如果变量是函数内的局部变量，并且它的生命周期仅限于函数执行期间，那么它通常会被分配在栈上。一旦函数执行结束，栈上的变量就会被自动释放。</li>
<li>如果变量的生命周期超出了当前函数的作用域（如通过返回指针、闭包引用等），则编译器可能会选择将其分配在堆上以确保在函数结束后的存活。</li>
</ul>
</li>
<li>逃逸分析：<ul>
<li>Go 编译器通过逃逸分析来确定变量是否需要分配在堆上。即使一个变量原本应该分配在栈上，但如果它满足逃逸条件（如返回指针、被全局引用等），编译器就会将其分配在堆上。</li>
</ul>
</li>
<li>类型和大小：<ul>
<li>对于大型对象或动态大小的类型（如切片、映射、通道和某些结构体），它们总是存储在堆上，因为栈的大小有限，不适合存储这些大小不固定的对象。</li>
</ul>
</li>
</ol>
<h4 id="介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？"><a href="#介绍一下大对象小对象，为什么小对象多了会造成-gc-压力？" class="headerlink" title="介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？"></a>介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？</h4><p>在 Go 语言中，内存分配通常会区分小对象和大对象：</p>
<ul>
<li><strong>小对象</strong>：指的是较小尺寸的内存分配请求。在 Go 语言中，小对象通常是指大小小于一定阈值（通常是 32KB 或由编译器设定）的对象，一般小对象通过 mspan 分配内存。</li>
<li><strong>大对象</strong>：相比之下，大对象则是指大于上述阈值的内存分配请求，如大尺寸的数组或大型结构体等。大对象通常直接从全局堆（mheap）分配，并且分配和回收的开销相对较大。</li>
</ul>
<p>小对象多了造成 GC（垃圾回收）压力的原因主要有以下几点：</p>
<ol>
<li><strong>内存碎片</strong>：小对象频繁分配和回收容易导致内存碎片，即使空闲内存总量足够，但由于分散成众多小块，难以分配给较大的内存请求，从而迫使 GC 更频繁地进行压缩和整理内存空间。</li>
<li><strong>扫描成本增加</strong>：GC 在执行时需要遍历整个堆内存来标记活跃对象。小对象数量增多意味着有更多的内存区域需要扫描，这对 CPU 资源的需求更高，从而加大了 GC 期间的停顿时间（STW，Stop-The-World）。</li>
<li><strong>元数据开销</strong>：每一个分配的小对象都需要额外的元数据来管理，包括但不限于对象头部信息、span（内存区块）管理信息等，这些都会增加堆内存的整体使用量。</li>
<li><strong>同步开销</strong>：小对象分配频繁，可能导致线程本地缓存（mcache）与全局堆（mheap）之间的同步操作增多，尤其是在多线程环境下，同步锁的竞争可能导致性能下降。</li>
<li><strong>分配&#x2F;回收开销</strong>：频繁的小对象分配和回收操作涉及内存管理单元（如 mcache、mcentral 等）的查找、分配、合并等一系列操作，这些操作本身也会带来一定的计算开销。</li>
</ol>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="Go-多返回值怎么实现的？"><a href="#Go-多返回值怎么实现的？" class="headerlink" title="Go 多返回值怎么实现的？"></a>Go 多返回值怎么实现的？</h2><ul>
<li><strong>函数签名定义</strong>： 在函数定义时，可以指定多个返回值类型</li>
<li><strong>栈上的存储</strong>： 在函数调用时，Go 会为所有的返回值分配足够的空间，就像为参数分配空间一样。这些返回值空间会被压入调用者的栈帧上。</li>
<li><strong>返回值传递</strong>： 当函数执行完毕并通过 <code>return</code> 语句返回时，会将返回值写入到之前预留的栈空间中。即便函数返回，这部分栈空间也不会立即被回收，因为它们现在包含了返回值。</li>
</ul>
<h2 id="讲讲-Go-中主协程如何等待其余协程退出"><a href="#讲讲-Go-中主协程如何等待其余协程退出" class="headerlink" title="讲讲 Go 中主协程如何等待其余协程退出?"></a>讲讲 Go 中主协程如何等待其余协程退出?</h2><ol>
<li>**使用<code>sync.WaitGroup</code>**：这是最常见且推荐的方式。<code>sync.WaitGroup</code>有三个方法：<code>Add</code>、<code>Done</code>和<code>Wait</code>。你可以在启动一个协程时调用<code>Add</code>来设置要等待的协程数量，每个协程完成时调用<code>Done</code>，最后在主协程中调用<code>Wait</code>来阻塞等待所有协程完成。</li>
<li><strong>使用通道（Channel）</strong>：你可以创建一个通道，并在每个协程中发送一个信号或特定的值。主协程可以通过<code>range</code>遍历通道或者用<code>len</code>函数检查通道的长度，以等待所有协程完成。</li>
<li>**使用<code>sync.Once</code>**：虽然<code>sync.Once</code>通常用于确保某个操作只执行一次，但你也可以将其用作同步机制。你可以在每个协程中调用<code>Do</code>方法，而在主协程中调用<code>Wait</code>方法来等待所有协程完成。</li>
<li><strong>使用<code>context</code>包</strong>：如果你的程序使用了Go的<code>context</code>包来管理多个协程，你可以使用<code>context.Done()</code>通道来等待所有协程完成。当上下文被取消时，所有使用该上下文的协程都会收到信号并退出。</li>
<li>**使用<code>time.Sleep</code>或<code>time.After</code>**：这种方法不是最佳实践，因为它会导致不必要的延迟。你可以通过设置一个足够长的睡眠时间来等待所有协程完成，但这是不可靠的，尤其是在不确定协程何时完成的情况下。</li>
<li><strong>使用第三方库</strong>：有些第三方库提供了更高级的同步原语，如<code>golang.org/x/sync/syncutil</code>包中的<code>WaitGroup</code>等。这些库可以提供更灵活的同步选项，但通常<code>sync.WaitGroup</code>已经足够使用。</li>
</ol>
<p>总的来说，<code>sync.WaitGroup</code>是最简单且常用的方法，它能够有效地满足主协程等待其他协程退出的需求。</p>
<h2 id="Go-语言中各种类型是如何比较是否相等？"><a href="#Go-语言中各种类型是如何比较是否相等？" class="headerlink" title="Go 语言中各种类型是如何比较是否相等？"></a>Go 语言中各种类型是如何比较是否相等？</h2><p>在 Go 语言中，不同类型的数据比较是否相等有不同的规则：</p>
<ol>
<li><strong>基础类型</strong>：<ul>
<li>布尔型 (<code>bool</code>)：可以直接使用 <code>==</code> 进行比较。</li>
<li>整型 (<code>int</code>, <code>uint</code>, <code>byte</code>, <code>rune</code> 等)、浮点型 (<code>float32</code>, <code>float64</code>) 和复数 (<code>complex64</code>, <code>complex128</code>)：可以用 <code>==</code> 进行比较。</li>
<li>字符串 (<code>string</code>)：同样使用 <code>==</code> 进行比较。</li>
</ul>
</li>
<li><strong>指针类型</strong>：<ul>
<li>指针类型可以直接用 <code>==</code> 比较，比较的是指针本身的地址是否相同，而不是它们指向的数据是否相等。</li>
</ul>
</li>
<li><strong>数组和切片</strong>：<ul>
<li>数组 (<code>[N]T</code>) 可以用 <code>==</code> 比较，<strong>前提是它们的类型相同且长度相等，且每个元素都可以比较。</strong></li>
<li>切片 (<code>[]T</code>) 也可以用 <code>==</code> 比较，但<strong>同样要求长度和元素都相等。如果需要比较切片内容的深拷贝相等性，可以使用 <code>reflect.DeepEqual</code> 函数</strong>。</li>
</ul>
</li>
<li><strong>结构体（struct）</strong>：<ul>
<li>结构体可以使用 <code>==</code> 进行比较，如果结构体中的所有字段都是可比较的（也就是说，它们要么是基本类型，要么也是可比较的结构体或数组等），那么整个结构体就可以通过 <code>==</code> 来比较是否相等。</li>
</ul>
</li>
<li><strong>接口类型</strong>：<ul>
<li>Go 语言中的接口值可以比较，但比较的前提是它们内部存储的具体类型必须是可比较的，<strong>即满足 Go 语言的比较规则（例如，基本类型、结构体类型等）。如果内部存储的是不可比较类型的值，则接口值之间也就无法进行比较。</strong></li>
<li>两个接口值（<code>interface&#123;&#125;</code>）如果它们的动态类型相同，并且动态值相等，那么它们才被认为是相等的。<strong>但是，由于接口可以包含任何类型的值，因此直接使用 <code>==</code> 通常只能比较它们是否为同一个值</strong>，<strong>不能比较它们所封装的具体值是否相等。</strong></li>
</ul>
</li>
<li><strong>Map、Channel 和 Function 类型</strong>：<ul>
<li>Map、Channel 和 Function 类型<strong>不可以直接用 <code>==</code> 比较</strong>，因为它们是引用类型，<strong>比较的是它们的地址，而不是它们的内容。</strong></li>
</ul>
</li>
<li><strong>自定义类型</strong>：<ul>
<li>对于自定义类型，你需要提供自定义的相等性判断方法，<strong>如 <code>Equal</code> 函数，或者实现 <code>Equal</code> 方法以满足某个接口要求。</strong></li>
</ul>
</li>
<li><strong>深层次比较</strong>：<ul>
<li>若要进行复杂的深度比较，例如包含嵌套结构、切片、Map 等混合类型的结构体，可以使用 <code>reflect.DeepEqual</code> 函数，它会对两个任意类型的数据进行深度比较，查看它们的值是否相等。但是要注意，<code>reflect.DeepEqual</code> 不适合用于比较包含不可比较类型（如函数或包含 channel 的结构体）的数据。</li>
</ul>
</li>
</ol>
<h2 id="Go-中-init-函数的特征"><a href="#Go-中-init-函数的特征" class="headerlink" title="Go 中 init 函数的特征?"></a>Go 中 init 函数的特征?</h2><ol>
<li><strong>自动调用</strong>： <strong><code>init</code> 函数是不需要显式调用</strong>，当包被加载（imported）时，该包中的所有 <code>init</code> 函数会自动执行。<strong>在程序启动之初，先执行所有的 <code>init</code> 函数，然后再执行 <code>main</code> 函数。</strong>不管包被导入多少次，包内的 <strong>init 函数只会执行一次</strong>。</li>
<li><strong>无参数和返回值</strong>： <code>init</code> 函数没有参数，也不返回任何值，其声明格式为：</li>
<li><strong>并发安全</strong>： 虽然多个包的 <code>init</code> 函数执行顺序不确定，但同一包内的多个 <code>init</code> 函数是顺序执行的，并且 Go 语言保证了并发安全，即不同 <code>init</code> 函数间的执行互不影响。</li>
<li><strong>跨包依赖</strong>： 不同包之间的 <code>init</code> 函数执行顺序遵循依赖关系，如果 A 包导入了 B 包，那么 B 包的 <code>init</code> 函数会在 A 包的 <code>init</code> 函数执行之前被执行。这允许开发者在包间构建一种依赖链式的初始化逻辑。</li>
</ol>
<h2 id="Go-中-uintptr-和-unsafe-Pointer-的区别？"><a href="#Go-中-uintptr-和-unsafe-Pointer-的区别？" class="headerlink" title="Go 中 uintptr 和 unsafe.Pointer 的区别？"></a>Go 中 uintptr 和 unsafe.Pointer 的区别？</h2><p>在 Go 语言中，<code>uintptr</code> 和 <code>unsafe.Pointer</code> 都与内存地址相关，但它们的用途和限制有所不同：</p>
<ol>
<li>uintptr：<ul>
<li><code>uintptr</code> 是 Go 语言的内建类型，<strong>代表一个无符号整数类型，足够存储指针的值。</strong></li>
<li><code>uintptr</code> <strong>通常用于进行指针算术（如偏移量计算），因为 Go 语言的标准指针类型不支持直接的数学运算。</strong></li>
<li><code>uintptr</code> 类型并不能直接解引用为原来的指针类型，也不能阻止垃圾回收器对指向的对象进行回收。换句话说，<code>uintptr</code> 仅仅是数字，不代表它指向的内存区域是有效的或可访问的。</li>
</ul>
</li>
<li>unsafe.Pointer：<ul>
<li><code>unsafe.Pointer</code> 是来自 <code>unsafe</code> 包的一个类型，<strong>它是 Go 语言中唯一的通用指针类型。</strong></li>
<li><code>unsafe.Pointer</code> 用于在不同类型的指针之间进行转换，这在高级内存操作、低级别编程或者与 C 语言接口交互时非常有用。</li>
<li><strong>虽然可以将任何类型的指针转换为 <code>unsafe.Pointer</code>，然后再转换回另一种类型的指针，但这违反了 Go 语言的安全抽象原则，因此只有在必要且知道风险的情况下才能使用。</strong></li>
<li>转换回具体类型指针后，<code>unsafe.Pointer</code> 指向的内存区域是可以被垃圾回收器追踪的，<strong>因此不会因为转换为 <code>unsafe.Pointer</code> 而丢失对对象的引用。</strong></li>
</ul>
</li>
</ol>
<h2 id="从数组中取一个相同大小的slice有成本吗？"><a href="#从数组中取一个相同大小的slice有成本吗？" class="headerlink" title="从数组中取一个相同大小的slice有成本吗？"></a>从数组中取一个相同大小的slice有成本吗？</h2><p>在 Go 语言中，<strong>从数组中取一个相同大小的切片（slice）操作本身几乎是没有成本的。slice并不存储任何数据，它仅仅是对底层数组的一个引用，并提供对该连续片段的访问。</strong>当创建一个切片时，<strong>它实际上是创建了一个轻量级的结构体</strong>，这个结构体包含三个字段：指向底层数组的指针、长度（length）和容量（capacity）。创建切片时，并不会复制数组的元素，只是创建了一个视图（view）而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/17/%E7%BB%BC%E5%90%88%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/17/%E7%BB%BC%E5%90%88%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">综合题目回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-17 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-17T13:26:38+08:00">2024-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-03 11:41:04" itemprop="dateModified" datetime="2024-06-03T11:41:04+08:00">2024-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h3 id="str-substring-4-7"><a href="#str-substring-4-7" class="headerlink" title="str.substring(4,7)"></a>str.substring(4,7)</h3><p>String str &#x3D; “WellcomToThunderSoft”; System.out.println(str.substring(4,7)): 运行后的结果</p>
<p>在Java中，<code>substring</code>方法用于提取字符串中的一部分。这个方法接受两个参数：开始索引（包含）和结束索引（不包含）。根据您提供的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;WellcomToThunderSoft&quot;</span>;</span><br><span class="line">System.out.println(str.substring(<span class="number">4</span>,<span class="number">7</span>));</span><br></pre></td></tr></table></figure>

<p><code>str.substring(4,7)</code> 将会从索引4开始提取，到索引7结束，但不包括索引7。在字符串 <code>&quot;WellcomToThunderSoft&quot;</code> 中，索引4是字符 <code>&#39;o&#39;</code>，索引7是字符 <code>&#39;T&#39;</code>。</p>
<p>所以，<code>str.substring(4,7)</code> 的结果将是 <code>&quot;com&quot;</code>，这是从索引4到6的字符。如果您运行这段代码，控制台上打印出来的结果应该是 <code>com</code>。</p>
<h3 id="类及类成员的访问控制符"><a href="#类及类成员的访问控制符" class="headerlink" title="类及类成员的访问控制符"></a>类及类成员的访问控制符</h3><p>在Java中，类及类成员的访问控制符共有四种，它们分别是：</p>
<ol>
<li><strong>public</strong>：公共的，被声明为public的成员可以在任何类中都能被访问到。这包括类、成员变量、方法，以及内部类。通过操作该类的对象，可以随意访问public成员。被public修饰的成员也能被所有的子类继承下来。</li>
<li><strong>protected</strong>：受保护的，受到该类所在的包所保护。被protected修饰的成员会被位于同一package中的所有类访问到。同时，被protected修饰的成员也能被该类的所有子类继承下来。</li>
<li><strong>default</strong>（也称为friendly）：默认的，同一package中的所有类都能访问。被default修饰的成员只能被该类所在同一个package中的子类所继承下来。</li>
<li><strong>private</strong>：私有的，只能在当前类中被访问。被private修饰的成员，包括成员变量和方法，不能被其他类或派生类访问。</li>
</ol>
<h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>下面关于new关键字的表述错误的是（) </p>
<p>A.new关键字在生成一个对象时会为对象开辟内存空间 </p>
<p>B.new关键字在生成一个对象时会调用类的构造方法 </p>
<p>C.new关键字在生成一个对象时会将生成的对象的地址返回 </p>
<p>D.Java中只能通过new关键字来生成一个对象</p>
<blockquote>
<p>Java中只能通过new关键字来生成一个对象</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LOL_toulan/article/details/89212383">这个说法是不正确的。虽然<code>new</code>关键字是Java中最常用的方式来创建对象，它确实会为对象分配内存空间、调用构造方法，并返回对象的内存地址，但Java中还有其他方式可以创建对象。例如，可以通过类的<code>clone()</code>方法来创建对象，或者使用反射（Reflection）中的<code>Class.newInstance()</code>方法来创建对象。这些方法也可以在运行时动态地创建对象和分配内存</a></p>
</blockquote>
<p>选项A、B和C描述的都是<code>new</code>关键字的正确行为：</p>
<ul>
<li><code>new</code>关键字在生成一个对象时会为对象开辟内存空间。</li>
<li><code>new</code>关键字在生成一个对象时会调用类的构造方法。</li>
<li>new&#96;关键字在生成一个对象时会将生成的对象的地址返回。</li>
</ul>
<h3 id="Set类元素排序"><a href="#Set类元素排序" class="headerlink" title="Set类元素排序"></a>Set类元素排序</h3><p>下面哪个Set类是按元素排好序的？() A.HashSet B.TreeSet C.LinkedHashSet D.AbstractSet</p>
<p>在Java中，按元素排好序的Set类是：</p>
<p>B. <strong>TreeSet</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_54162653/article/details/117771885"><code>TreeSet</code>实现了<code>SortedSet</code>接口，可以确保集合元素处于排序状态。它使用元素的自然顺序或者根据创建<code>TreeSet</code>时提供的<code>Comparator</code>进行排序</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_54162653/article/details/117771885">1</a>。这意味着，如果你插入可比较的对象（例如数字、字符串等），<code>TreeSet</code>会按照升序来保存它们。</p>
<p>其他选项的说明如下：</p>
<ul>
<li>A. <strong>HashSet</strong> 不保证集合的迭代顺序；它的元素实际上是无序的。</li>
<li>C. <strong>LinkedHashSet</strong> 维护着元素插入的顺序，但不是按自然顺序排序。</li>
<li>D. <strong>AbstractSet</strong> 是<code>Set</code>接口的骨架实现，它本身并不提供排序功能。</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>以下关于异常的说法正确的是（) </p>
<p>A.如果一个方法申明将抛出某个异常，它就必须真的抛出那个异常 </p>
<p>B.可能抛出系统异常的方法是不需要申明异常的 </p>
<p>C.在catch子句中匹配异常是一种精确匹配 </p>
<p>D.一旦出现异常，程序运行就终止了</p>
<p>在Java中，关于异常的正确说法是：</p>
<p>B. 可能抛出系统异常的方法是不需要声明异常的</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">这是正确的，因为在Java中，由系统异常（也称为未检查异常或运行时异常）引起的错误通常是由程序逻辑错误引起的，如<code>NullPointerException</code>或<code>ArrayIndexOutOfBoundsException</code>。这些异常是<code>RuntimeException</code>的子类，它们不需要在方法签名中声明，也不强制要求调用者处理这些异常</a><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">1</a><a target="_blank" rel="noopener" href="https://javabetter.cn/exception/gailan.html">2</a>。</p>
<p>C. 在catch子句中匹配异常是一种精确匹配</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">这也是正确的。在Java的异常处理中，<code>catch</code>子句会根据异常类型进行匹配。如果抛出的异常与<code>catch</code>子句中指定的异常类型相匹配，那么该<code>catch</code>子句将会执行。如果不匹配，它会继续寻找下一个匹配的<code>catch</code>子句</a><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">1</a><a target="_blank" rel="noopener" href="https://javabetter.cn/exception/gailan.html">2</a>。</p>
<p>选项A和D的说法是不正确的：</p>
<p>A. 如果一个方法声明将抛出某个异常，它就必须真的抛出那个异常</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">这是不正确的。方法可以声明抛出一个或多个异常，但这并不意味着它必须抛出这些异常。声明仅表示该方法可能会抛出这些异常，调用者应该准备好处理它们</a><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">1</a><a target="_blank" rel="noopener" href="https://javabetter.cn/exception/gailan.html">2</a>。</p>
<p>D. 一旦出现异常，程序运行就终止了</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">这也是不正确的。在Java中，如果异常被捕获并且有适当的处理，程序可以继续执行。只有当异常未被捕获时，程序才会终止</a><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-exceptions.html">1</a><a target="_blank" rel="noopener" href="https://javabetter.cn/exception/gailan.html">2</a>。</p>
<h3 id="JDK中常用包"><a href="#JDK中常用包" class="headerlink" title="JDK中常用包"></a>JDK中常用包</h3><p>JDK中常用包有（) )A.java.io ○ B.java.net )C.以上都是 D.java.lang</p>
<p>在JDK中，常用的包包括：</p>
<ul>
<li>A. <strong>java.io</strong>：这个包包含了用于数据流、序列化和文件系统的类。</li>
<li>B. <strong>java.net</strong>：这个包包含了用于网络编程的类，如URL、Sockets等。</li>
<li>D. <strong>java.lang</strong>：这个包是Java编程语言的核心类库，包含了基本的类和接口，如<code>String</code>、<code>Math</code>、<code>System</code>等。</li>
</ul>
<h3 id="广播错误"><a href="#广播错误" class="headerlink" title="广播错误"></a>广播错误</h3><p>下列关于广播错误的是（) </p>
<p>A.abortBroadcast0可以中断所有的广播 ○ </p>
<p>B.相同优先级下动态注册比静态注册更早接收有序广播 )</p>
<p>C.广播的注册方式分为静态和动态 </p>
<p>D.广播的发送方式分为有序和无序</p>
<p>在Android中，关于广播的错误表述是：</p>
<p>A. <strong>abortBroadcast()</strong> 可以中断所有的广播</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1881789">这个说法是不正确的。<code>abortBroadcast()</code> 方法只能用于中断有序广播（Ordered Broadcasts），而无法中断无序广播（Normal Broadcasts）或系统广播</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1881789">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/caoqijia123/article/details/92800075">2</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=Android+abortBroadcast+%E4%B8%AD%E6%96%AD%E6%89%80%E6%9C%89%E5%B9%BF%E6%92%AD">3</a><a target="_blank" rel="noopener" href="https://wenku.csdn.net/answer/15d039836ba945babd4b4337d2ea86e6">。有序广播是按照接收者的优先级顺序来传递的，而且前面的接收者可以通过调用<code>abortBroadcast()</code>来阻止后续的接收者接收到这个广播</a><a target="_blank" rel="noopener" href="https://wenku.csdn.net/answer/15d039836ba945babd4b4337d2ea86e6">4</a>。</p>
<p>选项B、C和D描述的都是广播的正确特性：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/380066272">B<strong>相同优先级下动态注册比静态注册更早接收有序广播</strong>：这是正确的，当两个接收者的优先级相同时，动态注册的接收者会比静态注册的接收者先接收到有序广播</a><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/380066272">5</a><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16213419/10404199">6</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42182599/article/details/137680583">C<strong>广播的注册方式分为静态和动态</strong>：这是正确的，广播接收者可以通过静态注册（在<code>AndroidManifest.xml</code>中声明）或动态注册（在代码中调用<code>registerReceiver()</code>方法）来接收广播</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42182599/article/details/137680583">7</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/fancynthia/article/details/124359900">8</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49095721/article/details/109448148">D<strong>广播的发送方式分为有序和无序</strong>：这也是正确的，广播可以以有序广播的方式发送，也可以以无序广播的方式发送</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=Android+%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%92%8C%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C%E6%8E%A5%E6%94%B6%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F">9</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49095721/article/details/109448148">10</a>。</li>
</ul>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>下列那些进程的优先级最高（) A.后台进程 B.服务进程 C.前台进程 D.可见进程</p>
<p>在Android系统中，进程的优先级从高到低排序如下：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly0724ok/article/details/117533723"><strong>前台进程</strong> (Foreground process): 这些进程包含用户正在交互的Activity或与之绑定的Service，以及执行特定操作如<code>onReceive()</code>方法的BroadcastReceiver。前台进程通常不会因为内存不足而被系统杀死</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly0724ok/article/details/117533723">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly0724ok/article/details/117533723"><strong>可见进程</strong> (Visible process): 这些进程不包含任何前台组件，但用户仍然可以在屏幕上看到它们。例如，一个Activity在调用了<code>onPause()</code>但还没有调用<code>onStop()</code>时，它仍然对用户可见。这些进程通常也不会被系统杀死，除非是为了保证所有前台进程的运行而不得不杀死可见进程</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly0724ok/article/details/117533723">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly0724ok/article/details/117533723"><strong>服务进程</strong> (Service process): 这些进程正在运行一个通过<code>startService()</code>启动的Service。例如，后台播放音乐或后台下载数据的Service属于服务进程</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly0724ok/article/details/117533723">1</a>。</li>
<li><strong>后台进程</strong> (Background process): 这些进程包含用户不可见的Activity（例如，用户离开了Activity，导致<code>onStop()</code>被调用）。后台进程不直接影响</li>
</ol>
<h3 id="synchronized和Lock"><a href="#synchronized和Lock" class="headerlink" title="synchronized和Lock"></a>synchronized和Lock</h3><p>下面关于synchronized和Lock描述错误的是（)</p>
<p> A.通过Lock可以知道有没有成功获取锁，而synchronized却无法办到 )</p>
<p>B.synchronized只能给代码块加锁；而lock可以给类、方法、代码块加锁 )</p>
<p>C.synchronized不需要手动获取锁和释放锁，发生异常会自动释放锁，不会造成死锁 </p>
<p>D.lock需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁</p>
<blockquote>
<p>Synchronized 是Java 并发编程中很重要的关键字，另外一个很重要的是 volatile。Syncronized 的目的是一次只允许一个线程进入由他修饰的代码段，从而允许他们进行自我保护。Synchronized 很像生活中的锁例子，进入由Synchronized 保护的代码区首先需要获取 Synchronized 这把锁，其他线程想要执行必须进行等待。Synchronized 锁住的代码区域执行完成后需要把锁归还，也就是释放锁，这样才能够让其他线程使用。</p>
<p>Lock 是 Java并发编程中很重要的一个接口，它要比 Synchronized 关键字更能直译”锁”的概念，Lock需要手动加锁和手动解锁，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁。与 Lock 关联密切的锁有 ReetrantLock 和 ReadWriteLock。</p>
<p>ReetrantLock 实现了Lock接口，它是一个可重入锁，内部定义了公平锁与非公平锁。</p>
<p>ReadWriteLock 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。ReentrantReadWirteLock实现了ReadWirteLock接口，并未实现Lock接口。</p>
<p>Synchronzied 和 Lock 的主要区别如下：</p>
<ul>
<li><strong>存在层面</strong>：Syncronized 是Java 中的一个关键字，存在于 JVM 层面，Lock 是 Java 中的一个接口</li>
<li><strong>锁的释放条件</strong>：1. 获取锁的线程执行完同步代码后，自动释放；2. 线程发生异常时，JVM会让线程释放锁；Lock 必须在 finally 关键字中释放锁，不然容易造成线程死锁</li>
<li><strong>锁的获取</strong>: 在 Syncronized 中，假设线程 A 获得锁，B 线程等待。如果 A 发生阻塞，那么 B 会一直等待。在 Lock 中，会分情况而定，Lock 中有尝试获取锁的方法，如果尝试获取到锁，则不用一直等待</li>
<li><strong>锁的状态</strong>：Synchronized 无法判断锁的状态，Lock 则可以判断</li>
<li><strong>锁的类型</strong>：Synchronized 是可重入，不可中断，非公平锁；Lock 锁则是 可重入，可判断，可公平锁</li>
<li><strong>锁的性能</strong>：Synchronized 适用于少量同步的情况下，性能开销比较大。Lock 锁适用于大量同步阶段：</li>
<li>Lock 锁可以提高多个线程进行读的效率(使用 readWriteLock)</li>
<li>在竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</li>
<li>ReetrantLock 提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。</li>
</ul>
</blockquote>
<p>在Java中，关于<code>synchronized</code>和<code>Lock</code>的描述中错误的是：1</p>
<p>B. synchronized只能给代码块加锁；而lock可以给类、方法、代码块加锁</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">这个说法是不正确的。<code>synchronized</code>关键字不仅可以用来给代码块加锁，还可以用来给整个方法加锁。当<code>synchronized</code>修饰一个方法时，这个方法就是同步方法，意味着一次只能有一个线程进入该方法。而<code>Lock</code>是一个接口，提供了比<code>synchronized</code>关键字更细粒度的锁操作，但它本身不能直接用来给类或方法加锁</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622760822">2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/drrzh/article/details/119519455">3</a>。</p>
<p>其他选项的描述是正确的：</p>
<ul>
<li>A. <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">通过<code>Lock</code>可以知道有没有成功获取锁，而<code>synchronized</code>却无法办到。<code>Lock</code>接口提供了<code>tryLock()</code>方法，可以用来尝试获取锁，如果获取成功则返回<code>true</code>，否则返回<code>false</code></a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622760822">2</a>。</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">C<code>synchronized</code>不需要手动获取锁和释放锁，发生异常会自动释放锁，不会造成死锁。这是<code>synchronized</code>的一个特性，它确保在发生异常时锁会被释放，从而避免死锁的发生</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622760822">2</a>。</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">D<code>Lock</code>需要自己加锁和释放锁，如果使用不当没有<code>unlock()</code>去释放锁就会造成死锁。这是<code>Lock</code>的使用方式，需要程序员显式地进行锁的管理</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622760822">2</a>。</li>
</ul>
<h3 id="集合对象的线程安全"><a href="#集合对象的线程安全" class="headerlink" title="集合对象的线程安全"></a>集合对象的线程安全</h3><p>以下集合对象中哪几个是线程安全的（) </p>
<p>A.Hashtable </p>
<p>B.Vector </p>
<p>C.LinkedList </p>
<p>D.ArrayList</p>
<p>在Java中，线程安全的集合对象意味着它们可以在多线程环境中安全地进行读写操作，而不会出现数据不一致或者竞态条件的问题。根据我的搜索结果，以下是线程安全的集合对象：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">A、<strong>Hashtable</strong>：它是一个早期的键值对集合类，使用<code>synchronized</code>方法来保证线程安全</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">B、<strong>Vector</strong>：它是一个动态数组，其所有操作都是线程安全的，因为它的方法都是同步的</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">1</a>。</li>
</ul>
<p>而选项C和D：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">C、<strong>LinkedList</strong>：它不是线程安全的，因为它的方法不是同步的</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">D、<strong>ArrayList</strong>：它也不是线程安全的，同样因为它的方法不是同步的</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/627192919">1</a>。</li>
</ul>
<h3 id="方法没有返回值"><a href="#方法没有返回值" class="headerlink" title="方法没有返回值"></a>方法没有返回值</h3><p>如果类的方法没有返回值，该方法的返回值类型应当是abstract。</p>
<p><strong>Void</strong></p>
<h3 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h3><p>关于默认构造方法的创建，陈述正确的是（) </p>
<p>A.只有当前类没有其他构造方法时，编译器才会创建默认构造方法</p>
<p> B.默认构造方法调用父类的无参数构造方法 </p>
<p>C.如果一个类缺少无参数构造方法，但有其他的构造方法，编译器会创建一个默认构造方法 </p>
<p>D.默认构造方法初始化方法变量 E.默认构造方法初始化类中声明的实例变量</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45804632/article/details/120643936">A<strong>只有当前类没有其他构造方法时，编译器才会创建默认构造方法</strong>：这是正确的。如果一个类没有显式地声明任何构造方法，编译器会自动为该类生成一个默认的无参构造方法</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45804632/article/details/120643936">1</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2335482">2</a>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/NYfor2017/article/details/104724282">B<strong>默认构造方法调用父类的无参数构造方法</strong>：这也是正确的。在Java中，子类的构造方法默认会调用父类的无参数构造方法，除非通过<code>super</code>关键字显式地调用了父类的其他构造方法</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/NYfor2017/article/details/104724282">3</a>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45804632/article/details/120643936">C<strong>如果一个类缺少无参数构造方法，但有其他的构造方法，编译器会创建一个默认构造方法</strong>：这是错误的。如果类中已经定义了至少一个构造方法（无论是有参还是无参），编译器不会自动提供默认的无参构造方法</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45804632/article/details/120643936">1</a>。</p>
<p>D. <strong>默认构造方法初始化方法变量</strong>：这个说法是不准确的。构造方法通常用于初始化实例变量，而不是方法变量（局部变量）。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39064700/article/details/81036913">E<strong>默认构造方法初始化类中声明的实例变量</strong>：这是部分正确的。默认构造方法会对类中的实例变量进行默认初始化，例如将整型变量初始化为0，对象引用初始化为<code>null</code>等。但如果类中的实例变量在声明时已经被初始化，或者在实例初始化代码块中被初始化，那么默认构造方法将不会改变这些初始化值</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39064700/article/details/81036913">4</a>。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>可唯一确定一棵二叉树的是（) </p>
<p>A.给定一棵二叉树的先序和中序遍历序列 </p>
<p>B.给定先序、中序和后序遍历序列中的任意一个即可 </p>
<p>C.给定一棵二叉树的先序和后序遍历序列 </p>
<p>D.给定一棵二叉树的后序和中序遍历序列</p>
<p>在二叉树的遍历中，要唯一确定一棵二叉树的结构，需要两种遍历序列，其中一种必须是中序遍历。这是因为中序遍历能够确定根节点在树中的位置，从而区分左右子树。因此，可以唯一确定一棵二叉树的遍历序列组合是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzy_nic/article/details/119550296">A<strong>先序遍历和中序遍历</strong>：先序遍历确定根节点，中序遍历区分左右子树</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzy_nic/article/details/119550296">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzy_nic/article/details/119550296">D<strong>后序遍历和中序遍历</strong>：后序遍历确定根节点，中序遍历区分左右子树</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzy_nic/article/details/119550296">1</a>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/533935579">给定先序、中序和后序遍历序列中的任意一个是不足以唯一确定一棵二叉树的结构的，因为没有中序遍历序列，我们无法确定根节点的位置。同样，先序和后序遍历序列的组合也不能唯一确定一棵二叉树，除非是在特殊情况下，比如二叉树是满二叉树</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/533935579">2</a>。</p>
<h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p>java中创建对象的方式由哪些</p>
<p> ①采用new </p>
<p>②通过反射 </p>
<p>③采用clone </p>
<p>④通过序列化机制</p>
<ol>
<li><p><strong>采用new关键字</strong>：这是最常见和最直接的创建对象的方式。通过使用<code>new</code>关键字，然后调用类的构造器来创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过反射</strong>：Java反射API允许程序在运行时访问、检查和操作类的对象。通过反射，你可以动态地创建对象和调用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;包名.MyClass&quot;);</span><br><span class="line">Object obj = clazz.newInstance(); // 或者 clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>采用clone</strong>：如果一个类实现了<code>java.lang.Cloneable</code>接口，那么可以通过克隆一个已存在的对象来创建一个新的对象。这需要类提供一个<code>protected</code>的<code>clone()</code>方法，该方法通常是从<code>java.lang.Object</code>继承的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass original = new MyClass();</span><br><span class="line">MyClass cloned = original.clone();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过序列化机制</strong>：Java的序列化机制允许你将对象的状态保存到磁盘或网络中，之后可以恢复该状态并重新创建一个对象。这通常涉及到实现<code>java.io.Serializable</code>接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;ObjectDataFile.obj&quot;);</span><br><span class="line">    ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class="line">    MyClass obj = (MyClass) ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用反序列化</strong>：与序列化相对，反序列化是在读取入一个序列化对象的过程，通常也涉及到实现<code>java.io.Serializable</code>接口。</p>
</li>
<li><p><strong>使用类加载器</strong>：Java类加载器负责加载类文件，它也可以用于创建类的对象。虽然这不是直接创建对象的方式，但它是创建对象背后的机制。</p>
</li>
<li><p><strong>使用框架和容器</strong>：例如使用Spring框架的依赖注入，或者使用EJB容器来管理企业JavaBean（EJB）。</p>
</li>
<li><p><strong>使用反例模式（如工厂模式、单例模式等）</strong>：在设计模式中，经常通过工厂方法或单例模式来控制对象的创建过程。</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>已知如下代码，哪些说法是正确的（)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> A.类B的构造器应该调用super0 </p>
<p>B.类B的构造器应该调用this0 </p>
<p>C.类B的构造器应该是没有参数 </p>
<p>D.类B的构造器应该是public</p>
<p>Java中，如果子类的构造器没有显式地调用一个超类的构造器或者同一个类中的另一个构造器，那么默认情况下，子类的构造器的第一句隐式地调用超类的无参构造器（<code>super()</code>）。如果超类中没有无参构造器，那么子类的构造器必须通过<code>super</code>关键字显式地调用超类中存在的其他构造器。</p>
<p>根据您提供的代码，<code>class A</code> 中有一个构造器 <code>A()</code>，而 <code>class B</code> 是 <code>class A</code> 的子类。但是，您提供的 <code>class B</code> 代码不完整，我们无法看到 <code>class B</code> 的构造器的具体实现。假设 <code>class B</code> 没有显式地定义任何构造器，那么：</p>
<p>A. **类B的构造器应该调用super()**：这是正确的。如果 <code>class B</code> 的构造器没有显式调用 <code>this()</code> 或 <code>super()</code>，它将隐式地调用 <code>super()</code>，即 <code>A</code> 类的无参构造器。</p>
<p>B. **类B的构造器应该调用this()**：这是错误的，除非 <code>class B</code> 中有多个构造器，并且一个构造器想要调用同一个类中的另一个构造器。</p>
<p>C. <strong>类B的构造器应该是没有参数</strong>：这是正确的，如果 <code>class B</code> 的构造器没有显式地定义任何参数。</p>
<p>D. <strong>类B的构造器应该是public</strong>：这是正确的，除非 <code>class B</code> 的构造器被声明为其他访问级别（如 <code>private</code> 或 <code>protected</code>），或者没有显式地指定访问级别。在Java中，如果不显式指定构造器的访问级别，默认情况下它是与类相同的访问级别。如果 <code>class B</code> 没有指定访问级别，那么它的构造器是 <code>package-private</code>（包访问权限），这意味着只有同一包内的其他类可以访问它。</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>以下哪些继承自Collection接口 A.Map B.List C.Set D.Array</p>
<p>在Java中，<code>Collection</code> 接口是所有集合类型（如列表、集合和队列）的根接口。以下是继承自 <code>Collection</code> 接口的类型：</p>
<p>A. <strong>Map</strong> - 错误。<code>Map</code> 提供了一个映射，其中每个键最多只能映射到一个值，它不是继承自 <code>Collection</code> 接口的，而是继承自 <code>java.util.Map</code> 接口。</p>
<p>B. <strong>List</strong> - 正确。<code>List</code> 是一个有序的集合，可以包含重复的元素。<code>List</code> 继承自 <code>Collection</code> 接口。</p>
<p>C. <strong>Set</strong> - 正确。<code>Set</code> 是一个不允许重复的集合。<code>Set</code> 同样继承自 <code>Collection</code> 接口。</p>
<p>D. <strong>Array</strong> - 错误。数组（Array）并不是继承自 <code>Collection</code> 接口。数组是一种基本的数据结构，用于存储固定数量的元素，它不是 <code>Collection</code> 框架的一部分。</p>
<p>因此，正确的说法是 B 和 C。<code>List</code> 和 <code>Set</code> 都是 <code>Collection</code> 接口的直接继承者。</p>
<h3 id="equals-和-x3D-x3D"><a href="#equals-和-x3D-x3D" class="headerlink" title="equals 和 &#x3D;&#x3D;"></a>equals 和 &#x3D;&#x3D;</h3><p>已知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;a&quot;</span>,</span><br><span class="line">String b=<span class="string">&quot;b&quot;</span>,</span><br><span class="line">String c=a+b,</span><br><span class="line">String d=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以下操作结果为true的是 () </p>
<p>A.c&#x3D;&#x3D;d </p>
<p>B.c.equals(d) </p>
<p>C.a+b&#x3D;&#x3D;c </p>
<p>D.(a+b).equals(c)</p>
<p>A. <code>c == d</code> - 这个表达式检查 <code>c</code> 和 <code>d</code> 是否引用同一个对象。由于 <code>c</code> 是通过 <code>a + b</code> 直接连接两个字符串字面量得到的，它可能是一个指向字符串常量池中 “ab” 的引用。而 <code>d</code> 是通过 <code>new String(&quot;ab&quot;)</code> 创建的，它创建了一个新的对象，即使内容相同，它也与 <code>c</code> 不是同一个对象。因此，这个表达式的结果通常是 <code>false</code>。</p>
<p>B. <code>c.equals(d)</code> - 这个表达式使用 <code>equals()</code> 方法来比较 <code>c</code> 和 <code>d</code> 的内容。由于 <code>c</code> 和 <code>d</code> 包含相同的字符序列 “ab”，所以这个方法将返回 <code>true</code>。</p>
<p>C. <code>a + b == c</code> - 这个表达式检查 <code>a + b</code> 的结果是否与 <code>c</code> 是同一个对象。由于 <code>c</code> 是通过 <code>a + b</code> 创建的，它们引用的是同一个对象。因此，这个表达式的结果为 <code>true</code>。</p>
<p>D. <code>(a + b).equals(c)</code> - 这个表达式首先计算 <code>(a + b)</code>，它将产生 “ab”，然后调用 <code>equals(c)</code> 来比较这个结果与 <code>c</code> 的内容。由于 <code>c</code> 就是 “ab”，所以 <code>(a + b)</code> 与 <code>c</code> 的内容相同，<code>equals()</code> 方法将返回 <code>true</code>。</p>
<p>因此，正确的选项是：</p>
<p>C. <code>a + b == c</code> D. <code>(a + b).equals(c)</code></p>
<p>选项 B 也是正确的，因为 <code>c.equals(d)</code> 比较的是内容，而不是引用。所以，正确的选项是 B、C 和 D。</p>
<h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>关于默认构造方法的创建，陈述正确的是（) </p>
<p>A.只有当前类没有其他构造方法时，编译器才会创建默认构造方法 </p>
<p>B.默认构造方法调用父类的无参数构造方法 </p>
<p>C.如果一个类缺少无参数构造方法，但有其他的构造方法，编译器会创建一个默认构造方法</p>
<p> D.默认构造方法初始化方法变量</p>
<p> E.默认构造方法初始化类中声明的实例变量</p>
<p>A. <strong>错误</strong>。即使类中有其他构造方法，编译器也会为这个类提供一个默认的无参数构造方法，除非显式地定义了构造方法。</p>
<p>B. <strong>正确</strong>。默认构造方法会隐式地调用其父类（超类）的无参数构造方法，除非在子类的构造方法中通过 <code>super()</code> 或 <code>this()</code> 显式地调用了其他构造方法。</p>
<p>C. <strong>错误</strong>。如果一个类定义了自己的构造方法，编译器不会提供默认的无参数构造方法。只有当类中没有任何构造方法时，编译器才会提供一个。</p>
<p>D. <strong>错误</strong>。默认构造方法不会特别初始化方法变量。方法变量（局部变量）需要在方法内部显式初始化。</p>
<p>E. <strong>错误</strong>。默认构造方法会按照变量的类型进行初始化。对于对象引用，初始化为 <code>null</code>；对于数值类型，如 <code>int</code>，会初始化为 <code>0</code>；对于布尔类型，会初始化为 <code>false</code>。但是，这并不是通过构造方法完成的，而是在对象创建时自动完成的。</p>
<p>因此，正确的陈述是 B。默认构造方法会调用父类的无参数构造方法。其他选项都是错误的。</p>
<h3 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h3><p>Java序列化是指把Java对象转换为字节序列的过程；Java反序列化是指把字节序列复为Java对象的过程。</p>
<p><strong>Java序列化</strong>：</p>
<ul>
<li>序列化是指将对象的状态信息转换为可以被存储（例如保存到磁盘上）或传输（通过网络发送到另一台计算机）的字节序列的过程。</li>
</ul>
<h3 id="InputStream类和OutputStream"><a href="#InputStream类和OutputStream" class="headerlink" title="InputStream类和OutputStream"></a>InputStream类和OutputStream</h3><p>InputStream类和OutputStream类是所有二进制I&#x2F;O的根类。</p>
<ol>
<li><strong>InputStream类</strong>：<ul>
<li><code>InputStream</code> 是Java中用于表示可以读取原始字节数据的所有类的根类。它属于 <code>java.io</code> 包。</li>
<li><code>InputStream</code> 提供了一些基本的方法，如 &#96;read()&#96;&#96;，用于从类派生的输入流中读取数据。</li>
</ul>
</li>
<li><strong>OutputStream类</strong>：<ul>
<li><code>OutputStream</code> 是Java中用于表示可以写入原始字节数据的所有类的根类。它也属于 <code>java.io</code> 包。</li>
<li><code>OutputStream</code> 提供了一些基本的方法，如 <code>write()</code>，用于向类派生的输出流中写入数据。</li>
</ul>
</li>
</ol>
<p>这两个类是Java I&#x2F;O流层次结构中的基类，但它们是专门用于二进制数据的输入和输出。对于字符数据的输入和输出，Java 提供了 <code>Reader</code> 和 <code>Writer</code> 类作为相应的根类。</p>
<h3 id="session-setAttribute"><a href="#session-setAttribute" class="headerlink" title="session.setAttribute"></a>session.setAttribute</h3><p>要在session对象中保存属性，可以使用session.setAttribute(“key”,”value”)语句</p>
<p>在Java的Servlet API中，<code>session</code> 对象用于在多个页面请求或访问中存储用户的信息。<code>session.setAttribute()</code> 方法用于将属性存储在会话（session）中。</p>
<p>以下是 <code>session.setAttribute()</code> 方法的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">true</span>); <span class="comment">// 或 request.getSession();</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数是属性的名称，它应该是一个字符串。</li>
<li>第二个参数是属性的值，它可以是任何对象。</li>
</ul>
<p>当您想要在用户的整个会话期间存储信息时，可以使用会话属性。例如，您可以存储用户的偏好设置、购物车内容或用户的身份验证信息。</p>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>abstract 只能存在于抽象类或接口中.</p>
<ul>
<li><strong>抽象类</strong>：使用 <code>abstract</code> 关键字声明，可以包含抽象方法和具体方法。</li>
<li><strong>接口</strong>：在Java 8之前，接口只包含抽象方法。从Java 8开始，接口也可以包含带有默认实现的默认方法和静态方法。</li>
</ul>
<p>除了抽象类和接口，<code>abstract</code> 关键字还可以用于：</p>
<ul>
<li><strong>抽象方法</strong>：即使在没有使用 <code>abstract</code> 关键字声明的类中，也可以有抽象方法（没有方法体的方法），这将隐式地使该类成为抽象类。</li>
<li><strong>局部抽象类</strong>：在一些特定的上下文中，如匿名类和 lambda 表达式，可以有局部的抽象实体，但这些不是完整的抽象类定义。</li>
</ul>
<p>总结来说，<code>abstract</code> 关键字主要用于声明抽象类和接口，但它也与抽象方法相关联。</p>
<h3 id="HashMap和Hashtable"><a href="#HashMap和Hashtable" class="headerlink" title="HashMap和Hashtable"></a>HashMap和Hashtable</h3><p>HashMap允许key和value为null,而Hashtable不允许</p>
<p><code>HashMap</code> 和 <code>Hashtable</code> 都是基于哈希表的键值对集合，它们在Java中用于存储映射关系，但它们在处理空键（null keys）和空值（null values）时的行为有所不同：</p>
<ol>
<li><strong>HashMap</strong>：<ul>
<li>允许一个空键（null key），但只能有一个，因为键是用来计算哈希码并确定对象存储位置的。</li>
<li>允许多个空值（null values），即可以有多个键映射到空值。</li>
</ul>
</li>
<li><strong>Hashtable</strong>：<ul>
<li>不允许空键（null key）。尝试将空键插入 <code>Hashtable</code> 将抛出 <code>NullPointerException</code>。</li>
<li>同样不允许空值（null values）。尝试将空值插入 <code>Hashtable</code> 也会抛出 <code>NullPointerException</code>。</li>
</ul>
</li>
</ol>
<p>这个差异是 <code>HashMap</code> 和 <code>Hashtable</code> 在设计上的一个关键区别，也是为什么在某些情况下，开发者可能更倾向于使用 <code>HashMap</code>，因为它提供了更大的灵活性。</p>
<p>此外，<code>Hashtable</code> 是线程安全的，它的所有方法都是同步的，而 <code>HashMap</code> 不是线程安全的。在单线程环境下，<code>HashMap</code> 通常提供更好的性能，但在多线程环境下，如果没有采取额外的同步措施，使用 <code>HashMap</code> 可能会导致数据不一致。在需要线程安全的哈希映射时，可以考虑使用 <code>Collections.synchronizedMap()</code> 将 <code>HashMap</code> 包装为线程安全，或者使用 <code>ConcurrentHashMap</code>，它是专为并发环境设计的哈希表。</p>
<h3 id="一个接口可以继承其他接口。"><a href="#一个接口可以继承其他接口。" class="headerlink" title="一个接口可以继承其他接口。"></a>一个接口可以继承其他接口。</h3><p>在Java中，接口可以继承一个或多个其他接口。这种机制允许创建接口的层次结构，其中更具体的接口可以继承一个或多个更通用的接口。</p>
<p>当一个接口继承另一个接口时，它继承了父接口中定义的所有方法（从Java 8开始，也包括默认方法和静态方法）。实现该接口的类必须提供所有继承方法的实现。</p>
<p>下面是一个接口继承其他接口的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceOne &#123;</span><br><span class="line">    void methodOne();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface InterfaceTwo &#123;</span><br><span class="line">    void methodTwo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ExtendedInterface extends InterfaceOne, InterfaceTwo &#123;</span><br><span class="line">    void methodThree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ExtendedInterface</code> 继承了 <code>InterfaceOne</code> 和 <code>InterfaceTwo</code>。因此，实现 <code>ExtendedInterface</code> 的任何类都必须提供 <code>methodOne()</code>、<code>methodTwo()</code> 和 <code>methodThree()</code> 的实现。</p>
<p>接口继承提供了一种方法来创建一个接口的组合，这可以用于实现多继承的效果，而在Java中类是不能多继承的。接口继承是Java实现多态和抽象化的一种强大工具。</p>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h3 id="保存activity数据"><a href="#保存activity数据" class="headerlink" title="保存activity数据"></a>保存activity数据</h3><p>下列方法可以保存activity数据的是（) </p>
<p>A.onSavelnstanceState O </p>
<p>B.onDestory O </p>
<p>C. onRestorelnstanceState </p>
<p>D.onNewlnstance</p>
<p>在Android开发中，用于保存Activity数据的方法是：</p>
<p>A. <strong>onSaveInstanceState</strong></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1661080">这个方法在Activity可能被系统销毁前被调用，用于保存Activity的状态。它通过传递一个Bundle对象，允许开发者将需要保存的状态以键值对的形式存储起来。如果Activity确实被系统销毁，这些状态信息可以在Activity重建时恢复</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1661080">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/107242189">2</a>。</p>
<p>C. <strong>onRestoreInstanceState</strong></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1661080">这个方法与<code>onSaveInstanceState</code>配合使用，在Activity被重新创建后，可以通过这个方法恢复之前保存的状态。它通常在<code>onStart</code>之后<code>onResume</code>之前被调用</a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1661080">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/107242189">2</a>。</p>
<p>选项B和D不是用于保存Activity数据的方法：</p>
<ul>
<li>B. <strong>onDestroy</strong> 是在Activity即将被销毁时调用的，用于执行清理工作，而不是保存数据。</li>
<li>D. <strong>onNewInstance</strong> 并不是一个标准的Android生命周期方法。</li>
</ul>
<h3 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity()"></a>启动Activity()</h3><p>以下那些方法可以启动Activity() </p>
<p>A.getActivity.next() </p>
<p>B.startActivityForResult()</p>
<p>C.getActivity.show()</p>
<p>D.startActivity()</p>
<p>在Android中，可以用来启动Activity的方法是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyqx/p/10927458.html">B**startActivityForResult()**：这个方法不仅可以启动一个Activity，还可以在Activity执行完毕后返回结果给调用者</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyqx/p/10927458.html">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyqx/p/10927458.html">D**startActivity()**：这是最常用的方法来启动一个新的Activity</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyqx/p/10927458.html">1</a>。</li>
</ul>
<p>选项A和C不是标准的Android方法来启动Activity。<code>getActivity()</code>通常用于Fragment中获取与之关联的Activity的实例，而不是用来启动新的Activity。<code>next()</code>和<code>show()</code>也不是用于启动Activity的方法。</p>
<h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>下面代码输出结果是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alpha</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Alpha</span>(); <span class="comment">// 创建Alpha类的实例，会打印出&quot;test&quot;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Base</span>();  <span class="comment">// 创建Base类的实例，也会打印出&quot;test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当创建<code>Alpha</code>类的实例时，它的构造器会隐式地调用父类<code>Base</code>的构造器，打印出第一个”test”。紧接着，当直接创建<code>Base</code>类的实例时，它的构造器再次被调用，打印出第二个”test”。</p>
<p>但是，您的代码中有一些语法错误，我已经为您纠正了这些错误。下面是修正后的代码：</p>
<h3 id="List-声明"><a href="#List-声明" class="headerlink" title="List 声明"></a>List 声明</h3><p>在如下代码中，list扩充了（)次 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">20</span>); </span><br></pre></td></tr></table></figure>

<p>A.0 B.2 C.1 D.3</p>
<p><a target="_blank" rel="noopener" href="https://cloud.baidu.com/article/3311861">在Java中，<code>ArrayList</code>的扩容机制是当添加元素时，如果集合中元素的数量超过了当前的容量，<code>ArrayList</code>会进行扩容。扩容的新容量通常是旧容量的1.5倍</a><a target="_blank" rel="noopener" href="https://cloud.baidu.com/article/3311861">1</a>。</p>
<p>对于您的问题，由于您已经用初始容量20创建了<code>ArrayList</code>，除非添加的元素数量超过了20，否则<code>ArrayList</code>不会进行扩容。因此，如果在<code>list</code>中添加的元素数量没有超过20个，那么<code>list</code>将不会扩充。</p>
<p>如下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="comment">// 此处应该返回Integer类型，以匹配Super类中的返回类型</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Super</span> <span class="variable">sooper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Super</span>();</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        <span class="comment">// 正确调用toString()方法</span></span><br><span class="line">        System.out.println(sooper.getLength().toString() + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">                           sub.getLength().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是（)</p>
<p><strong>重写返回的数据类型必须一致</strong></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14694852/can-overridden-methods-differ-in-return-type">在Java中，方法重写（Overriding）时，子类方法的返回类型应该是父类方法返回类型的子类型，这被称为协变返回类型。但是，基本数据类型（如<code>Integer</code>和<code>Long</code>）不支持协变返回类型，因为它们不是类类型，而是原始数据类型</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14694852/can-overridden-methods-differ-in-return-type">1</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14519797/overriding-a-method-with-different-return-types-in-java">2</a><a target="_blank" rel="noopener" href="https://www.sparkcodehub.com/java/overriding">3</a>。</p>
<p>在您提供的代码中，<code>Sub</code>类试图重写<code>Super</code>类的<code>getLength()</code>方法，并改变返回类型从<code>Integer</code>到<code>Long</code>。这是不允许的，因为<code>Integer</code>和<code>Long</code>都是包装类，它们分别封装了<code>int</code>和<code>long</code>原始数据类型，而且它们之间没有继承关系。</p>
<p>因此，这段代码会导致编译错误，而不是成功执行并输出结果。如果您尝试编译这段代码，您将会收到一个错误，指出<code>Sub</code>类中的<code>getLength()</code>方法不能重写<code>Super</code>类中的<code>getLength()</code>方法。</p>
<p>为了让代码正确编译，子类<code>Sub</code>中的方法必须有与父类<code>Super</code>中的方法相同的返回类型<code>Integer</code>，或者是<code>Integer</code>的子类型（如果<code>Integer</code>有子类型的话）。但是在这种情况下，由于我们是在处理包装类，所以返回类型必须保持一致。</p>
<p>请注意，代码中还有一些其他的小错误，例如方法名<code>getLenght</code>应该是<code>getLength</code>，并且在<code>main</code>方法的打印语句中，<code>toString0</code>应该是<code>toString()</code>。这里是修正后的代码示例：</p>
<h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p>下面代码会抛出什么异常 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, String&gt; map ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，<code>map</code>是一个静态的<code>Map</code>对象，但是它没有被初始化，即没有分配内存空间。当尝试使用<code>map.put(1,&quot;A&quot;)</code>向<code>map</code>中添加元素时，由于<code>map</code>是<code>null</code>，这将会导致<code>NullPointerException</code>异常。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>如下代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.</span> <span class="keyword">public</span> Object <span class="title function_">m</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="number">11.</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">3.14F</span>); </span><br><span class="line"><span class="number">12.</span> Object [] oa = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>]; </span><br><span class="line"><span class="number">13.</span> oa[<span class="number">0</span>]=o; </span><br><span class="line"><span class="number">14.</span> o=<span class="literal">null</span>; </span><br><span class="line"><span class="number">15.</span> oa[<span class="number">0</span>]=<span class="literal">null</span>; </span><br><span class="line"><span class="number">16.</span> print<span class="string">&#x27;return 0&#x27;</span>; <span class="number">17.</span>&#125; </span><br></pre></td></tr></table></figure>

<p>当Float对象在第11行被创建后，什么时候能够被垃圾回收 </p>
<p>A.13行以后 )B.14行以后 C.15行以后 D.16行以后</p>
<p>在Java中，一个对象可以被垃圾回收（GC）的前提是该对象不再被任何活动的引用所引用。在您提供的代码中，<code>Float</code>对象最初被引用变量<code>o</code>引用，然后在第13行，这个引用被赋值给<code>oa</code>数组的第一个元素。在第14行，变量<code>o</code>被赋值为<code>null</code>，但此时<code>Float</code>对象仍然被<code>oa</code>数组中的引用所持有，因此它还不能被垃圾回收。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feiying0canglang/article/details/121030668">直到第15行，<code>oa</code>数组的第一个元素也被赋值为<code>null</code>，这时<code>Float</code>对象不再有任何活动引用指向它，因此它现在可以被垃圾回收。但请注意，这并不意味着对象立即被回收，只是它现在<strong>可以</strong>被回收。实际的回收时机取决于GC算法和GC运行的具体时机</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/feiying0canglang/article/details/121030668">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/658949296">2</a>。</p>
<h3 id="变量的访问权限"><a href="#变量的访问权限" class="headerlink" title="变量的访问权限"></a>变量的访问权限</h3><p>已知如下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.0f</span>; </span><br><span class="line">    <span class="type">int</span> m=<span class="number">12</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span> ( )  ; <span class="comment">// Check point </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p> 在代码中“Check point”处替换为哪些语句是合法的0 A.Test.n; B.this.n; C.t.f: D.Test.m;</p>
<p>在Java中，合法的语句是那些遵循语法规则并且在语境中有意义的语句。在“Check point”处，我们需要考虑静态上下文（因为<code>main</code>方法是静态的）和变量的访问权限。以下是对每个选项的分析：</p>
<p>A. <code>Test.n;</code> - 这是一个合法的语句，因为<code>n</code>是<code>Test</code>类的静态变量，可以通过类名直接访问。</p>
<p>B. <code>this.n;</code> - 这是不合法的语句，因为<code>this</code>关键字在静态上下文中没有意义，不能在<code>main</code>方法中使用。</p>
<p>C. <code>t.f;</code> - 这是一个合法的语句，因为<code>f</code>是<code>Test</code>类的实例变量，可以通过实例<code>t</code>访问。</p>
<p>D. <code>Test.m;</code> - 这是不合法的语句，因为<code>m</code>是一个实例变量，不能通过类名直接访问，必须通过类的实例来访问。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><p>现有一个数据类Bean,</p>
<p>打印getA()的结果会显示那个值（) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> a; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getA</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，由于没有对<code>Bean</code>实例的变量<code>a</code>进行赋值，所以打印<code>getA()</code>的结果将会是<code>0.0</code>。</p>
<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p>按照学生平均成绩（avg_grade)将students表中的数据检索出来， 下面SQL语句正确的是（) </p>
<p>A.SELECT*FROM students ORDER BY avg_grade DESC *</p>
<p><em>B.SELECT</em>FROM students ORDER by avg_grade ASC </p>
<p>C.SELECT*FROM students ORDER BY avg_grade *</p>
<p>D.SELECT*FROM students GROUP BY avg_grade ASC</p>
<p>在SQL中，如果您想要根据学生的平均成绩<code>avg_grade</code>对<code>students</code>表中的数据进行排序，您可以使用<code>ORDER BY</code>子句。这个子句可以指定排序的列和排序的方向（升序ASC或降序DESC）。没有指定方向时，默认是升序。</p>
<p>选项A和B都是正确的，它们分别表示：</p>
<ul>
<li>A. <strong>按平均成绩降序排列</strong>：<code>SELECT * FROM students ORDER BY avg_grade DESC</code></li>
<li>B. <strong>按平均成绩升序排列</strong>：<code>SELECT * FROM students ORDER BY avg_grade ASC</code></li>
</ul>
<p>选项C也是有效的，但它没有明确指出排序的方向，因此默认为升序：</p>
<ul>
<li>C. <strong>按平均成绩升序排列</strong>（默认）：<code>SELECT * FROM students ORDER BY avg_grade</code></li>
</ul>
<p>选项D使用了<code>GROUP BY</code>子句，这通常用于聚合函数（如COUNT, MAX, MIN, SUM, AVG等）的情况，而不是用于排序，所以它不适用于这个查询：</p>
<ul>
<li>D. <strong>错误的使用了GROUP BY</strong>：<code>SELECT * FROM students GROUP BY avg_grade ASC</code></li>
</ul>
<h1 id="Mybatis-x2F-Mybatis-plus"><a href="#Mybatis-x2F-Mybatis-plus" class="headerlink" title="Mybatis&#x2F;Mybatis-plus"></a>Mybatis&#x2F;Mybatis-plus</h1><h3 id="Mybatis分页的实现方式"><a href="#Mybatis分页的实现方式" class="headerlink" title="Mybatis分页的实现方式"></a>Mybatis分页的实现方式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38377803/article/details/114092155"><strong>配置分页插件</strong>：在配置类中添加分页插件</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>();</span><br><span class="line">        paginationInnerInterceptor.setOverflow(<span class="literal">true</span>);</span><br><span class="line">        paginationInnerInterceptor.setMaxLimit(<span class="number">100L</span>);</span><br><span class="line">        interceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38377803/article/details/114092155"><strong>使用分页查询</strong>：在Controller或Service层中，使用<code>Page</code>对象进行分页查询</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">IPage&lt;User&gt; userIPage = userMapper.selectPage(page, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Map-常用函数"><a href="#Map-常用函数" class="headerlink" title="Map 常用函数"></a>Map 常用函数</h3><p>put</p>
<p>get</p>
<p>remove</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Spring面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-15 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-15T13:26:38+08:00">2024-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-17 01:19:49" itemprop="dateModified" datetime="2024-05-17T01:19:49+08:00">2024-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 是一个轻量级的IoC 和AOP 容器框架。是为Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML 的配置、基于注解的配置、基于Java 的配置。<br>主要由以下几个模块组成：<br>Spring Core ：核心类库，提供IOC 服务；<br>Spring Context：提供框架式的Bean 访问方式，以及企业级功能（JNDI、定时任务等）；<br>Spring AOP：AOP 服务；<br>Spring DAO：对JDBC 的抽象，简化了数据访问异常的处理；<br>Spring ORM：对现有的ORM 框架的支持；<br>Spring Web：提供了基本的面向Web 的综合特性，例如多方文件上传；<br>Spring MVC：提供面向Web 应用的Model-View-Controller 实现。</p>
<h2 id="Autowired和Resource关键字的区别？"><a href="#Autowired和Resource关键字的区别？" class="headerlink" title="Autowired和Resource关键字的区别？"></a>Autowired和Resource关键字的区别？</h2><p>@Resource 和@Autowired 都是做bean 的注入时使用，其实@Resource 并不是Spring 的注解，它的包是javax.annotation.Resource ，需要导入，但是Spring 支持该注解的注入。<br>1、共同点<br>两者都可以写在字段和setter 方法上。两者如果都写在字段上，那么就不需要再写setter 方法。<br>2、不同点<br>（ 1 ）@Autowired@Autowired 为Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired；只按照byType 注入。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null 值，可以设置它的required 属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier 注解一起使用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>@Resource 默认按照ByName 自动注入，由J2EE 提供，需要导入包javax.annotation.Resource。</p>
<p>@Resource 有两个重要的属性： name 和type，而Spring 将@Resource 注解的name 属性解析为</p>
<p>bean 的名字，而type 属性则解析为bean 的类型。所以，如果使用name 属性，则使用byName的自动注入策略，而使用type 属性时则使用byType 自动注入策略。如果既不指定name 也不指定type 属性，这时将通过反射机制使用byName 自动注入策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="comment">// 下面两种@Resource 只要使用一种即可</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的setter 方法</span></span><br><span class="line">上<span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Resource 装配顺序：<br>①如果同时指定了name 和type，则从Spring 上下文中找到唯一匹配的bean 进行装配，找不到则抛出异常。<br>②如果指定了name ，则从上下文中查找名称（id）匹配的bean 进行装配，找不到则抛出异常。<br>③如果指定了type，则从上下文中找到类似匹配的唯一bean 进行装配，找不到或是找到多个，都会抛出异常。<br>④如果既没有指定name ，又没有指定type，则自动按照byName 方式进行装配；如果没有匹配， 则回退为一个原始类型进行匹配，如果匹配则自动装配。<br>@Resource 的作用相当于@Autowired，只不过@Autowired 按照byType 自动注入。</p>
<h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p><strong>构造器注入</strong>将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</p>
<p>优点： 对象初始化完成后便可获得可使用的对象。<br>缺点： 当需要注入的对象很多时，构造器参数列表将会很长； 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</p>
<h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>setter方法注入loC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。<br>优点：灵活。可以选择性地注入需要的对象。<br>缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</p>
<h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>接口注入依赖类必须实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。<br>优点接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。<br>缺点： 侵入性太强，不建议使用。<br>PS：什么是侵入行？ 如果类A 要使用别人提供的一个功能，若为了使用这功能，需要在自己的<br>类中增加额外的代码，这就是侵入性。</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>MVC：MVC 是一种设计模式<br>MVC 的原理图：</p>
<ul>
<li>M-Model 模型（完成业务逻辑：由javaBean 构成，service+dao+entity）</li>
<li>V-View 视图（做界面的展示jsp ，html…… ）</li>
<li>C-Controller 控制器（接收请求—〉调用模型—〉根据结果派发页面）</li>
</ul>
<p>springMVC 是一个MVC 的开源框架，springMVC&#x3D;struts2+spring ，springMVC 就相当于是Struts2加上spring 的整合，</p>
<p>可以简单地把springMVC 理解为是spring 的一个模块（类似AOP ，IOC 这样的模块），网络上经常会说springMVC 和spring 无缝集成，其实springMVC<br>就是spring 的一个子模块，所以根本不需要同spring 进行整合。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405160110946.png"/>

<ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView。</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View。</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<p>以下组件通常使用框架提供实现：</p>
<p>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p>
<p>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。</p>
<p>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p>
<p><strong>组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong></p>
<p>作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
<p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p>
<p>作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p><strong>3、处理器适配器HandlerAdapter</strong></p>
<p>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p><strong>4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong></p>
<p>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>
<p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong></p>
<p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>
<p><strong>6、视图View(需要工程师开发jsp…)</strong></p>
<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>
<h3 id="下边两个组件通常情况下需要开发："><a href="#下边两个组件通常情况下需要开发：" class="headerlink" title="下边两个组件通常情况下需要开发："></a>下边两个组件通常情况下需要开发：</h3><p>Handler：处理器，即后端控制器用controller表示。</p>
<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>
<h2 id="SpringMVC常用的注解"><a href="#SpringMVC常用的注解" class="headerlink" title="SpringMVC常用的注解"></a>SpringMVC常用的注解</h2><p>@RequestMapping：用于处理请求url 映射的注解，可用于类或方法上。用于类上，则表示类<br>中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http 请求的json 数据，将json 转换为java 对象。</p>
<p>@ResponseBody：注解实现将conreoller 方法返回对象转化为json 对象响应给客户。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块<br>所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的<br>重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p>
<p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP 就会使用<br>JDK 动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK 动态代理，转而使<br>用CGlib 动态代理生成一个被代理对象的子类来作为代理。</p>
<h3 id="Spring-AOP-和-Aspect-AOP-有什么区别？"><a href="#Spring-AOP-和-Aspect-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 Aspect] AOP 有什么区别？"></a>Spring AOP 和 Aspect] AOP 有什么区别？</h3><p>Spring AOP 是属于运行时增强，而AspectJ 是编译时增强。Spring AOP 基于代理（Proxying），而AspectJ 基于字节码操作（Bytecode Manipulation）。</p>
<p>Spring AOP 已经集成了AspectJ ，AspectJ 应该算得上是Java 生态系统中最完整的AOP 框架了。AspectJ 相比于Spring AOP 功能更加强大，但是Spring AOP 相对来说更简单。</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它<br>比SpringAOP 快很多。</p>
<h3 id="在SpringAOP中，关注点和横切关注的区别是什么？"><a href="#在SpringAOP中，关注点和横切关注的区别是什么？" class="headerlink" title="在SpringAOP中，关注点和横切关注的区别是什么？"></a>在SpringAOP中，关注点和横切关注的区别是什么？</h3><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<p>那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP 的位置。</p>
<p>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
<h3 id="通知-与-通知的类型"><a href="#通知-与-通知的类型" class="headerlink" title="通知 与 通知的类型"></a>通知 与 通知的类型</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的<br>代码段。<br>Spring切面可以应用五种类型的通知：</p>
<ul>
<li>before: 前置通知，在一个方法执行前被调用。</li>
<li>after: 在方法执行之后调用的通知，无论方法执行是否成功。</li>
<li>after-returning: 仅当方法成功完成后执行的通知。</li>
<li>after-throwing: 在方法抛出异常退出时执行的通知。</li>
<li>around: 在方法执行之前和之后调用的通知。</li>
</ul>
<h2 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h2><p>IOC 就是控制反转，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖IoC 容器来动态注入对象需要的外部资源。</p>
<p>最直观的表达就是，IOC 让对象的创建不用去new 了，可以由spring 自动生产，使用java的反射机制，根据配置文件在运行时动态地去创建对象以及管理对象，并调用对象的方法的。</p>
<p>Spring 的IOC 有三种注入方式：构造器注入、setter 方法注入、根据注解注入。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161629381.png"/>

<h2 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h2><p>首先说一下Servlet 的生命周期：实例化，初始init，接收请求service，销毁destroy；</p>
<p>Spring 上下文中的Bean 生命周期也类似，如下：</p>
<h3 id="实例化Bean-："><a href="#实例化Bean-：" class="headerlink" title="实例化Bean ："></a>实例化Bean ：</h3><p>对于BeanFactory 容器，当客户向容器请求一个尚未初始化的bean 时，或初始化bean 的时候需要注入另一个尚未初始化的依赖时， 容器就会调用createBean 进行实例化。对于ApplicationContext 容器，当容器启动结束后，通过获取BeanDefinition 对象中的信息，实例化所有的bean。</p>
<h3 id="设置对象属性（依赖注入）："><a href="#设置对象属性（依赖注入）：" class="headerlink" title="设置对象属性（依赖注入）："></a>设置对象属性（依赖注入）：</h3><p>实例化后的对象被封装在BeanWrapper 对象中，紧接着，Spring 根据BeanDefinition 中的信<br>息以及通过BeanWrapper 提供的设置属性的接口完成依赖注入。</p>
<h3 id="处理Aware-接口："><a href="#处理Aware-接口：" class="headerlink" title="处理Aware 接口："></a>处理Aware 接口：</h3><p>接着，Spring 会检测该对象是否实现了xxxAware 接口，并将相关的xxxAware 实例注入Bean ：</p>
<ol>
<li>如果这个Bean 已经实现了BeanNameAware 接口，会调用它实现的setBeanName(String beanId）方法，此处传递的就是Spring 配置文件中Bean 的id 值；</li>
<li>如果这个Bean 已经实现了BeanFactoryAware 接口，会调用它实现的setBeanFactory(）方法，传递的是Spring 工厂自身。</li>
<li>如果这个Bean 已经实现了ApplicationContextAware 接口，会调用<br>setApplicationContext(ApplicationContext）方法，传入Spring上下文</li>
</ol>
<h3 id="BeanPostProcessor："><a href="#BeanPostProcessor：" class="headerlink" title="BeanPostProcessor："></a>BeanPostProcessor：</h3><p>如果想对Bean 进行一些自定义的处理，那么可以让Bean 实现了BeanPostProcessor 接口，那<br>将会调用postProcessBeforeInitialization(Object obj, Strings）方法。</p>
<h3 id="InitializingBean-与init-method-："><a href="#InitializingBean-与init-method-：" class="headerlink" title="InitializingBean 与init-method ："></a>InitializingBean 与init-method ：</h3><p>如果Bean 在Spring 配置文件中配置了init-method 属性，则会自动调用其配置的初始化方法。</p>
<h3 id="BeanPostProcessor：-1"><a href="#BeanPostProcessor：-1" class="headerlink" title="BeanPostProcessor："></a>BeanPostProcessor：</h3><p>如果这个Bean 实现了BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, Strings）方法；由于这个方法是在Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>
<p><strong>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个Bean 了。</strong></p>
<h3 id="DisposableBean-："><a href="#DisposableBean-：" class="headerlink" title="DisposableBean ："></a>DisposableBean ：</h3><p>当Bean 不再需要时，会经过清理阶段，如果Bean 实现了DisposableBean 这个接口，会调用其实现的destroy(）方法；</p>
<h3 id="destroy-method-："><a href="#destroy-method-：" class="headerlink" title="destroy-method ："></a>destroy-method ：</h3><p>最后，如果这个Bean 的Spring 配置中配置了destroy-method 属性，会自动调用其配置的销<br>毁方法。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161641151.png"/>

<h2 id="Spring支持的几种bean的作用域？"><a href="#Spring支持的几种bean的作用域？" class="headerlink" title="Spring支持的几种bean的作用域？"></a>Spring支持的几种bean的作用域？</h2><p>Spring 容器中的bean 可以分为5 个范围：</p>
<ol>
<li>singleton：默认，每个容器中只有一个bean 的实例，<strong>单例的模式</strong>由<strong>BeanFactory 自身来维护</strong>。</li>
<li>prototype：<strong>为每一个bean 请求提供一个实例。</strong></li>
<li>request：<strong>为每一个网络请求创建一个实例</strong>，在请求完成以后，<strong>bean 会失效并被垃圾回收器回收</strong>。</li>
<li>session：与request 范围类似，<strong>确保每个session 中有一个bean 的实例</strong>，<strong>在session 过期后， bean 会随之失效</strong>。</li>
<li>global-session：全局作用域，global-session 和Portlet 应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet 共用全局的存储变量的话，那么这全局变量需要存储在global-session 中。全局作用域与Servlet 中的session 作用域效果相同。</li>
</ol>
<h2 id="Spring基于xml注入bean的几种方式？"><a href="#Spring基于xml注入bean的几种方式？" class="headerlink" title="Spring基于xml注入bean的几种方式？"></a>Spring基于xml注入bean的几种方式？</h2><p>（ 1 ）Set 方法注入；<br>（ 2）构造器注入：①通过index 设置参数的位置；②通过type 设置参数类型；<br>（ 3）静态工厂注入；<br>（ 4）实例工厂；</p>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><ul>
<li><p><strong>简单工厂模式：</strong></p>
<p>Spring 中的BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p>
</li>
<li><p><strong>工厂模式：</strong></p>
<p>Spring 中的FactoryBean 就是典型的工厂方法模式，实现了FactoryBean 接口的bean 是一类叫做factory 的bean。其特点是，spring 在使用getBean() 调用获得该bean 时，会自动调用该bean 的getObject() 方法，所以返回的不是factory 这个bean，而是这个bean.getOjbect() 方法的返回值。</p>
</li>
<li><p><strong>单例模式：</strong></p>
<p>在spring 中用到的单例模式有： scope&#x3D;”singleton” ，注册式单例模式，bean 存放于Map 中。bean name 当做key ，bean 当做value。</p>
</li>
<li><p><strong>原型模式：</strong></p>
<p>在spring 中用到的原型模式有： scope&#x3D;”prototype” ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。迭代器模式：在Spring 中有个CompositeIterator 实现了Iterator ，Iterable 接口和Iterator接口，这两个都是迭代相关的接口。可以这么认为，实现了Iterable 接口，则表示某对象是可被迭代的。Iterator 接口相当于是一个迭代器，实现了Iterator 接口，等于具体定义了这个可被迭代的对象是如何进行迭代的。</p>
</li>
<li><p><strong>代理模式：</strong></p>
<p>Spring 中经典的AOP，就是使用动态代理实现的，分JDK 和CGlib 动态代理。</p>
</li>
<li><p><strong>适配器模式：</strong></p>
<p>Spring 中的AOP 中AdvisorAdapter 类，它有三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapterThrowsAdviceAdapter。Spring会根据不同的AOP 配置来使用对应的Advice，与策略模式不同的是，一个方法可以同时拥有多个Advice。Spring 存在很多以Adapter 结尾的，大多数都是适配器模式。</p>
</li>
<li><p><strong>观察者模式：</strong></p>
<p>Spring 中的Event 和Listener。spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自EventObject。spring 事件监听器：ApplicationListener，该接口继承了EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。</p>
</li>
<li><p><strong>模板模式：</strong></p>
<p>Spring 中的org.springframework.jdbc.core.JdbcTemplate 就是非常经典的模板模式的应用，里面的execute 方法，把整个算法步骤都定义好了。</p>
</li>
<li><p><strong>责任链模式：</strong></p>
<p>DispatcherServlet 中的doDispatch() 方法中获取与请求匹配的处理<br>器HandlerExecutionChain ，this.getHandler() 方法的处理使用到了责任链模式。</p>
</li>
</ul>
<p>注意：这里只是列举了部分设计模式，其实里面用到了还有享元模式、建造者模等。可选择性地回答，主要是怕你回答了迭代器模式，然后继续问你，结果你一问三不知，那就尴了干了。</p>
<h2 id="Spring中ApplicationContext和BeanFactory的区别"><a href="#Spring中ApplicationContext和BeanFactory的区别" class="headerlink" title="Spring中ApplicationContext和BeanFactory的区别"></a>Spring中ApplicationContext和BeanFactory的区别</h2><h3 id="包目录不同"><a href="#包目录不同" class="headerlink" title="包目录不同"></a><strong>包目录不同</strong></h3><p>spring-beans.jar 中org.springframework.beans.factory.BeanFactory<br>spring-context.jar 中org.springframework.context.ApplicationContext</p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>BeanFactory 是不支持国际化功能的，因为BeanFactory 没有扩展Spring 中MessageResource 接口。相反，由于ApplicationContext 扩展了MessageResource 接口，因而具有消息处理的能力（ i18N ）。</p>
<h3 id="强大事件机制（Event）"><a href="#强大事件机制（Event）" class="headerlink" title="强大事件机制（Event）"></a>强大事件机制（Event）</h3><p>基本上牵涉到事件（Event）方面的设计，就离不开观察者模式ApplicationContext 的事件机制主要通过ApplicationEvent 和ApplicationListener 这两个接口来提供的，和Java swing 中的事件机制一样。即当ApplicationContext 中发布一个事件时，所有扩展了ApplicationListener的Bean 都将接收到这个事件，并进行相应的处理。</p>
<h3 id="底层资源的访问"><a href="#底层资源的访问" class="headerlink" title="底层资源的访问"></a>底层资源的访问</h3><p>ApplicationContext 扩展了ResourceLoader（资源加载器）接口，从而可以用来加载多个Resource ，而BeanFactory 是没有扩展ResourceLoader。</p>
<h3 id="对Web应用的支持"><a href="#对Web应用的支持" class="headerlink" title="对Web应用的支持"></a>对Web应用的支持</h3><p>与BeanFactory通常以编程的方式被创建，ApplicationContext能以声明的方式创建，如使用ContextLoader。当然你也可以使用 ApplicationContext的实现方式之一，以编程的方式创建ApplicationContext 实例。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><ol>
<li>BeanFactroy 采用的是延迟加载形式来注入Bean 的，即只有在使用到某个Bean 时（调用getBean())，才对该Bean 进行加载实例化。这样，我们就不能发现一些存在的spring 的配置问题。而ApplicationContext 则相反，它是在容器启动时，一次性创建了有的Bean。<br>这样，在容器启动时，我们就可以发现Spring 中存在的配置错误。</li>
<li>BeanFactory 和ApplicationContext 都支持BeanPostProcessor、BeanFactoryPostProcessor 的使用。两者之间的区别是：BeanFactory 需要手动注册，而ApplicationContext 则是自动注册。</li>
</ol>
<p>可以看到，ApplicationContext 继承了BeanFactory ，BeanFactory 是Spring 中比较原始的Factory，它不支持AOP、Web 等Spring 插件。而ApplicationContext 不仅包含了BeanFactory的所有功能，还支持Spring 的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。BeanFactory 是Spring 框架的基础设施面向Spring 本身；而ApplicationContext 面向使用Spring 的开发者，相BeanFactory 提供了更多面向实际应用的功能，几乎所有场合都可以直接使用ApplicationContext，而不是底层的BeanFactory。</p>
<h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><p>BeanFactory 类型的有XmlBeanFactory，它可以根据XML 文件中定义的内容，创建相应的Bean。<br>ApplicationContext 类型的常用容器有：</p>
<ol>
<li>ClassPathXmlApplicationContext：从ClassPath 的XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</li>
<li>FileSystemXmlApplicationContext：由文件系统中的XML 配置文件读取上文。</li>
<li>XmlWebApplicationContext：由Web 应用的XML 文件读取上下文。例如我们在SpringMVC 使用的情况。</li>
</ol>
<h2 id="Spring-框架中的单例-Bean-是线程安全的吗？"><a href="#Spring-框架中的单例-Bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的吗？"></a>Spring 框架中的单例 Bean 是线程安全的吗？</h2><p>Spring 框架并没有对单例Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例Bean 的线程安全和并发问题，需要开发者自行去搞定。</li>
<li>单例的线程安全问题，并不是Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例Bean 或多例Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的Spring Bean 并没有可变的状态，所以在某种程度上说Spring 的单例Bean 是线程安全的。如果你的Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态Bean 的作用域（Scope）由Singleton 变更为Prototype。</p>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161935493.png"/>

<ol>
<li>首先A 完成初始化第一步并将自己提前曝光出来（通过ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象B，此时就会去尝试get(B)，这个时候发现B 还没有被创建出来；</li>
<li>然后B 就走创建流程，在B 初始化的时候，同样发现自己依赖C ，C 也没有被创建出来；</li>
<li>这个时候C 又开始初始化进程，但是在初始化的过程中发现自己依赖A，于是尝试get(A)。这个时候由于A 已经添加至缓存中（一般都是添加至三级缓存<strong>singletonFactories</strong>），通过ObjectFactory 提前曝光，所以可以通过ObjectFactory#getObject() 方法来拿到A 对象。C拿到A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</li>
<li>回到B ，B 也可以拿到C 对象，完成初始化，A 可以顺利拿到B 完成初始化。到这里整个链路就已经完成了初始化过程了。</li>
</ol>
<p>关键字：三级缓存，提前曝光。</p>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="事务的隔离级别（MYSQL）"><a href="#事务的隔离级别（MYSQL）" class="headerlink" title="事务的隔离级别（MYSQL）"></a>事务的隔离级别（MYSQL）</h3><h4 id="事务的传播等级"><a href="#事务的传播等级" class="headerlink" title="事务的传播等级"></a>事务的传播等级</h4><p>Spring 事务定义了7 种传播机制：</p>
<ol>
<li>PROPAGATION_REQUIRED：默认的Spring 事务传播级别，若当前存在事务，则加入该事务，<br> 若不存在事务，则新建一个事务。</li>
<li>PAOPAGATION_REQUIRE_NEW：若当前没有事务，则新建一个事务。若当前存在事务，<strong>则新</strong><br> <strong>建一个事务，新老事务相互独立。</strong>外部事务抛出异常回滚不会影响内部事务的正常提交。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，<strong>则嵌套在当前事务中执行</strong>。如果当前没有事务，<br> 则新建一个事务，<strong>类似于REQUIRE_NEW。</strong></li>
<li>PROPAGATION_SUPPORTS：支持当前事务，若当前不存在事务，<strong>以非事务的方式执行</strong>。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务的方式执行，若当前存在事务，<strong>则把当前事务</strong><br> <strong>挂起</strong>。</li>
<li>PROPAGATION_MANDATORY：<strong>强制事务执行，</strong>若当前不存在事务，则抛出异常.</li>
<li>PROPAGATION_NEVER：<strong>以非事务的方式执行，</strong>如果当前存在事务，则抛出异常。</li>
</ol>
<p>Spring 事务传播级别一般不需要定义，默认就是PROPAGATION_REQUIRED，除非在嵌套事务的<br>  情况下需要重点了解。</p>
<h3 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h3><ul>
<li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</li>
</ul>
<h3 id="事务管理有哪些优点"><a href="#事务管理有哪些优点" class="headerlink" title="事务管理有哪些优点"></a>事务管理有哪些优点</h3><ul>
<li>它为不同的事务API（如JTA, JDBC, Hibernate, JPA, 和JDO）提供了统一的编程模型。</li>
<li>它为编程式事务管理提供了一个简单的API 而非一系列复杂的事务API（如JTA).</li>
<li>它支持声明式事务管理。</li>
<li>它可以和Spring 的多源数据访问技术很好地融合。</li>
</ul>
<h3 id="事务三要素"><a href="#事务三要素" class="headerlink" title="事务三要素"></a>事务三要素</h3><ul>
<li><strong>数据源：</strong>表示具体的事务性资源，是事务的真正处理者，如MySQL 等。</li>
<li><strong>事务管理器：</strong>像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</li>
<li><strong>事务应用和属性配置：</strong>像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</li>
</ul>
<h3 id="事务注解的本质"><a href="#事务注解的本质" class="headerlink" title="事务注解的本质"></a>事务注解的本质</h3><p>@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置的事务行为。大致来说具有两方面功能， 一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为</p>
<p>声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性增强（advice），来驱动事务完成。</p>
<p>@Transactional 注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的<br>所有方法。如果此时方法上也标注了，则方法上的优先级高。另外注意方法一定要是public 的。</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>Spring Boot 优点非常多，如：<br>一、独立运行<br>Spring Boot 而且内嵌了各种servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到<br>容器中，Spring Boot 只要打成一个可执行的jar 包就能独立运行，所有的依赖包都在一个jar 包<br>内。</p>
<p>二、简化配置<br>spring-boot-starter-web 启动器自动依赖其他组件，减少了maven 的配置。</p>
<p>三、自动配置<br>Spring Boot 能根据当前类路径下的类、jar 包来自动配置bean，如添加一个<br>spring-boot-starter- web 启动器就能拥有web 的功能，无需其他配置。</p>
<p>四、无代码生成和XML 配置<br>Spring Boot 配置过程中无代码生成，也无需XML 配置文件就能完成所有配置工作，这一切都是借<br>助于条件注解完成的，这也是Spring4.x 的核心功能之一。</p>
<p>五、应用监控<br>Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。</p>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p>启动类上面的注解是@SpringBootApplication，它也是Spring Boot 的核心注解，主要组合包含了以下3个注解：</p>
<ul>
<li>@SpringBootConfiguration：组合了@Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D;{ DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan ：Spring 组件扫描。</li>
</ul>
<h2 id="Spring-Boot有哪几种方式？"><a href="#Spring-Boot有哪几种方式？" class="headerlink" title="Spring Boot有哪几种方式？"></a>Spring Boot有哪几种方式？</h2><p>1）打包用命令或者放到容器中运行<br>2）用Maven&#x2F;Gradle 插件运行<br>3）直接执行main 方法运行</p>
<h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><p>Starters 是什么：<br>Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA 访问数据库，只要加入spring-boot-starter-data-jpa 启动器依赖就能使用了。Starters 包含了许多项目中需要用到的依赖，它们能快速持续地运行，都是一系列得到支持的管理传递性依赖。</p>
<h3 id="Starters-命名："><a href="#Starters-命名：" class="headerlink" title="Starters 命名："></a>Starters 命名：</h3><p>Spring Boot 官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的启动器不能以spring-boot 开头命名，它们都被Spring Boot 官方保留。一般一个第三方的应该这样命名，像mybatis 的mybatis-spring-boot-starter。</p>
<ul>
<li>spring-boot-starter-web 嵌入tomcat 和web 开发需要servlet 与jsp 支持</li>
<li>spring-boot-starter-data-jpa 数据库支持</li>
<li>spring-boot-starter-data-redis redis 数据库支持</li>
<li>spring-boot-starter-data-solr solr 支持</li>
<li>mybatis-spring-boot-starter 第三方的mybatis 集成starter</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170118378.png"/>

<h2 id="Spring-Boot-的核心配置文件"><a href="#Spring-Boot-的核心配置文件" class="headerlink" title="Spring Boot 的核心配置文件"></a>Spring Boot 的核心配置文件</h2><ul>
<li>pring Boot 的核心配置文件是application 和bootstrap 配置文件。</li>
<li>application 配置文件这个容易理解，主要用于Spring Boot 项目的自动化配置。</li>
<li>bootstrap 配置文件有以下几个应用场景。<ul>
<li>使用Spring Cloud Config 配置中心时，这时需要在bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li>
<li>一些固定的不能被覆盖的属性；</li>
<li>一些加密&#x2F;解密的场景；</li>
</ul>
</li>
</ul>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>基于SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML 里，解除sql 与程序代码的耦合，便于统一管理；提供XML 标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC 相比，减少了50%以上的代码量，消除了JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好地与各种数据库兼容（因为MyBatis 使用JDBC 来连接数据库，所以只要JDBC 支持的数据库MyBatis 都支持）。</li>
<li>能够与Spring 很好地集成；</li>
<li>提供映射标签，支持对象与数据库的ORM 字段关系映射；提供对象关系映射标签，支持对象关键组件维护。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1.<br>   SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL 语句的功底有一定要求。<br>2. SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h2 id="｛｝和-｛｝的区别是什么？"><a href="#｛｝和-｛｝的区别是什么？" class="headerlink" title="#｛｝和$｛｝的区别是什么？"></a>#｛｝和$｛｝的区别是什么？</h2><p>#{｝是预编译处理，${｝是字符串替换。</p>
<p>Mybatis 在处理#{｝时，会将sql 中的#{｝替换为？号，调用PreparedStatement 的set 方法来赋值；</p>
<p>Mybatis 在处理${｝时，就是把${｝替换成变量的值。使用#{｝可以有效地防止SQL 注入，提高系统安全性。</p>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用RowBounds 对象进行分页，它是针对ResultSet 结果集执行的内存分页，而非物理分页。可以在sql 内直接拼写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页，比如：MySQL 数据的时候，在原有SQL 后面拼写limit。</p>
<p>分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>
<p>第二种是使用sql 列的别名功能，将列的别名书写为对象属性名。</p>
<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一<br>赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h2 id="实现一对一有几种方式？具体怎么操作的？"><a href="#实现一对一有几种方式？具体怎么操作的？" class="headerlink" title="实现一对一有几种方式？具体怎么操作的？"></a>实现一对一有几种方式？具体怎么操作的？</h2><p>有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次， 通过在resultMap<br>里面配置association 节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去在另外一个表里面查询数据，也是<br>通过association 配置，但另外一个表的查询通过select 属性配置。</p>
<h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis 仅支持association 关联对象和collection 关联集合对象的延迟加载，association 指的就<br>是一对一，collection 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加<br>载lazyLoadingEnabled&#x3D;true|false。</p>
<blockquote>
<p>它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke(）方法发现a.getB(）是null 值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName(）方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
</blockquote>
<h2 id="Mybatis-的缓存机制："><a href="#Mybatis-的缓存机制：" class="headerlink" title="Mybatis 的缓存机制："></a>Mybatis 的缓存机制：</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170045709.png"/>

<h3 id="一级缓存localCache"><a href="#一级缓存localCache" class="headerlink" title="一级缓存localCache"></a>一级缓存localCache</h3><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL ，<br>MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的SQL 语句，会优先命中一级缓<br>存， 避免直接对数据库进行查询，提高性能。</p>
<p>每个SqlSession 中持有了Executor，每个Executor 中有一个LocalCache。当用户发起查询<br>时， MyBatis 根据当前执行的语句生成MappedStatement，在Local Cache 进行查询，如果<br>缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local<br>Cache，最后返回结果给用户。具体实现类的类关系图如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170101103.png"/>

<ol>
<li>MyBatis 一级缓存的生命周期和SqlSession 一致。</li>
<li>MyBatis 一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis 的一级缓存最大范围是SqlSession 内部，有多个SqlSession 或者分布式的环境下， 数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession 内部，如果多个SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor 装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170107703.png"/>

<p>二级缓存开启后，同一个namespace 下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程为：</p>
<p>二级缓存 —&gt; 一级缓存 —&gt; 数据库</p>
<ol>
<li>MyBatis 的二级缓存相对于一级缓存来说，实现了SqlSession 之间缓存数据的共享，同时粒度更加细，能够到namespace 级别，通过Cache 接口实现类不同的组合，对Cache 的可控性也更强。</li>
<li>MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis 的Cache 接口实现，有一定的开发成本，直接使用Redis、Memcached 等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h2 id="Mybatis设计模式"><a href="#Mybatis设计模式" class="headerlink" title="Mybatis设计模式"></a>Mybatis设计模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170110652.png"/>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">MYSQL面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-13 10:18:00" itemprop="dateModified" datetime="2024-06-13T10:18:00+08:00">2024-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><p>第一范式：列不可再分</p>
<p>第二范式：行可以唯一区分，主键约束</p>
<p>第三范式：表的非主属性不能依赖</p>
<p>与其他表的非主属性外键约束且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>
<h2 id="MYSQL数据库引擎"><a href="#MYSQL数据库引擎" class="headerlink" title="MYSQL数据库引擎"></a>MYSQL数据库引擎</h2><p>mysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405131951060.png"/>

<ul>
<li>MYISAM：<strong>全表锁</strong>，拥有较高的执行速度，<strong>不支持事务，不支持外键</strong>，并发性能差，占用空间相对较小，<strong>对事务完整性没有要求</strong>，以select、insert 为主的应用基本上可以使用这引擎</li>
<li>Innodb：<strong>行级锁</strong>，提供了具有提交、<strong>回滚和崩溃回复能力的事务安全，支持自动增长列</strong>，<strong>支持外键约束</strong>，并发能力强，占用空间是MYISAM 的2.5 倍，处理效率相对会差一些</li>
<li>Memory：全表锁，存储在内容中，速度快，<strong>但会占用和数据量成正比的内存空间</strong>且<strong>数据在mysql 重启时会丢失，默认使用HASH 索引</strong>，检索效率非常高，但<strong>不适用于精确查找</strong>，主要用于那些内容变化不频繁的代码表</li>
<li>MERGE：是一组MYISAM 表的组合</li>
</ul>
<h3 id="InnoDB-与-MyISAM-的区别"><a href="#InnoDB-与-MyISAM-的区别" class="headerlink" title="InnoDB 与 MyISAM 的区别"></a>InnoDB 与 MyISAM 的区别</h3><ol>
<li>InnoDB 支持事务，MyISAM 不支持，对于InnoDB 每一条SQL 语言都默认封装成事务，自<br>动提交，这样会影响速度，所以最好把多条SQL 语言放在begin 和commit 之间，组成一<br>个事务；</li>
<li>InnoDB 支持外键，而MyISAM 不支持。对一个包含外键的InnoDB 表转为MYISAM 会失败；</li>
<li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须有主键，通过主键索引效率很高。<br>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应<br>该过大，因为主键太大，其他索引也都会很大。而MyISAM 是非聚集索引，数据文件是分<br>离的， 索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而MyISAM<br>用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb 不支持全文索引，而MyISAM 支持全文索引，查询效率上MyISAM 要高；</li>
</ol>
<h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><p>什么是事务？ 多条 sql 语句，要么全部成功，要么全部失败。</p>
<p>事务的特征：数据库事务特征：</p>
<ul>
<li>原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功， 整个事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。</li>
<li>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A 转账100 元给B，不管操作是否成功，A 和B 的账户总额是不变的。</li>
<li>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</li>
<li>持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>官方介绍索引是帮助MySQL 高效获取数据的数据结构。更通俗地说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</li>
<li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</li>
<li>我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用树结构组织（多路搜索树，并不一定是二叉的）的索引。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ol>
<li>查询语句中不要使用select *</li>
<li>尽量减少子查询，使用关联查询（left join,right join,inner join）替代</li>
<li>减少使用IN 或者NOT IN ，使用exists ，not exists 或者关联查询语句替代</li>
<li>or 的查询尽量用union 或者union all 代替（在确认没有重复数据或者不用剔除重复数据时， union all 会更好）</li>
<li>应尽量避免在where 子句中使用！&#x3D;或〈〉操作符，<strong>否则将引擎放弃使用索引而进行全表扫描。</strong></li>
<li>应尽量避免在where 子句中对字段进行null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num 上设置默认值0，确保表中num列没有null 值，然后这样查询： select id from t where num&#x3D;0</li>
</ol>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>delete 和truncate 只删除<strong>表的数据不删除表的结构</strong></p>
<p>速度一般来说： drop&gt; truncate &gt;delete</p>
<p>delete 语句是dml，这个操作会放到rollback segement 中，事务提交之后才生效； 如果有相应的trigger，执行的时候将被触发. </p>
<p>truncate,drop 是ddl, 操作立即生效，原数据不放到rollback segment 中，不能回滚. 操作不触发trigger.</p>
<h2 id="试图"><a href="#试图" class="headerlink" title="试图"></a>试图</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易， 相比多表查询。</p>
<h2 id="内连接、左外连接、右外连接"><a href="#内连接、左外连接、右外连接" class="headerlink" title="内连接、左外连接、右外连接"></a>内连接、左外连接、右外连接</h2><ul>
<li><strong>内连接（Inner Join）：</strong>匹配2 张表中相关联的记录。</li>
<li><strong>左外连接（Left Outer Join）：</strong>除了匹配2 张表中相关联的记录外，还会匹配左表中剩余的记录，<strong>右表中未匹配到的字段用NULL 表示。</strong></li>
<li><strong>右外连接（Right Outer Join）：</strong>除了匹配2 张表中相关联的记录外，还会匹配右表中剩余的记录，<strong>左表中未匹配到的字段用NULL 表示。</strong>在判定左表和右表时，<strong>要根据表名出现在Outer Join 的左右位置关系。</strong></li>
</ul>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<p><strong>脏读（Dirty read ）：</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据” ，依据“脏数据”所做的操作可能是不正确的。</p>
<p><strong>丢失修改（ Lost to modify）：</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1 读取某表中的数据A&#x3D;20，事务2 也读取A&#x3D;20，事务1 修改A&#x3D;A-1，事务2 也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1 的修改被丢失。</p>
<p><strong>不可重复读（Unrepeatableread)：</strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>**幻读（Phantom read):**幻读与不可重复读类似。它发生在一个事务（T1)读取了几行数据，接着另一个并发事务（T2)插入了一些数据时。在随后的查询中，第一个事务（T1)就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p>不可重复读和幻读区别：<br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="SQL标准定义了四个隔离级别"><a href="#SQL标准定义了四个隔离级别" class="headerlink" title="SQL标准定义了四个隔离级别"></a>SQL标准定义了四个隔离级别</h3><ul>
<li>READ-UNCOMMITTED(读取未提交）:最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交）:允许读取并发事务已经提交的数据，可以阻止重读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读）:对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止重读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化）:最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止空读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>存储引擎的默认支持的隔离级别是 REPEATABLE-READ(可重读）。</p>
<p>这里需要注意的是：与SQL标准不同的地方在于InnoDB存储引擎在</p>
<p>REPEATABLE-READ(可重读）事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生，这与其他数据库系统（如SQLServer)是不同的。所以说InnoDB存储引擎的默认支持的隔离级别是</p>
<p>REPEATABLE-READ(可重读）已经可以完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化）隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是</p>
<p>READ-COMMITTED(读取提交内容）,但是你要知道的是InnoDB存储引擎默认使用REPEAaTABLE-READ(可重读）并不会有任何性能损失。</p>
<p>InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化）隔离级别。</p>
<h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL 单表记录数过大时，数据库的CRUD 性能会明显下降，一些常见的优化</p>
<p>措施如下：</p>
<h3 id="限定数据的范围"><a href="#限定数据的范围" class="headerlink" title="限定数据的范围"></a>限定数据的范围</h3><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h3 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h3><p>根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指数据表列的拆分，<strong>把一张列比较多的表拆分为多张表</strong>。</p>
<ul>
<li><strong>垂直拆分的优点：</strong>可以使得列数据变小，在查询时减少读取的Block数，减少1&#x2F;0次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong>主键会出现允余，需要管理穴余列，并会引起Join操作，可以通过在应用层 进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h3 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h3><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一组数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL 并发能力没有什么意义，所以<strong>水平拆分最好分库</strong>。</p>
<blockquote>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。《Java 工程师修炼之道》的作者推荐尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</p>
</blockquote>
<p>下面补充一下数据库分片的两种常见方案：</p>
<p>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常用的实现。</p>
<p>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分库分表之后，-id主键如何处理"><a href="#分库分表之后，-id主键如何处理" class="headerlink" title="分库分表之后， id主键如何处理"></a>分库分表之后， id主键如何处理</h3><p>因为要是分成多个表之后，每个表都是从1 开始累加，这样是不对的，我们需要一个全局唯一的id 来支持</p>
<p>生成全局id 有下面这几种方式：</p>
<ul>
<li><p>UUID:不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成一的名字的标示比如文件的名字。</p>
</li>
<li><p>数据库自增id：两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的id有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>
</li>
<li><p>利用redis生成id：性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
</li>
<li><p>Twitter的snowflake算法：Github地址：</p>
</li>
<li><p>美团的分布式生成系统：Leaf 是美团开源的分布式ID 生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper 等中间件。</p>
</li>
</ul>
<h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><ol>
<li><p>取得链接，使用到MySQL 中的连接器。</p>
</li>
<li><p>查询缓存，key 为SQL 语句，value 为查询结果，如果查到就直接返回。不建议使用次缓存， 在MySQL 8.0 版本已经将查询缓存删除，也就是说MySQL 8.0 版本后不存在此功能。</p>
</li>
<li><p>分析器，分为词法分析和语法分析。此阶段只是做一些SQL 解析，语法校验。所以一般语法错误在此阶段。</p>
</li>
<li><p>优化器，是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时候（join），决定各个表的连接顺序。</p>
</li>
<li><p>执行器，通过分析器让SQL 知道你要干啥，通过优化器知道该怎么做，于是开始执行语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行语句的时候还要判断是否具备此权限，没有权限就直接返回提示没有权限的错误；有权限则打开表，根据表的引擎定义，去使用这个引擎提供的接口，获取这个表的第一行，判断id 是否等于1。如果是，直接返回；如果不是继续调用引擎接口去下一行，重复相同的判断，直到取到这个表的最后一行，最后返回。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405142210161.png"/>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度</li>
<li>降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本</li>
</ul>
<p>缺点</p>
<ul>
<li><p>占用存储空间：素引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上</p>
</li>
<li><p>降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更从而减低的更新速度。否则索引指向的物理数据可能不对，这也是素引失效的原因</p>
</li>
</ul>
<h2 id="MySQL中varchar与char的区别？varchar-30-中的30代表的含义？"><a href="#MySQL中varchar与char的区别？varchar-30-中的30代表的含义？" class="headerlink" title="MySQL中varchar与char的区别？varchar(30)中的30代表的含义？"></a>MySQL中varchar与char的区别？varchar(30)中的30代表的含义？</h2><p>varchar与char的区别，char是一种固定长度的类型，varchar则是一种可变长度的类型。</p>
<p>varchar(30)中30的涵义最多存放30个字符。varchar(30)和（130)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为ORDER BY col 采用 fixed_length 计算col长度（memory引擎也一样）。</p>
<p>对效率要求高用char,对空间使用要求高用varchar。</p>
<h2 id="int-11-中的11代表什么含义？"><a href="#int-11-中的11代表什么含义？" class="headerlink" title="int(11)中的11代表什么含义？"></a>int(11)中的11代表什么含义？</h2><p>int(11)中的11,不影响字段存储的范围，只影响展示效果</p>
<h2 id="为什么-SELECT-COUNT-FROM-table在InnoDB比-MylSAM-慢？"><a href="#为什么-SELECT-COUNT-FROM-table在InnoDB比-MylSAM-慢？" class="headerlink" title="为什么 SELECT COUNT(*)FROM table在InnoDB比 MylSAM 慢？"></a>为什么 SELECT COUNT(*)FROM table在InnoDB比 MylSAM 慢？</h2><p>对于SELECT COUNT(*) FROM table语句，在没有WHERE条件的情况下，InnoDB比MyISAM可能会慢很多，尤其在大表的情况下。因为，InnoDB是去实时统计结果，会全表扫描；而MyISAM内部维持了一个计数器，预存了结果，所以直接返回即可。</p>
<h2 id="InnoDB与MyISAM区别？"><a href="#InnoDB与MyISAM区别？" class="headerlink" title="InnoDB与MyISAM区别？"></a>InnoDB与MyISAM区别？</h2><ul>
<li><p>在MySQL5.1及之前的版本中，MyISAM是默认的存储引擎，而在MySQL5.5版本以后<br>默认使用InnoDB存储引擎。</p>
</li>
<li><p>MyISAM不支持行级锁，换句话说，MyISAM会对整张表加锁，而不是针对行。同时，MyISAM不支持事务和外键。MyISAM可被压缩，存储空间较小，而且MyISAM在筛选大量数据时非常快。</p>
</li>
<li><p>InnoDB是事务型引擎，当事务异常提交时，会被回滚。同时，InnoDB支持行锁。此外，InnoDB需要更多存储空间，会在内存中建立其专用的缓冲池用于高速缓冲数据和索引。<br>InnoDB支持自动崩溃恢复特性。</p>
</li>
</ul>
<p>建议：一般情况下，个人建议优先选择InnoDB存储引擎，并且尽量不要将InnoDB与MyISAM混合使用。</p>
<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>索引列中的值必须是唯一的，不允许有空值。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列中的值必须是唯一的，但是允许为空值。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>只能在文本类型CHAR,VARCHAR,TEXT 类型字段上创建全文索引。字段长度比较大时，如果创建<br>普通索引，在进行like 模糊查询时效率比较低，这时可以创建全文索引。MyISAM 和InnoDB<br>中都可以使用全文索引。</p>
<h3 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h3><p>MySQL 在5.7 之后的版本支持了空间索引，而且支持OpenGIS 几何数据模型。MySQL 在空间索<br>引这方面遵循OpenGIS 几何数据模型规则。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>在文本类型如CHAR,VARCHAR,TEXT 类列上创建索引时，可以指定索引列的长度，但是数值类型<br>不能指定。</p>
<p>其他（按照索引列数量分类）</p>
<ol>
<li>单列索引</li>
<li>组合索引<br>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则） 。一般情况下在条件允许的<br>情况下使用组合索引替代多个单列索引使用。</li>
</ol>
<h3 id="什么时候不要使用索引"><a href="#什么时候不要使用索引" class="headerlink" title="什么时候不要使用索引"></a>什么时候不要使用索引</h3><ol>
<li>经常增删改的列不要建立索引；</li>
<li>有大量重复的列不建立索引；</li>
<li>表记录太少不要建立索引。</li>
</ol>
<h3 id="主键与索引有什么区别？"><a href="#主键与索引有什么区别？" class="headerlink" title="主键与索引有什么区别？"></a>主键与索引有什么区别？</h3><p>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；<br>主键不允许为空值，唯一索引列允许空值；<br>一个表只能有一个主键，但是可以有多个唯一索引；<br>主键可以被<strong>其他表引用为外键，唯一索引</strong>列不可以；<br>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制（MVCC&#x3D;Multi-Version Concurrency Control），是一种用来解决读- 写冲突的无锁并发控制。也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。同时还可以解决脏读、幻读、不可重复读等事务隔离问题，但不能解决更新丢失问题。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理<br>主要是依赖记录中的3 个隐式字段、undo 日志、Read View 来实现的。</p>
<h2 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h2><ol>
<li>共享锁：不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响。</li>
<li>排他锁：一个写操作阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他<br> 用户读取正在写入的资源。</li>
<li>表锁：系统开销最小，会锁定整张表，MyISAM 使用表锁。</li>
<li>行锁：容易出现死锁，发生冲突概率低，并发高，InnoDB 支持行锁（必须有索引才能实现，<br> 否则会自动锁全表，那么就不是行锁了）。</li>
</ol>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定。读取数据时给加锁，其他事务无<br>法修改这些数据。修改删除数据时也要加锁，其他事务无法读取这些数据。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁<br>机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对<br>长事务而言，这样的开销往往无法承受。</p>
<p>乐观锁，大多是基于数据版本（Version）记录机制<br>实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是<br>通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新<br>时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比<br>对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>MySQL 行锁只能加在索引上，如果操作不走索引，就会升级为表锁。因为InnoDB 的行锁 是加在索引上的，如果不走索引，自然就没法使用行锁了，原因是InnoDB 是将primary key index 和相关的行数据共同放在B+ 树的叶节点。InnoDB 一定会有一个primary key ，secondary index 查找的时候，也是通过找到对应的primary ，再找对应的数据行。</p>
<p>当非唯一索引上记录数超过一定数量时，行锁也会升级为表锁。测试发现当非唯一索引相同的内容不少于整个表记录的二分之一时会升级为表锁。因为当非唯一索引相同的内容达到整个记录的二分之一时，索引需要的性能比全文检索还要大，查询语句优化时会选择不走索引，造成索引失效，行锁自然就会升级为表锁。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ol>
<li>设置获取锁的超时时间，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；</li>
<li>设置按照同一顺序访问资源，类似于串行执行；</li>
<li>避免事务中的用户交叉；</li>
<li>保持事务简短并在一个批处理中；</li>
<li>使用低隔离级别；</li>
<li>使用绑定链接。</li>
</ol>
<h2 id="如何做到高可用方案？"><a href="#如何做到高可用方案？" class="headerlink" title="如何做到高可用方案？"></a>如何做到高可用方案？</h2><p>MySQL 高可用，意味着不能一台MySQL 出了问题，就不能访问了。</p>
<ol>
<li>MySQL 高可用：分库分表，通过MyCat 连接多个MySQL</li>
<li>MyCat 也得高可用：Haproxy，连接多个MyCat</li>
<li>Haproxy 也得高可用：通过keepalived 辅助Haproxy</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202406131017905.png"/>

<h2 id="为了应对多请求缓存数据，缓解mysql压力而诞生"><a href="#为了应对多请求缓存数据，缓解mysql压力而诞生" class="headerlink" title="为了应对多请求缓存数据，缓解mysql压力而诞生"></a>为了应对多请求缓存数据，缓解mysql压力而诞生</h2><p>Redis主要数据存在内存中，通过设置超时时间来解决Redis在内存内数据不断膨胀问题<br>当内存压力太大时，通过随机算法删除内容释放空间（随机算法）<br>当超期数据太久于内存中未删除，遇到请求查询超期键值，则会立即删除该数据（被动触发，惰性删除）</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>①noeviction：返回错误，不会删除任何键值<br>②allkeys-lru：使用LRU算法删除最近最少使用的键值<br>③volatile-lru：使用LRU算法从设置了过期时间的键集合中删除最近最少使用的键值<br>④allkeys-random:从所有key随机删除<br>⑤volatile-random：从设置了过期时间的键的集合中随机删除<br>⑥volat计e-ttl：从设置了过期时间的键中删除剩余时间最短的键<br>⑦volatile・lfu：从配置了过期时间的键中删除使用频率最少的键<br>⑧allkeys-lfu:从所有键中删除使用频率最少的键</p>
<h2 id="缓存击穿-缓存雪崩"><a href="#缓存击穿-缓存雪崩" class="headerlink" title="缓存击穿 缓存雪崩"></a>缓存击穿 缓存雪崩</h2><p>mysql被多次申请查询返回空数据从而使得redis无法缓存（缓存穿透&#x2F;缓存击穿）</p>
<p>mysql因为（大量）redis数据丢失或者数据删除导致大量请求涌向mysql导致mysql处理不过来请求（缓存雪崩）<br>解决方法：过期时间均匀分布+热点数据永不过期</p>
<h2 id="持久化-RDB-AOF"><a href="#持久化-RDB-AOF" class="headerlink" title="持久化 RDB AOF"></a>持久化 RDB AOF</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>redis因为出错导致丢失数据（需要通过持久化存储）<br>RDB：将全部遍历写入二进制连续文件 rdb (周期性备份)<br>为了防止大量重复备份，redis提供了save配置参数解决问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 #900秒 内有一个写入即备份（由子进程进行）</span><br></pre></td></tr></table></figure>

<p>RDB数据不一致问题:因为数据库都是分钟级的，这种周期性备份还是容易丢数据</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久化:类似mysql的binlog，将写入操作记录下来，保存操作的数据会先写入缓冲区AOF_BUF (会存放SET SAOO RPUSH等)</p>
<p>AOF重写，为了防止AOF缓存数据过大问题：指令合并（子进程进行）</p>
<p>但是子进程进行会导致AOF重写数据不一致。所以需要将指令存放AOF_REWRITE_BUF缓冲区，将重写进程启动后的命令写入缓冲区，运行完毕回写进去</p>
<h3 id="主从节点"><a href="#主从节点" class="headerlink" title="主从节点"></a>主从节点</h3><p>为了防止Redis多次崩溃<br>主从：主节点主要负责写入数据，从节点主要负责读数据，做好数据同步，读写分离 提高性能。主节点崩了从节点就顶上（高可用集群）</p>
<ul>
<li>数据同步：若主节点生成的RDB文件同步期间又收到修改命令也会一并发给从节点</li>
<li>命令传播：若主节点有数据写入、删除、修改命令也会挨个发给从节点</li>
<li>版本控制：主节点发给从节点的数据会发送一份给缓存区，若从节点掉线了，从缓冲区的偏移量起发送同步数据</li>
</ul>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>哨兵：专门有几个节点负责当管理员，不负责写入，当节点掉线时，由哨兵选择一个从节点顶上主节点<br>    每隔10s哨兵都需要发送info命令问候主节点情况（有多少从节点）<br>    每隔1s ping命令问候全部节点，若出现节点掉线则启动故障转移。这时发现的哨兵认定主观下线，会问候其他哨兵，当少服从多数认为下线，则认定客观下线。具体需要多少个哨兵认定，可以自己定义。<br>    故障转移：选个新的主节点，让其他从节点从新主节点那同步数据，再把原来的主节点改为从节点<br>    新主节点选择标准：给不同节点设置优先级，配置高的的优先级越高，与断开节点链接越短的，复制偏移越高的。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>为了防止数据量过大（由于之前全都全量复制）</p>
<p>集群：合并大服务器</p>
<p>新节点加入问题：新节点加入必须由集群内某一节点发送MEET请求后，新节点回应PONG请求，再由集群内节点发送PING请求（类似TCP三次握手）</p>
<p>数据分配：数据量公平问题：划分16384个哈希桶（槽位Slot）由程序员分配每个集群节点负责的槽位量。数据读写时对数据进行哈希运算，存入对应到槽位。每次计算存入节点会通知集群内所有节点。使用二进制通知，负责的槽位为1，共2048字节。（这样会导致存入数据需要遍历查看存入数据需要是哪个redis节点负责。）由此 新建一个大数组来存储每个槽位由哪个节点负责。（数据索引）</p>
<p>需要每个槽位都有节点负责，集群才能正确上线。</p>
<p>数据读写时候，集群节点会先检查数据是否由自己负责，否则会发送MOVED错误给请求端，使其去寻找正确节点（发送槽号，IP，端口）自动运行，无须调用</p>
<p>为了防止节点掉线，从节点会充当集群内节点的Backup</p>
<h2 id="Redis实现消息队列"><a href="#Redis实现消息队列" class="headerlink" title="Redis实现消息队列"></a>Redis实现消息队列</h2><p>一般使用list结构作为队列，rpush生产消息，1pop消费消息。当1pop没有消息的时候，要适当<br>sleep一会再重试。</p>
<ul>
<li>面试官可能会问可不可以不用sleep呢？list还有个指令吸pop,在没有消息的时候，它会<br>阻塞住直到消息到来。</li>
<li>面试官可能还问能不能生产一次消费多次呢？使用pub&#x2F;sub主题订阅者模式，可以实现<br>1:N的消息队列。</li>
<li>面试官可能还问pub&#x2F;sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使<br>用专业的消息队列如rabbit MQ等</li>
<li>Redis 如何实现延时队列：使用SortedSet 拿时间戳做Score</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">JAVA面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-15 01:18:56" itemprop="dateModified" datetime="2024-05-15T01:18:56+08:00">2024-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p><strong>面向过程：</strong>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象：</strong>是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1.int 是基本数据类型，Integer 是 int 的封装类，是引用类型。int 默认值是 0，而 Integer 默认值 是 null，所以 Integer 能区分出 0 和 null 的情况。一旦 java 看到 null，就知道这个引用 还没有指向某个 对象，在任何引用使用前，必须为其指定一个对象，否则会报错。 </p>
<p>2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给 另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看得见。</p>
<p>虽然定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值。</p>
<p>在编译之后 都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是1 个字节。使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这 里不是指的 是 32&#x2F;64 位系统，而是指 CPU 硬件层面），具有高效存取的特点</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof需要非基本类 i 必须是引用类型，不能是基本类</p>
<p>注意：编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错，如果 不能 确定类型，则通过编译，具体看运行时定</p>
<p>在 JavaSE 规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将 返 回 false。</p>
<h2 id="Java自动装箱和拆箱"><a href="#Java自动装箱和拆箱" class="headerlink" title="Java自动装箱和拆箱"></a>Java自动装箱和拆箱</h2><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;integer ）；调用方法：valueOf(int) 的方法 </p>
<p>拆箱就是自动将包装器类型转换为基本数据类型（integer–&gt;int ）。调用方法：intValue 的方法</p>
<p>在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之 间， </p>
<p>便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p>
<p>在某个范围内的整形数值的个数是有限的，而浮点数却不是。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重 写 （Override）从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。 子 类继承了父类原有的方法，但有时子类并不想原封不动地继承父类中的某个方法，所以在方法 名， 参数列表，返回类型（除过子类中方法的返回值是父类中方法返回值的子类时）</p>
<p>都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<ol>
<li>发生在父类与子类之间 </li>
<li>方法名，参数列表，返回类型（除过子类中方法的返回类 型 是父类中返回类型的子类）必须相同 </li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符 (public&gt;protected&gt;default&gt;private) </li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法 申 明更加宽泛的检查性异常</li>
</ol>
<p>重载 （Overload ） 在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>
<ol>
<li>重载 Overload 是一个类中多态性的一种表现 </li>
<li>重载要求同名方法的参数列表不同 （参数类型，参数个数甚至是参数顺序） </li>
<li>重载的时候，返回值类型可以相同也可以不相同。 无法返回 型别作为重载函数的区分标准</li>
</ol>
<h2 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals 与 &#x3D;&#x3D;"></a>equals 与 &#x3D;&#x3D;</h2><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即 否实指相同一个对象。比较的是真正意义上的指针操作。 </p>
<ol>
<li>比较的是操作符两端的操作数是否是同一个对象。 </li>
<li>两边的操作数必须是同一类型的（可以 是 父子类之间）才能编译通过。 </li>
<li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则 为 true，如： int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0 都是相同的（为 true），因为他们都指 向地 址为 10 的堆。</li>
</ol>
<p>equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的， 所 以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是&#x3D;&#x3D;的判断。 </p>
<p>总结： 所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的 equals object 可能为 null 则空指针</p>
<p>在阿里的代码规范中只使用 equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“&#x3D;&#x3D;” ，替换成 equals</p>
<h2 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h2><p>Java 的集合有两类，一类是 List，还有一类是 Set。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多， 用这样 的方法就会比较</p>
<p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域， 每 个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对 象的 哈希码就可以确定该对象应该存储的哪个区域</p>
<p>hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当 集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物 理 位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较 了；如 果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其他的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只 需要一两次。</p>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String 是只读字符串，它并不是基本数据类型、而是一个对象。从底层源码来看是一个final 类型 的 字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。<strong>每次对 String 的操作都 会生成 新的 String 对象</strong></p>
<p>隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append方法 <strong>拼接</strong>+后面的字符。</p>
<p>StringBuffer 和 StringBuilder 他们俩都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到</p>
<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和 StringBuilder 来进行操作。 </p>
<p> StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁， 所以来是线程安全的。</p>
<p> StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h2 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h2><p>Array(数组)是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 </p>
<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据，（因为删除数据以后，需要把后面所有的数据前移）</p>
<p>缺点：数组初始化必须指定初始化的长度，否则报错</p>
<p>List一是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</p>
<p>List有两个重要的实现类：ArrayList和LinkedList</p>
<ul>
<li><p>ArrayList:可以看作是能够<strong>自动增长容量</strong>的数组</p>
</li>
<li><p>ArrayList的toArray方法返回一个数组</p>
</li>
<li><p>ArrayList的asList方法返回一个列表</p>
</li>
<li><p>ArrayList底层的实现是Array,数组扩容实现</p>
</li>
<li><p>ArrayList Clone() 是浅复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</span><br><span class="line">缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</span><br><span class="line">高并发的情况下，线程不安全。多个线程同时操作ArrayList ，会引发不可预知的异常或错误。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>LinkList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList.当然，这些对比都是指数据量很大或者操作很频繁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开拓内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</span><br><span class="line">缺点：因为LinkedList 要移动指针，所以查询操作性能比较低。</span><br></pre></td></tr></table></figure>



<p>当需要对数据进行随机访问的时候，选用ArrayList。<br>当需要对数据进行多次增加删除修改时，采用LinkedList。<br>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用ArrayList。<br>当然，绝大多数业务的场景下，使用ArrayList 就够了，但需要注意避免ArrayList 的扩容，以及非顺序的插入。</p>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>1、两者父类不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了</span><br><span class="line">同时实现了map、Cloneable(可复制）、Serializable(可序列化）这三个接口。</span><br></pre></td></tr></table></figure>

<p>2、对外提供的接口不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable比HashMap多提供了elments()和contains()两个方法。elments()方法</span><br><span class="line">继承自Hashtable的父类Dictionnary。elements()方法用于返回此Hashtable中的</span><br><span class="line">value的枚举。</span><br><span class="line">contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致</span><br><span class="line">事实上，contansValue()就只是调用了一下contains()方法。</span><br></pre></td></tr></table></figure>

<p>3、对null的支持不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:key和value都不能为null。</span><br><span class="line">HashMap:key可以为null,但是这样的key只能有一个，因为必须保证key的唯一性；可以有</span><br><span class="line">多个key值对应的value为null</span><br></pre></td></tr></table></figure>

<p>4、安全性不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员</span><br><span class="line">自已处理多线程的安全问题。</span><br><span class="line"></span><br><span class="line">Hashtable是线程安全的，它的每个方法上都有synchronized关键字，因此可直接用于多线程中。</span><br><span class="line"></span><br><span class="line">虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为</span><br><span class="line">大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap.</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因</span><br><span class="line">为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</span><br></pre></td></tr></table></figure>

<p>5、初始容量大小和每次扩充容量大小不同 、</p>
<p>6、计算hash值的方法不</p>
<h2 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h2><p>Collection 是集合类的上级接口，子接口有 Set、 List、LinkedList、ArrayList、Vector、Stack、 Set； Collections 是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各 种 集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
<h2 id="JAVA的四种引用（强弱软虚）"><a href="#JAVA的四种引用（强弱软虚）" class="headerlink" title="JAVA的四种引用（强弱软虚）"></a>JAVA的四种引用（强弱软虚）</h2><ul>
<li><p>强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用 弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<p>可用场景： Java 源码中的中的就是使用弱引用，一旦我不需要某个引用，JVM 会自动帮我处理它，这样我就不需要做其他操作。</p>
</li>
<li><p>软引用 软引用在程序内存不足时，会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf 这个引用也是强引用，它是指向 SoftReference 这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向 new String(&quot;str&quot;）的引用，也就是 SoftReference 类中 T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用</p>
<p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入<strong>ReferenceQueue中</strong>。</p>
<p>注意哦，其他引用是被JVM 回收后才被传入中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有<br>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;())</span><br></pre></td></tr></table></figure>

<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做<br>这类动作，但是这个方式既不安全又低效</p>
</li>
</ul>
<p>上述所说的几类引用，都是指对象本身的引用，而不是指Reference 的四个子类的引用(SoftReference 等）。</p>
<h2 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h2><p>“泛型” ，顾名思义， “泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="JAVA创建对象有几种方式"><a href="#JAVA创建对象有几种方式" class="headerlink" title="JAVA创建对象有几种方式"></a>JAVA创建对象有几种方式</h2><p>java中提供了以下四种创建对象的方式：</p>
<ul>
<li><p>new创建新对象</p>
</li>
<li><p>通过反射机制</p>
</li>
<li><p>采用clone机制</p>
</li>
<li><p>通过序列化机制</p>
<p>调用ObjectInputStream 类的readObject() 方法。<br>反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对象。</p>
</li>
</ul>
<h2 id="可能两个不相等的对象有相同的hashcode"><a href="#可能两个不相等的对象有相同的hashcode" class="headerlink" title="可能两个不相等的对象有相同的hashcode"></a>可能两个不相等的对象有相同的hashcode</h2><p>有可能.在产生hash 冲突时，两个不相等的对象就会有相同的hashcode 值.当hash 冲突产生时，一般有以下几种方式来处理：</p>
<ul>
<li><p>拉链法：每个哈希表节点都有一个next 指针，多个哈希表节点可以用next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>
</li>
<li><p>再哈希：又叫双哈希法，有多个不同的Hash 函数.当发生冲突时，使用第二个，第三个….等哈希函数计算地址，直到无冲突.</p>
</li>
</ul>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><ul>
<li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象.换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象.</li>
<li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>被final 修饰的类不可以被继承</li>
<li>被final 修饰的方法不可以被重写</li>
<li>被final 修饰的变量不可以被改变.如果修饰引用，那么表示引用不可变，引用指向的内<br>容可变.</li>
<li>被final 修饰的方法，JVM 会尝试将其内联，以提高运行效率</li>
<li>被final 修饰的常量，在编译阶段会存入常量池</li>
</ul>
<p>编译器对final 域要遵守的两个重排序规则更好：</p>
<p>在构造函数内对一个final 域的写入,随后把这个被构造对象的引用赋值给一个引用变量</p>
<p>这两个操作之间不能重排序初次读一个包含final 域的对象的引用，与随后初次读这个final 域</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态变量和静态方法.也就是被static 所修饰的变量&#x2F; 方法都属于类的静态资源，</p>
<p>类实例所共享除了静态变量和静态方法之外，static 也用于静态块，多用于初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//执行相关操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外static 也多用于修饰内部类，此时称之为静态内部类.最后一种用法就是静态导包，即import static .import static 是在JDK 1.5 之后引入的新特性，<br>可以用来指定导入某个类中的静态资源，并且不需要使用类名，可以直接使用资源名，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//System.out.println(Math.sin(20))；传统做法</span></span><br><span class="line">System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="a-x3D-a-b-与-a-x3D-b"><a href="#a-x3D-a-b-与-a-x3D-b" class="headerlink" title="a&#x3D;a+b 与 a+&#x3D;b"></a>a&#x3D;a+b 与 a+&#x3D;b</h2><p>+&#x3D;操作符会进行隐式自动类型转换，此处a+&#x3D;b 隐式的将加操作的结果类型强制转换为持有结果<br>的类型，而a&#x3D;a+b 则不会自动进行类型转换.如：</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><strong>finally 的执行早于try 里面的return</strong></p>
<ol>
<li>不管有没有出现异常，finally 块中代码都会执行；</li>
<li>当try 和catch 中有return 时，finally 仍然会执行；</li>
<li>finally 是在return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally 执行前确定的；</li>
<li>finally 中最好不要包含return，否则程序会提前退出，返回值不是try 或catch 中保存的返回值。</li>
</ol>
<h2 id="Exception-与-Error-包结构"><a href="#Exception-与-Error-包结构" class="headerlink" title="Exception 与 Error 包结构"></a>Exception 与 Error 包结构</h2><p>Java 可抛出（Throwable）的结构分为三种类型：被检查的异常（CheckedException)，运行<br>时异常(RuntimeException)，错误（Error)。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>RuntimeException 及其子类都被称为运行时异常</p>
<p>常见的五种运行时异常：</p>
<ul>
<li>ClassCastException（类转换异常）</li>
<li>IndexOutOfBoundsException（数组越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArrayStoreException（数据存储异常，操作数组类型不一致）</li>
<li>BufferOverflowException</li>
</ul>
<h3 id="被检查异常"><a href="#被检查异常" class="headerlink" title="被检查异常"></a>被检查异常</h3><p>Exception 类本身，以及Exception 的子类中除了”运行时异常”之外的其他子类都属于被检查异常。</p>
<p>此类异常，要么通过throws 进行声明抛出，要么通过try-catch 进行捕获处理，否则不能通过编译。</p>
<p>例如 ：clone(）接口去克隆一个对象，而该对象对应的类没有实现Cloneable 接口，就会抛出<br>CloneNotSupportedException 异常。被检查异常通常都是可以恢复的。如：</p>
<ul>
<li>IOException</li>
<li>FileNotFoundException</li>
<li>SQLException</li>
</ul>
<p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的<br>FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对<br>象引用时没有确保对象非空而引起的NullPointerException 。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>定义: Error 类及其子类。</p>
<p>特点: 和运行时异常一样，编译器也不会对错误进行检查。</p>
<p>当资源不足、约束失败，或是或是其他程序无法继续运行的条件发生时，就产生错误。程序本身<br>无法修复这些错误的。例如，VirtualMachineError 就属于错误。出现这种错误会导致程序终止<br>运行。</p>
<p>OutOfMemoryError、ThreadDeath。</p>
<p>Java 虚拟机规范规定JVM 的内存分为好几块，比如堆，栈，程序计数器，方法区等</p>
<h2 id="OOM、SOF"><a href="#OOM、SOF" class="headerlink" title="OOM、SOF"></a>OOM、SOF</h2><p>OutOfMemoryError 异常</p>
<ul>
<li>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM）异常的可能。</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>运行时常量池溢出</li>
<li>方法区溢出</li>
</ul>
<p>SOF堆栈溢出 StackOverflow：</p>
<p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p>
<h2 id="线程、进程、程序"><a href="#线程、进程、程序" class="headerlink" title="线程、进程、程序"></a>线程、进程、程序</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h2 id="JAVA序列化中如果有写字段不想进行序列化"><a href="#JAVA序列化中如果有写字段不想进行序列化" class="headerlink" title="JAVA序列化中如果有写字段不想进行序列化"></a>JAVA序列化中如果有写字段不想进行序列化</h2><p>对于不想进行序列化的变量，使用transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化<br>时，被transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和<br>方法。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h3><p>NIO 即New IO，这个库是在JDK1.4 中才引入的。NIO 和IO 有相同的作用和目的，但实现方式不<br>同， NIO 主要用到的是块，所以NIO 的效率要比IO 高很多。在Java API 中提供了两套NIO ，一<br>套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h2 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h2><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象， 都能够调用它的任意一个方法。在java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。<br>动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的反射机制。(jdbc 就是典型的反射)</p>
<h3 id="反射的实现方式："><a href="#反射的实现方式：" class="headerlink" title="反射的实现方式："></a>反射的实现方式：</h3><p>第一步：获取Class 对象，有4 种方法：</p>
<ol>
<li><p>Class.forName(“类的路径”）</p>
</li>
<li><p>类名.class </p>
</li>
<li><p>对象名.getClass() </p>
</li>
<li><p>基本类型的包装类，可以调用包装类的Type 属性来获得该包装类的Class<br>对象</p>
</li>
<li><p>Class：表示正在运行的Java 应用程序中的类和接口注意： 所有获取对象的信息都需要Class类来实现。</p>
</li>
<li><p>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
</li>
<li><p>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限</p>
</li>
<li><p>Method：提供类或接口中某个方法的信息</p>
</li>
</ol>
<p>优点： </p>
<ul>
<li>能够运行时动态获取类的实例，提高灵活性； </li>
<li>与动态编译结合</li>
</ul>
<p>缺点： </p>
<ul>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</li>
</ul>
<p>解决方案： </p>
<ul>
<li>通过setAccessible(true)关闭JDK 的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多</li>
<li>ReflectASM 工具类，通过字节码生成的方式加快反射速度,相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li>
</ul>
<h2 id="List，Set，Map"><a href="#List，Set，Map" class="headerlink" title="List，Set，Map"></a>List，Set，Map</h2><p><strong>List（对付顺序的好帮手）：</strong> List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p>
<p><strong>Set（注重独一无二的性质）：</strong>不允许重复的集合。不会有多个元素引用相同的对象。</p>
<p><strong>Map（用来搜索的专家）：</strong> 使用键值对存储。Map 会维护与Key 有关联的值。两个Key 可以引用相同的对象，但Key 不能重复，典型的Key 是String 类型，但也可以是任何对象。</p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast 机制是Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：当某一个线程A 通过iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程A 访问集合时，就会抛出ConcurrentModificationException 异常，产生fail-fast 事件。这里的操作主要是指add、remove 和clear ，对集合元素个数进行修改。</span><br></pre></td></tr></table></figure>



<p>解决办法：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<p>可以这么理解：在遍历之前，把modCount 记下来expectModCount，后面expectModCount去和modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出ConcurrentModificationException 异常。</p>
<h2 id="Hashtable-与-HashMap"><a href="#Hashtable-与-HashMap" class="headerlink" title="Hashtable 与 HashMap"></a>Hashtable 与 HashMap</h2><ol>
<li>都实现了Map、Cloneable、Serializable</li>
<li>HashMap 继承的是AbstractMap，并且AbstractMap 也实现了Map 接口。Hashtable 继承Dictionary。</li>
<li>Hashtable 中大部分public 修饰普通方法都是synchronized 字段修饰的，是线程安全的， HashMap 是非线程安全的。</li>
<li>Hashtable 的key 不能为null ，value 也不能为null，这个可以从Hashtable 源码中的put方法看到，判断如果value 为null 就直接抛出空指针异常</li>
<li>HashMap 的key 和value 都可以为null。在计算hash 值的时候，有判断，如果key&#x3D;&#x3D;null ，则其hash&#x3D;0 ；至于value 是否为null ，根本没有判断过。</li>
<li>Hashtable 直接使用对象的hash 值。hash 值是JDK 根据对象的地址或者字符串或者数字算出来的int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li>
<li>默认情况下，初始容量不同，Hashtable 的初始长度是11，之后每次扩充容量变为之前的2n+1（ n 为上一次的长度）<strong>而HashMap 的初始长度为16</strong> ，之后每次扩充变为原来的两倍。</li>
</ol>
<p>Hashtable 是线程安全，推荐使用HashMap 代替Hashtable；如果需要线程安全<br>高并发的话，推荐使用ConcurrentHashMap 代替Hashtable。这个回答完了，面试官可能会继续问：HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p>
<h3 id="HashMap-中的-key-可以用任何类吗"><a href="#HashMap-中的-key-可以用任何类吗" class="headerlink" title="HashMap 中的 key 可以用任何类吗"></a>HashMap 中的 key 可以用任何类吗</h3><p>平时可能大家使用得最多的就是使用String 作为HashMap 的key，但是现在我们想使用某个自定义类作为HashMap 的key，那就需要注意以下几点：</p>
<ul>
<li>如果类重写了equals 方法，它也应该重写hashCode 方法。</li>
<li>类的所有实例需要遵循与equals 和hashCode 相关的规则。</li>
<li>如果一个类没有使用equals，你不应该在hashCode 中使用它。</li>
<li>咱们自定义key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode 和equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h3 id="HashMap的长度为什么是2-n次方"><a href="#HashMap的长度为什么是2-n次方" class="headerlink" title="HashMap的长度为什么是2^n次方"></a>HashMap的长度为什么是2^n次方</h3><p>为了能让HashMap 存数据和取数据的效率高，尽可能地减少hash 值的碰撞，也就是说尽量把数据能均匀地分配，每个链表或者红黑树长度尽量相等。</p>
<p>我们首先可能会想到% 取模的操作来实现。</p>
<p>下面是回答的重点哟：</p>
<blockquote>
<p>取余（%）操作中如果除数是2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说hash % length &#x3D;&#x3D; hash &amp;(length - 1) 的前提是length 是2 的n 次方）。并且，采用二进制位操作&amp; ，相对于% 能够提高运算效率。<br>这就是为什么HashMap 的长度需要2 的N 次方了。</p>
</blockquote>
<h3 id="HashMap的数组的元素类型"><a href="#HashMap的数组的元素类型" class="headerlink" title="HashMap的数组的元素类型"></a>HashMap的数组的元素类型</h3><blockquote>
<p>java.util.Map$Entry。JDK1.7的HashMap中有内部类Entry实现Entry接口</p>
<p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口，并且TreeNode是Node的子类。</p>
</blockquote>
<h3 id="HashMap的映射关系的存储索引index如何计算"><a href="#HashMap的映射关系的存储索引index如何计算" class="headerlink" title="HashMap的映射关系的存储索引index如何计算"></a>HashMap的映射关系的存储索引index如何计算</h3><p>hash &amp; table.length-1</p>
<h3 id="为什么数组还需要链表？或问如何解决hash或-index-冲突问题？"><a href="#为什么数组还需要链表？或问如何解决hash或-index-冲突问题？" class="headerlink" title="为什么数组还需要链表？或问如何解决hash或[index]冲突问题？"></a>为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</h3><blockquote>
<p>答：为了解决hash和[index]冲突问题</p>
<p>（1）两个不相同的key的hashCode值本身可能相同</p>
<p>（2）两个不相同的key的hashCode值不同，但是经过hash()运算，结果相同</p>
<p>（3）两个hashCode不相同的key，经过hash()运算，结果也不相同，但是通过 hash &amp; table.length-1运算得到的[index]可能相同</p>
<p>那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p>
</blockquote>
<h3 id="HashMap的数组什么时候扩容？"><a href="#HashMap的数组什么时候扩容？" class="headerlink" title="HashMap的数组什么时候扩容？"></a>HashMap的数组什么时候扩容？</h3><blockquote>
<p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!&#x3D;null时，两个条件同时满足会扩容</p>
<p>JDK1.8版：当要添加新Entry对象时发现</p>
<p>（1）size达到threshold</p>
<p>（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容 ， **达到64会进行树化 **因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p>
<p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p>
</blockquote>
<h2 id="HashMap-与-ConcurrentHashMap-的异同"><a href="#HashMap-与-ConcurrentHashMap-的异同" class="headerlink" title="HashMap 与 ConcurrentHashMap 的异同"></a>HashMap 与 ConcurrentHashMap 的异同</h2><ol>
<li><p>都是key-value 形式的存储数据；</p>
</li>
<li><p>HashMap 是线程不安全的，ConcurrentHashMap 是JUC 下的线程安全的；</p>
</li>
<li><p>HashMap 底层数据结构是数组+ 链表（JDK 1.8 之前）。JDK 1.8 之后是数组+ 链表+ 红黑树。当链表中元素个数达到8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</p>
</li>
<li><p>HashMap 初始数组大小为16（默认），当出现扩容的时候，以0.75 *数组大小的方式进行扩容；</p>
</li>
<li><p>ConcurrentHashMap 在JDK 1.8 之前是采用分段锁来实现的Segment + HashEntry ，Segment 数组大小默认是16 ，2 的n 次方；JDK 1.8 之后，采用Node + CAS +Synchronized 来保证并发安全进行实现</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png"/>

<h1 id="JAVA多线程与并发"><a href="#JAVA多线程与并发" class="headerlink" title="JAVA多线程与并发"></a>JAVA多线程与并发</h1><p>创建线程的常用三种方式：</p>
<ol>
<li>继承Thread 类</li>
<li>实现Runnable 接口</li>
<li>实现Callable 接口（ JDK1.5&gt;&#x3D;）</li>
<li>线程池方式创建</li>
</ol>
<p>通过继承Thread 类或者实现Runnable 接口、Callable 接口都可以实现多线程，不过实现Runnable接口与实现Callable 接口的方式基本相同，只是Callable 接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable 接口和实现Callable 接口归为一种方式。这种方式与继承Thread 方式之间的主要差别如下。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="Runnable-和Callable-接口优缺点"><a href="#Runnable-和Callable-接口优缺点" class="headerlink" title="Runnable 和Callable 接口优缺点"></a>Runnable 和Callable 接口优缺点</h3><p>优点：</p>
<ul>
<li>线程类只是实现了Runnable 或者Callable 接口，还可以继承其他类。这种方式下，多个线程</li>
<li>可以共享一个target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
<p>缺点：编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread() 方法</p>
<h3 id="Thread接口"><a href="#Thread接口" class="headerlink" title="Thread接口"></a>Thread接口</h3><p>优点：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread() 方法，直接使用this 即可获取当前线程<br>缺点：因为线程类已经继承了Thread 类，Java 语言是单继承的，所以就不能再继承其他父类了。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ol>
<li><p>使用退出标志，使线程正常退出，也就是当run 方法完成后线程终止。</p>
</li>
<li><p>使用stop 方法强行终止，但是不推荐这个方法，因为stop 和suspend 及resume 一样都是过期作废的方法。</p>
</li>
<li><p>使用interrupt 方法中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1.stop = <span class="literal">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h3><p><code>notify()</code> 方法用于唤醒在某个对象监视器上等待的单个线程。如果多个线程在等待，任何一个线程被唤醒是完全不确定的。如果需要唤醒所有等待的线程，可以使用 <code>notifyAll()</code> 方法。</p>
<ul>
<li>notify 可能会导致死锁，而notifyAll 则不会</li>
<li>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码使用notifyall，可以唤醒所有处于wait 状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li>
<li>wait() 应配合while 循环使用，不应使用if，务必在wait(）调用前后都检查条件，如果不满足，必须调用notify(）唤醒另外的线程来处理，自己继续wait(）直至条件满足再往下执行。</li>
<li>notify() 是对notifyAll(）的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是WaitSet 中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify(）下一个线程，并且自身需要重新回到WaitSet 中.</li>
</ul>
<h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h3><p>对于sleep(）方法，我们首先要知道该方法是属于Thread 类中的。而wait(）方法，则是属于Object 类中的。</p>
<p>sleep(）方法导致了程序暂停执行指定的时间，让出cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep(）方法的过程中，线程不会释放对象锁。</p>
<p>当调用wait(）方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用</p>
<p>notify(）方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</p>
<h2 id="volatile-可以保证有序性"><a href="#volatile-可以保证有序性" class="headerlink" title="volatile 可以保证有序性"></a>volatile 可以保证有序性</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile 修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，volatile 关键字会强制将修改的值立即写入主存。</p>
<p>2）禁止进行指令重排序。volatile 不是原子性操作</p>
<p><strong>保证部分有序性：</strong>当程序执行到volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p><code>由于flag 变量为volatile 变量，那么在进行指令重排序的过程的时候，不会修改其在代码中的位置，但其他的非volatile变量就无法保证其位置是否会变动</code></p>
<p>使用volatile 一般用于状态标记量和单例模式的双检锁</p>
<h3 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h3><ul>
<li>volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法和类级别的。</li>
<li>volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<h2 id="Thread类中的-start-和-run-区别"><a href="#Thread类中的-start-和-run-区别" class="headerlink" title="Thread类中的 start() 和 run() 区别"></a>Thread类中的 start() 和 run() 区别</h2><p>start(）方法被用来启动新创建的线程，而且start(）内部调用了run(）方法，</p>
<p>当你调用run(）方法的时候，只会是在原来的线程中调用，没有新的线程启动，start() 方法才会启动新线程。</p>
<h2 id="为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait,notify和notifyAll这些方法不在thread类里面？"></a>为什么wait,notify和notifyAll这些方法不在thread类里面？</h2><p>明显的原因是JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。</p>
<p>如果wait(）方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。</p>
<p>简单地说，由于wait ，notify 和notifyAll 都是锁级别的操作，所以把他们定义在Object 类中因为锁属于对象。</p>
<h2 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h2><ol>
<li>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify(）和notifyAll(）方法。</li>
<li>如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免wait 和notify 之间产生竞态条件。</li>
</ol>
<p>wait(）方法强制当前线程释放对象锁。这意味着在调用某对象的wait(）方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait(）方法。</p>
<p>在调用对象的notify(）和notifyAll(）方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify(）或notifyAll(）方法。</p>
<p>调用wait(）方法的原因通常是，调用线程希望某个特殊的状态（或变量）被设置之后再继续执行。调用notify(）或notifyAll(）方法的原因通常是，调用线程希望告诉其他等待中的线程：”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态（或变量）。</p>
<h2 id="Java-中-interrupted-和-islnterrupted方法的区别？"><a href="#Java-中-interrupted-和-islnterrupted方法的区别？" class="headerlink" title="Java 中 interrupted 和 islnterrupted方法的区别？"></a>Java 中 interrupted 和 islnterrupted方法的区别？</h2><p>interrupted() 和isInterrupted(）的主要区别是前者会将中断状态清除而后者不会。</p>
<p>Java 多线程的中断机制是用内部标识来实现的，调用Thread.interrupt(）来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted(）来检查中断状态时，中断状态会被清零。</p>
<p>而非静态方式法isInterrupted(）用来查询其他线程的中断状态且不会改变中断状态标识。</p>
<p>简单地说就是任何抛出InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有可能被其他线程调用中断来改变。</p>
<h2 id="Java中synchronized和ReentrantLock有什么不同？"><a href="#Java中synchronized和ReentrantLock有什么不同？" class="headerlink" title="Java中synchronized和ReentrantLock有什么不同？"></a>Java中synchronized和ReentrantLock有什么不同？</h2><p>相似点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，</span><br><span class="line">也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等，而进行线程阻塞和唤醒的代价是比较高的.</span><br></pre></td></tr></table></figure>



<p>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两种方式最大区别就是对于Synchronized 来说，它是java 语言的关键字，是原生语法层面的互斥，需要jvm 实现。</span><br><span class="line"></span><br><span class="line">而ReentrantLock 它是JDK 1.5 之后提供的API 层面的互斥锁，需要lock(）和unlock(）方法配合try/finally 语句块来完成。</span><br></pre></td></tr></table></figure>



<p>Synchronized 进过编译，会在同步块的前后分别形成monitorenter 和monitorexit 这两个字节码指令。在执行monitorenter 指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应地，在执行monitorexit 指令时会将锁计算器就减1，当计算器为0 时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<p>由于ReentrantLock 是java.util.concurrent 包下提供的一套互斥锁，相比<br>Synchronized ， ReentrantLock 类提供了一些高级功能，主要有以下3 项：</p>
<ol>
<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized 来说可以避免出现死锁的情况。</li>
<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized 锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true 设为公平锁，但公平锁表现的性能不是很好。</li>
<li>锁绑定多个条件，一个ReentrantLock 对象可以同时绑定多个对象。</li>
</ol>
<h2 id="保证线程的顺序执行"><a href="#保证线程的顺序执行" class="headerlink" title="保证线程的顺序执行"></a>保证线程的顺序执行</h2><p>可以用线程类的join(）方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>实际上先启动三个线程中哪一个都行， 因为在每个线程的run 方法中用join 方法限定了三个线程的执行顺序。</p>
<h2 id="SynchronizedMap和-ConcurrentHashMap有什么区别？"><a href="#SynchronizedMap和-ConcurrentHashMap有什么区别？" class="headerlink" title="SynchronizedMap和 ConcurrentHashMap有什么区别？"></a>SynchronizedMap和 ConcurrentHashMap有什么区别？</h2><p>SynchronizedMap(）和Hashtable 一样，实现上在调用map 所有方法时，都对整个map 进行同步。</p>
<p>而ConcurrentHashMap 的实现却更加精细，它对map 中的<strong>所有桶加了锁</strong>。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map 执行某些操作。</p>
<p>所以，ConcurrentHashMap 在性能以及安全性方面，明显比Collections.synchronizedMap(）更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map 时，如果其他线程试图对map 进行数据修改，也不会抛出ConcurrentModificationException。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。<br>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释得最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p>
<p>这个问题有值得一提的地方，就是远程安全也是有几个级别的：</p>
<p>（ 1）不可变<br>像String、Integer、Long 这些，都是final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<p>（ 2）绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>
<p>（ 3）相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector ，99%的情况下都会出现ConcurrentModificationException，也就是机制。</p>
<p>（ 4）线程非安全<br>ArrayList、LinkedList、HashMap 等都是线程非安全的类</p>
<h3 id="保证几个基本特征"><a href="#保证几个基本特征" class="headerlink" title="保证几个基本特征"></a>保证几个基本特征</h3><ul>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h2 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h2><p>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU 占用而不能保证使其他线程一定能占用CPU，执行yield(）的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="Java线程池中submit-和execute-方法有什么区别？"><a href="#Java线程池中submit-和execute-方法有什么区别？" class="headerlink" title="Java线程池中submit()和execute()方法有什么区别？"></a>Java线程池中submit()和execute()方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，</p>
<p> execute(）方法的返回类型是void，它定义在Executor 接口中， </p>
<p>而submit(）方法可以返回持有计算结果的Future 对象，它定义在ExecutorService 接口中，它扩展了Executor 接口，其它线程池类像ThreadPoolExecutor 和ScheduledThreadPoolExecutor 都有这些方法。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<blockquote>
<p>在Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。</p>
</blockquote>
<p>Java 6 之后synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p><strong>修饰实例方法： 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁修饰静态方法：</strong></p>
<p>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new 了多少个对象，只有一份）。所以如果一个线程A 调用一个实例对象的非静态synchronized 方法，而线程B 需要调用这个实例对象所属类的静态synchronized 方法，是允许的，不会发生互斥现象，</p>
<p>因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态方法占用的锁是当前实例对象锁。</p>
<p><strong>修饰代码块：</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<p><strong>总结：</strong>synchronized 关键字加到static 静态方法和synchronized(class）代码块上都是给Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a) 因为JVM 中，字符串常量池具有缓存功能！</p>
<h2 id="Vector是一个线程安全类"><a href="#Vector是一个线程安全类" class="headerlink" title="Vector是一个线程安全类"></a>Vector是一个线程安全类</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。</p>
<p>Vector 是用同步方法来实现线程安全的， 而和它相似的ArrayList 不是线程安全的。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li>最大线程数maximumPoolSize</li>
<li>核心线程数corePoolSize</li>
<li>活跃时间keepAliveTime</li>
<li>阻塞队列workQueue</li>
<li>拒绝策略RejectedExecutionHandler</li>
</ol>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="线程池的理解"><a href="#线程池的理解" class="headerlink" title="线程池的理解"></a>线程池的理解</h3><p>（如果问到了这样的问题，可以展开地说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ol>
<h3 id="JAVA线程池中队列常用类型有哪些"><a href="#JAVA线程池中队列常用类型有哪些" class="headerlink" title="JAVA线程池中队列常用类型有哪些"></a>JAVA线程池中队列常用类型有哪些</h3><ul>
<li><p>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出）原则对元素进行排序。</p>
</li>
<li><p>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO(先进先出）排序元素，吞吐量通常要高于ArrayBlockingQueue。</p>
</li>
<li><p>SynchronousQueue 一个不存储元素的阻塞队列。</p>
</li>
<li><p>PriorityBlockingQueue 一个具有优先级的无限阻塞队。 也是基于最小二叉堆实现 </p>
</li>
<li><p>DelayQueue ：</p>
<ul>
<li>只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</li>
<li>DelayQueue是一个没有大小限制的队列，</li>
<li>因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
</ul>
</li>
</ul>
<p>这里能说出前三种也就差不多了，如果能说全那是最好。</p>
<h3 id="线程池核心线程数设置"><a href="#线程池核心线程数设置" class="headerlink" title="线程池核心线程数设置"></a>线程池核心线程数设置</h3><p>分为CPU 密集型和IO 密集型</p>
<p><strong>CPU：</strong>这种任务消耗的主要是CPU 资源，可以将线程数设置为N（ CPU 核心数）+1，比CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU 的空闲时间。</p>
<p><strong>IO密集型：</strong>这种任务应用起来，系统会用大部分的时间来处理I&#x2F;O 交互，而线程在处理I&#x2F;O 的时间段内不会占用CPU 来处理，这时就可以将CPU 交出给其他线程使用。因此在I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是：核心线程数&#x3D;CPU 核心数量*2。</p>
<h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>主要有4 种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li>
<li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常</li>
</ol>
<h2 id="JAVA程序是如何执行的"><a href="#JAVA程序是如何执行的" class="headerlink" title="JAVA程序是如何执行的"></a>JAVA程序是如何执行的</h2><ul>
<li><p>先把Java 代码编译成字节码，也就是把.java 类型的文件编译成.class 类型的文件。这个过程的大致执行流程：</p>
<p><strong>Java 源代码-&gt; 词法分析器-&gt; 语法分析器-&gt; 语义分析器-&gt; 字符码生成器-&gt; 最终生成字节码</strong></p>
<p>其中任何一个节点执行失败就会造成编译失败；</p>
</li>
<li><p>把class 文件放置到Java 虚拟机，这个虚拟机通常指的是Oracle 官方自带的Hotspot JVM；</p>
</li>
<li><p>Java 虚拟机使用类加载器（Class Loader）装载class 文件；</p>
</li>
<li><p>类加载完成之后，会进行字节码校验，字节码校验通过之后JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以Hotspot 虚拟机来说，它本身提供了JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。</p>
<p>Java 程序执行流程图如下：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405131631960.png"/></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>从JDK1.6 版本之后，synchronized 本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p>
<p>锁的状态从低到高依次为无锁－〉偏向锁－〉轻量级锁－〉重量级锁，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
<ul>
<li><p><strong>自旋锁：</strong>由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所以没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环， 可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10 次，可以使用-XX:PreBlockSpin 设置。</p>
</li>
<li><p><strong>自适应锁：</strong>自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p>
</li>
<li><p><strong>锁消除：</strong>锁消除指的是JVM 检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
</li>
<li><p><strong>锁粗化：</strong>锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围<strong>扩展到整个操作序列</strong>之外。</p>
</li>
<li><p><strong>偏向锁：</strong>当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS 来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以通过设置-XX:+UseBiasedLocking 开启偏向锁。</p>
</li>
<li><p><strong>轻量级锁：</strong>JVM 的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM 将会使用CAS 方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败， 当前线程就尝试自旋来获得锁。<br>整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。</p>
</li>
</ul>
<p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS 了，而轻量级锁主要就是通过CAS 修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li>互斥条件：一个资源每次只能被一个线程使用</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>指定获取锁的顺序，举例如下：</p>
<ol>
<li>比如某个线程只有获得A 锁和B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</li>
<li>获得锁的顺序是一定的，比如规定，只有获得A 锁的线程才有资格获取B 锁，按顺序获取锁就可以避免死锁！！！</li>
</ol>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写－读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p>例如上图线程A 与线程B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li><p>线程A 把本地内存A 更新过的共享变量刷新到主内存中去。</p>
</li>
<li><p>线程B 到主内存中去读取线程A 之前更新过的共享变量。</p>
</li>
</ol>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确地发送消息来显式进行通信。</p>
<p>在Java 中典型的消息传递方式，就是wait() 和notify() ，或者BlockingQueue 。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>hreadLocal 可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized 的做法是用空间来换时间。</p>
<p>ThreadLocal 有一个静态内部类ThreadLocalMap ，ThreadLocalMap 又包含了一个Entry 数组，Entry 本身是一个弱引用，他的key 是指向ThreadLocal 的弱引用，Entry 具备了保存key value键值对的能力。</p>
<p>弱引用的目的是防止内存泄漏，如果是强引用那么ThreadLocal 对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC 的时候被回收。</p>
<p>但是这样还是会存在内存泄漏的问题，假如key 和ThreadLocal 对象被回收之后，entry 中就存在key 为null，但是value 有值的entry 对象，但是永远没办法被访问到，同样除非线程结束运行。</p>
<p>但是只要ThreadLocal 使用恰当，在使用完之后调用remove 方法删除Entry 对象，实际上是不会出现这个问题的。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>随着CPU 和内存的发展速度差异的问题，导致CPU 的速度远快于内存，所以现在的CPU 加入了 高速缓存，高速缓存一般可以分为L1、L2、L3 三级缓存。基于上面的例子我们知道了这导致了 缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU 的重排序导致了原子性和有序性的问题，JMM 内存模型正是对多线程操作下的一系列规范约束， 因为不可能让程序员的代码去兼容所有的CPU，通过JMM 我们才屏蔽了不同硬件和操作系统内 存的访问差异， 这样保证了Java 程序在不同的平台下达到一致的内存访问效果，同时也是保证在 高效并发的时候程序能够正确执行。</p>
<h3 id="happen-before-规则"><a href="#happen-before-规则" class="headerlink" title="happen-before 规则"></a>happen-before 规则</h3><p>虽然指令重排提高了并发的性能，但是Java 虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意地改变执行位置，主要有以下几点：</p>
<ol>
<li>单线程每个操作，happen-before 于该线程中任意后续操作</li>
<li>volatile 写happen-before 与后续对这个变量的读</li>
<li>synchronized 解锁happen-before 后续对这个锁的加锁</li>
<li>final 变量的写happen-before 于final 域对象的读，happen-before 后续对final 变量的读</li>
<li>传递性规则，A 先于B ，B 先于C，那么A 一定先于C 发生</li>
</ol>
<p>主内存可以认为就是物理内存，Java 内存模型中实际就是虚拟机内存的一部分。而工作内存就是CPU 缓存，他有可能是寄存器也有可能是L1\L2\L3 缓存，都是有可能的。</p>
<h2 id="CyclicBarrier和-CountDownLatch的区别？"><a href="#CyclicBarrier和-CountDownLatch的区别？" class="headerlink" title="CyclicBarrier和 CountDownLatch的区别？"></a>CyclicBarrier和 CountDownLatch的区别？</h2><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：<br>(1)CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>
<p>(2)CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p>
<p>(3)CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>简单说一下AQS ，AQS 全称为AbstractQueuedSychronizer ，翻译过来应该是抽象队列同步器。</p>
<p>如果说java.util.concurrent 的基础是CAS 的话，那么AQS 就是整个Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry 中并连成双向队列，前面一个线程使用ReentrantLock 好了，则双向队列实际上的第一个Entry 开始运行。</p>
<p>AQS 定义了对双向队列所有的操作，而只开放了tryLock 和tryRelease 方法给开发者使用，开发者可以根据自己的实现重写tryLock 和tryRelease 方法，以实现自己的并发功能。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>emaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个int 型整数n ，表示某段代码最多只有n 个线程可以访问，如果超出了n ，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore 构造函数中</p>
<p>传入的int 型整数n&#x3D;1，相当于变成了一个synchronized 了</p>
<h2 id="Callable-和-Future"><a href="#Callable-和-Future" class="headerlink" title="Callable 和 Future"></a>Callable 和 Future</h2><p>Callable 接口类似于Runnable，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。</p>
<p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以Callable 用于产生结果， Future 用于获取结果。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>JDK7 提供了7 个阻塞队列。分别是：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue ：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue ：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque ：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="多线程上下文切换"><a href="#多线程上下文切换" class="headerlink" title="多线程上下文切换"></a>多线程上下文切换</h2><p>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p>
<p>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe ）。“页码”信息会一直保存到CPU 的内存中，直到他们被再次使用。</p>
<p>上下文切换是存储和恢复CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h2 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h2><p>所谓后台（daemon）线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程， 并且这个线程并不属于程序中不可或缺的部分。</p>
<p>因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说， 只要有任何非后台线程还在运行，程序就不会终止。</p>
<p>必须在线程启动之前调用setDaemon(）方法，才能把它设置为后台线程。注意：后台进程在不执行finally 子句的情况下就会终止其run(）方法。</p>
<p>比如：JVM 的垃圾回收线程就是Daemon 线程，Finalizer 也是守护线程。</p>
<h2 id="乐观锁和悲观锁的理解及如何实现"><a href="#乐观锁和悲观锁的理解及如何实现" class="headerlink" title="乐观锁和悲观锁的理解及如何实现"></a>乐观锁和悲观锁的理解及如何实现</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，<strong>所以每次在拿数据的时候都会上锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java 里面的同步原语synchronized 关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>，可以使用版本号等机制。</p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
<p>在Java 中java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式CAS 实现的。</p>
<h3 id="乐观锁实现机制"><a href="#乐观锁实现机制" class="headerlink" title="乐观锁实现机制"></a>乐观锁实现机制</h3><ol>
<li><p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p>
</li>
<li><p>java 中的Compare and Swap 即CAS ，当多个线程尝试使用CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
</li>
</ol>
<p>CAS 操作中包含三个操作数—— 需要读写的内存位置<br>（V）、进行比较的预期原值（A）和拟写入的新值（B)。如果内存位置V 的值与预期原值A 相<br>匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包<br>含三个操作数：</p>
<ol>
<li>变量内存地址，V 表示</li>
<li>旧的预期值，A 表示</li>
<li>准备设置的阈值，B 表示</li>
</ol>
<p>当执行CAS 指令时，只有当V 等于A 时，才会用B 去更新V 的值，否则就不会执行更新操作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>ABA 的问题 ：</strong>指的是在CAS 更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS 更新的漏洞就叫做ABA。只是ABA 的问题大部分场景下都不影响并发的最终效果。</p>
<p>Java 中有AtomicStampedReference 来解决这个问题，他加入了预期标志和更新后标志两个字段， 更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<p><strong>循环时间长开销大：</strong>自旋CAS 的方式如果长时间不成功，会给CPU 带来很大的开销。</p>
<p><strong>只能保证一个共享变量的原子操作：</strong>只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference 来处理或者使用锁synchronized 实现。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120013055.png"/>

<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>线程独占：栈，本地方法栈，程序计数器线程共享：堆，方法区</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>又称方法栈，线程私有的，线程执行方法是会创建一个栈阵，用来存储局部变量表，操作栈，动态链接，方法出口等信息.调用方法时执行入栈，方法返回式执行出栈.</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与栈类似，也是用来保存执行方法的信息.执行Java 方法是使用栈，执行Native 方法时使用本地方<br>法栈.</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>保存着当前线程执行的字节码位置，每个线程工作时都有独立的计数器，只为执行Java 方法服务，执行Native 方法时，程序计数器为空.</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405122146852.png"/>

<p>JVM 内存管理最大的一块，对被线程共享， 目的是存放对象的实例，几乎所有的对象实例都会放在这里， 当堆没有可用空间时，会抛出OOM 异常.根据对象的存活周期不同，JVM 把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</p>
<h3 id="堆内分配与回收策略"><a href="#堆内分配与回收策略" class="headerlink" title="堆内分配与回收策略"></a>堆内分配与回收策略</h3><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>大多数情况下，对象在新生代Eden区中分配，当 Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC</p>
<h4 id="什么是Minor-GC"><a href="#什么是Minor-GC" class="headerlink" title="什么是Minor GC"></a>什么是Minor GC</h4><p>指发生在新生代的垃圾收集，因为 Java对象大多朝生夕灭，所以 Minor GC非常频繁， 一般回收速度也比较快</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p><strong>XX:PretenureSizeThreshold</strong> 当创建的对象超过指定大小时，直接把对象分配在老年代<br>大对象就是指需要大量连续内存空间的 Java 对象如字符串、数组，为了避免为大对象分配内存时<br>由于分配担保机制带来的复制而降低效率</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><ul>
<li>-XX:MaxTenuringThreshold 设定对象在Survivor区最大年龄阈值，超过阈值转移到老年代，默认15</li>
<li>对象头的 Age 属性记录年龄，对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1，对象</li>
<li>在 Survivor 中每熬过一次MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>并不一定要Age到达阈值才晋升到老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大<br>于 Survivor 空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><p>又称非堆区，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器优化后的代码等<br>数据.1.7 的永久栈和1.8 的元空间都是方法区的一种实现</p>
<h2 id="JVM内存可见性"><a href="#JVM内存可见性" class="headerlink" title="JVM内存可见性"></a>JVM内存可见性</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120017757.png"/>

<p>JMM 是定义程序中变量的访问规则，线程对于变量的操作只能在自己的工作内存中进行，而不能直接对主内存操作.由于指令重排序，读写的顺序会被打乱，因此JMM 需要提供原子性，可见性，有序性保证.</p>
<h2 id="类加载与卸载"><a href="#类加载与卸载" class="headerlink" title="类加载与卸载"></a>类加载与卸载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120018966.png"/>

<p>其中<strong>验证，准备，解析</strong>合成链接</p>
<p><strong>加载</strong>通过类的完全限定名，查找此类字节码文件，利用字节码文件创建Class 对象.</p>
<p><strong>验证</strong>确保Class 文件符合当前虚拟机的要求，不会危害到虚拟机自身安全.</p>
<p><strong>准备</strong>进行内存分配，为static 修饰的类变量分配内存，并设置初始值（0 或null).不包含final 修饰的静态变量，因为final 变量在编译时分配.</p>
<p><strong>解析</strong>将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.</p>
<p>初始化主要完成静态块执行以及静态变量的赋值.先初始化父类，再初始化当前类.只有对类主动<br>使用时才会初始化.</p>
<p>触发条件包括，创建类的实例时，访问类的静态方法或静态变量的时候，使用Class.forName 反射<br>类的时候，或者某个子类初始化的时候.</p>
<p>Java 自带的加载器加载的类，在虚拟机的生命周期中是不会被卸载的，只有用户自定义的加载器<br>加载的类才可以被卸.</p>
<h4 id="加载机制－双向委派模式"><a href="#加载机制－双向委派模式" class="headerlink" title="加载机制－双向委派模式"></a>加载机制－双向委派模式</h4><p>双亲委派模式，即加载器加载类时先把请求委托给自己的父类加载器执行，直到顶层的启动类加<br>载器. 父类加载器能够完成加载则成功返回，不能则子类加载器才自己尝试加载.*</p>
<ol>
<li>避免类的重复加载</li>
<li>避免Java 的核心API 被篡改</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120020479.png"/>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/" class="post-title-link" itemprop="url">考研政治复习(1)-马原</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-13 08:14:01" itemprop="dateCreated datePublished" datetime="2023-10-13T08:14:01+08:00">2023-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-22 17:00:37" itemprop="dateModified" datetime="2023-10-22T17:00:37+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%94%BF%E6%B2%BB/" itemprop="url" rel="index"><span itemprop="name">政治</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><span style="color:red">红色</span>：重点内容<br><span style="color:orange">橙色</span>：下述内容的归纳总结</p>
<h1 id="马克思主义原理"><a href="#马克思主义原理" class="headerlink" title="马克思主义原理"></a>马克思主义原理</h1><h2 id="马克思主义的创立"><a href="#马克思主义的创立" class="headerlink" title="马克思主义的创立"></a>马克思主义的创立</h2><h3 id="马克思主义产生的社会根源、阶级基础和思想渊源"><a href="#马克思主义产生的社会根源、阶级基础和思想渊源" class="headerlink" title="马克思主义产生的社会根源、阶级基础和思想渊源"></a>马克思主义产生的社会根源、阶级基础和思想渊源</h3><ol>
<li><p>资本主义经济的发展为马克思主义的产生提供了<strong>经济</strong>、<strong>社会历史条件</strong></p>
</li>
<li><p><strong>无产阶级</strong>（工人阶级）在反抗资产阶级的斗争中逐步走向<strong>自觉</strong>（跟自发不一样，自发是自然发生，无意识），对科学理论的指导提出了强烈的需求（马克思主义产生的<strong>阶级基础和实践基础</strong>）</p>
</li>
<li><p>马克思、恩格斯的革命实践和对人类文明成果的继承与创新（主观条件）</p>
<p><strong>19世纪西欧三大先进思潮（德国古典哲学、英国古典政治经济学、英法两国的空想社会主义）</strong>为马克思主义的创立提供了直接的理论来源。<strong>19世纪的三大科学发现、即细胞学说、能量守恒与转化定律生物进化论，为马克思主义的产生提供了自然科学前提</strong></p>
</li>
</ol>
<h3 id="马恩列重要著作（第一页重点）"><a href="#马恩列重要著作（第一页重点）" class="headerlink" title="* 马恩列重要著作（第一页重点）"></a>* 马恩列重要著作（第一页重点）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310131619588.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310180939679.png"/>

<h3 id="马克思主义的创立-1"><a href="#马克思主义的创立-1" class="headerlink" title="马克思主义的创立"></a>马克思主义的创立</h3><p>一国胜利论：由于资本主义的政治发展不平衡，提出社会主义革命可能会在<strong>一国或者数国首先发生并取得胜利</strong>的论断，俄国的十月革命的胜利使其变成可现实-《国家与革命》</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181051090.png"/>

<p>毛中特补充下属内容</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181054418.png"/>

<h3 id="马克思主义的鲜明特征"><a href="#马克思主义的鲜明特征" class="headerlink" title="* 马克思主义的鲜明特征"></a>* 马克思主义的鲜明特征</h3><p>科发民革践</p>
<ol>
<li><p>科学性</p>
<p>马克思主义是对自然、社会和人类思雏<strong>发展本质和规律的正确反映</strong>。马克思主义具有科学的世界观和方法论基础，即辩证唯物主义和历史唯物主义，这是马克思主义的一个<strong>突出特征和理论优势</strong>，也是马克思主义科学性的重要体现。</p>
</li>
<li><p>发展性</p>
<p>马克思主义是不断发展的学说，具有与时俱进的理论品质。</p>
</li>
<li><p>人民性</p>
<p><strong>人民至上</strong>是马克思主义的<strong>政治立场</strong>。马克思主义政党把人民放在心中最高位置，一切奋斗都致力于实现最广大人民的根本利益。<strong>人民性是马克思主义最鲜明的品格</strong>。马克思主义博大精深，<strong>归根到底就是一句话：为人类求解放</strong></p>
</li>
<li><p><strong>革命性</strong>（科学性+革命性【人民+实践+发展】）</p>
<p>马克思主义的鲜明特征，<strong>用一句话概括，就是科学性与革命性的统一</strong>。革命性是马克思主义的内在品质，是马克思主义的人民性、实践性和发展性的应有之义和必然要求。在马克思主义指导革命的过程中，<strong>人民性、实践性和发展性集中地体现为革命性</strong>。【科发民革践】</p>
</li>
<li><p>实践性</p>
<p>马克思主义是从实践中来、到实践中去，在实践中接受检验，并随实践而不断发展的学说。<strong>实践性是马克思主义理论区别于其他理论的显著特征。实践观点是马克思主义首要的和基本的观点。</strong></p>
</li>
</ol>
<h3 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h3><ol>
<li>马克思主义理论区别于其他理论的根本特征：实践性</li>
<li><strong>实践的观点</strong>是马克思主义的基本观点</li>
<li>马克思主义的<strong>本质属性</strong>：人民性</li>
<li>马克思主义追求的<strong>根本价值目标</strong>：实现人的自由而全面的发展</li>
<li><strong>马克思的整个世界观不是教义，而是方法。</strong>它提供的不是现成的教条，是进一步研究的出发点和供这种研究使用的方法。如果选项中出现“现成答案”“现成理想方案”等，多为干扰项。</li>
</ol>
<h4 id="马克思主义的当代价值"><a href="#马克思主义的当代价值" class="headerlink" title="马克思主义的当代价值"></a>马克思主义的当代价值</h4><p>(一）观察当代世界变化的<strong>认识工具</strong><br>(二）指引当代中国发展的<strong>行动指南</strong><br>(三）引领人类杜会进步的<strong>科学真理</strong></p>
<h1 id="世界多样性与物质统一性"><a href="#世界多样性与物质统一性" class="headerlink" title="世界多样性与物质统一性"></a>世界多样性与物质统一性</h1><h2 id="物质及其存在方式"><a href="#物质及其存在方式" class="headerlink" title="物质及其存在方式"></a>物质及其存在方式</h2><h3 id="哲学基本问题及其内容"><a href="#哲学基本问题及其内容" class="headerlink" title="哲学基本问题及其内容"></a>哲学基本问题及其内容</h3><ol>
<li><p>哲学基本问题—<strong>存在和思维的关系问题。</strong></p>
<p>恩格斯第一次明确提出：“全部哲学，特别是近代哲学的重大的基本问题，是<strong>思维和存在的关系问题。</strong></p>
</li>
<li><p>哲学基本问题的内容，包括两个方面：</p>
<p>第一，存在和思维究竞谁是世界的本原，即物<strong>质和精神何者是第一性、何者是第二性的问题</strong>；</p>
<p>第二，思维能否正确认识存在的问题，即<strong>思维和存在有无同一性的问题</strong>。</p>
</li>
<li><p>唯物主义与辩证法要统一起来</p>
<p>只有既坚持唯物主义，又坚持辩证法，才能全面地认识世界的本质和发展规律。只有达到唯物主义和辩证法的内在统一，才能有科学的彻底的唯物主义和科学的彻底的辩证法</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181121085.png"/>

<h4 id="刷题总结-1"><a href="#刷题总结-1" class="headerlink" title="刷题总结"></a>刷题总结</h4><h5 id="哲学基本问题及其内容-1"><a href="#哲学基本问题及其内容-1" class="headerlink" title="哲学基本问题及其内容"></a>哲学基本问题及其内容</h5><ol>
<li>物质第一性，第二性，只是就谁是世界的本原而言的，不要把它与价值混淆。不存在物质和谁比谁更重要，也不涉及谁与社会生活的关系更密切的问题。第一性不等于第一重要，第二性也不等于第二重要。</li>
<li>唯心主义并非都是不可知论。唯物主义哲学家以及坚持唯物主义观点的科学家，都反对不可知论，主张世界是可以认识的；唯心主义既有可知论（如黑格尔），也有不可知论。</li>
<li><strong>唯心主义不等于形而上学，唯物主义不等于辩证法。</strong></li>
<li>唯心主义又分为主观唯心主义和客观唯心主义。主观唯心主义把人的感觉、观念作为世界的本原（关键词：心、观念、感觉、精神等）；客观唯心主义把某种脱离物质、脱离任何个人的精神作为世界的本原（关键词：理、理念、绝对观念、上帝、造物主、绝对精神等)</li>
</ol>
<h5 id="物质"><a href="#物质" class="headerlink" title="物质"></a>物质</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181127848.png"/>

<h3 id="物质-1"><a href="#物质-1" class="headerlink" title="物质"></a>物质</h3><ul>
<li><p><strong>[马克思主义]物质观</strong></p>
<p>马克思批判了旧唯物主义对物质世界的直观、消极的理解，强调要从<strong>能动的<span style="color:red">实践</span>出发</strong>去把握客观世界的意义</p>
</li>
<li><p><strong>[恩格斯]对物质概念作了初步概括</strong></p>
<p>“<strong>物、物质无非是各种物的总和，而这个概念就是从这一总和中抽象出来的。”</strong>这就是说，物质这个名词是一种简称，“我们就用这种简称把感官可感知的许多不同的事物依照其共同的属性概括起来”。这样就明确指出了哲学物质概念与自然科学关于具体的物质形态和物质结构的概念之间<strong>共性与个性</strong>的关系</p>
</li>
<li><p><strong>[列宁]对物质概念作了全面的科学的规定</strong></p>
<p>物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映。”<strong>列宁是从物质与的关系上来把握物质的</strong>。物质范畴是对物质世界多样性和统一性所作的最高的哲学概括。<strong>物质的共同特性（唯一特性）是客观实在性</strong>，它存在于人的之外，可以为人的所反映。换句话说，<strong>所谓物质，就是不依赖于人类的而存在，并能为人类的所反映的客观实在</strong></p>
<p><strong>马克思主义的物质概念是与实践的观点内在统一的。人类的社会生活本质上是实践的</strong></p>
</li>
</ul>
<h4 id="刷题总结-2"><a href="#刷题总结-2" class="headerlink" title="刷题总结"></a>刷题总结</h4><ol>
<li><p>客观实在不一定是人可以直接<strong>看得见、摸得着的实物</strong>（比如磁场就需要通过仪器来感知），重点在干它是存在于人的之外，不以人的意志为转移。</p>
</li>
<li><p>不要混淆<strong>自然科学物质结构概念与哲学物质范畴</strong>，它们是<strong>个别与一般、个性与共性</strong>的关系</p>
<blockquote>
<p>【个别与一般&#x3D;普遍与特殊&#x3D;个性与共性；任何个别都是一般；<span style="color:red">≠整体与部分</span></p>
<p>个别就是各种具体事物（如大李子、张三），一般则是同类事物的共同本质（人）。白马是马的一种，马腿是马的一部分】</p>
</blockquote>
</li>
<li><p>马克思主义以前的旧唯物主义在自然观上是唯物的．在历史观上却陷入唯心，所以是不彻底的“半截子”唯物主义。</p>
</li>
<li><p><span style="color:red"><strong>庸俗唯物主义不是唯物主义</strong></span>，它混淆物质与的界限，认为人的精神活动能力只不过是脑物质的分泌物。</p>
</li>
<li><p>物质和的对立，只有在它们何者为第一性、何者为第二性这一范围内才具有绝对的意义；<strong>超出这个范围，物质和的对立便是相对的。</strong></p>
</li>
<li><p>马克思主义以前的旧唯物主义在自然观上是唯物的，在历史观上却陷入唯心，所以是不彻底的“半截子”唯物主义。马克思主义既看到了自然界的物质性，又以实践为基础揭示了人类社会的物质性，实现了唯物主义自然观和历史观的统一。</p>
</li>
</ol>
<h3 id="物质的存在方式"><a href="#物质的存在方式" class="headerlink" title="物质的存在方式"></a>物质的存在方式</h3><ol>
<li><p>物质与运动</p>
<p>①<strong>运动是物质的根本属性或存在方式</strong>。世界是物质的，而物质是运动的。运动是标志一切事物和现象的变化及其过程的哲学范畴。</p>
<p>②<strong>物质和运动不可分割</strong>。一方面，物质是运动着的物质，脱离运动的物质是不存在的。<strong>设想有不运动的物质，将导致形而上学</strong>。另一方面，运动是物质的运动。<strong>物质是一切运动变化和发展过程的实在基础和承担者</strong>，世界上没有离开物质的运动，任何形式的运动都有它的物质载体，<strong>设想无物质的运动，将导致唯心主义</strong></p>
</li>
<li><p>运动与静止 <span style="color:orange">【绝对运动，相对静止】</span></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181151093.png"/>
</li>
<li><p>物质运动与时间、空间</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181152224.png"/></li>
</ol>
<h4 id="刷题总结-3"><a href="#刷题总结-3" class="headerlink" title="刷题总结"></a>刷题总结</h4><ol>
<li><p>在很多概念的描述中，<strong>“绝对的”与“无条件的”井列，“相对的”与“有条件的”并列</strong></p>
</li>
<li><p>客观实在性是物质的共同特性，运动是物质的根本属性（存在方式)，时空是运动着的物质的基本存在形式【如果单独说时间，空间也对】</p>
</li>
</ol>
<h3 id="物质世界的二重化"><a href="#物质世界的二重化" class="headerlink" title="物质世界的二重化"></a>物质世界的二重化</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310221122090.png"/>

<h2 id="物质与意识的辩证关系"><a href="#物质与意识的辩证关系" class="headerlink" title="物质与意识的辩证关系"></a>物质与意识的辩证关系</h2><p><span style="color:red"><strong>物质决定意识，意识依赖于物质井反作用于物质</strong></span></p>
<h3 id="物质决定意识"><a href="#物质决定意识" class="headerlink" title="物质决定意识"></a>物质决定意识</h3><p><span style="color:orange">意识是人类独有的</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">计算机组成原理(2)-存储与指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-07 19:28:57 / 修改时间：20:21:53" itemprop="dateCreated datePublished" datetime="2023-09-07T19:28:57+08:00">2023-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理笔记"><a href="#计算机组成原理笔记" class="headerlink" title="计算机组成原理笔记"></a>计算机组成原理笔记</h1><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><p>存储器的层次化结构</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071938083.png"/>

<p>存储器的分类–层次</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071938377.png"/>

<p>存储器的分类–存储介质</p>
<ul>
<li>半导体存储器：主存、Cache</li>
<li>磁表面存储器：磁盘、磁带（以磁性材料存储信息）</li>
<li>光存储器：光盘（以光介质存储信息）</li>
</ul>
<p>存储器的分类–存取方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071939552.png"/>

<p>相联存储器既可以按地址又可以按内容寻址。</p>
<p>存储器的分类–信息的可更改性</p>
<ul>
<li>读写存储器–即可读、也可写（如：磁盘、内存、Cache）</li>
<li>只读存储器–只可读，不能写</li>
</ul>
<p>存储器的分类–信息的可保存性</p>
<ul>
<li>断电后，存储信息消失的存储器–易失性存储器 (主存、Cache)</li>
<li>断电后，存储信息依然保持的存储器- – 非易失性存储器(磁盘、光盘)</li>
<li>信息读出后，原存储信息被破坏– -破坏性读出(如DRAM芯片，读出数据后要进行重写</li>
<li>信息读出后，原存储信息不被破坏– - 非破坏性读出(如SRAM芯片、磁盘、光盘)</li>
</ul>
<p>RAM都是易失性存储器；<br>ROM都是非易失性存储器；<br>随机存取存储器：RAM（专有名词）；<br>随机存取：是存取方式，ROM和RAM存取方式都是随机存取。</p>
<h2 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a><strong>存储器的性能指标</strong></h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071939078.png"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071940862.png"/>

<h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><strong>基本的半导体元件及原理</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071940021.png"/>

<p>注：MOS管可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通。</p>
<h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a><strong>存储器芯片的基本原理</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071949374.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071954292.png"/>

<p>驱动器在译码器后面，保证译码器输出的电信号是稳定可靠的。<br>片选线作用：若有多个存储芯片，保证此次读取指定芯片的数据，CS给予低电平，其他芯片为高电平。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071954216.png"/>

<h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a><strong>寻址</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071955963.png"/>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071956297.png"/>

<h2 id="SRAM与DRAM"><a href="#SRAM与DRAM" class="headerlink" title="SRAM与DRAM"></a>SRAM与DRAM</h2><p>DRAM（动态RAM）用于主存，SRAM（静态RAM）用于Cache<br>DRAM芯片：使用栅极电容存储信息<br>SRAM芯片：使用双稳态触发器存储信息</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071957212.png"/>

<blockquote>
<p>1：电容内存储了电荷<br>0：电容内未存储电荷</p>
<p>若触发器里存储的的二进制的1，当字选择线接通之后，BLX输出低电平信号</p>
<p>若触发器里存储的的二进制的0，当字选择线接通之后，BL输出低电平信号<br>写入0：给BL加低电平，给BLX加高电平，呈现A低B高</p>
<p>栅极电容：每个存储元制造成本更低，集成度高，功耗低。电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失，2ms之内必须“刷新”一次（给电容充电）</p>
<p>双稳态触发器：每个存储元制造成本更高，集成度低，功耗大。只要不断电，触发器的状态就不会改变</p>
</blockquote>
<h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a><strong>DRAM的刷新</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071958116.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959175.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959206.png"/>

<p>分散刷新不存在死区</p>
<h3 id="DRAM的地址线复用技术"><a href="#DRAM的地址线复用技术" class="headerlink" title="DRAM的地址线复用技术"></a><strong>DRAM的地址线复用技术</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959879.png"/>

<blockquote>
<p>地址：00000000。<br>同时送行列地址，需要8根地址线。两次送只需要4根地址线。<br>地址线复用技术：地址线是原来的1&#x2F;2（行和列相等）且地址线分行、列两次传送。<br>这里地址线取决于行和列的最大值。<br>地址引脚：log2max{行，列}</p>
</blockquote>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072000322.png"/>

<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072001457.png"/>

<p>EPROM不能作为随机存储器。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072002486.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072004305.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072005955.png"/>

<h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p>现在的计算机</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072006106.png"/>

<p><strong>存储器芯片的输入输出信号</strong></p>
<p>WE头上没有横杠，高电平表示写，低电平表示读。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072007728.png"/>

<h3 id="增加主存的存储字长-位扩展"><a href="#增加主存的存储字长-位扩展" class="headerlink" title="增加主存的存储字长-位扩展"></a><strong>增加主存的存储字长-位扩展</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008374.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008222.png"/>

<h3 id="增加主存的存储字数-字扩展"><a href="#增加主存的存储字数-字扩展" class="headerlink" title="增加主存的存储字数-字扩展"></a><strong>增加主存的存储字数-字扩展</strong></h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a><strong>线选法</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008888.png"/>

<h4 id="译码片选线"><a href="#译码片选线" class="headerlink" title="译码片选线"></a><strong>译码片选线</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072009042.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072010084.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072010580.png"/>

<h3 id="主存容量扩展-字位同时扩展"><a href="#主存容量扩展-字位同时扩展" class="headerlink" title="主存容量扩展-字位同时扩展"></a><strong>主存容量扩展-字位同时扩展</strong></h3><p>①可以存储低四位–（D0、D1、D2、D3）</p>
<p>②可以存储另四位–（D4、D5、D6、D7）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072011694.png"/>

<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014238.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014879.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072015772.png"/></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014088.png"/>

<h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072016516.png"/>

<h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a><strong>双端口RAM</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072016425.png"/>

<h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a><strong>多体并行存储器</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072017237.png"/>

<h3 id="应该取几个“体”"><a href="#应该取几个“体”" class="headerlink" title="应该取几个“体”"></a><strong>应该取几个“体”</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072017662.png"/>

<blockquote>
<p>当m&#x3D;T&#x2F;r时，存取流水线的效率最高，存储体的数量最少，成本最低。</p>
<p>思考？<br>假设有m个存储体，第一种方法：可以根据体号确定它属于第几个存储体；第二种方法：用十进制地址x对m取余</p>
</blockquote>
<h3 id="多模块存储体"><a href="#多模块存储体" class="headerlink" title="多模块存储体"></a><strong>多模块存储体</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072018732.png"/>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072019521.png"/>

<h2 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h2><h3 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a><strong>外存储器</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072019733.png"/>

<h3 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a><strong>磁盘设备的组成</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020333.png"/>

<h3 id="磁盘的性能指标"><a href="#磁盘的性能指标" class="headerlink" title="磁盘的性能指标"></a><strong>磁盘的性能指标</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020912.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020736.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072021549.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072021194.png"/>

<h3 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a><strong>磁盘阵列</strong></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">计算机组成原理(1)-概述与数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-08 21:44:13" itemprop="dateCreated datePublished" datetime="2023-08-08T21:44:13+08:00">2023-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-07 21:20:07" itemprop="dateModified" datetime="2023-09-07T21:20:07+08:00">2023-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理笔记"><a href="#计算机组成原理笔记" class="headerlink" title="计算机组成原理笔记"></a>计算机组成原理笔记</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061623419.png"/>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机的发展"><a href="#计算机的发展" class="headerlink" title="计算机的发展"></a>计算机的发展</h2><p>数据库管理系统–系统软件<br>数据库系统–应用软件</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061530626.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061530997.png"/>

<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><p>“存储程序”的概念是指将指令以<strong>二进制代码</strong>的形式事先输入计算机的主存储器，然后按其在<strong>存储器中的首地址执行程序的第一条指令</strong>，以后就按该程序的规定顺序执行其他指令，直到程序执行结束。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>输入设备</td>
<td>将信息转换成机器能识别的形式</td>
</tr>
<tr>
<td>运算器</td>
<td>算术运算逻辑运算</td>
</tr>
<tr>
<td>存储器</td>
<td>存放数据和程序</td>
</tr>
<tr>
<td>控制器</td>
<td>指挥程序运行</td>
</tr>
<tr>
<td>输出设备</td>
<td>将结果转换成人们熟悉的形式</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061533552.png"/>

<h4 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h4><ul>
<li>计算机由五大部件组成</li>
<li>指令和数据以同等地位存于存储器，可按地址访问（统一编址，指令和数据所在存储单元无差异）</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成</li>
<li>存储程序</li>
<li>以运算器为中心（输入输出设备与存储器之间的数据传送通过运算器完成）</li>
</ul>
<h4 id="数据驱动方式："><a href="#数据驱动方式：" class="headerlink" title="数据驱动方式："></a>数据驱动方式：</h4><ul>
<li>控制流驱动：指令–&gt;数据</li>
<li>数据流驱动：数据–&gt;指令</li>
</ul>
<h3 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061536471.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061539722.png"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061539037.png"/>

<h2 id="各硬件的工作原理"><a href="#各硬件的工作原理" class="headerlink" title="各硬件的工作原理"></a>各硬件的工作原理</h2><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061540782.png"/>

<ol>
<li>MAR（Memory Address Register）：MAR是一个存储器地址寄存器，用于存储要访问的内存地址。当计算机需要读取或写入内存中的数据时，它会将要访问的内存地址存储在MAR中。MAR通常是一个专门的寄存器，它可以直接与内存进行交互，将存储器地址传递给内存模块。</li>
<li>MDR（Memory Data Register）：MDR是一个存储器数据寄存器，用于存储从内存中读取或要写入内存的数据。当计算机需要从内存中读取数据时，它将数据从内存传输到MDR中。同样，当计算机需要将数据写入内存时，它将数据从MDR传输到内存中的指定位置。MDR也是一个专门的寄存器，它在内存和其他计算机组件之间传递数据。</li>
</ol>
<p>因此，MAR和MDR之间的区别在于它们的功能和作用。MAR用于存储要访问的内存地址，而MDR用于存储从内存读取的数据或要写入内存的数据。它们共同参与内存的读取和写入操作，实现了计算机与内存之间的数据传输和交互。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061546501.png"/>

<ul>
<li>存储单元：每个存储单元存放一串二进制代码</li>
<li>存储字(word)：存储单元中二进制代码的组合</li>
<li>存储字长：存储单元中二进制代码的位数</li>
<li>存储元：即存储二进制的电子元件，每个存储元可存1bit</li>
</ul>
<h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061552267.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>加</th>
<th>减</th>
<th>乘</th>
<th>除</th>
</tr>
</thead>
<tbody><tr>
<td>ACC</td>
<td>累加器，用于存放操作数，或运算结果。</td>
<td>被加数，和</td>
<td>被减数、差</td>
<td>乘积高位</td>
<td>被除数、余数</td>
</tr>
<tr>
<td>MQ</td>
<td>乘商寄存器，在乘、除运算时，用于存放作数或运算结果。</td>
<td></td>
<td></td>
<td>乘数、乘积低位</td>
<td>商</td>
</tr>
<tr>
<td>X</td>
<td>通用的操作数寄存器，用于存放操作数</td>
<td>加数</td>
<td>减数</td>
<td>被乘数</td>
<td>除数</td>
</tr>
<tr>
<td>ALU</td>
<td>算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061559165.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CU 控制单元</td>
<td>控制单元，分析指令，给出控制信号</td>
</tr>
<tr>
<td>IR 指令寄存器</td>
<td>指令寄存器，存放当前执行的指令</td>
</tr>
<tr>
<td>PC 程序计数器</td>
<td>程序计数器，存放下一条指令地址，自动加1功能</td>
</tr>
</tbody></table>
<h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061602437.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061602487.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603976.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603669.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603318.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603758.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603390.png"/>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>注：现在的计算机通常把MAR,MDR也集成在CPU内</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061604660.png"/>

<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p>汇编语言指令和机器语言指令一一对应<br>LOAD： 取数操作 ，MUL： 乘法操作</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061605498.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061608592.png"/>

<p><strong>编译程序</strong>：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后在执行机器语言程序（只需翻译一次）。 例如：使用我们使用C语言写的程序，经过编译和汇编之后，最终形成.exe文件，该.exe文件是用机器语言描述的程序，每次运行这个程序，只需加载.exe文件。</p>
<p><strong>解释程序</strong>：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着在翻译下一句（每一次都要翻译）。 编译型语言执行效率较解释型语言高。 注：编译、汇编、解释程序，可统称为“翻译程序”。</p>
<p>计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）</p>
<ul>
<li>如何设计硬件与软件之间的接口。</li>
</ul>
<p>计算机组成原理：实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p>
<ul>
<li>如何用硬件实现所定义的接口。</li>
</ul>
<p>“透明”：看不见<br>“公开透明”：看得见</p>
<table>
<thead>
<tr>
<th></th>
<th>是否一次性</th>
<th>编译时间</th>
<th>运行速度</th>
</tr>
</thead>
<tbody><tr>
<td>编译程序</td>
<td>是</td>
<td>长</td>
<td>快</td>
</tr>
<tr>
<td>解释</td>
<td>否</td>
<td>短</td>
<td>慢</td>
</tr>
</tbody></table>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061617236.png"/>

<h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>机器字长</td>
<td>能够直接处理的二进制数据的位数</td>
</tr>
<tr>
<td>指令字长</td>
<td>一个指令中包含的二进制代码的位数</td>
</tr>
<tr>
<td>存储字长</td>
<td>一个存储单元二进制数据的位数</td>
</tr>
</tbody></table>
<h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><ul>
<li>MAR位数反应存储单元的个数（最后支持多少个）</li>
<li>MDR位数&#x3D;存储字长&#x3D;每个存储单元的大小</li>
</ul>
<p>总容量&#x3D;存储单元个数×存储字长 bit &#x3D;存储单元个数×存储字长&#x2F;8 Byte<br>$$<br>总容量 &#x3D; 存储单元个数 * 存储字长 bit &#x3D; 存储单元个数 * 存储字长&#x2F;8 Byte<br>$$</p>
<blockquote>
<p>Eg:MAR为32位，MDR为8位<br>总容量&#x3D;2^32×8 bit&#x3D;4GB</p>
<p>2^10:K<br>2^20:M<br>2^30:G<br>2^40:T</p>
</blockquote>
<h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061624562.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061627825.png"/>

<p><strong>注</strong>：公式中主频的值反映的是：每秒钟会出现多少个时钟周期。</p>
<p><strong>注</strong>：注意与存储器的容量或者文件的大小中的K、M、G、T的区别</p>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>数据通路带宽</td>
<td>数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</td>
</tr>
<tr>
<td>吞吐量</td>
<td>指系统在单位时间内处理请求的数量。他取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</td>
</tr>
<tr>
<td>响应时间</td>
<td>指从用户向计算发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销时间）。</td>
</tr>
</tbody></table>
<p>动态测试：基准程序（跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。</p>
<blockquote>
<p><strong>思考：</strong><br>1、主频高的CPU一定比主频低的CPU快吗？<br>答：不一定，如两个CPU，A的主频为2GHz，平均CPI&#x3D;10，一秒钟可以执行0.2G条指令；B的主频为1GHz，平均CPI&#x3D;1，一秒钟可以执行1G条指令。</p>
<p>2、若A、B两个CPU的平均CPI相同，那么A一定更快吗？<br>答：不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。</p>
<p>3、基准程序执行的越快说明机器性能越好吗？<br>答：基准程序中的语句存在频度差异，运行结果也不能完全说明问题。</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061630617.png"/>

<p>存储器的容量：衡量计算机的存储容量<br>机器字长：衡量计算机并行处理的能力<br>数据通路带宽：衡量计算机在功能部件之间传送数据的能力</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061631856.png"/>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="..进制转换"></a>..进制转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061632203.png"/>

<h3 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h3><p>无符号整数，即“自然数”，0、1、2、3、4、5…</p>
<p>C语言中的无符号整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a=<span class="number">1</span>; <span class="comment">//无符号整数 （短整型 2B）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b=<span class="number">2</span>; <span class="comment">//无符号整数 （整型 4B）</span></span><br></pre></td></tr></table></figure>

<p>无符号整数的表示</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061634609.png"/>

<h3 id="无符号整数的加法运算"><a href="#无符号整数的加法运算" class="headerlink" title="..无符号整数的加法运算"></a>..无符号整数的加法运算</h3><h3 id="带符号整数的表示和运算-原反补"><a href="#带符号整数的表示和运算-原反补" class="headerlink" title="..带符号整数的表示和运算_原反补"></a>..带符号整数的表示和运算_原反补</h3><p>带符号整数，即“整数”，-2、-1、0、1、2、3、4、5…</p>
<p>C语言中的带符号整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a=<span class="number">1</span>; <span class="comment">//带符号整数 （短整型 2B）</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">-2</span>; <span class="comment">//带符号整数 （整型 4B）</span></span><br></pre></td></tr></table></figure>

<h3 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061638672.png"/>

<h2 id="原反补码的特性对比"><a href="#原反补码的特性对比" class="headerlink" title="原反补码的特性对比"></a>原反补码的特性对比</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061639934.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071628336.png"/>

<p>注：反码与原码表示的范围是一样的，当n是整数时，真值负数最小时，原码是1111 1111，反码是1000 0000。</p>
<h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629744.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629912.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629875.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630537.png"/>

<h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630949.png"/>

<h3 id="定点小数原反补码的转换"><a href="#定点小数原反补码的转换" class="headerlink" title="定点小数原反补码的转换"></a><strong>定点小数原反补码的转换</strong></h3><p>注：和定点整数一模一样。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630223.png"/>

<h3 id="定点小数的加减法运算"><a href="#定点小数的加减法运算" class="headerlink" title="定点小数的加减法运算"></a><strong>定点小数的加减法运算</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630004.png"/>

<p>小数的加减运算和整数的处理逻辑是一样的。</p>
<p>定点小数VS定点整数</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631154.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631788.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631522.png"/>

<h2 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h2><h3 id="ALU（算数逻辑单元）"><a href="#ALU（算数逻辑单元）" class="headerlink" title="ALU（算数逻辑单元）"></a><strong>ALU（算数逻辑单元）</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071632246.png"/>

<h4 id="基本的逻辑运算"><a href="#基本的逻辑运算" class="headerlink" title="基本的逻辑运算"></a><strong>基本的逻辑运算</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071632415.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071633941.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071633736.png"/>

<blockquote>
<p>异或：AB不同Y为1，相同为 0；同或：AB相同Y为1，不同为0。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">软件工程基础概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 16:42:55" itemprop="dateCreated datePublished" datetime="2023-06-10T16:42:55+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-14 16:36:23" itemprop="dateModified" datetime="2023-06-14T16:36:23+08:00">2023-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><ul>
<li>软件&#x3D;程序+数据+文档</li>
<li>软件是被开发或设计的</li>
<li>软件不会磨损，但是会退化</li>
</ul>
<h2 id="软件工程的概述"><a href="#软件工程的概述" class="headerlink" title="软件工程的概述"></a>软件工程的概述</h2><p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法区开发和维护软件，以及如何把经过时间考虑而证明正确的管理技术和当前能够得到的最好技术方法结合起来的学科。</p>
<h2 id="软件工程的方法"><a href="#软件工程的方法" class="headerlink" title="软件工程的方法"></a>软件工程的方法</h2><h3 id="传统方法："><a href="#传统方法：" class="headerlink" title="传统方法："></a>传统方法：</h3><p>也称生命周期方法或结构化方法。采用结构化技术来完成软件开发的各项任务</p>
<h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>从面向对象程序设计发展起来的。有OOA面向对象分析、OOD面向对象设计、OMG对象管理组织、UML统一建模语言等概念</p>
<h3 id="面向服务方法"><a href="#面向服务方法" class="headerlink" title="面向服务方法"></a>面向服务方法</h3><p>SOA，服务提供与请求的设计模式</p>
<h3 id="面向数据的方法"><a href="#面向数据的方法" class="headerlink" title="面向数据的方法"></a>面向数据的方法</h3><p>基于数据思维，从业务逻辑的角度，强调一切业务“数据化”；从体系结构的角度，突出“面向暑假和以暑假为核心”的思想</p>
<h3 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h3><p>基于形式化数学变换的软件开发方法</p>
<h1 id="软件工程的层次"><a href="#软件工程的层次" class="headerlink" title="软件工程的层次"></a>软件工程的层次</h1><p>软件工程的定义：将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中。</p>
<ul>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程范型</li>
</ul>
<h2 id="软件工程的过程模型"><a href="#软件工程的过程模型" class="headerlink" title="软件工程的过程模型"></a>软件工程的过程模型</h2><h3 id="软件工程的三个要素"><a href="#软件工程的三个要素" class="headerlink" title="软件工程的三个要素"></a>软件工程的三个要素</h3><p>过程、方法、工具</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101647572.png"/>

<ol>
<li>支持软件工程的根基在于质量关注点（quality focus）：是对软件的组织承诺，是支持软件工程的基石</li>
<li>软件工程的基础是过程（process）层。软件过程将各个技术层次结合在一起，使得合理、及时地开发计算机软件成为可能。</li>
<li>软件工程方法（method）为构建软件提供技术上的解决方法。方法包括：沟通、需求分析、设计模型、编程、测试和技术支持。</li>
<li>软件工程工具为过程和方法提供自动化或半自动化的支持。</li>
</ol>
<h3 id="软件过程的三个阶段"><a href="#软件过程的三个阶段" class="headerlink" title="软件过程的三个阶段"></a>软件过程的三个阶段</h3><ol>
<li><p>定义阶段：<strong>“做什么”</strong>，系统和软件的关键需求被标识</p>
<p>系统和信息工程</p>
<p>软件项目计划</p>
<p>需求分析</p>
</li>
<li><p>开发阶段：<strong>“如何做”</strong>，定义数据结构、体系结构、过程细节、界面表示、算法和测试如何执行</p>
<p>软件设计</p>
<p>代码生成</p>
<p>软件测试</p>
</li>
<li><p>支持阶段：<strong>“变化”</strong>：纠正错误、随着软件环境的演化而要求的适应性修改、用户需求的变化而带来的增强性修改</p>
<p>纠错性维护</p>
<p>适应性维护</p>
<p>完善性维护</p>
<p>预防性维护</p>
</li>
</ol>
<h3 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h3><p>CMM是20世纪90年代提出的 <strong>软件能力成熟度模型</strong></p>
<ol>
<li>CMM定义了当一个组织达到不同的过程成熟度时应该具有的软件工程能力</li>
<li>CMM是一种<strong>衡量软件开发能力和成熟度的标准</strong></li>
<li>CMM模型提供了衡量一个公司软件工程实践的整体有效性的方法，且建立了<strong>五级</strong>的过程成熟度级别</li>
</ol>
<h4 id="初始级"><a href="#初始级" class="headerlink" title="初始级"></a>初始级</h4><p>软件过程是<strong>特定的和偶然的</strong>，有时甚至是混乱的，几乎没有过程定义，成功完全取决于个人能力。</p>
<h4 id="可重复级"><a href="#可重复级" class="headerlink" title="可重复级"></a>可重复级</h4><p>建立了<strong>基本的</strong>项目管理过程，能够跟踪费用、进度和功能。有适当的必要的过程规范，可以重复与疫情类似的项目的成功</p>
<h4 id="定义级"><a href="#定义级" class="headerlink" title="定义级"></a>定义级</h4><p>用于管理和工程活动的软件过程已经文档化、<strong>标准化</strong>并与整个组织的软件过程相集成。所有项目都使用统一的、文档化的、组织过程认可的版本来开发和维护软件。</p>
<p>​	包含第二级的所有特征。</p>
<h4 id="管理级"><a href="#管理级" class="headerlink" title="管理级"></a>管理级</h4><p>软件过程和产品质量的详细数据被收集，通过这些度量数据，软件过程和产品能够<strong>被定量地</strong>理解和控制，包含三级的所有特征。</p>
<h4 id="优化级"><a href="#优化级" class="headerlink" title="优化级"></a>优化级</h4><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><p>通过定量反馈进行不断的过程改进，这些反馈来自于过程或通过<strong>试验新的的想法</strong>和技术而得到。包含第四级的所有特征。</p>
<p>软件过程模型是软件开发全部过程、活动和任务的结构框架。是一种开发策略，包含过程，方法和工具三个层次以及一般性阶段，常称为：</p>
<ol>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程模型</li>
</ol>
<h3 id="过程模型两种类型"><a href="#过程模型两种类型" class="headerlink" title="过程模型两种类型"></a>过程模型两种类型</h3><ul>
<li><p>传统的软件过程模型</p>
<ol>
<li>瀑布模型（线性顺序模型）</li>
<li>V模型</li>
<li>原型</li>
<li>RAD模型</li>
<li>增量模型</li>
<li>螺旋模型</li>
<li>形式化方法模型</li>
</ol>
</li>
<li><p>敏捷的软件过程模型</p>
<ol>
<li>极限编程（XP）</li>
<li>自适应软件开发 (ASD)</li>
<li>橄榄球模型 (Scrum)</li>
<li>特征驱动开发 (PDD)</li>
</ol>
</li>
</ul>
<h3 id="传统的软件过程模型"><a href="#传统的软件过程模型" class="headerlink" title="传统的软件过程模型"></a>传统的软件过程模型</h3><h4 id="瀑布模型（waterfall-model）："><a href="#瀑布模型（waterfall-model）：" class="headerlink" title="瀑布模型（waterfall model）："></a>瀑布模型（waterfall model）：</h4><p>又被称为经典生命周期（classic life cycle），它提出了一个系统的、顺序的软件开发方法。<br>优点：</p>
<blockquote>
<ul>
<li>有利于大型软件开发过程中人员的组织、管理，从而提高了大型软件项目开发的质量和效率。</li>
<li>当需求确定、工作采用线性的方式完成的时候瀑布模型是一个很有用的过程模型。</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>过于理想，缺乏灵活性，容易产生需求偏差。</li>
<li>实际的项目很少遵守瀑布模型提出的顺序。</li>
<li>客户通常很难清楚的描述所有的需求。</li>
<li>客户必须要有耐心，因为只有在项目接近尾声的时候，他们才能得到可以执行的程序。</li>
<li>适用范围： 需求确定，工作能够采用线性的方式完成的软件。</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101712288.png"/>

<h4 id="V模型（V-model）："><a href="#V模型（V-model）：" class="headerlink" title="V模型（V-model）："></a>V模型（V-model）：</h4><p>描述了质量保证动作同沟通、建模相关动作以及早期构建相关的动作之间的关系。<br>V模型强调软件开发的协作和速度，将软件实现和验证有机地结合起来，在保证较高的软件质量情况下缩短开发周期。<br>优点：适合工程量小、人力资源少并且开发过程中改动不大的项目<br>缺点：错误发现时间迟，产生的风险代价高</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101714922.png"/>

<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><h5 id="抛弃式（一次性）原型不作为最终产品使用"><a href="#抛弃式（一次性）原型不作为最终产品使用" class="headerlink" title="抛弃式（一次性）原型不作为最终产品使用"></a>抛弃式（一次性）原型不作为最终产品使用</h5><blockquote>
<ul>
<li>降低项目中的风险，看看是否可以做些什么。（优势）</li>
<li>捕获需求，即客户是否可以喜欢GUI。（优势）</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li><p>资源可能会被浪费，因此需要控制</p>
</li>
<li><p>需要良好的项目管理</p>
</li>
<li><p>需要与客户进行良好的沟通</p>
</li>
<li><p>什么时候是停止开发原型的好时机</p>
</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101803536.png"/>

<h5 id="演化式"><a href="#演化式" class="headerlink" title="演化式"></a>演化式</h5><p>逐步改进和细化原型，将原型进化为最终系统</p>
<p>优势</p>
<blockquote>
<ul>
<li>客户可以看到他们想要的更改。</li>
<li>非常适合用户界面的接受。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在文档方面非常薄弱（即系统不断变化）。</li>
<li>需要强有力的项目控制，领导者需要监控发展。</li>
<li>什么时候是停止发展和完成项目的好时机可能会导致系统结构不良。</li>
<li>可能需要特殊的开发人员。</li>
</ul>
</blockquote>
<h6 id="演化过程模型（Evolutionary-Model）"><a href="#演化过程模型（Evolutionary-Model）" class="headerlink" title="演化过程模型（Evolutionary Model）"></a>演化过程模型（Evolutionary Model）</h6><p>演化模型是迭代的过程模型。</p>
<p>原型开发（prototyping ）：当需求很模糊的时候，原型开发可以帮助软件开发人员和利益相关者更好地理解究竟需要做什么。<br><strong>优点：</strong><br>开发者与用户充分交流，可以澄清模糊需求，需求定义比其他模型好得多<br>开发过程与用户培训过程同步<br>为用户需求的改变提供了充分的余地<br>开发风险低，产品柔性好<br>开发费用低，时间短<br>系统易维护，对用户更友好</p>
<p><strong>缺点：</strong><br>1、 没有考虑软件的整体质量和长期的可维护性。<br>2、 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>3、 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。<br>适用范围：<br>尽管原型可以用作独立的流程模型，但它更常用作一种可以在任何流模型的上下文中实现的技术。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715254.png"/>

<h5 id="增量型"><a href="#增量型" class="headerlink" title="增量型"></a>增量型</h5><p>在建立软件总体设计基础上，采用增量开发方法，使原型成为最终系统。</p>
<p>优势：</p>
<blockquote>
<p>有利于将一个更大的系统分解成多个部分，从而使组件更容易构建。<br>客户对系统的看法是分阶段的，所以没有“大爆炸”的方法。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>需要良好的沟通和协议。<br>需要良好的项目管理、控制和监控工作。</p>
</blockquote>
<h6 id="增量过程模型（Incremental-Model）"><a href="#增量过程模型（Incremental-Model）" class="headerlink" title="增量过程模型（Incremental Model）"></a>增量过程模型（Incremental Model）</h6><p><strong>增量模型融合了瀑布模型的基本成分和原型的迭代特征</strong></p>
<p>增量过程模型侧重于每一个增量都提交一个可以运行的产品。<br><strong>优点：</strong></p>
<ol>
<li>能在较短的时间内向用户提交可完成部分工作的产品。</li>
<li>逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
<li>规避技术风险</li>
<li>可并行开发构件，加快开发的进度</li>
<li>对于在业务截止日期之前完全实施的人员配置非常有用。<br><strong>缺点：</strong><br>（1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；<br>（2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。</li>
</ol>
<p><strong>适用范围：</strong><br>（1）进行已有产品升级或新版本开发，增量模型是非常适合的；<br>（2）对完成期限严格要求的产品，可以使用增量模型；<br>（3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。<br>（4）项目在既定的商业要求期限之前不可能找到足够的开发人员</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715951.png"/>

<h4 id="统一过程（Unified-Process）"><a href="#统一过程（Unified-Process）" class="headerlink" title="统一过程（Unified Process）"></a>统一过程（Unified Process）</h4><p><strong>统一过程模型</strong><br>统一过程模型是一种“用例驱动、以体系结构为核心、迭代及增量”的软件 过程框架，由 UML 方法和工具支持。它是一种增量模型，定义了五个阶段：<br>a、起始阶段，包括用户沟通和计划活动，强调定义和细化用例<br>b、细化阶段，包括用户沟通和建模活动，重点是创建分析和设计模型。<br>c、构件阶段，细化模型设计，并将设计模型转化为软件构件实现<br>d、转化阶段，将软件从开发人员传递给最终用户，并由用户完成 beta 测试和验收测试<br>e、生产阶段，持续地监控软件的运行，并提供技术支持。</p>
<p><strong>优点：</strong><br>1.任何功能开发后就进入测试过程，及早进行验证<br>2.早期风险识别，采取预防措施</p>
<p><strong>缺点：</strong></p>
<ol>
<li>需求必须在开始之前完全弄清楚，否怎有可能在架构上出现错误</li>
<li>必须有严格的过程管理，以免使过程退化为原始的试→错→改模式</li>
<li>如果不加控制的让用户过早接触没有测试完全、版本不稳定的产品可能对用户和开发团队都带来负面的影响。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101717848.png"/>

<h4 id="RAD模型"><a href="#RAD模型" class="headerlink" title="RAD模型"></a>RAD模型</h4><p>通过使用“基于构件的建造方法”赢得快速开发</p>
<ul>
<li><p>业务建模</p>
</li>
<li><p>数据建模</p>
</li>
<li><p>过程建模</p>
</li>
<li><p>应用生成</p>
</li>
<li><p>测试及反复</p>
</li>
</ul>
<p>特点：</p>
<blockquote>
<ul>
<li>强调极短的开发时 间，每一个主要功能在不到三个月的时间内完成。</li>
<li>强调复用。</li>
</ul>
</blockquote>
<p> 缺点：</p>
<blockquote>
<ul>
<li>对于大型的的项目，RAD需要足够的人力资源以建立足够的RAD组。</li>
<li>RAD要求开发者和客户承担在一个很短的时间框架下完成一个系统所必要的快速活动。</li>
<li>并非所有应用都适合RAD,不适合技术风险很高的情况</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101807461.png"/>

<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>主要适用于内部开发的大规模软件项目</p>
<ul>
<li>客户交流一建立开发者和客户之间有效的通信所需的任务。</li>
<li>计划一定义资源、进度及其他相关项目所需要的任务。</li>
<li>风险分析一评估技术的及管理的风险所需的任务。</li>
<li>工程一建立应用的一个或多个表示所需要的任务。</li>
<li>构造及发布一构造、测试、安装和提供用户支持（如文档及培训）所需的任务</li>
<li>客户评估一基于对在工程阶段产生的或在安装阶段实现的软件表示的评估，获得客户反馈所需要的任务。</li>
</ul>
<p>优点：</p>
<blockquote>
<p>随着过程进展演化，开发者和客户能够更好地理解和对待每一个级别上的<br>风险，使用原型实现作为降低风险的机制。<br>更真实地反映了现实世界。<br>如应用得当，能在风险变成问题之前降低它。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>模型的成功依赖于风险评估的专门技术，<br>是一个较新的模型，功效的确定尚需若干年时间。</p>
</blockquote>
<h3 id="敏捷的软件过程模型"><a href="#敏捷的软件过程模型" class="headerlink" title="敏捷的软件过程模型"></a>敏捷的软件过程模型</h3><h4 id="敏捷开发-敏捷宣言（Agile-development-manifesto）："><a href="#敏捷开发-敏捷宣言（Agile-development-manifesto）：" class="headerlink" title="敏捷开发-敏捷宣言（Agile development manifesto）："></a><strong>敏捷开发-敏捷宣言（Agile development manifesto）：</strong></h4><p><strong>应付变化而来的开发模型</strong></p>
<ul>
<li><strong>个体和互动 高于 流程和工具</strong>：个人和他们之间的交流胜过了开发过程和工具</li>
<li><strong>工作的软件 高于 详尽的文档</strong>：可运行的软件胜过了宽泛的文档</li>
<li><strong>客户合作 高于 合作谈判</strong>：客户合作胜过了合同谈判</li>
<li><strong>响应变化 高于 遵循计划</strong>：对变更的良好响应胜过了按部就班地遵循计划</li>
</ul>
<h4 id="极限编程（Extreme-Programming-XP-）"><a href="#极限编程（Extreme-Programming-XP-）" class="headerlink" title="极限编程（Extreme Programming (XP)）"></a>极限编程（Extreme Programming (XP)）</h4><p>极限编程是敏捷软件开发使用最广泛的一个方法。</p>
<ol>
<li><p>策划：<br>开始创造“用户故事”<br>敏捷团队评估每个故事并分配一个成本（开发周数）<br>故事被分组到一个可交付增量<br>承诺在交付日期进行<br>在第一次递增之后，“项目速度”用于帮助估计后续发行版本的发布日期和进度安排，确定是否对整个开发项目中的所有故事有过分承诺。</p>
</li>
<li><p>设计<br>遵循KIS（保持简洁）原则<br>对于困难的设计问题，建议创建“尖峰解决方案” - 一个设计原型<br>鼓励“重构”： 重构是以不改变代码外部行为而改进其内部结构的方式来修改软件系统的过程。</p>
<blockquote>
<p>重构是XP的一个重要组成部分。所谓重构是指在 不改变代码外在行为的前提下对代码做出的修改，以 改进代码的内部结构。重构是一种有纪律的、经过训 练的、有条不紊的代码整理方法，可以将整理过程中 不小心引入错误的可能性降到最低。从本质上说，重 构就是在代码写好之后改进它的设计。 重构的节奏：重新推理、小的更改、重新推理、 小的更改、重新推理…</p>
</blockquote>
</li>
<li><p>编码<br>在编码开始之前，建议对故事进行单元测试<br>鼓励“结队编程”</p>
<blockquote>
<p>结对编程是让两个人共同设计和开发代码的实践。结对者是全职合作者，轮流执行键入和监视；这提供了持续的设计和代码评审。<br>不是两个人做一个人的事情。</p>
</blockquote>
<p>连续集成<br>有助于避免兼容性和接口问题，建立能及早发现错误的“冒烟测试”</p>
<blockquote>
<p>​	持续集成的思想是任何时候，只要有一项任务完成，就集成新代码，构造系统并测试。持续集成是每日构建\每晚构建的一种极限形式，是XP的重要基础。<br>​	每日构建\每晚构建是将一个软件项目的所有最新代码取出，从头开始编译、链接，用安装软件包将链接好的程序安 装好，运行安装后的软件，使用测试工具对主要功能进行测 试，发现错误并报告错误的完整过程。<br>​	让开发人员在第一时间了解到软件的错误，并迅速排除错误，是每日构建\每晚构建最重要的目标之一。<br>​	每日构建\每晚构建必须出日志和报告，并发布构建结<br>果的有关信息，最好能够使用自动化工具发出电子邮件通知</p>
</blockquote>
</li>
<li><p>所有的单元测试每天都执行<br>“验收测试”，由客户规定技术条件，并且着眼于客户可见的、可评审的系统级的特征和功能。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730576.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730350.png"/></li>
</ol>
<h4 id="橄榄球模型（Scrum）"><a href="#橄榄球模型（Scrum）" class="headerlink" title="橄榄球模型（Scrum）"></a>橄榄球模型（Scrum）</h4><ul>
<li>待定项(backlog)——一个能为用户提供商业价值的项目需求或特性的优先級列表。待定项中可以随时加入新项(这就是变更的引入)。产品经理根据需要评估待定项并修改优先级。</li>
<li>冲刺(sprint) ——一些工作单元组成，这些工作单元是达到待定项中定义的需求所必需的，并且必须能在预定的时间段( time-box9)内(一般情况下为30天)完成。冲刺过程中不允许有变更(例如积压工作项)。因此，冲刺给开发团队成员的工作提供了短期但稳定的环境。</li>
<li>Scrum例会——Serum 团队每天召开的短会(一般情况为15分钟)，会上所有成员要回答三个问题[Noy02]:<ol>
<li>上次例会后做了什么?</li>
<li>遇到了什么困难?</li>
<li>下次例会前计划做些什么</li>
</ol>
</li>
<li>演示——交付软件，客户进行评估</li>
</ul>
<p>燃尽图：衡量在一个Sprint时间段内剩余的Sprint待办事项列表条目。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101759647.png"/>

<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="软件项目管理的定义"><a href="#软件项目管理的定义" class="headerlink" title="软件项目管理的定义"></a>软件项目管理的定义</h2><p>软件项目管理是为了使软件项目能够顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p>
<p><strong>对软件工程项目</strong>：他所涉及的范围覆盖了整个软件工程过程</p>
<p><strong>这种项目挂你在技术工作开始之前就应该开始</strong>，在软件从概念到实现的过程中<strong>继续进行</strong>，当软件工程过程最后结束时<strong>才终止</strong></p>
<h2 id="管理的四要素"><a href="#管理的四要素" class="headerlink" title="管理的四要素"></a>管理的四要素</h2><ul>
<li>人员People：成功项目的重要因素</li>
<li>产品Product：要开发的软件</li>
<li>过程Process：软件工程的框架活动，包括了任务、里程碑、工作一起质量保证点</li>
<li>项目Project：开发软件所需要的所有工作</li>
</ul>
<h2 id="项目管理小组结构"><a href="#项目管理小组结构" class="headerlink" title="项目管理小组结构"></a>项目管理小组结构</h2><ul>
<li><p>民主分散式（democratic decentralized，DD）【比以下两种缺陷要多】</p>
<p>没有固定的负责人，适合难度比较高、交付期限很长及生存期较长的项目，最适合于解决模块化程度比较低的问题，因为需要通信</p>
</li>
<li><p>控制分散式（controlled decentralized，CD）</p>
<p>CD(控制分散式）:有一个固定的负责人，若有子负责人，<strong>子负责人和总负责人的通信是垂直的</strong>，而个人间的通信是水平的，适合交付期限较长、比较简单的项目</p>
</li>
<li><p>控制集中式（controlled centralized，CC）</p>
<p>CC(控制集中式）:负责人和小组成员之间的通信是垂直的，适合解决<strong>交付期限比较严格的、简单的、模块化程度高</strong>的项目</p>
</li>
</ul>
<h3 id="小组通信路径"><a href="#小组通信路径" class="headerlink" title="小组通信路径"></a>小组通信路径</h3><p> <em>C &#x3D; (n * (n-1))&#x2F;2</em></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121025899.png"/>

<h3 id="软件范围"><a href="#软件范围" class="headerlink" title="软件范围"></a>软件范围</h3><ul>
<li>在进行项目计划之前，软件开发者和客户必须一起定义产品的目的和范围考虑可选的解决方案，标识技术和管理的约束。</li>
<li>没有这些信息，就不可能进行合理的（准确的）成本估算、有效的风险评估、适当的项目任务划分或是可管理的项目进度安排。</li>
<li>软件范围是软件项目管理的第一个活动。</li>
</ul>
<h1 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h1><h2 id="软件度量的目的"><a href="#软件度量的目的" class="headerlink" title="软件度量的目的"></a>软件度量的目的</h2><ul>
<li>改进过程</li>
<li>提高产品的质量</li>
</ul>
<h2 id="度量的作用"><a href="#度量的作用" class="headerlink" title="度量的作用"></a>度量的作用</h2><p>有效地定量地进行管理</p>
<h2 id="过程度量"><a href="#过程度量" class="headerlink" title="过程度量"></a>过程度量</h2><ul>
<li>在软件发布之前的错误数的测量</li>
<li>交付给最终用户并由最终用户报告的缺陷的测量</li>
<li>交付的工作产品（生产率）的测量</li>
<li>花费的工作量的测量</li>
<li>花费的时间的测量</li>
<li>与进度是否一致的测量</li>
</ul>
<h2 id="度量的方式"><a href="#度量的方式" class="headerlink" title="度量的方式"></a>度量的方式</h2><h3 id="物理度量方式"><a href="#物理度量方式" class="headerlink" title="物理度量方式"></a>物理度量方式</h3><p>直接测量</p>
<p>间接测量</p>
<h3 id="软件度量方式"><a href="#软件度量方式" class="headerlink" title="软件度量方式"></a>软件度量方式</h3><p>直接测量</p>
<ul>
<li>软件工程过程的直接测量包括所投入的成本和工作量。</li>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<p>间接测量</p>
<ul>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<h2 id="度量的分类"><a href="#度量的分类" class="headerlink" title="度量的分类"></a>度量的分类</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121414638.png"/>

<ul>
<li>需要注意的是：在表格中记载的工作量和成本是整个软件工程的活动（分析、设计、编码和测试）,<strong>而不仅仅是编码活动</strong></li>
<li>对于每一个项目，可以根据表格中列出的<strong>基本数据</strong>计算简单的<strong>面向规模</strong>的生产率和质量等的度量</li>
<li>根据表格可以对所有的项目计算出的有用度量：<ul>
<li>生产率&#x3D;<strong>KLOC</strong>&#x2F;PM(人月）</li>
<li>质量&#x3D;错误数&#x2F;<strong>KLOC</strong></li>
<li>成本&#x3D;元&#x2F;<strong>LOC</strong></li>
<li>文档&#x3D;文档页数&#x2F;<strong>KLOC</strong></li>
</ul>
</li>
</ul>
<h3 id="基于FP的软件度量"><a href="#基于FP的软件度量" class="headerlink" title="基于FP的软件度量"></a>基于FP的软件度量</h3><ul>
<li>每个FP的错误数（Errors per FP)</li>
<li>每个FP的缺陷数（Defects per FP)</li>
<li>每个FP的花费（$ per FP)</li>
<li>每个FP的文档页数（Pages of documentation per FP)</li>
<li>每人月完成的FP数（FP per person-month)</li>
</ul>
<h2 id="度量的计算"><a href="#度量的计算" class="headerlink" title="度量的计算"></a>度量的计算</h2><p>计算功能点，使用如下的计算公式<br>$$<br>FP &#x3D; 总计算值*[0.65+0.01*∑(Fi)]<br>$$<br>总计数值是所有加权计数项的和</p>
<p>Fi（i&#x3D;1…14）是复杂性校正值，它们应通过逐一回答如下提问来确定。</p>
<blockquote>
<p>Fi的取值0..5:<br>0没有影响	1微小影响<br>2轻度			3中度<br>4显著			5重大</p>
</blockquote>
<p>∑(Fi)是求和函数</p>
<h2 id="软件质量度量指标"><a href="#软件质量度量指标" class="headerlink" title="软件质量度量指标"></a>软件质量度量指标</h2><ul>
<li><p>正确性</p>
</li>
<li><p>可维护性</p>
</li>
<li><p>完整性</p>
<ul>
<li><p>危险性是特定类型的攻击将在一给定时间内发生的概率。<br>安全性是排除特定类型攻击的概率。</p>
</li>
<li><p>一个系统的完整性可定义为<br>$$<br>完整性&#x3D;∑[1-危险性×(1-安全性）]<br>$$<br>其中，对每一个攻击的危险性和安全性都进行累加。</p>
</li>
</ul>
</li>
<li><p>可用性</p>
</li>
</ul>
<h2 id="DRE缺陷排除效率"><a href="#DRE缺陷排除效率" class="headerlink" title="DRE缺陷排除效率"></a>DRE缺陷排除效率</h2><p>DRE是对质量保证及控制活动中滤除缺陷能力的一个测量</p>
<h1 id="软件风险"><a href="#软件风险" class="headerlink" title="软件风险"></a>软件风险</h1><h2 id="风险及风险管理"><a href="#风险及风险管理" class="headerlink" title="风险及风险管理"></a>风险及风险管理</h2><ul>
<li>风险：所有在软件开发过程中带来负面影响的问题，是一个潜在的问题</li>
<li>风险分析和管理是标识风险、评估其发生的概率、估算其影响并建立问题实际发生情形下的应急计划，是一系列帮助软件小组理解和管理部确定的步骤</li>
</ul>
<h2 id="被动的风险策略"><a href="#被动的风险策略" class="headerlink" title="被动的风险策略"></a>被动的风险策略</h2><p>被动风险策略：对风险不闻不问，直到发生了错误项项目组才赶紧采取行动，试图迅速地纠正错误。</p>
<h2 id="主动的风险策略"><a href="#主动的风险策略" class="headerlink" title="主动的风险策略"></a>主动的风险策略</h2><p>主动风险策略：在技术工作开始之前就已经启动，标识出潜在的风险，评估出现的概率及产生的影响，且按重要性加以排序。主要目标预防风险，需要建立一个应急计划，使必要时能够以可控的及有效地方式做出反应。</p>
<h2 id="风险的类型"><a href="#风险的类型" class="headerlink" title="风险的类型"></a>风险的类型</h2><h3 id="项目风险"><a href="#项目风险" class="headerlink" title="项目风险"></a>项目风险</h3><p>威胁到项目技术</p>
<p>潜在的预算、进度、人力资源、客户及需求等方面的问题</p>
<h3 id="技术风险"><a href="#技术风险" class="headerlink" title="技术风险"></a>技术风险</h3><p>威胁到要开发软件的质量和交付时间</p>
<p>潜在的设计、实现、接口、验证和维护等方面的问题</p>
<h3 id="商业风险"><a href="#商业风险" class="headerlink" title="商业风险"></a>商业风险</h3><p>威胁到要开发软件的生存能力</p>
<p>商业风险的分类</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>开发了一个没有人真正需要的优秀产品或系统</td>
<td>市场风险</td>
</tr>
<tr>
<td>开发的产品不再符合公司的整体商业策略</td>
<td>策略风险</td>
</tr>
<tr>
<td>建造了一个销售部门不知道如何去出售的产品</td>
<td>销售风险</td>
</tr>
<tr>
<td>由于重点转移或人员的变动而失去了高级管理层的支持</td>
<td>管理风险</td>
</tr>
<tr>
<td>没有得到预算或人力上的保证。</td>
<td>预算风险</td>
</tr>
</tbody></table>
<h2 id="风险管理的步骤"><a href="#风险管理的步骤" class="headerlink" title="风险管理的步骤"></a>风险管理的步骤</h2><h3 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h3><ul>
<li>风险识别的方法一建立风险条目检查表。</li>
<li>产品规模–与要建造或要修改的软件的总体规模相关的经验；</li>
<li>商业影响–与管理或市场所加的约束相关的风险；</li>
<li>客户特征–与客户的素质以及开发者和客户及时通信的能力相关的风险；</li>
<li>过程定义–与软件过程被定义的程度以及他们被开发组织所遵守的程度相关的风险；</li>
</ul>
<h3 id="风险预测"><a href="#风险预测" class="headerlink" title="风险预测"></a>风险预测</h3><p>风险预测从两个方面评估风险：风险发生的可能性或概率、风险发生所产生的后果（评估风险影响）。</p>
<h4 id="评估风险影响"><a href="#评估风险影响" class="headerlink" title="评估风险影响"></a>评估风险影响</h4><p>风险显露度（risk exposure)<br>$$<br>RE &#x3D; P * C<br>$$<br>其中，P是风险发生的概率，c是风险发生时带来的项目成本</p>
<blockquote>
<p>一个例子：计划了60个可复用构件，其中只有70%可能被使用，剩下的要重新定制开发，已知构件平均是100LOC,每个LOC的成本是14美元，假设该风险发生的概率是80%,计算风险显露度RE。</p>
</blockquote>
<p>$$<br>RE &#x3D; 80%*C<br>$$</p>
<p>$$<br>C &#x3D; 60 *(1-70%)<em>100</em>14<br>$$</p>
<h1 id="项目进度安排与跟踪"><a href="#项目进度安排与跟踪" class="headerlink" title="项目进度安排与跟踪"></a>项目进度安排与跟踪</h1><h2 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527813.png"/>

<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527622.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527818.png"/></p>
</blockquote>
<h2 id="项目进度安排方法"><a href="#项目进度安排方法" class="headerlink" title="项目进度安排方法"></a>项目进度安排方法</h2><h3 id="关键路径方法（CPM）"><a href="#关键路径方法（CPM）" class="headerlink" title="关键路径方法（CPM）"></a>关键路径方法（CPM）</h3><p>在关键路径上的活动才是按时完成任务的关键</p>
<h3 id="项目-进度计划-评估和评审技术-PERT）"><a href="#项目-进度计划-评估和评审技术-PERT）" class="headerlink" title="项目(进度计划)评估和评审技术(PERT）"></a>项目(进度计划)评估和评审技术(PERT）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530592.png"/>

<h3 id="获得值分析"><a href="#获得值分析" class="headerlink" title="获得值分析"></a>获得值分析</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534873.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530680.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121531061.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121533877.png"/>

<h1 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h1><h2 id="数据流图DFD"><a href="#数据流图DFD" class="headerlink" title="数据流图DFD"></a>数据流图DFD</h2><ul>
<li>面向数据流进行需求分析的方法</li>
<li>适合于数据处理类型软件的需求分析</li>
<li>用抽象模型的概念，按照软件内部数据传递、变换的关系，自项向下逐层分解，直到满足所有的功能要求。<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534481.png"/></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121535618.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121536102.png"/>

<h2 id="数据字典DD"><a href="#数据字典DD" class="headerlink" title="数据字典DD"></a>数据字典DD</h2><ul>
<li>数据字典对数据流图中的各种成分起注解、说明作用，给这些成分赋以实际的内容。</li>
<li>数据字典与数据流图配合，能清楚地表达数据处理的要求。</li>
<li>条目：数据流、数据元素、数据存储、数据加工、外部实体。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121537663.png"/>

<h2 id="结构化英语"><a href="#结构化英语" class="headerlink" title="结构化英语"></a>结构化英语</h2><ul>
<li>顺序结构</li>
<li>重复结构</li>
<li>判定结构</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121538728.png"/>

<h1 id="结构化设计概述"><a href="#结构化设计概述" class="headerlink" title="结构化设计概述"></a>结构化设计概述</h1><h2 id="分析模型到设计模型"><a href="#分析模型到设计模型" class="headerlink" title="分析模型到设计模型"></a>分析模型到设计模型</h2><ul>
<li>数据设计：侧重于数据结构的定义</li>
<li>体系结构设计：定义软件系统各主要成份之间的关系</li>
<li>接口设计：描述了软件内部、软件和协作系统之间以及软件同人之间如何通信</li>
<li>过程设计：则是把结构成份转换成软件的过程性描述</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>结构图反映了模块之间的层次调用关系和联系：它以特定的符号表示模块、模块间的调用关系和模块间信息的传递</p>
<h3 id="模块的调用关系"><a href="#模块的调用关系" class="headerlink" title="模块的调用关系"></a>模块的调用关系</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542806.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542853.png"/>

<ul>
<li>模块独立性，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其它的模块的接口是简单的。</li>
<li>例如，若一个模块只具有单一的功能且与其它模块没有太多的联系，则称此模块具有模块独立性。</li>
<li>一般采用两个准则度量模块独立性。即模块间藕合和模块内聚。</li>
<li>藕合是模块之间的互相连接的紧密程度的度量。</li>
<li>内聚是模块功能强度（一个模块内部各个元素彼此结合的紧密程度）的度量。</li>
<li>模块独立性比较强的模块应是高内聚低精合的模块。</li>
</ul>
<h3 id="模块间的耦合"><a href="#模块间的耦合" class="headerlink" title="模块间的耦合"></a>模块间的耦合</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121545118.png"/>

<h3 id="体系结构设计-系统结构模块"><a href="#体系结构设计-系统结构模块" class="headerlink" title="体系结构设计(系统结构模块)"></a>体系结构设计(系统结构模块)</h3><ul>
<li>传入模块</li>
<li>传出模块</li>
<li>变换模块</li>
<li>协调模块</li>
</ul>
<h3 id="模块的独立性"><a href="#模块的独立性" class="headerlink" title="模块的独立性"></a>模块的独立性</h3><table>
<thead>
<tr>
<th>模块间耦合形成</th>
<th>可读性</th>
<th>错误扩散能力</th>
<th>可修改性</th>
<th>通用性</th>
</tr>
</thead>
<tbody><tr>
<td>数据耦合</td>
<td>好</td>
<td>弱</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>控制耦合</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>公共耦合</td>
<td>不好</td>
<td>强</td>
<td>不好</td>
<td>不好</td>
</tr>
<tr>
<td>内容耦合</td>
<td>差</td>
<td>最强</td>
<td>最差</td>
<td>最差</td>
</tr>
</tbody></table>
<ul>
<li>在系统结构图中的模块</li>
<li>传入模块——从下属模块取得数据，经过某些处理，再将其传送给上级模 块。它传送的数据流叫做逻辑输入数据流。</li>
<li>传出模块——从上级模块获得数据，进行某些处理，再将其传送给下属模 块。它传送的数据流叫做理输出数据流。</li>
<li>变换模块——它从上级模块取得数据，进行特定的处理，转换成其它形式， 再传送回上级模块。它加工的数据流叫做变换数据流。</li>
<li>协调模块——对所有下属模块进行协调和管理的模块。</li>
</ul>
<h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121546537.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552195.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552021.png"/>

<h1 id="面向对象和UML"><a href="#面向对象和UML" class="headerlink" title="面向对象和UML"></a>面向对象和UML</h1><h2 id="面向对象方法-1"><a href="#面向对象方法-1" class="headerlink" title="面向对象方法"></a>面向对象方法</h2><h3 id="传统分析设计方法"><a href="#传统分析设计方法" class="headerlink" title="传统分析设计方法"></a>传统分析设计方法</h3><ul>
<li>以功能为中心的软件开发方法（结构化方法）</li>
<li>低内聚，高精合，缺乏灵活性和可维护性</li>
<li>分析与设计阶段采用的概念和表示不一致</li>
<li>以数据为中心的软件开发方法（信息建模方法）</li>
<li>对功能的处理较弱，不适合具有复杂功能的系统</li>
</ul>
<h3 id="类（抽象，分类）"><a href="#类（抽象，分类）" class="headerlink" title="类（抽象，分类）"></a>类（抽象，分类）</h3><p>类是具有共同属性和操作的对象的集合，对象是类的一个实例，类用于创建对象。</p>
<p>体现了抽象及分类原则，是人们分析问题的基本方法</p>
<ul>
<li><p>抽象：忽路事物的非本质特征，抽取共同的本质特征</p>
</li>
<li><p>分类：把具有共性的事物划分为一类</p>
</li>
</ul>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性：特殊类可以对继承来的属性和操作做出自己的解释，即在继承关系的类层次结构中可以定义同名操作或属性，形成同一操作或属性的多种形态，这样可以按不同的行为响应同一个消息。<br>多态性进一步体现了信息隐蔽的原则，可以实现接口的独立封装</p>
<h3 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555429.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555544.png"/>

<h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><h3 id="对象建模"><a href="#对象建模" class="headerlink" title="对象建模"></a>对象建模</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121557058.png"/>

<h3 id="协作图-x2F-通信图"><a href="#协作图-x2F-通信图" class="headerlink" title="协作图&#x2F;通信图"></a>协作图&#x2F;通信图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121558079.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">数学-线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 09:29:59" itemprop="dateCreated datePublished" datetime="2023-03-09T09:29:59+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 13:32:28" itemprop="dateModified" datetime="2023-03-30T13:32:28+08:00">2023-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>本视频基于【2023考研数学汤家凤线性代数基础课程】</strong></p>
<p>[第一章行列式.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==">https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==</a></p>
<p>[第二章矩阵.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==">https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==</a></p>
<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p>核心1:线性方程级</p>
<blockquote>
<table>
<thead>
<tr>
<th>工具</th>
</tr>
</thead>
<tbody><tr>
<td>行列式</td>
</tr>
<tr>
<td>矩阵</td>
</tr>
<tr>
<td>向量</td>
</tr>
</tbody></table>
</blockquote>
<p>核心2:矩阵对角比</p>
<blockquote>
<p>特征值与特征向量</p>
</blockquote>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h2><p>i,j ∈ N（自然数）且 i ≠ j</p>
<blockquote>
<p>这样就会形成两种情况</p>
<p>i &lt; j （i ，j ）即顺序</p>
<p>i &gt; j  （i，j）即逆序</p>
</blockquote>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>设<br>$$<br>i,i_2,…,i_n 为1，2，…n的一个排列i_1,i_2,…i_n含逆序个数之和称为逆序数<br>$$<br>记做<br>$$<br>\tau(i_1,i_2,…,i_n)<br>$$</p>
<blockquote>
<p>例如<br>$$<br>\tau（5,1,4,2,3）&#x3D; 6<br>$$<br>那其中这个6就成为逆序数</p>
</blockquote>
<h2 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h2><p>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n} \<br>…\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn} \<br>\end{matrix}\right|<br>&amp; 称为n阶行列式<br>$$</p>
<p>行列式计算</p>
<p>此处以三阶行列式为例<br>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; a_{13} \<br>a_{21} &amp; a_{22} &amp; a_{23} \<br>a_{31} &amp; a_{32} &amp; a_{33} \<br>\end{matrix}\right|<br>$$</p>
<p>$$<br>D&#x3D;+a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}+a_{12}a_{13}a_{21}+a_{32}-a_{13}a_{22}a_{31}<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
