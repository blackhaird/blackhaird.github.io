<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MEIDE&#39;S BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MEIDE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">JAVA面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-10 13:26:38 / 修改时间：14:09:41" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/" class="post-title-link" itemprop="url">考研政治复习(1)-马原</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-13 08:14:01" itemprop="dateCreated datePublished" datetime="2023-10-13T08:14:01+08:00">2023-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-22 17:00:37" itemprop="dateModified" datetime="2023-10-22T17:00:37+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%94%BF%E6%B2%BB/" itemprop="url" rel="index"><span itemprop="name">政治</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><span style="color:red">红色</span>：重点内容<br><span style="color:orange">橙色</span>：下述内容的归纳总结</p>
<h1 id="马克思主义原理"><a href="#马克思主义原理" class="headerlink" title="马克思主义原理"></a>马克思主义原理</h1><h2 id="马克思主义的创立"><a href="#马克思主义的创立" class="headerlink" title="马克思主义的创立"></a>马克思主义的创立</h2><h3 id="马克思主义产生的社会根源、阶级基础和思想渊源"><a href="#马克思主义产生的社会根源、阶级基础和思想渊源" class="headerlink" title="马克思主义产生的社会根源、阶级基础和思想渊源"></a>马克思主义产生的社会根源、阶级基础和思想渊源</h3><ol>
<li><p>资本主义经济的发展为马克思主义的产生提供了<strong>经济</strong>、<strong>社会历史条件</strong></p>
</li>
<li><p><strong>无产阶级</strong>（工人阶级）在反抗资产阶级的斗争中逐步走向<strong>自觉</strong>（跟自发不一样，自发是自然发生，无意识），对科学理论的指导提出了强烈的需求（马克思主义产生的<strong>阶级基础和实践基础</strong>）</p>
</li>
<li><p>马克思、恩格斯的革命实践和对人类文明成果的继承与创新（主观条件）</p>
<p><strong>19世纪西欧三大先进思潮（德国古典哲学、英国古典政治经济学、英法两国的空想社会主义）</strong>为马克思主义的创立提供了直接的理论来源。<strong>19世纪的三大科学发现、即细胞学说、能量守恒与转化定律生物进化论，为马克思主义的产生提供了自然科学前提</strong></p>
</li>
</ol>
<h3 id="马恩列重要著作（第一页重点）"><a href="#马恩列重要著作（第一页重点）" class="headerlink" title="* 马恩列重要著作（第一页重点）"></a>* 马恩列重要著作（第一页重点）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310131619588.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310180939679.png"/>

<h3 id="马克思主义的创立-1"><a href="#马克思主义的创立-1" class="headerlink" title="马克思主义的创立"></a>马克思主义的创立</h3><p>一国胜利论：由于资本主义的政治发展不平衡，提出社会主义革命可能会在<strong>一国或者数国首先发生并取得胜利</strong>的论断，俄国的十月革命的胜利使其变成可现实-《国家与革命》</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181051090.png"/>

<p>毛中特补充下属内容</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181054418.png"/>

<h3 id="马克思主义的鲜明特征"><a href="#马克思主义的鲜明特征" class="headerlink" title="* 马克思主义的鲜明特征"></a>* 马克思主义的鲜明特征</h3><p>科发民革践</p>
<ol>
<li><p>科学性</p>
<p>马克思主义是对自然、社会和人类思雏<strong>发展本质和规律的正确反映</strong>。马克思主义具有科学的世界观和方法论基础，即辩证唯物主义和历史唯物主义，这是马克思主义的一个<strong>突出特征和理论优势</strong>，也是马克思主义科学性的重要体现。</p>
</li>
<li><p>发展性</p>
<p>马克思主义是不断发展的学说，具有与时俱进的理论品质。</p>
</li>
<li><p>人民性</p>
<p><strong>人民至上</strong>是马克思主义的<strong>政治立场</strong>。马克思主义政党把人民放在心中最高位置，一切奋斗都致力于实现最广大人民的根本利益。<strong>人民性是马克思主义最鲜明的品格</strong>。马克思主义博大精深，<strong>归根到底就是一句话：为人类求解放</strong></p>
</li>
<li><p><strong>革命性</strong>（科学性+革命性【人民+实践+发展】）</p>
<p>马克思主义的鲜明特征，<strong>用一句话概括，就是科学性与革命性的统一</strong>。革命性是马克思主义的内在品质，是马克思主义的人民性、实践性和发展性的应有之义和必然要求。在马克思主义指导革命的过程中，<strong>人民性、实践性和发展性集中地体现为革命性</strong>。【科发民革践】</p>
</li>
<li><p>实践性</p>
<p>马克思主义是从实践中来、到实践中去，在实践中接受检验，并随实践而不断发展的学说。<strong>实践性是马克思主义理论区别于其他理论的显著特征。实践观点是马克思主义首要的和基本的观点。</strong></p>
</li>
</ol>
<h3 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h3><ol>
<li>马克思主义理论区别于其他理论的根本特征：实践性</li>
<li><strong>实践的观点</strong>是马克思主义的基本观点</li>
<li>马克思主义的<strong>本质属性</strong>：人民性</li>
<li>马克思主义追求的<strong>根本价值目标</strong>：实现人的自由而全面的发展</li>
<li><strong>马克思的整个世界观不是教义，而是方法。</strong>它提供的不是现成的教条，是进一步研究的出发点和供这种研究使用的方法。如果选项中出现“现成答案”“现成理想方案”等，多为干扰项。</li>
</ol>
<h4 id="马克思主义的当代价值"><a href="#马克思主义的当代价值" class="headerlink" title="马克思主义的当代价值"></a>马克思主义的当代价值</h4><p>(一）观察当代世界变化的<strong>认识工具</strong><br>(二）指引当代中国发展的<strong>行动指南</strong><br>(三）引领人类杜会进步的<strong>科学真理</strong></p>
<h1 id="世界多样性与物质统一性"><a href="#世界多样性与物质统一性" class="headerlink" title="世界多样性与物质统一性"></a>世界多样性与物质统一性</h1><h2 id="物质及其存在方式"><a href="#物质及其存在方式" class="headerlink" title="物质及其存在方式"></a>物质及其存在方式</h2><h3 id="哲学基本问题及其内容"><a href="#哲学基本问题及其内容" class="headerlink" title="哲学基本问题及其内容"></a>哲学基本问题及其内容</h3><ol>
<li><p>哲学基本问题—<strong>存在和思维的关系问题。</strong></p>
<p>恩格斯第一次明确提出：“全部哲学，特别是近代哲学的重大的基本问题，是<strong>思维和存在的关系问题。</strong></p>
</li>
<li><p>哲学基本问题的内容，包括两个方面：</p>
<p>第一，存在和思维究竞谁是世界的本原，即物<strong>质和精神何者是第一性、何者是第二性的问题</strong>；</p>
<p>第二，思维能否正确认识存在的问题，即<strong>思维和存在有无同一性的问题</strong>。</p>
</li>
<li><p>唯物主义与辩证法要统一起来</p>
<p>只有既坚持唯物主义，又坚持辩证法，才能全面地认识世界的本质和发展规律。只有达到唯物主义和辩证法的内在统一，才能有科学的彻底的唯物主义和科学的彻底的辩证法</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181121085.png"/>

<h4 id="刷题总结-1"><a href="#刷题总结-1" class="headerlink" title="刷题总结"></a>刷题总结</h4><h5 id="哲学基本问题及其内容-1"><a href="#哲学基本问题及其内容-1" class="headerlink" title="哲学基本问题及其内容"></a>哲学基本问题及其内容</h5><ol>
<li>物质第一性，第二性，只是就谁是世界的本原而言的，不要把它与价值混淆。不存在物质和谁比谁更重要，也不涉及谁与社会生活的关系更密切的问题。第一性不等于第一重要，第二性也不等于第二重要。</li>
<li>唯心主义并非都是不可知论。唯物主义哲学家以及坚持唯物主义观点的科学家，都反对不可知论，主张世界是可以认识的；唯心主义既有可知论（如黑格尔），也有不可知论。</li>
<li><strong>唯心主义不等于形而上学，唯物主义不等于辩证法。</strong></li>
<li>唯心主义又分为主观唯心主义和客观唯心主义。主观唯心主义把人的感觉、观念作为世界的本原（关键词：心、观念、感觉、精神等）；客观唯心主义把某种脱离物质、脱离任何个人的精神作为世界的本原（关键词：理、理念、绝对观念、上帝、造物主、绝对精神等)</li>
</ol>
<h5 id="物质"><a href="#物质" class="headerlink" title="物质"></a>物质</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181127848.png"/>

<h3 id="物质-1"><a href="#物质-1" class="headerlink" title="物质"></a>物质</h3><ul>
<li><p><strong>[马克思主义]物质观</strong></p>
<p>马克思批判了旧唯物主义对物质世界的直观、消极的理解，强调要从<strong>能动的<span style="color:red">实践</span>出发</strong>去把握客观世界的意义</p>
</li>
<li><p><strong>[恩格斯]对物质概念作了初步概括</strong></p>
<p>“<strong>物、物质无非是各种物的总和，而这个概念就是从这一总和中抽象出来的。”</strong>这就是说，物质这个名词是一种简称，“我们就用这种简称把感官可感知的许多不同的事物依照其共同的属性概括起来”。这样就明确指出了哲学物质概念与自然科学关于具体的物质形态和物质结构的概念之间<strong>共性与个性</strong>的关系</p>
</li>
<li><p><strong>[列宁]对物质概念作了全面的科学的规定</strong></p>
<p>物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映。”<strong>列宁是从物质与的关系上来把握物质的</strong>。物质范畴是对物质世界多样性和统一性所作的最高的哲学概括。<strong>物质的共同特性（唯一特性）是客观实在性</strong>，它存在于人的之外，可以为人的所反映。换句话说，<strong>所谓物质，就是不依赖于人类的而存在，并能为人类的所反映的客观实在</strong></p>
<p><strong>马克思主义的物质概念是与实践的观点内在统一的。人类的社会生活本质上是实践的</strong></p>
</li>
</ul>
<h4 id="刷题总结-2"><a href="#刷题总结-2" class="headerlink" title="刷题总结"></a>刷题总结</h4><ol>
<li><p>客观实在不一定是人可以直接<strong>看得见、摸得着的实物</strong>（比如磁场就需要通过仪器来感知），重点在干它是存在于人的之外，不以人的意志为转移。</p>
</li>
<li><p>不要混淆<strong>自然科学物质结构概念与哲学物质范畴</strong>，它们是<strong>个别与一般、个性与共性</strong>的关系</p>
<blockquote>
<p>【个别与一般&#x3D;普遍与特殊&#x3D;个性与共性；任何个别都是一般；<span style="color:red">≠整体与部分</span></p>
<p>个别就是各种具体事物（如大李子、张三），一般则是同类事物的共同本质（人）。白马是马的一种，马腿是马的一部分】</p>
</blockquote>
</li>
<li><p>马克思主义以前的旧唯物主义在自然观上是唯物的．在历史观上却陷入唯心，所以是不彻底的“半截子”唯物主义。</p>
</li>
<li><p><span style="color:red"><strong>庸俗唯物主义不是唯物主义</strong></span>，它混淆物质与的界限，认为人的精神活动能力只不过是脑物质的分泌物。</p>
</li>
<li><p>物质和的对立，只有在它们何者为第一性、何者为第二性这一范围内才具有绝对的意义；<strong>超出这个范围，物质和的对立便是相对的。</strong></p>
</li>
<li><p>马克思主义以前的旧唯物主义在自然观上是唯物的，在历史观上却陷入唯心，所以是不彻底的“半截子”唯物主义。马克思主义既看到了自然界的物质性，又以实践为基础揭示了人类社会的物质性，实现了唯物主义自然观和历史观的统一。</p>
</li>
</ol>
<h3 id="物质的存在方式"><a href="#物质的存在方式" class="headerlink" title="物质的存在方式"></a>物质的存在方式</h3><ol>
<li><p>物质与运动</p>
<p>①<strong>运动是物质的根本属性或存在方式</strong>。世界是物质的，而物质是运动的。运动是标志一切事物和现象的变化及其过程的哲学范畴。</p>
<p>②<strong>物质和运动不可分割</strong>。一方面，物质是运动着的物质，脱离运动的物质是不存在的。<strong>设想有不运动的物质，将导致形而上学</strong>。另一方面，运动是物质的运动。<strong>物质是一切运动变化和发展过程的实在基础和承担者</strong>，世界上没有离开物质的运动，任何形式的运动都有它的物质载体，<strong>设想无物质的运动，将导致唯心主义</strong></p>
</li>
<li><p>运动与静止 <span style="color:orange">【绝对运动，相对静止】</span></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181151093.png"/>
</li>
<li><p>物质运动与时间、空间</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181152224.png"/></li>
</ol>
<h4 id="刷题总结-3"><a href="#刷题总结-3" class="headerlink" title="刷题总结"></a>刷题总结</h4><ol>
<li><p>在很多概念的描述中，<strong>“绝对的”与“无条件的”井列，“相对的”与“有条件的”并列</strong></p>
</li>
<li><p>客观实在性是物质的共同特性，运动是物质的根本属性（存在方式)，时空是运动着的物质的基本存在形式【如果单独说时间，空间也对】</p>
</li>
</ol>
<h3 id="物质世界的二重化"><a href="#物质世界的二重化" class="headerlink" title="物质世界的二重化"></a>物质世界的二重化</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310221122090.png"/>

<h2 id="物质与意识的辩证关系"><a href="#物质与意识的辩证关系" class="headerlink" title="物质与意识的辩证关系"></a>物质与意识的辩证关系</h2><p><span style="color:red"><strong>物质决定意识，意识依赖于物质井反作用于物质</strong></span></p>
<h3 id="物质决定意识"><a href="#物质决定意识" class="headerlink" title="物质决定意识"></a>物质决定意识</h3><p><span style="color:orange">意识是人类独有的</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">计算机组成原理(2)-存储与指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-07 19:28:57 / 修改时间：20:21:53" itemprop="dateCreated datePublished" datetime="2023-09-07T19:28:57+08:00">2023-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理笔记"><a href="#计算机组成原理笔记" class="headerlink" title="计算机组成原理笔记"></a>计算机组成原理笔记</h1><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><p>存储器的层次化结构</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071938083.png"/>

<p>存储器的分类–层次</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071938377.png"/>

<p>存储器的分类–存储介质</p>
<ul>
<li>半导体存储器：主存、Cache</li>
<li>磁表面存储器：磁盘、磁带（以磁性材料存储信息）</li>
<li>光存储器：光盘（以光介质存储信息）</li>
</ul>
<p>存储器的分类–存取方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071939552.png"/>

<p>相联存储器既可以按地址又可以按内容寻址。</p>
<p>存储器的分类–信息的可更改性</p>
<ul>
<li>读写存储器–即可读、也可写（如：磁盘、内存、Cache）</li>
<li>只读存储器–只可读，不能写</li>
</ul>
<p>存储器的分类–信息的可保存性</p>
<ul>
<li>断电后，存储信息消失的存储器–易失性存储器 (主存、Cache)</li>
<li>断电后，存储信息依然保持的存储器- – 非易失性存储器(磁盘、光盘)</li>
<li>信息读出后，原存储信息被破坏– -破坏性读出(如DRAM芯片，读出数据后要进行重写</li>
<li>信息读出后，原存储信息不被破坏– - 非破坏性读出(如SRAM芯片、磁盘、光盘)</li>
</ul>
<p>RAM都是易失性存储器；<br>ROM都是非易失性存储器；<br>随机存取存储器：RAM（专有名词）；<br>随机存取：是存取方式，ROM和RAM存取方式都是随机存取。</p>
<h2 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a><strong>存储器的性能指标</strong></h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071939078.png"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071940862.png"/>

<h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><strong>基本的半导体元件及原理</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071940021.png"/>

<p>注：MOS管可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通。</p>
<h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a><strong>存储器芯片的基本原理</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071949374.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071954292.png"/>

<p>驱动器在译码器后面，保证译码器输出的电信号是稳定可靠的。<br>片选线作用：若有多个存储芯片，保证此次读取指定芯片的数据，CS给予低电平，其他芯片为高电平。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071954216.png"/>

<h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a><strong>寻址</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071955963.png"/>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071956297.png"/>

<h2 id="SRAM与DRAM"><a href="#SRAM与DRAM" class="headerlink" title="SRAM与DRAM"></a>SRAM与DRAM</h2><p>DRAM（动态RAM）用于主存，SRAM（静态RAM）用于Cache<br>DRAM芯片：使用栅极电容存储信息<br>SRAM芯片：使用双稳态触发器存储信息</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071957212.png"/>

<blockquote>
<p>1：电容内存储了电荷<br>0：电容内未存储电荷</p>
<p>若触发器里存储的的二进制的1，当字选择线接通之后，BLX输出低电平信号</p>
<p>若触发器里存储的的二进制的0，当字选择线接通之后，BL输出低电平信号<br>写入0：给BL加低电平，给BLX加高电平，呈现A低B高</p>
<p>栅极电容：每个存储元制造成本更低，集成度高，功耗低。电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失，2ms之内必须“刷新”一次（给电容充电）</p>
<p>双稳态触发器：每个存储元制造成本更高，集成度低，功耗大。只要不断电，触发器的状态就不会改变</p>
</blockquote>
<h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a><strong>DRAM的刷新</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071958116.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959175.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959206.png"/>

<p>分散刷新不存在死区</p>
<h3 id="DRAM的地址线复用技术"><a href="#DRAM的地址线复用技术" class="headerlink" title="DRAM的地址线复用技术"></a><strong>DRAM的地址线复用技术</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959879.png"/>

<blockquote>
<p>地址：00000000。<br>同时送行列地址，需要8根地址线。两次送只需要4根地址线。<br>地址线复用技术：地址线是原来的1&#x2F;2（行和列相等）且地址线分行、列两次传送。<br>这里地址线取决于行和列的最大值。<br>地址引脚：log2max{行，列}</p>
</blockquote>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072000322.png"/>

<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072001457.png"/>

<p>EPROM不能作为随机存储器。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072002486.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072004305.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072005955.png"/>

<h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p>现在的计算机</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072006106.png"/>

<p><strong>存储器芯片的输入输出信号</strong></p>
<p>WE头上没有横杠，高电平表示写，低电平表示读。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072007728.png"/>

<h3 id="增加主存的存储字长-位扩展"><a href="#增加主存的存储字长-位扩展" class="headerlink" title="增加主存的存储字长-位扩展"></a><strong>增加主存的存储字长-位扩展</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008374.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008222.png"/>

<h3 id="增加主存的存储字数-字扩展"><a href="#增加主存的存储字数-字扩展" class="headerlink" title="增加主存的存储字数-字扩展"></a><strong>增加主存的存储字数-字扩展</strong></h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a><strong>线选法</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008888.png"/>

<h4 id="译码片选线"><a href="#译码片选线" class="headerlink" title="译码片选线"></a><strong>译码片选线</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072009042.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072010084.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072010580.png"/>

<h3 id="主存容量扩展-字位同时扩展"><a href="#主存容量扩展-字位同时扩展" class="headerlink" title="主存容量扩展-字位同时扩展"></a><strong>主存容量扩展-字位同时扩展</strong></h3><p>①可以存储低四位–（D0、D1、D2、D3）</p>
<p>②可以存储另四位–（D4、D5、D6、D7）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072011694.png"/>

<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014238.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014879.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072015772.png"/></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014088.png"/>

<h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072016516.png"/>

<h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a><strong>双端口RAM</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072016425.png"/>

<h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a><strong>多体并行存储器</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072017237.png"/>

<h3 id="应该取几个“体”"><a href="#应该取几个“体”" class="headerlink" title="应该取几个“体”"></a><strong>应该取几个“体”</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072017662.png"/>

<blockquote>
<p>当m&#x3D;T&#x2F;r时，存取流水线的效率最高，存储体的数量最少，成本最低。</p>
<p>思考？<br>假设有m个存储体，第一种方法：可以根据体号确定它属于第几个存储体；第二种方法：用十进制地址x对m取余</p>
</blockquote>
<h3 id="多模块存储体"><a href="#多模块存储体" class="headerlink" title="多模块存储体"></a><strong>多模块存储体</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072018732.png"/>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072019521.png"/>

<h2 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h2><h3 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a><strong>外存储器</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072019733.png"/>

<h3 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a><strong>磁盘设备的组成</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020333.png"/>

<h3 id="磁盘的性能指标"><a href="#磁盘的性能指标" class="headerlink" title="磁盘的性能指标"></a><strong>磁盘的性能指标</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020912.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020736.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072021549.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072021194.png"/>

<h3 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a><strong>磁盘阵列</strong></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">计算机组成原理(1)-概述与数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-08 21:44:13" itemprop="dateCreated datePublished" datetime="2023-08-08T21:44:13+08:00">2023-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-07 21:20:07" itemprop="dateModified" datetime="2023-09-07T21:20:07+08:00">2023-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理笔记"><a href="#计算机组成原理笔记" class="headerlink" title="计算机组成原理笔记"></a>计算机组成原理笔记</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061623419.png"/>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机的发展"><a href="#计算机的发展" class="headerlink" title="计算机的发展"></a>计算机的发展</h2><p>数据库管理系统–系统软件<br>数据库系统–应用软件</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061530626.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061530997.png"/>

<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><p>“存储程序”的概念是指将指令以<strong>二进制代码</strong>的形式事先输入计算机的主存储器，然后按其在<strong>存储器中的首地址执行程序的第一条指令</strong>，以后就按该程序的规定顺序执行其他指令，直到程序执行结束。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>输入设备</td>
<td>将信息转换成机器能识别的形式</td>
</tr>
<tr>
<td>运算器</td>
<td>算术运算逻辑运算</td>
</tr>
<tr>
<td>存储器</td>
<td>存放数据和程序</td>
</tr>
<tr>
<td>控制器</td>
<td>指挥程序运行</td>
</tr>
<tr>
<td>输出设备</td>
<td>将结果转换成人们熟悉的形式</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061533552.png"/>

<h4 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h4><ul>
<li>计算机由五大部件组成</li>
<li>指令和数据以同等地位存于存储器，可按地址访问（统一编址，指令和数据所在存储单元无差异）</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成</li>
<li>存储程序</li>
<li>以运算器为中心（输入输出设备与存储器之间的数据传送通过运算器完成）</li>
</ul>
<h4 id="数据驱动方式："><a href="#数据驱动方式：" class="headerlink" title="数据驱动方式："></a>数据驱动方式：</h4><ul>
<li>控制流驱动：指令–&gt;数据</li>
<li>数据流驱动：数据–&gt;指令</li>
</ul>
<h3 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061536471.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061539722.png"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061539037.png"/>

<h2 id="各硬件的工作原理"><a href="#各硬件的工作原理" class="headerlink" title="各硬件的工作原理"></a>各硬件的工作原理</h2><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061540782.png"/>

<ol>
<li>MAR（Memory Address Register）：MAR是一个存储器地址寄存器，用于存储要访问的内存地址。当计算机需要读取或写入内存中的数据时，它会将要访问的内存地址存储在MAR中。MAR通常是一个专门的寄存器，它可以直接与内存进行交互，将存储器地址传递给内存模块。</li>
<li>MDR（Memory Data Register）：MDR是一个存储器数据寄存器，用于存储从内存中读取或要写入内存的数据。当计算机需要从内存中读取数据时，它将数据从内存传输到MDR中。同样，当计算机需要将数据写入内存时，它将数据从MDR传输到内存中的指定位置。MDR也是一个专门的寄存器，它在内存和其他计算机组件之间传递数据。</li>
</ol>
<p>因此，MAR和MDR之间的区别在于它们的功能和作用。MAR用于存储要访问的内存地址，而MDR用于存储从内存读取的数据或要写入内存的数据。它们共同参与内存的读取和写入操作，实现了计算机与内存之间的数据传输和交互。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061546501.png"/>

<ul>
<li>存储单元：每个存储单元存放一串二进制代码</li>
<li>存储字(word)：存储单元中二进制代码的组合</li>
<li>存储字长：存储单元中二进制代码的位数</li>
<li>存储元：即存储二进制的电子元件，每个存储元可存1bit</li>
</ul>
<h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061552267.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>加</th>
<th>减</th>
<th>乘</th>
<th>除</th>
</tr>
</thead>
<tbody><tr>
<td>ACC</td>
<td>累加器，用于存放操作数，或运算结果。</td>
<td>被加数，和</td>
<td>被减数、差</td>
<td>乘积高位</td>
<td>被除数、余数</td>
</tr>
<tr>
<td>MQ</td>
<td>乘商寄存器，在乘、除运算时，用于存放作数或运算结果。</td>
<td></td>
<td></td>
<td>乘数、乘积低位</td>
<td>商</td>
</tr>
<tr>
<td>X</td>
<td>通用的操作数寄存器，用于存放操作数</td>
<td>加数</td>
<td>减数</td>
<td>被乘数</td>
<td>除数</td>
</tr>
<tr>
<td>ALU</td>
<td>算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061559165.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CU 控制单元</td>
<td>控制单元，分析指令，给出控制信号</td>
</tr>
<tr>
<td>IR 指令寄存器</td>
<td>指令寄存器，存放当前执行的指令</td>
</tr>
<tr>
<td>PC 程序计数器</td>
<td>程序计数器，存放下一条指令地址，自动加1功能</td>
</tr>
</tbody></table>
<h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061602437.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061602487.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603976.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603669.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603318.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603758.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603390.png"/>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>注：现在的计算机通常把MAR,MDR也集成在CPU内</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061604660.png"/>

<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p>汇编语言指令和机器语言指令一一对应<br>LOAD： 取数操作 ，MUL： 乘法操作</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061605498.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061608592.png"/>

<p><strong>编译程序</strong>：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后在执行机器语言程序（只需翻译一次）。 例如：使用我们使用C语言写的程序，经过编译和汇编之后，最终形成.exe文件，该.exe文件是用机器语言描述的程序，每次运行这个程序，只需加载.exe文件。</p>
<p><strong>解释程序</strong>：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着在翻译下一句（每一次都要翻译）。 编译型语言执行效率较解释型语言高。 注：编译、汇编、解释程序，可统称为“翻译程序”。</p>
<p>计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）</p>
<ul>
<li>如何设计硬件与软件之间的接口。</li>
</ul>
<p>计算机组成原理：实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p>
<ul>
<li>如何用硬件实现所定义的接口。</li>
</ul>
<p>“透明”：看不见<br>“公开透明”：看得见</p>
<table>
<thead>
<tr>
<th></th>
<th>是否一次性</th>
<th>编译时间</th>
<th>运行速度</th>
</tr>
</thead>
<tbody><tr>
<td>编译程序</td>
<td>是</td>
<td>长</td>
<td>快</td>
</tr>
<tr>
<td>解释</td>
<td>否</td>
<td>短</td>
<td>慢</td>
</tr>
</tbody></table>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061617236.png"/>

<h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>机器字长</td>
<td>能够直接处理的二进制数据的位数</td>
</tr>
<tr>
<td>指令字长</td>
<td>一个指令中包含的二进制代码的位数</td>
</tr>
<tr>
<td>存储字长</td>
<td>一个存储单元二进制数据的位数</td>
</tr>
</tbody></table>
<h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><ul>
<li>MAR位数反应存储单元的个数（最后支持多少个）</li>
<li>MDR位数&#x3D;存储字长&#x3D;每个存储单元的大小</li>
</ul>
<p>总容量&#x3D;存储单元个数×存储字长 bit &#x3D;存储单元个数×存储字长&#x2F;8 Byte<br>$$<br>总容量 &#x3D; 存储单元个数 * 存储字长 bit &#x3D; 存储单元个数 * 存储字长&#x2F;8 Byte<br>$$</p>
<blockquote>
<p>Eg:MAR为32位，MDR为8位<br>总容量&#x3D;2^32×8 bit&#x3D;4GB</p>
<p>2^10:K<br>2^20:M<br>2^30:G<br>2^40:T</p>
</blockquote>
<h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061624562.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061627825.png"/>

<p><strong>注</strong>：公式中主频的值反映的是：每秒钟会出现多少个时钟周期。</p>
<p><strong>注</strong>：注意与存储器的容量或者文件的大小中的K、M、G、T的区别</p>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>数据通路带宽</td>
<td>数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</td>
</tr>
<tr>
<td>吞吐量</td>
<td>指系统在单位时间内处理请求的数量。他取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</td>
</tr>
<tr>
<td>响应时间</td>
<td>指从用户向计算发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销时间）。</td>
</tr>
</tbody></table>
<p>动态测试：基准程序（跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。</p>
<blockquote>
<p><strong>思考：</strong><br>1、主频高的CPU一定比主频低的CPU快吗？<br>答：不一定，如两个CPU，A的主频为2GHz，平均CPI&#x3D;10，一秒钟可以执行0.2G条指令；B的主频为1GHz，平均CPI&#x3D;1，一秒钟可以执行1G条指令。</p>
<p>2、若A、B两个CPU的平均CPI相同，那么A一定更快吗？<br>答：不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。</p>
<p>3、基准程序执行的越快说明机器性能越好吗？<br>答：基准程序中的语句存在频度差异，运行结果也不能完全说明问题。</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061630617.png"/>

<p>存储器的容量：衡量计算机的存储容量<br>机器字长：衡量计算机并行处理的能力<br>数据通路带宽：衡量计算机在功能部件之间传送数据的能力</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061631856.png"/>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="..进制转换"></a>..进制转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061632203.png"/>

<h3 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h3><p>无符号整数，即“自然数”，0、1、2、3、4、5…</p>
<p>C语言中的无符号整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a=<span class="number">1</span>; <span class="comment">//无符号整数 （短整型 2B）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b=<span class="number">2</span>; <span class="comment">//无符号整数 （整型 4B）</span></span><br></pre></td></tr></table></figure>

<p>无符号整数的表示</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061634609.png"/>

<h3 id="无符号整数的加法运算"><a href="#无符号整数的加法运算" class="headerlink" title="..无符号整数的加法运算"></a>..无符号整数的加法运算</h3><h3 id="带符号整数的表示和运算-原反补"><a href="#带符号整数的表示和运算-原反补" class="headerlink" title="..带符号整数的表示和运算_原反补"></a>..带符号整数的表示和运算_原反补</h3><p>带符号整数，即“整数”，-2、-1、0、1、2、3、4、5…</p>
<p>C语言中的带符号整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a=<span class="number">1</span>; <span class="comment">//带符号整数 （短整型 2B）</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">-2</span>; <span class="comment">//带符号整数 （整型 4B）</span></span><br></pre></td></tr></table></figure>

<h3 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061638672.png"/>

<h2 id="原反补码的特性对比"><a href="#原反补码的特性对比" class="headerlink" title="原反补码的特性对比"></a>原反补码的特性对比</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061639934.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071628336.png"/>

<p>注：反码与原码表示的范围是一样的，当n是整数时，真值负数最小时，原码是1111 1111，反码是1000 0000。</p>
<h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629744.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629912.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629875.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630537.png"/>

<h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630949.png"/>

<h3 id="定点小数原反补码的转换"><a href="#定点小数原反补码的转换" class="headerlink" title="定点小数原反补码的转换"></a><strong>定点小数原反补码的转换</strong></h3><p>注：和定点整数一模一样。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630223.png"/>

<h3 id="定点小数的加减法运算"><a href="#定点小数的加减法运算" class="headerlink" title="定点小数的加减法运算"></a><strong>定点小数的加减法运算</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630004.png"/>

<p>小数的加减运算和整数的处理逻辑是一样的。</p>
<p>定点小数VS定点整数</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631154.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631788.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631522.png"/>

<h2 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h2><h3 id="ALU（算数逻辑单元）"><a href="#ALU（算数逻辑单元）" class="headerlink" title="ALU（算数逻辑单元）"></a><strong>ALU（算数逻辑单元）</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071632246.png"/>

<h4 id="基本的逻辑运算"><a href="#基本的逻辑运算" class="headerlink" title="基本的逻辑运算"></a><strong>基本的逻辑运算</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071632415.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071633941.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071633736.png"/>

<blockquote>
<p>异或：AB不同Y为1，相同为 0；同或：AB相同Y为1，不同为0。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">软件工程基础概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 16:42:55" itemprop="dateCreated datePublished" datetime="2023-06-10T16:42:55+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-14 16:36:23" itemprop="dateModified" datetime="2023-06-14T16:36:23+08:00">2023-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><ul>
<li>软件&#x3D;程序+数据+文档</li>
<li>软件是被开发或设计的</li>
<li>软件不会磨损，但是会退化</li>
</ul>
<h2 id="软件工程的概述"><a href="#软件工程的概述" class="headerlink" title="软件工程的概述"></a>软件工程的概述</h2><p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法区开发和维护软件，以及如何把经过时间考虑而证明正确的管理技术和当前能够得到的最好技术方法结合起来的学科。</p>
<h2 id="软件工程的方法"><a href="#软件工程的方法" class="headerlink" title="软件工程的方法"></a>软件工程的方法</h2><h3 id="传统方法："><a href="#传统方法：" class="headerlink" title="传统方法："></a>传统方法：</h3><p>也称生命周期方法或结构化方法。采用结构化技术来完成软件开发的各项任务</p>
<h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>从面向对象程序设计发展起来的。有OOA面向对象分析、OOD面向对象设计、OMG对象管理组织、UML统一建模语言等概念</p>
<h3 id="面向服务方法"><a href="#面向服务方法" class="headerlink" title="面向服务方法"></a>面向服务方法</h3><p>SOA，服务提供与请求的设计模式</p>
<h3 id="面向数据的方法"><a href="#面向数据的方法" class="headerlink" title="面向数据的方法"></a>面向数据的方法</h3><p>基于数据思维，从业务逻辑的角度，强调一切业务“数据化”；从体系结构的角度，突出“面向暑假和以暑假为核心”的思想</p>
<h3 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h3><p>基于形式化数学变换的软件开发方法</p>
<h1 id="软件工程的层次"><a href="#软件工程的层次" class="headerlink" title="软件工程的层次"></a>软件工程的层次</h1><p>软件工程的定义：将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中。</p>
<ul>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程范型</li>
</ul>
<h2 id="软件工程的过程模型"><a href="#软件工程的过程模型" class="headerlink" title="软件工程的过程模型"></a>软件工程的过程模型</h2><h3 id="软件工程的三个要素"><a href="#软件工程的三个要素" class="headerlink" title="软件工程的三个要素"></a>软件工程的三个要素</h3><p>过程、方法、工具</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101647572.png"/>

<ol>
<li>支持软件工程的根基在于质量关注点（quality focus）：是对软件的组织承诺，是支持软件工程的基石</li>
<li>软件工程的基础是过程（process）层。软件过程将各个技术层次结合在一起，使得合理、及时地开发计算机软件成为可能。</li>
<li>软件工程方法（method）为构建软件提供技术上的解决方法。方法包括：沟通、需求分析、设计模型、编程、测试和技术支持。</li>
<li>软件工程工具为过程和方法提供自动化或半自动化的支持。</li>
</ol>
<h3 id="软件过程的三个阶段"><a href="#软件过程的三个阶段" class="headerlink" title="软件过程的三个阶段"></a>软件过程的三个阶段</h3><ol>
<li><p>定义阶段：<strong>“做什么”</strong>，系统和软件的关键需求被标识</p>
<p>系统和信息工程</p>
<p>软件项目计划</p>
<p>需求分析</p>
</li>
<li><p>开发阶段：<strong>“如何做”</strong>，定义数据结构、体系结构、过程细节、界面表示、算法和测试如何执行</p>
<p>软件设计</p>
<p>代码生成</p>
<p>软件测试</p>
</li>
<li><p>支持阶段：<strong>“变化”</strong>：纠正错误、随着软件环境的演化而要求的适应性修改、用户需求的变化而带来的增强性修改</p>
<p>纠错性维护</p>
<p>适应性维护</p>
<p>完善性维护</p>
<p>预防性维护</p>
</li>
</ol>
<h3 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h3><p>CMM是20世纪90年代提出的 <strong>软件能力成熟度模型</strong></p>
<ol>
<li>CMM定义了当一个组织达到不同的过程成熟度时应该具有的软件工程能力</li>
<li>CMM是一种<strong>衡量软件开发能力和成熟度的标准</strong></li>
<li>CMM模型提供了衡量一个公司软件工程实践的整体有效性的方法，且建立了<strong>五级</strong>的过程成熟度级别</li>
</ol>
<h4 id="初始级"><a href="#初始级" class="headerlink" title="初始级"></a>初始级</h4><p>软件过程是<strong>特定的和偶然的</strong>，有时甚至是混乱的，几乎没有过程定义，成功完全取决于个人能力。</p>
<h4 id="可重复级"><a href="#可重复级" class="headerlink" title="可重复级"></a>可重复级</h4><p>建立了<strong>基本的</strong>项目管理过程，能够跟踪费用、进度和功能。有适当的必要的过程规范，可以重复与疫情类似的项目的成功</p>
<h4 id="定义级"><a href="#定义级" class="headerlink" title="定义级"></a>定义级</h4><p>用于管理和工程活动的软件过程已经文档化、<strong>标准化</strong>并与整个组织的软件过程相集成。所有项目都使用统一的、文档化的、组织过程认可的版本来开发和维护软件。</p>
<p>​	包含第二级的所有特征。</p>
<h4 id="管理级"><a href="#管理级" class="headerlink" title="管理级"></a>管理级</h4><p>软件过程和产品质量的详细数据被收集，通过这些度量数据，软件过程和产品能够<strong>被定量地</strong>理解和控制，包含三级的所有特征。</p>
<h4 id="优化级"><a href="#优化级" class="headerlink" title="优化级"></a>优化级</h4><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><p>通过定量反馈进行不断的过程改进，这些反馈来自于过程或通过<strong>试验新的的想法</strong>和技术而得到。包含第四级的所有特征。</p>
<p>软件过程模型是软件开发全部过程、活动和任务的结构框架。是一种开发策略，包含过程，方法和工具三个层次以及一般性阶段，常称为：</p>
<ol>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程模型</li>
</ol>
<h3 id="过程模型两种类型"><a href="#过程模型两种类型" class="headerlink" title="过程模型两种类型"></a>过程模型两种类型</h3><ul>
<li><p>传统的软件过程模型</p>
<ol>
<li>瀑布模型（线性顺序模型）</li>
<li>V模型</li>
<li>原型</li>
<li>RAD模型</li>
<li>增量模型</li>
<li>螺旋模型</li>
<li>形式化方法模型</li>
</ol>
</li>
<li><p>敏捷的软件过程模型</p>
<ol>
<li>极限编程（XP）</li>
<li>自适应软件开发 (ASD)</li>
<li>橄榄球模型 (Scrum)</li>
<li>特征驱动开发 (PDD)</li>
</ol>
</li>
</ul>
<h3 id="传统的软件过程模型"><a href="#传统的软件过程模型" class="headerlink" title="传统的软件过程模型"></a>传统的软件过程模型</h3><h4 id="瀑布模型（waterfall-model）："><a href="#瀑布模型（waterfall-model）：" class="headerlink" title="瀑布模型（waterfall model）："></a>瀑布模型（waterfall model）：</h4><p>又被称为经典生命周期（classic life cycle），它提出了一个系统的、顺序的软件开发方法。<br>优点：</p>
<blockquote>
<ul>
<li>有利于大型软件开发过程中人员的组织、管理，从而提高了大型软件项目开发的质量和效率。</li>
<li>当需求确定、工作采用线性的方式完成的时候瀑布模型是一个很有用的过程模型。</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>过于理想，缺乏灵活性，容易产生需求偏差。</li>
<li>实际的项目很少遵守瀑布模型提出的顺序。</li>
<li>客户通常很难清楚的描述所有的需求。</li>
<li>客户必须要有耐心，因为只有在项目接近尾声的时候，他们才能得到可以执行的程序。</li>
<li>适用范围： 需求确定，工作能够采用线性的方式完成的软件。</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101712288.png"/>

<h4 id="V模型（V-model）："><a href="#V模型（V-model）：" class="headerlink" title="V模型（V-model）："></a>V模型（V-model）：</h4><p>描述了质量保证动作同沟通、建模相关动作以及早期构建相关的动作之间的关系。<br>V模型强调软件开发的协作和速度，将软件实现和验证有机地结合起来，在保证较高的软件质量情况下缩短开发周期。<br>优点：适合工程量小、人力资源少并且开发过程中改动不大的项目<br>缺点：错误发现时间迟，产生的风险代价高</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101714922.png"/>

<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><h5 id="抛弃式（一次性）原型不作为最终产品使用"><a href="#抛弃式（一次性）原型不作为最终产品使用" class="headerlink" title="抛弃式（一次性）原型不作为最终产品使用"></a>抛弃式（一次性）原型不作为最终产品使用</h5><blockquote>
<ul>
<li>降低项目中的风险，看看是否可以做些什么。（优势）</li>
<li>捕获需求，即客户是否可以喜欢GUI。（优势）</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li><p>资源可能会被浪费，因此需要控制</p>
</li>
<li><p>需要良好的项目管理</p>
</li>
<li><p>需要与客户进行良好的沟通</p>
</li>
<li><p>什么时候是停止开发原型的好时机</p>
</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101803536.png"/>

<h5 id="演化式"><a href="#演化式" class="headerlink" title="演化式"></a>演化式</h5><p>逐步改进和细化原型，将原型进化为最终系统</p>
<p>优势</p>
<blockquote>
<ul>
<li>客户可以看到他们想要的更改。</li>
<li>非常适合用户界面的接受。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在文档方面非常薄弱（即系统不断变化）。</li>
<li>需要强有力的项目控制，领导者需要监控发展。</li>
<li>什么时候是停止发展和完成项目的好时机可能会导致系统结构不良。</li>
<li>可能需要特殊的开发人员。</li>
</ul>
</blockquote>
<h6 id="演化过程模型（Evolutionary-Model）"><a href="#演化过程模型（Evolutionary-Model）" class="headerlink" title="演化过程模型（Evolutionary Model）"></a>演化过程模型（Evolutionary Model）</h6><p>演化模型是迭代的过程模型。</p>
<p>原型开发（prototyping ）：当需求很模糊的时候，原型开发可以帮助软件开发人员和利益相关者更好地理解究竟需要做什么。<br><strong>优点：</strong><br>开发者与用户充分交流，可以澄清模糊需求，需求定义比其他模型好得多<br>开发过程与用户培训过程同步<br>为用户需求的改变提供了充分的余地<br>开发风险低，产品柔性好<br>开发费用低，时间短<br>系统易维护，对用户更友好</p>
<p><strong>缺点：</strong><br>1、 没有考虑软件的整体质量和长期的可维护性。<br>2、 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>3、 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。<br>适用范围：<br>尽管原型可以用作独立的流程模型，但它更常用作一种可以在任何流模型的上下文中实现的技术。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715254.png"/>

<h5 id="增量型"><a href="#增量型" class="headerlink" title="增量型"></a>增量型</h5><p>在建立软件总体设计基础上，采用增量开发方法，使原型成为最终系统。</p>
<p>优势：</p>
<blockquote>
<p>有利于将一个更大的系统分解成多个部分，从而使组件更容易构建。<br>客户对系统的看法是分阶段的，所以没有“大爆炸”的方法。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>需要良好的沟通和协议。<br>需要良好的项目管理、控制和监控工作。</p>
</blockquote>
<h6 id="增量过程模型（Incremental-Model）"><a href="#增量过程模型（Incremental-Model）" class="headerlink" title="增量过程模型（Incremental Model）"></a>增量过程模型（Incremental Model）</h6><p><strong>增量模型融合了瀑布模型的基本成分和原型的迭代特征</strong></p>
<p>增量过程模型侧重于每一个增量都提交一个可以运行的产品。<br><strong>优点：</strong></p>
<ol>
<li>能在较短的时间内向用户提交可完成部分工作的产品。</li>
<li>逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
<li>规避技术风险</li>
<li>可并行开发构件，加快开发的进度</li>
<li>对于在业务截止日期之前完全实施的人员配置非常有用。<br><strong>缺点：</strong><br>（1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；<br>（2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。</li>
</ol>
<p><strong>适用范围：</strong><br>（1）进行已有产品升级或新版本开发，增量模型是非常适合的；<br>（2）对完成期限严格要求的产品，可以使用增量模型；<br>（3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。<br>（4）项目在既定的商业要求期限之前不可能找到足够的开发人员</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715951.png"/>

<h4 id="统一过程（Unified-Process）"><a href="#统一过程（Unified-Process）" class="headerlink" title="统一过程（Unified Process）"></a>统一过程（Unified Process）</h4><p><strong>统一过程模型</strong><br>统一过程模型是一种“用例驱动、以体系结构为核心、迭代及增量”的软件 过程框架，由 UML 方法和工具支持。它是一种增量模型，定义了五个阶段：<br>a、起始阶段，包括用户沟通和计划活动，强调定义和细化用例<br>b、细化阶段，包括用户沟通和建模活动，重点是创建分析和设计模型。<br>c、构件阶段，细化模型设计，并将设计模型转化为软件构件实现<br>d、转化阶段，将软件从开发人员传递给最终用户，并由用户完成 beta 测试和验收测试<br>e、生产阶段，持续地监控软件的运行，并提供技术支持。</p>
<p><strong>优点：</strong><br>1.任何功能开发后就进入测试过程，及早进行验证<br>2.早期风险识别，采取预防措施</p>
<p><strong>缺点：</strong></p>
<ol>
<li>需求必须在开始之前完全弄清楚，否怎有可能在架构上出现错误</li>
<li>必须有严格的过程管理，以免使过程退化为原始的试→错→改模式</li>
<li>如果不加控制的让用户过早接触没有测试完全、版本不稳定的产品可能对用户和开发团队都带来负面的影响。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101717848.png"/>

<h4 id="RAD模型"><a href="#RAD模型" class="headerlink" title="RAD模型"></a>RAD模型</h4><p>通过使用“基于构件的建造方法”赢得快速开发</p>
<ul>
<li><p>业务建模</p>
</li>
<li><p>数据建模</p>
</li>
<li><p>过程建模</p>
</li>
<li><p>应用生成</p>
</li>
<li><p>测试及反复</p>
</li>
</ul>
<p>特点：</p>
<blockquote>
<ul>
<li>强调极短的开发时 间，每一个主要功能在不到三个月的时间内完成。</li>
<li>强调复用。</li>
</ul>
</blockquote>
<p> 缺点：</p>
<blockquote>
<ul>
<li>对于大型的的项目，RAD需要足够的人力资源以建立足够的RAD组。</li>
<li>RAD要求开发者和客户承担在一个很短的时间框架下完成一个系统所必要的快速活动。</li>
<li>并非所有应用都适合RAD,不适合技术风险很高的情况</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101807461.png"/>

<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>主要适用于内部开发的大规模软件项目</p>
<ul>
<li>客户交流一建立开发者和客户之间有效的通信所需的任务。</li>
<li>计划一定义资源、进度及其他相关项目所需要的任务。</li>
<li>风险分析一评估技术的及管理的风险所需的任务。</li>
<li>工程一建立应用的一个或多个表示所需要的任务。</li>
<li>构造及发布一构造、测试、安装和提供用户支持（如文档及培训）所需的任务</li>
<li>客户评估一基于对在工程阶段产生的或在安装阶段实现的软件表示的评估，获得客户反馈所需要的任务。</li>
</ul>
<p>优点：</p>
<blockquote>
<p>随着过程进展演化，开发者和客户能够更好地理解和对待每一个级别上的<br>风险，使用原型实现作为降低风险的机制。<br>更真实地反映了现实世界。<br>如应用得当，能在风险变成问题之前降低它。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>模型的成功依赖于风险评估的专门技术，<br>是一个较新的模型，功效的确定尚需若干年时间。</p>
</blockquote>
<h3 id="敏捷的软件过程模型"><a href="#敏捷的软件过程模型" class="headerlink" title="敏捷的软件过程模型"></a>敏捷的软件过程模型</h3><h4 id="敏捷开发-敏捷宣言（Agile-development-manifesto）："><a href="#敏捷开发-敏捷宣言（Agile-development-manifesto）：" class="headerlink" title="敏捷开发-敏捷宣言（Agile development manifesto）："></a><strong>敏捷开发-敏捷宣言（Agile development manifesto）：</strong></h4><p><strong>应付变化而来的开发模型</strong></p>
<ul>
<li><strong>个体和互动 高于 流程和工具</strong>：个人和他们之间的交流胜过了开发过程和工具</li>
<li><strong>工作的软件 高于 详尽的文档</strong>：可运行的软件胜过了宽泛的文档</li>
<li><strong>客户合作 高于 合作谈判</strong>：客户合作胜过了合同谈判</li>
<li><strong>响应变化 高于 遵循计划</strong>：对变更的良好响应胜过了按部就班地遵循计划</li>
</ul>
<h4 id="极限编程（Extreme-Programming-XP-）"><a href="#极限编程（Extreme-Programming-XP-）" class="headerlink" title="极限编程（Extreme Programming (XP)）"></a>极限编程（Extreme Programming (XP)）</h4><p>极限编程是敏捷软件开发使用最广泛的一个方法。</p>
<ol>
<li><p>策划：<br>开始创造“用户故事”<br>敏捷团队评估每个故事并分配一个成本（开发周数）<br>故事被分组到一个可交付增量<br>承诺在交付日期进行<br>在第一次递增之后，“项目速度”用于帮助估计后续发行版本的发布日期和进度安排，确定是否对整个开发项目中的所有故事有过分承诺。</p>
</li>
<li><p>设计<br>遵循KIS（保持简洁）原则<br>对于困难的设计问题，建议创建“尖峰解决方案” - 一个设计原型<br>鼓励“重构”： 重构是以不改变代码外部行为而改进其内部结构的方式来修改软件系统的过程。</p>
<blockquote>
<p>重构是XP的一个重要组成部分。所谓重构是指在 不改变代码外在行为的前提下对代码做出的修改，以 改进代码的内部结构。重构是一种有纪律的、经过训 练的、有条不紊的代码整理方法，可以将整理过程中 不小心引入错误的可能性降到最低。从本质上说，重 构就是在代码写好之后改进它的设计。 重构的节奏：重新推理、小的更改、重新推理、 小的更改、重新推理…</p>
</blockquote>
</li>
<li><p>编码<br>在编码开始之前，建议对故事进行单元测试<br>鼓励“结队编程”</p>
<blockquote>
<p>结对编程是让两个人共同设计和开发代码的实践。结对者是全职合作者，轮流执行键入和监视；这提供了持续的设计和代码评审。<br>不是两个人做一个人的事情。</p>
</blockquote>
<p>连续集成<br>有助于避免兼容性和接口问题，建立能及早发现错误的“冒烟测试”</p>
<blockquote>
<p>​	持续集成的思想是任何时候，只要有一项任务完成，就集成新代码，构造系统并测试。持续集成是每日构建\每晚构建的一种极限形式，是XP的重要基础。<br>​	每日构建\每晚构建是将一个软件项目的所有最新代码取出，从头开始编译、链接，用安装软件包将链接好的程序安 装好，运行安装后的软件，使用测试工具对主要功能进行测 试，发现错误并报告错误的完整过程。<br>​	让开发人员在第一时间了解到软件的错误，并迅速排除错误，是每日构建\每晚构建最重要的目标之一。<br>​	每日构建\每晚构建必须出日志和报告，并发布构建结<br>果的有关信息，最好能够使用自动化工具发出电子邮件通知</p>
</blockquote>
</li>
<li><p>所有的单元测试每天都执行<br>“验收测试”，由客户规定技术条件，并且着眼于客户可见的、可评审的系统级的特征和功能。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730576.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730350.png"/></li>
</ol>
<h4 id="橄榄球模型（Scrum）"><a href="#橄榄球模型（Scrum）" class="headerlink" title="橄榄球模型（Scrum）"></a>橄榄球模型（Scrum）</h4><ul>
<li>待定项(backlog)——一个能为用户提供商业价值的项目需求或特性的优先級列表。待定项中可以随时加入新项(这就是变更的引入)。产品经理根据需要评估待定项并修改优先级。</li>
<li>冲刺(sprint) ——一些工作单元组成，这些工作单元是达到待定项中定义的需求所必需的，并且必须能在预定的时间段( time-box9)内(一般情况下为30天)完成。冲刺过程中不允许有变更(例如积压工作项)。因此，冲刺给开发团队成员的工作提供了短期但稳定的环境。</li>
<li>Scrum例会——Serum 团队每天召开的短会(一般情况为15分钟)，会上所有成员要回答三个问题[Noy02]:<ol>
<li>上次例会后做了什么?</li>
<li>遇到了什么困难?</li>
<li>下次例会前计划做些什么</li>
</ol>
</li>
<li>演示——交付软件，客户进行评估</li>
</ul>
<p>燃尽图：衡量在一个Sprint时间段内剩余的Sprint待办事项列表条目。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101759647.png"/>

<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="软件项目管理的定义"><a href="#软件项目管理的定义" class="headerlink" title="软件项目管理的定义"></a>软件项目管理的定义</h2><p>软件项目管理是为了使软件项目能够顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p>
<p><strong>对软件工程项目</strong>：他所涉及的范围覆盖了整个软件工程过程</p>
<p><strong>这种项目挂你在技术工作开始之前就应该开始</strong>，在软件从概念到实现的过程中<strong>继续进行</strong>，当软件工程过程最后结束时<strong>才终止</strong></p>
<h2 id="管理的四要素"><a href="#管理的四要素" class="headerlink" title="管理的四要素"></a>管理的四要素</h2><ul>
<li>人员People：成功项目的重要因素</li>
<li>产品Product：要开发的软件</li>
<li>过程Process：软件工程的框架活动，包括了任务、里程碑、工作一起质量保证点</li>
<li>项目Project：开发软件所需要的所有工作</li>
</ul>
<h2 id="项目管理小组结构"><a href="#项目管理小组结构" class="headerlink" title="项目管理小组结构"></a>项目管理小组结构</h2><ul>
<li><p>民主分散式（democratic decentralized，DD）【比以下两种缺陷要多】</p>
<p>没有固定的负责人，适合难度比较高、交付期限很长及生存期较长的项目，最适合于解决模块化程度比较低的问题，因为需要通信</p>
</li>
<li><p>控制分散式（controlled decentralized，CD）</p>
<p>CD(控制分散式）:有一个固定的负责人，若有子负责人，<strong>子负责人和总负责人的通信是垂直的</strong>，而个人间的通信是水平的，适合交付期限较长、比较简单的项目</p>
</li>
<li><p>控制集中式（controlled centralized，CC）</p>
<p>CC(控制集中式）:负责人和小组成员之间的通信是垂直的，适合解决<strong>交付期限比较严格的、简单的、模块化程度高</strong>的项目</p>
</li>
</ul>
<h3 id="小组通信路径"><a href="#小组通信路径" class="headerlink" title="小组通信路径"></a>小组通信路径</h3><p> <em>C &#x3D; (n * (n-1))&#x2F;2</em></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121025899.png"/>

<h3 id="软件范围"><a href="#软件范围" class="headerlink" title="软件范围"></a>软件范围</h3><ul>
<li>在进行项目计划之前，软件开发者和客户必须一起定义产品的目的和范围考虑可选的解决方案，标识技术和管理的约束。</li>
<li>没有这些信息，就不可能进行合理的（准确的）成本估算、有效的风险评估、适当的项目任务划分或是可管理的项目进度安排。</li>
<li>软件范围是软件项目管理的第一个活动。</li>
</ul>
<h1 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h1><h2 id="软件度量的目的"><a href="#软件度量的目的" class="headerlink" title="软件度量的目的"></a>软件度量的目的</h2><ul>
<li>改进过程</li>
<li>提高产品的质量</li>
</ul>
<h2 id="度量的作用"><a href="#度量的作用" class="headerlink" title="度量的作用"></a>度量的作用</h2><p>有效地定量地进行管理</p>
<h2 id="过程度量"><a href="#过程度量" class="headerlink" title="过程度量"></a>过程度量</h2><ul>
<li>在软件发布之前的错误数的测量</li>
<li>交付给最终用户并由最终用户报告的缺陷的测量</li>
<li>交付的工作产品（生产率）的测量</li>
<li>花费的工作量的测量</li>
<li>花费的时间的测量</li>
<li>与进度是否一致的测量</li>
</ul>
<h2 id="度量的方式"><a href="#度量的方式" class="headerlink" title="度量的方式"></a>度量的方式</h2><h3 id="物理度量方式"><a href="#物理度量方式" class="headerlink" title="物理度量方式"></a>物理度量方式</h3><p>直接测量</p>
<p>间接测量</p>
<h3 id="软件度量方式"><a href="#软件度量方式" class="headerlink" title="软件度量方式"></a>软件度量方式</h3><p>直接测量</p>
<ul>
<li>软件工程过程的直接测量包括所投入的成本和工作量。</li>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<p>间接测量</p>
<ul>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<h2 id="度量的分类"><a href="#度量的分类" class="headerlink" title="度量的分类"></a>度量的分类</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121414638.png"/>

<ul>
<li>需要注意的是：在表格中记载的工作量和成本是整个软件工程的活动（分析、设计、编码和测试）,<strong>而不仅仅是编码活动</strong></li>
<li>对于每一个项目，可以根据表格中列出的<strong>基本数据</strong>计算简单的<strong>面向规模</strong>的生产率和质量等的度量</li>
<li>根据表格可以对所有的项目计算出的有用度量：<ul>
<li>生产率&#x3D;<strong>KLOC</strong>&#x2F;PM(人月）</li>
<li>质量&#x3D;错误数&#x2F;<strong>KLOC</strong></li>
<li>成本&#x3D;元&#x2F;<strong>LOC</strong></li>
<li>文档&#x3D;文档页数&#x2F;<strong>KLOC</strong></li>
</ul>
</li>
</ul>
<h3 id="基于FP的软件度量"><a href="#基于FP的软件度量" class="headerlink" title="基于FP的软件度量"></a>基于FP的软件度量</h3><ul>
<li>每个FP的错误数（Errors per FP)</li>
<li>每个FP的缺陷数（Defects per FP)</li>
<li>每个FP的花费（$ per FP)</li>
<li>每个FP的文档页数（Pages of documentation per FP)</li>
<li>每人月完成的FP数（FP per person-month)</li>
</ul>
<h2 id="度量的计算"><a href="#度量的计算" class="headerlink" title="度量的计算"></a>度量的计算</h2><p>计算功能点，使用如下的计算公式<br>$$<br>FP &#x3D; 总计算值*[0.65+0.01*∑(Fi)]<br>$$<br>总计数值是所有加权计数项的和</p>
<p>Fi（i&#x3D;1…14）是复杂性校正值，它们应通过逐一回答如下提问来确定。</p>
<blockquote>
<p>Fi的取值0..5:<br>0没有影响	1微小影响<br>2轻度			3中度<br>4显著			5重大</p>
</blockquote>
<p>∑(Fi)是求和函数</p>
<h2 id="软件质量度量指标"><a href="#软件质量度量指标" class="headerlink" title="软件质量度量指标"></a>软件质量度量指标</h2><ul>
<li><p>正确性</p>
</li>
<li><p>可维护性</p>
</li>
<li><p>完整性</p>
<ul>
<li><p>危险性是特定类型的攻击将在一给定时间内发生的概率。<br>安全性是排除特定类型攻击的概率。</p>
</li>
<li><p>一个系统的完整性可定义为<br>$$<br>完整性&#x3D;∑[1-危险性×(1-安全性）]<br>$$<br>其中，对每一个攻击的危险性和安全性都进行累加。</p>
</li>
</ul>
</li>
<li><p>可用性</p>
</li>
</ul>
<h2 id="DRE缺陷排除效率"><a href="#DRE缺陷排除效率" class="headerlink" title="DRE缺陷排除效率"></a>DRE缺陷排除效率</h2><p>DRE是对质量保证及控制活动中滤除缺陷能力的一个测量</p>
<h1 id="软件风险"><a href="#软件风险" class="headerlink" title="软件风险"></a>软件风险</h1><h2 id="风险及风险管理"><a href="#风险及风险管理" class="headerlink" title="风险及风险管理"></a>风险及风险管理</h2><ul>
<li>风险：所有在软件开发过程中带来负面影响的问题，是一个潜在的问题</li>
<li>风险分析和管理是标识风险、评估其发生的概率、估算其影响并建立问题实际发生情形下的应急计划，是一系列帮助软件小组理解和管理部确定的步骤</li>
</ul>
<h2 id="被动的风险策略"><a href="#被动的风险策略" class="headerlink" title="被动的风险策略"></a>被动的风险策略</h2><p>被动风险策略：对风险不闻不问，直到发生了错误项项目组才赶紧采取行动，试图迅速地纠正错误。</p>
<h2 id="主动的风险策略"><a href="#主动的风险策略" class="headerlink" title="主动的风险策略"></a>主动的风险策略</h2><p>主动风险策略：在技术工作开始之前就已经启动，标识出潜在的风险，评估出现的概率及产生的影响，且按重要性加以排序。主要目标预防风险，需要建立一个应急计划，使必要时能够以可控的及有效地方式做出反应。</p>
<h2 id="风险的类型"><a href="#风险的类型" class="headerlink" title="风险的类型"></a>风险的类型</h2><h3 id="项目风险"><a href="#项目风险" class="headerlink" title="项目风险"></a>项目风险</h3><p>威胁到项目技术</p>
<p>潜在的预算、进度、人力资源、客户及需求等方面的问题</p>
<h3 id="技术风险"><a href="#技术风险" class="headerlink" title="技术风险"></a>技术风险</h3><p>威胁到要开发软件的质量和交付时间</p>
<p>潜在的设计、实现、接口、验证和维护等方面的问题</p>
<h3 id="商业风险"><a href="#商业风险" class="headerlink" title="商业风险"></a>商业风险</h3><p>威胁到要开发软件的生存能力</p>
<p>商业风险的分类</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>开发了一个没有人真正需要的优秀产品或系统</td>
<td>市场风险</td>
</tr>
<tr>
<td>开发的产品不再符合公司的整体商业策略</td>
<td>策略风险</td>
</tr>
<tr>
<td>建造了一个销售部门不知道如何去出售的产品</td>
<td>销售风险</td>
</tr>
<tr>
<td>由于重点转移或人员的变动而失去了高级管理层的支持</td>
<td>管理风险</td>
</tr>
<tr>
<td>没有得到预算或人力上的保证。</td>
<td>预算风险</td>
</tr>
</tbody></table>
<h2 id="风险管理的步骤"><a href="#风险管理的步骤" class="headerlink" title="风险管理的步骤"></a>风险管理的步骤</h2><h3 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h3><ul>
<li>风险识别的方法一建立风险条目检查表。</li>
<li>产品规模–与要建造或要修改的软件的总体规模相关的经验；</li>
<li>商业影响–与管理或市场所加的约束相关的风险；</li>
<li>客户特征–与客户的素质以及开发者和客户及时通信的能力相关的风险；</li>
<li>过程定义–与软件过程被定义的程度以及他们被开发组织所遵守的程度相关的风险；</li>
</ul>
<h3 id="风险预测"><a href="#风险预测" class="headerlink" title="风险预测"></a>风险预测</h3><p>风险预测从两个方面评估风险：风险发生的可能性或概率、风险发生所产生的后果（评估风险影响）。</p>
<h4 id="评估风险影响"><a href="#评估风险影响" class="headerlink" title="评估风险影响"></a>评估风险影响</h4><p>风险显露度（risk exposure)<br>$$<br>RE &#x3D; P * C<br>$$<br>其中，P是风险发生的概率，c是风险发生时带来的项目成本</p>
<blockquote>
<p>一个例子：计划了60个可复用构件，其中只有70%可能被使用，剩下的要重新定制开发，已知构件平均是100LOC,每个LOC的成本是14美元，假设该风险发生的概率是80%,计算风险显露度RE。</p>
</blockquote>
<p>$$<br>RE &#x3D; 80%*C<br>$$</p>
<p>$$<br>C &#x3D; 60 *(1-70%)<em>100</em>14<br>$$</p>
<h1 id="项目进度安排与跟踪"><a href="#项目进度安排与跟踪" class="headerlink" title="项目进度安排与跟踪"></a>项目进度安排与跟踪</h1><h2 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527813.png"/>

<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527622.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527818.png"/></p>
</blockquote>
<h2 id="项目进度安排方法"><a href="#项目进度安排方法" class="headerlink" title="项目进度安排方法"></a>项目进度安排方法</h2><h3 id="关键路径方法（CPM）"><a href="#关键路径方法（CPM）" class="headerlink" title="关键路径方法（CPM）"></a>关键路径方法（CPM）</h3><p>在关键路径上的活动才是按时完成任务的关键</p>
<h3 id="项目-进度计划-评估和评审技术-PERT）"><a href="#项目-进度计划-评估和评审技术-PERT）" class="headerlink" title="项目(进度计划)评估和评审技术(PERT）"></a>项目(进度计划)评估和评审技术(PERT）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530592.png"/>

<h3 id="获得值分析"><a href="#获得值分析" class="headerlink" title="获得值分析"></a>获得值分析</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534873.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530680.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121531061.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121533877.png"/>

<h1 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h1><h2 id="数据流图DFD"><a href="#数据流图DFD" class="headerlink" title="数据流图DFD"></a>数据流图DFD</h2><ul>
<li>面向数据流进行需求分析的方法</li>
<li>适合于数据处理类型软件的需求分析</li>
<li>用抽象模型的概念，按照软件内部数据传递、变换的关系，自项向下逐层分解，直到满足所有的功能要求。<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534481.png"/></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121535618.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121536102.png"/>

<h2 id="数据字典DD"><a href="#数据字典DD" class="headerlink" title="数据字典DD"></a>数据字典DD</h2><ul>
<li>数据字典对数据流图中的各种成分起注解、说明作用，给这些成分赋以实际的内容。</li>
<li>数据字典与数据流图配合，能清楚地表达数据处理的要求。</li>
<li>条目：数据流、数据元素、数据存储、数据加工、外部实体。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121537663.png"/>

<h2 id="结构化英语"><a href="#结构化英语" class="headerlink" title="结构化英语"></a>结构化英语</h2><ul>
<li>顺序结构</li>
<li>重复结构</li>
<li>判定结构</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121538728.png"/>

<h1 id="结构化设计概述"><a href="#结构化设计概述" class="headerlink" title="结构化设计概述"></a>结构化设计概述</h1><h2 id="分析模型到设计模型"><a href="#分析模型到设计模型" class="headerlink" title="分析模型到设计模型"></a>分析模型到设计模型</h2><ul>
<li>数据设计：侧重于数据结构的定义</li>
<li>体系结构设计：定义软件系统各主要成份之间的关系</li>
<li>接口设计：描述了软件内部、软件和协作系统之间以及软件同人之间如何通信</li>
<li>过程设计：则是把结构成份转换成软件的过程性描述</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>结构图反映了模块之间的层次调用关系和联系：它以特定的符号表示模块、模块间的调用关系和模块间信息的传递</p>
<h3 id="模块的调用关系"><a href="#模块的调用关系" class="headerlink" title="模块的调用关系"></a>模块的调用关系</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542806.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542853.png"/>

<ul>
<li>模块独立性，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其它的模块的接口是简单的。</li>
<li>例如，若一个模块只具有单一的功能且与其它模块没有太多的联系，则称此模块具有模块独立性。</li>
<li>一般采用两个准则度量模块独立性。即模块间藕合和模块内聚。</li>
<li>藕合是模块之间的互相连接的紧密程度的度量。</li>
<li>内聚是模块功能强度（一个模块内部各个元素彼此结合的紧密程度）的度量。</li>
<li>模块独立性比较强的模块应是高内聚低精合的模块。</li>
</ul>
<h3 id="模块间的耦合"><a href="#模块间的耦合" class="headerlink" title="模块间的耦合"></a>模块间的耦合</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121545118.png"/>

<h3 id="体系结构设计-系统结构模块"><a href="#体系结构设计-系统结构模块" class="headerlink" title="体系结构设计(系统结构模块)"></a>体系结构设计(系统结构模块)</h3><ul>
<li>传入模块</li>
<li>传出模块</li>
<li>变换模块</li>
<li>协调模块</li>
</ul>
<h3 id="模块的独立性"><a href="#模块的独立性" class="headerlink" title="模块的独立性"></a>模块的独立性</h3><table>
<thead>
<tr>
<th>模块间耦合形成</th>
<th>可读性</th>
<th>错误扩散能力</th>
<th>可修改性</th>
<th>通用性</th>
</tr>
</thead>
<tbody><tr>
<td>数据耦合</td>
<td>好</td>
<td>弱</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>控制耦合</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>公共耦合</td>
<td>不好</td>
<td>强</td>
<td>不好</td>
<td>不好</td>
</tr>
<tr>
<td>内容耦合</td>
<td>差</td>
<td>最强</td>
<td>最差</td>
<td>最差</td>
</tr>
</tbody></table>
<ul>
<li>在系统结构图中的模块</li>
<li>传入模块——从下属模块取得数据，经过某些处理，再将其传送给上级模 块。它传送的数据流叫做逻辑输入数据流。</li>
<li>传出模块——从上级模块获得数据，进行某些处理，再将其传送给下属模 块。它传送的数据流叫做理输出数据流。</li>
<li>变换模块——它从上级模块取得数据，进行特定的处理，转换成其它形式， 再传送回上级模块。它加工的数据流叫做变换数据流。</li>
<li>协调模块——对所有下属模块进行协调和管理的模块。</li>
</ul>
<h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121546537.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552195.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552021.png"/>

<h1 id="面向对象和UML"><a href="#面向对象和UML" class="headerlink" title="面向对象和UML"></a>面向对象和UML</h1><h2 id="面向对象方法-1"><a href="#面向对象方法-1" class="headerlink" title="面向对象方法"></a>面向对象方法</h2><h3 id="传统分析设计方法"><a href="#传统分析设计方法" class="headerlink" title="传统分析设计方法"></a>传统分析设计方法</h3><ul>
<li>以功能为中心的软件开发方法（结构化方法）</li>
<li>低内聚，高精合，缺乏灵活性和可维护性</li>
<li>分析与设计阶段采用的概念和表示不一致</li>
<li>以数据为中心的软件开发方法（信息建模方法）</li>
<li>对功能的处理较弱，不适合具有复杂功能的系统</li>
</ul>
<h3 id="类（抽象，分类）"><a href="#类（抽象，分类）" class="headerlink" title="类（抽象，分类）"></a>类（抽象，分类）</h3><p>类是具有共同属性和操作的对象的集合，对象是类的一个实例，类用于创建对象。</p>
<p>体现了抽象及分类原则，是人们分析问题的基本方法</p>
<ul>
<li><p>抽象：忽路事物的非本质特征，抽取共同的本质特征</p>
</li>
<li><p>分类：把具有共性的事物划分为一类</p>
</li>
</ul>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性：特殊类可以对继承来的属性和操作做出自己的解释，即在继承关系的类层次结构中可以定义同名操作或属性，形成同一操作或属性的多种形态，这样可以按不同的行为响应同一个消息。<br>多态性进一步体现了信息隐蔽的原则，可以实现接口的独立封装</p>
<h3 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555429.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555544.png"/>

<h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><h3 id="对象建模"><a href="#对象建模" class="headerlink" title="对象建模"></a>对象建模</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121557058.png"/>

<h3 id="协作图-x2F-通信图"><a href="#协作图-x2F-通信图" class="headerlink" title="协作图&#x2F;通信图"></a>协作图&#x2F;通信图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121558079.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">数学-线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 09:29:59" itemprop="dateCreated datePublished" datetime="2023-03-09T09:29:59+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 13:32:28" itemprop="dateModified" datetime="2023-03-30T13:32:28+08:00">2023-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>本视频基于【2023考研数学汤家凤线性代数基础课程】</strong></p>
<p>[第一章行列式.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==">https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==</a></p>
<p>[第二章矩阵.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==">https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==</a></p>
<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p>核心1:线性方程级</p>
<blockquote>
<table>
<thead>
<tr>
<th>工具</th>
</tr>
</thead>
<tbody><tr>
<td>行列式</td>
</tr>
<tr>
<td>矩阵</td>
</tr>
<tr>
<td>向量</td>
</tr>
</tbody></table>
</blockquote>
<p>核心2:矩阵对角比</p>
<blockquote>
<p>特征值与特征向量</p>
</blockquote>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h2><p>i,j ∈ N（自然数）且 i ≠ j</p>
<blockquote>
<p>这样就会形成两种情况</p>
<p>i &lt; j （i ，j ）即顺序</p>
<p>i &gt; j  （i，j）即逆序</p>
</blockquote>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>设<br>$$<br>i,i_2,…,i_n 为1，2，…n的一个排列i_1,i_2,…i_n含逆序个数之和称为逆序数<br>$$<br>记做<br>$$<br>\tau(i_1,i_2,…,i_n)<br>$$</p>
<blockquote>
<p>例如<br>$$<br>\tau（5,1,4,2,3）&#x3D; 6<br>$$<br>那其中这个6就成为逆序数</p>
</blockquote>
<h2 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h2><p>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n} \<br>…\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn} \<br>\end{matrix}\right|<br>&amp; 称为n阶行列式<br>$$</p>
<p>行列式计算</p>
<p>此处以三阶行列式为例<br>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; a_{13} \<br>a_{21} &amp; a_{22} &amp; a_{23} \<br>a_{31} &amp; a_{32} &amp; a_{33} \<br>\end{matrix}\right|<br>$$</p>
<p>$$<br>D&#x3D;+a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}+a_{12}a_{13}a_{21}+a_{32}-a_{13}a_{22}a_{31}<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" class="post-title-link" itemprop="url">英语语法学习笔记(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 12:24:51 / 修改时间：13:48:00" itemprop="dateCreated datePublished" datetime="2023-03-01T12:24:51+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">英语语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法概论"><a href="#语法概论" class="headerlink" title="语法概论"></a>语法概论</h1><h2 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h2><h3 id="实词"><a href="#实词" class="headerlink" title="实词"></a>实词</h3><table>
<thead>
<tr>
<th>词类</th>
<th>名称全称</th>
<th>全程简称</th>
<th>作用</th>
<th>句子成分</th>
<th>列词</th>
</tr>
</thead>
<tbody><tr>
<td>名词</td>
<td>Noun</td>
<td>n.</td>
<td>表示人或事物的名称</td>
<td>主、宾、表、同位语、补足语、定语</td>
<td>Lily、childhood</td>
</tr>
<tr>
<td>代词</td>
<td>pronoun</td>
<td>pron.</td>
<td>代替名词、数词等</td>
<td>主、宾、表、同位语、定语</td>
<td>I、we、none</td>
</tr>
<tr>
<td>数词</td>
<td>Numeral</td>
<td>num.</td>
<td>表示数目或顺序</td>
<td>主、宾、表、同位语、定语</td>
<td>one、ninth</td>
</tr>
<tr>
<td>形容词</td>
<td>Adjective</td>
<td>adj.</td>
<td>表示事物的特种</td>
<td>主、定、状、补足语</td>
<td>effective、popular</td>
</tr>
<tr>
<td>副词</td>
<td>Adverb</td>
<td>adv.</td>
<td>表示行为或状态特征（修饰动词）</td>
<td>状语、表语、补足语、定语</td>
<td>curiously、bravely</td>
</tr>
<tr>
<td>动词</td>
<td>Verb</td>
<td>v.</td>
<td>表示动词或状态</td>
<td>谓语</td>
<td>absorb、devote</td>
</tr>
</tbody></table>
<h3 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h3><table>
<thead>
<tr>
<th>词类</th>
<th>名称全称</th>
<th>全程简称</th>
<th>作用</th>
<th>句子成分</th>
<th>列词</th>
</tr>
</thead>
<tbody><tr>
<td>冠词</td>
<td>Article</td>
<td>art.</td>
<td>用在名词前，起限定作用</td>
<td></td>
<td>a、an、the</td>
</tr>
<tr>
<td>介词</td>
<td>Preposition</td>
<td>prep.</td>
<td>用在名词、代词等前，说明与其他词的关系</td>
<td></td>
<td>in、before、beyond</td>
</tr>
<tr>
<td>连词</td>
<td>Conjunction</td>
<td>conj.</td>
<td>用来连接词与词、短语与短语或句子与句子</td>
<td></td>
<td>and、when、until、if、once</td>
</tr>
<tr>
<td>感叹词</td>
<td>Interjection</td>
<td>interj.</td>
<td>表示说话时的感情或语气</td>
<td></td>
<td>oh、ah、aha、hurrah</td>
</tr>
</tbody></table>
<h2 id="句子成分"><a href="#句子成分" class="headerlink" title="句子成分"></a>句子成分</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称(英)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>主语</td>
<td>Subject</td>
<td>一句话的中心</td>
</tr>
<tr>
<td>谓语</td>
<td>Predicate</td>
<td>主语的主要情况，即表示动作，也可表示状态</td>
</tr>
<tr>
<td>宾语</td>
<td>Object</td>
<td>动作的承受者或动作针对的对象</td>
</tr>
<tr>
<td>表语</td>
<td>Predicative</td>
<td>主语的身份、性质、特征、状态等、和系动词一起构成谓语<br />【Life is not <strong>all roses</strong>】</td>
</tr>
<tr>
<td>定语</td>
<td>Attribute</td>
<td>修饰名词、代词等</td>
</tr>
<tr>
<td>状语</td>
<td>Adverbial</td>
<td>修辞动词、形容词、副词等</td>
</tr>
</tbody></table>
<h2 id="短语与从句"><a href="#短语与从句" class="headerlink" title="短语与从句"></a>短语与从句</h2><h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>动词短语</td>
<td></td>
</tr>
<tr>
<td>不定式短语</td>
<td></td>
</tr>
<tr>
<td>动名词短语</td>
<td></td>
</tr>
<tr>
<td>分词短语</td>
<td></td>
</tr>
<tr>
<td>分词短语</td>
<td></td>
</tr>
<tr>
<td>介词短语</td>
<td></td>
</tr>
<tr>
<td>名词短语</td>
<td></td>
</tr>
</tbody></table>
<h3 id="从句"><a href="#从句" class="headerlink" title="从句"></a>从句</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>名词性从句</td>
<td></td>
</tr>
<tr>
<td>状语从句</td>
<td></td>
</tr>
<tr>
<td>定语从句</td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 13:27:36" itemprop="dateCreated datePublished" datetime="2023-02-18T13:27:36+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-12 00:49:42" itemprop="dateModified" datetime="2023-05-12T00:49:42+08:00">2023-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">计算机系统概述</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87">操作系统的功能和目标</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81">操作系统的四个特征</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">操作系统的运行机制和体系结构</a><ul>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a></li>
<li><a href="#cpu">CPU</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F">程序</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8">操作系统的内核</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8">中断和异常</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8">概念和作用</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>系统调用和库函数的区别</strong></a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%84%E6%88%90%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%89%B9%E5%BE%81">进程的定义，组成，组织方式，特征</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F">进程的组织方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2">进程的状态和转换</a><ul>
<li><a href="#%E7%8A%B6%E6%80%81">状态</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2">转换</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-1">含义</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD">相关原语</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-2">含义</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1">共享存储，消息传递，管道通信。</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">线程概念和多线程模型</a><ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB">线程分类</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">多线程模型</a><ul>
<li><a href="#%E5%A4%9A%E5%AF%B91%E6%A8%A1%E5%9E%8B">多对1模型</a></li>
<li><a href="#1%E5%AF%B91%E6%A8%A1%E5%9E%8B">1对1模型</a></li>
<li><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B">多对多模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1">处理机调度的概念和层次</a><ul>
<li><a href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%88%9D%E7%BA%A7%E8%B0%83%E5%BA%A6">高级调度，中级调度，初级调度。</a><ul>
<li><a href="#1%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6">1.高级调度</a></li>
<li><a href="#2%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6">2.中级调度</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B">补充知识：进程的七状态模型</a></li>
</ul>
</li>
<li><a href="#3%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6">3.低级调度</a></li>
<li><a href="#%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%AF%B9%E6%AF%94">三种调度的联系和对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%B9%E5%BC%8F">进程调度的时机，切换过程和方式</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">进程调度时机</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B">进程的切换与过程</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">调度算法的评价指标</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">调度算法</a><ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E9%AB%98%E5%93%8D%E5%BA%94%E5%BF%85%E4%BC%98%E5%85%88">先来先服务，短作业优先，高响应必优先</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85">补充：</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">时间片轮转调度，优先级调度算法，多级反馈队列调度算法</a><ul>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6rr">时间片轮转调度RR</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">优先级调度算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级反馈队列调度算法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程同步与进程互斥</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程互斥</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的软件实现方法</a><ul>
<li><a href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95">单标志法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95">双标志先检查法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95">双标志后检查法</a></li>
<li><a href="#peterson%E7%AE%97%E6%B3%95">Peterson算法</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的硬件实现方法</a><ul>
<li><a href="#testandset%E6%8C%87%E4%BB%A4">TestAndSet指令</a></li>
<li><a href="#swap%E6%8C%87%E4%BB%A4">Swap指令</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81">进程互斥：锁</a><ul>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81-1">互斥锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6">信号量机制</a><ul>
<li><a href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F">整形信号量</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">记录型信号量</a></li>
<li><a href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">用信号量实现进程互斥，同步，前驱关系</a><ul>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">信号量机制实现进程互斥</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">信号量机制实现进程同步</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">信号量机制实现前驱关系</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者——消费者问题</a></li>
<li><a href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85">多生产者——多消费者</a></li>
<li><a href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98">吸烟者问题</a></li>
<li><a href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">读者——写者问题</a></li>
<li><a href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD">哲学家吃饭</a></li>
<li><a href="#%E7%AE%A1%E7%A8%8B">管程</a><ul>
<li><a href="#java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">java中类似于管程的机制（单例模式）</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a><ul>
<li><a href="#%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB">死锁，饥饿，死循环的区别</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁产生的必要条件</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81">什么时候会发生死锁</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">死锁的处理策略</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ol>
<li><p>作为系统资源的管理者</p>
<ul>
<li><p>文件管理</p>
</li>
<li><p>内存管理</p>
</li>
<li><p>处理及（CPU）管理</p>
</li>
<li><p>设备（计算机硬件，例如摄像头）管理</p>
</li>
</ul>
</li>
<li><p>作为用户和计算机硬件之间的接口</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181513303.png"/>


</li>
<li><p>对硬件机器的扩展</p>
</li>
</ol>
<h2 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a>操作系统的四个特征</h2><ol>
<li><p>并发</p>
<p>并发是指<strong>两个或多个事件在同一时间间隔内发生</strong>。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p>
<p><span style="color:red">易混淆的概念——并行：两个或多个事件在同一时刻同时发生</span></p>
</li>
<li><p>共享</p>
<p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p>
<table>
<thead>
<tr>
<th>两种资源共享方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>互斥共享方式</td>
<td>系统中的某些资源，虽然可以提供给多个进程使用，<br><span style="color:red">但<strong>一个时间段内只允许一个进程访问该资源</strong></span></td>
</tr>
<tr>
<td>同时共享方式</td>
<td>系统中的某些资源，<br><span style="color:red"><strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></span></td>
</tr>
</tbody></table>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p>
<p>例如：</p>
<ul>
<li><p>互斥共享方式：使用QQ和微信进行视频，但是同一个时间段内摄像头只能分配给其中一个进程</p>
</li>
<li><p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></p>
</li>
</ul>
</li>
<li><p>虚拟</p>
<p>虚拟是指把一个屋里上的实体变成若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<table>
<thead>
<tr>
<th>虚拟技术</th>
<th>例如</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空分复用技术</td>
<td>虚拟存储器技术</td>
<td></td>
</tr>
<tr>
<td>时分复用技术</td>
<td>虚拟处理器</td>
<td>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<span style="color:red"><strong>没有并发性，就谈不上虚拟性</strong></span></td>
</tr>
</tbody></table>
</li>
<li><p>异步</p>
<p>异步是指,在多道程序环境下，<strong>允许多个程序并发执行</strong>，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<ul>
<li>只有系统拥有并发性，才有可能导致异步性。</li>
</ul>
</li>
</ol>
<h2 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>特权指令</td>
<td>如内存清零指令（不允许用户程序使用）</td>
</tr>
<tr>
<td>非特权指令</td>
<td>如普通的运算指令</td>
</tr>
</tbody></table>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><table>
<thead>
<tr>
<th>两种处理器状态</th>
<th>(用程序状态字寄存器（PSW)中的某 标志位来标识当前处理器处于什么状 态。如0为用户态，1为核心态)</th>
</tr>
</thead>
<tbody><tr>
<td>用户态（目态）</td>
<td>此时CPU只能执行非特权指令</td>
</tr>
<tr>
<td>核心态（管态）</td>
<td>特权指令、非特权指令都可执行</td>
</tr>
</tbody></table>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table>
<thead>
<tr>
<th>两种程序</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内核程序</td>
<td>操作系统的内核程序是系统的管理者，即可执行特权指令，也可以执行非特权指令，运行也在核心态</td>
</tr>
<tr>
<td>应用程序</td>
<td>为了保证系统能安全运行，普通应用程序只能执行费特权指令，运行在用户态</td>
</tr>
</tbody></table>
<h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>由于内核划分功能的不同，内核分为大内核和微内核</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181514707.png"/>

<ul>
<li><p>大内核和微内核的优缺点</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181515691.png"/></li>
</ul>
<p>类比：</p>
<ul>
<li>操作系统的体系结构问题与企业的管理问题很相似。</li>
<li>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</li>
<li>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</li>
<li>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</li>
</ul>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><p><strong>中断</strong>是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li>
<li>对于不同的中断信号，会进行不同的处理。</li>
<li>有了中断，才能实现多道程序并发执行。</li>
<li>“用户态→核心态”是通过中断实现的，<strong>并且中断是唯一途径</strong>。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p> 中断型号的来源来自CPU内部称为内中断，外部称为外中断。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181520216.png"/>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181523855.png"/>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证操作系统的稳定性和安全性，防止用户进行非法操作。</p>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h3><p>编程语言（C、JAVA）中里边有很多库函数，其实他们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li>
<li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进行核心态。</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，组成，组织方式，特征"><a href="#进程的定义，组成，组织方式，特征" class="headerlink" title="进程的定义，组成，组织方式，特征"></a>进程的定义，组成，组织方式，特征</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序：就是指令序列</p>
<p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p>
<p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p>
<p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p>
<p><strong>PCB是进程存在的唯一标识。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201633291.png"/>



<h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p>
<p>相当于java中的链表和数组。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201634493.png"/>

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201635642.png"/>



<h2 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201638848.png"/>

<p>除此之外，进程还有两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640201.png"/>

<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640665.png"/>

<blockquote>
<p>注意：<strong>不能由阻塞态直接转换为运行态也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121229670.png"/>

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>进程控制就是要<strong>实现进程状态转换</strong>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</p>
<p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 <strong>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201648777.png"/>

<p>那么原语是如何实现进程状态的转换呢？</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>a.所有的进程控制原语一定都会修改进程状态标志<br>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c.某进程开始运行前必然要恢复期运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配&#x2F;回收资源</li>
</ol>
<p>具体实现如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201704327.png"/>

<h3 id="相关原语"><a href="#相关原语" class="headerlink" title="相关原语"></a>相关原语</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121237633.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121238008.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121239248.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121240249.png"/>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>进程通信就是<strong>进程间的信息交换</strong></p>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p>
<h3 id="共享存储，消息传递，管道通信。"><a href="#共享存储，消息传递，管道通信。" class="headerlink" title="共享存储，消息传递，管道通信。"></a>共享存储，消息传递，管道通信。</h3><ol>
<li><p>共享存储</p>
<p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式<br><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</p>
<p>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的（互斥访问通过操作系统提供的工具实现）<br>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201843057.png"/>
</li>
<li><p>管道通信</p>
</li>
</ol>
<blockquote>
<p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
<p>2.各进程要互斥地访问管道。</p>
<p>3.数据以字符流的形式写入管道，当管道<strong>写满时</strong>，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。</p>
<p>4.<strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></p>
<p>5．数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个，否则可能会有读错数据的情况。</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201847528.png"/>

<ol start="3">
<li><p>消息传递</p>
<p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p>
<p>类似于Http协议。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201849801.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121248665.png"/></li>
</ol>
<h2 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h2><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能<strong>串行</strong>执行一系列程序。因此，引入“线程”，来增加并发度。</p>
<ul>
<li>可以把线程理解为轻量级的进程。</li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</li>
<li>引入线程后，进程作为除CPU之外的系统资源的分配单元。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201852799.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121252713.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121253934.png"/></p>
<h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><ol>
<li>用户级线程</li>
</ol>
<ul>
<li>用户级线程由应用程序通过线程库实现。<strong>所有的线程管理工作都由应用程序负责（包括线程切换)</strong></li>
<li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预。</strong></li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li>
<li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li>
</ul>
<ol start="2">
<li>内核级线程</li>
</ol>
<ul>
<li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li>
</ul>
<p><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对1模型"><a href="#多对1模型" class="headerlink" title="多对1模型"></a>多对1模型</h4><ul>
<li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li>
<li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li>
<li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201913689.png"/>

<h4 id="1对1模型"><a href="#1对1模型" class="headerlink" title="1对1模型"></a>1对1模型</h4><ul>
<li>一对一模型:一个用户级线程映射到一个内核级线程。</li>
<li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li>
<li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201917778.png"/>

<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><ul>
<li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201918142.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121258062.png"/></p>
<h2 id="处理机调度的概念和层次"><a href="#处理机调度的概念和层次" class="headerlink" title="处理机调度的概念和层次"></a>处理机调度的概念和层次</h2><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p>
<p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p>
<p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p>
<h3 id="高级调度，中级调度，初级调度。"><a href="#高级调度，中级调度，初级调度。" class="headerlink" title="高级调度，中级调度，初级调度。"></a>高级调度，中级调度，初级调度。</h3><h4 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h4><ul>
<li><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
</li>
<li><p>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</p>
</li>
<li><p><strong>高级调度是辅存（外存）与内存之间的调度</strong>。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。<strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201923361.png"/></li>
</ul>
<h4 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h4><ul>
<li><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量</strong>。</p>
</li>
<li><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p>
</li>
<li><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></p>
</li>
<li><p>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201924752.png"/></li>
</ul>
<h5 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h5><ul>
<li><p>暂时被调到外存等待的进程状态称为挂起状态。</p>
</li>
<li><p>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201926432.png"/></li>
</ul>
<h4 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h4><ul>
<li>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的频率很高，一般几十毫秒一次。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202014458.png"/>

<h4 id="三种调度的联系和对比"><a href="#三种调度的联系和对比" class="headerlink" title="三种调度的联系和对比"></a>三种调度的联系和对比</h4><table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存（面向作业）</td>
<td>最低</td>
<td>无-创建态-就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td>外存-&gt;内存（面向进程）</td>
<td>中等</td>
<td>挂起态-就绪态（阻塞挂起-阻塞态）</td>
</tr>
<tr>
<td>低级调度（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-运行态</td>
</tr>
</tbody></table>
<h2 id="进程调度的时机，切换过程和方式"><a href="#进程调度的时机，切换过程和方式" class="headerlink" title="进程调度的时机，切换过程和方式"></a>进程调度的时机，切换过程和方式</h2><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202048883.png"/>

<p>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><ul>
<li>非剥夺调度方式，又称非抢占方式。即，<strong>只允许进程主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
</ul>
<p>优点：实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
<ul>
<li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
</ul>
<p>优点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<p><strong>优点：</strong></p>
<p>可以有限处理更紧急的进程，也可实现让哥进程按时间骗轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别:</p>
<ul>
<li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p>
</li>
<li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
</li>
</ul>
<p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p>
<p>进程切换的过程主要完成了:</p>
<ul>
<li>1.对原来运行进程各种数据的保存</li>
<li>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ul>
<p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><ul>
<li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li>
<li>系统吞吐量：单位时间内完成作业的数量。</li>
</ul>
<p>$$<br>系统吞吐量&#x3D;{总共完成了多少道作业\over总共花了多少时间}<br>$$</p>
<ul>
<li><p>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</p>
<p><span style="color:red"><strong>周转时间&#x3D;作业完成时的时间-作业提交时间</strong></span></p>
<p><span style="color:red"><strong>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</strong></span></p>
</li>
</ul>
<p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。<br>$$<br>带权周转时间&#x3D;{作业周转时间\over作业实际运行的时间}&#x3D;{作业完成的时间-作业提交时间\over作业实际运行的时间}<br>$$</p>
<p>$$<br>平均的带权周转时间&#x3D;{各个作业带权周转时间之和\over作业数}<br>$$</p>
<ul>
<li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li>
</ul>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<ul>
<li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务，短作业优先，高响应必优先"><a href="#先来先服务，短作业优先，高响应必优先" class="headerlink" title="先来先服务，短作业优先，高响应必优先"></a>先来先服务，短作业优先，高响应必优先</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>算法思想与规则</th>
<th>可抢占？</th>
<th>优点</th>
<th>缺点</th>
<th>考虑到等待时间&amp;运行时间？</th>
<th>会导致饥饿？</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务</td>
<td>FCFS</td>
<td>公平，先到先得</td>
<td>非</td>
<td>公平，实现简单</td>
<td>对短作业不利</td>
<td>有等待，无运行</td>
<td>不</td>
</tr>
<tr>
<td>短作业优先</td>
<td>SJF&#x2F;SPF</td>
<td>追求快<br />时间最短的先服务</td>
<td>默认为非抢占式版本，也有SJF的抢占式版本最短剩余时间优先算法(SRTN)</td>
<td>“最短的”平均等待&#x2F;周转时间</td>
<td>对长作业不利，可能导致饥饿；难以做到真正的短时间优先</td>
<td>有运行，无等待</td>
<td>会</td>
</tr>
<tr>
<td>高响应必优先</td>
<td>HRRN</td>
<td>作业&#x2F;进程的等待时间<br />计算<span style="color:red">响应比</span>,选择<span style="color:red">响应比最高的</span>作业&#x2F;进程优先</td>
<td>非</td>
<td>权衡折中，综合考虑等待时间和运行时间</td>
<td></td>
<td>都有</td>
<td>不</td>
</tr>
</tbody></table>
<p><span style="color:red">响应比</span> (响应比&gt;&#x3D;1) ：<br>$$<br>响应比&#x3D;{等待时间+要求服务时间\over要求服务时间}<br>$$<br>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><blockquote>
<ol>
<li><p>FCFS 由于在长作业过程中，后面的短作业需要等很长的时间，带权周转时间很大，对短作业用户体验不好。</p>
</li>
<li><p>FCFS 用于作业调度时，考虑的是那个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p>
</li>
<li><p>SJF 是用于作业调度，也可用于进程调度。用于进程调度时成为”短进程优先”(SPF，Shortest Process First)</p>
</li>
<li><p>SJF 和 SPF 是非抢占式算法，但是也有抢占式的版本–最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)</p>
</li>
<li><p>SJF 对长作业不利，可能产生饥饿现象。另外，作业&#x2F;进程真正运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p>
</li>
<li><p>SJF 如果有源源不断地有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生”饥饿”现象，如果一直得不到服务，则称为 饿死</p>
</li>
<li><p>HRRN 在每次调度室先计算各个作业&#x2F;进程的 响应比 ，选择响应比<span style="color:red">最高</span>的作业&#x2F;进程为其服务</p>
</li>
<li><ul>
<li><p>HRRN 综合考虑了等待时间和运行时间（要求服务时间）</p>
</li>
<li><p>等待时间相同时，要求服务时间端的优先（SJF 的优点）</p>
</li>
<li><p>要求服务时间相同时，等待时间长的优先（FCFS的优点）</p>
</li>
<li><p>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"><a href="#时间片轮转调度，优先级调度算法，多级反馈队列调度算法" class="headerlink" title="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"></a>时间片轮转调度，优先级调度算法，多级反馈队列调度算法</h3><h4 id="时间片轮转调度RR"><a href="#时间片轮转调度RR" class="headerlink" title="时间片轮转调度RR"></a>时间片轮转调度RR</h4><table>
<thead>
<tr>
<th>时间片轮转调度<br />（RR，Round-Robin）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td>
</tr>
<tr>
<td>算法规则</td>
<td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<span style="color:red">时间片</span>（如100ms)。若进程未在一个时间片内执行完则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度（只有作业放入内存建立了相应的进程后，<br/>才能被分配处理机时间片）</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>若进程未能在时间片内运行完，将被强行剥夺处理机使权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平；响应快，适用于分时操作系统；<br />缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>否</td>
</tr>
<tr>
<td>补充</td>
<td>时间片问题：<br />如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。<br />另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。<br />一般来说，设计时间片要让切换进程的开销占比不超过1%。</td>
</tr>
</tbody></table>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><table>
<thead>
<tr>
<th>优先级调度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场最需要根据任务的紧急程度来决定处理顺序</td>
</tr>
<tr>
<td>算法规则</td>
<td>调度时选择优先级最高的作业&#x2F;进程</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>既可用于作业调度，也可用于进程调度。甚至还会用于在之后会学习的I&#x2F;O调度中</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需任就绪队列变化时，检查是否会发生抢占。</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：用优先级区分紧总程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充</td>
<td>如下图</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251342602.png"/>

<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><table>
<thead>
<tr>
<th>多级反馈队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>对其他调度算法的折中权衡</td>
</tr>
<tr>
<td>算法规则</td>
<td>1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k级 队列队尾</td>
</tr>
<tr>
<td>优缺点</td>
<td>对各类型进程相对公平(FCFS的优点)：每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的时间就可完成(SPF的优点)；不必实现估计进程的运行时间（避免用户作假）：可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、&#x2F;O密集型进程（拓展：可以将因&#x2F;O而阻塞的进程重新放回原队列，这样&#x2F;O型进程就可以保持较高优先级)</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充理解</td>
<td>如下文</td>
</tr>
</tbody></table>
<blockquote>
<p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>P1(1) —— P2(1) —— P1(2) —— P2(1) —— P3(1) —— P2(2) —— P1(4) —— P1(1)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251358421.png"/>

<p>设置多级就绪队列，各级队列<strong>优先级从高到低</strong>，<strong>时间片从小到大</strong></p>
<p><span style="color:red">新进程</span>到达时<span style="color:red">先进入第1级队列</span>，按<span style="color:red">FCFS原则</span>排队等待被分配时间片。若用完时间片进程还<strong>未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>己经在最下级</strong>的队列，则<strong>重新放回</strong>最下级队列队尾</p>
<p>只有第<strong>k级队列为空</strong>时，才会<strong>为k+1级</strong>队头的进程<strong>分配时间片</strong><br><strong>被抢占处理机的进程重新放回原队列队尾</strong></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括<strong>分时操作系统、实时操作系统</strong>等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统。</strong>(比如UNIX使用的就是多级反馈队列调度算法)</p>
<h3 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>以下例子为管道通信为实例</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282350043.png"/>

<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></p>
<blockquote>
<p>含义</p>
</blockquote>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><ul>
<li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li>
<li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li>
<li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282351880.png"/>

<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282359512.png"/>

<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091148134.png"/>

<blockquote>
<p>turn的初值为0，即刚开始只允许0号进程进入临界区。<br>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。<br>因此，<strong>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p>
<p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→…这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。<br>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p>
</blockquote>
<h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091154224.png"/>

<p>若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091158727.png"/>

<p>若按照①⑤②⑥…的顺序执行，P0和P1将都无法进入临界区因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091200387.png"/>

<ul>
<li>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li>
<li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li>
</ul>
<h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516619.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516916.png"/>

<blockquote>
<p>关中断指令只对执行关中断指令的处理机有用</p>
</blockquote>
<h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518026.png"/>

<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518466.png"/>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="进程互斥：锁"><a href="#进程互斥：锁" class="headerlink" title="进程互斥：锁"></a>进程互斥：锁</h4><h5 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>解决临界区最简单的工具就是互斥锁（mutexlock)。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available); <span class="comment">//忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>; <span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>; <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。<br>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁（</strong>spin lock)，如TSL指令、swap指令、单标志法 </p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261531895.png"/>

<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li><strong>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，</strong>可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li>
<li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li>
<li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li>
<li>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261532635.png"/>

<p>进程互斥的四种软件实现方式（单标志法，双标志先检查，双标志后检查，Peterson算法）</p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法，TS&#x2F;TSL指令，Swap&#x2F;XCHG指令）</p>
<p>1.在双标志先检查法中，进去区的”检查“，”上锁“操作无法一气呵成，中间有可能先执行了检查就进行了进程切换，从而导致了两个进程有可能同时进入临界区的问题；</p>
<p>2.所有的解决方案都无法实现”让权等待“</p>
<blockquote>
<p>其中单标志法，双标志先检查，双标志后检查都存在着比较严重的一些问题的隐患。Peterson算法还有后面的三种硬件实现方式其实问题都不大，但是这些方式也都无法解决”让权等待“原则</p>
</blockquote>
<h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072113564.png"/>

<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072114497.png"/>

<h3 id="用信号量实现进程互斥，同步，前驱关系"><a href="#用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="用信号量实现进程互斥，同步，前驱关系"></a>用信号量实现进程互斥，同步，前驱关系</h3><h4 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol>
<li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li>
<li>设置互斥信号量mutex，初值为1</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072115578.png"/>

<p>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p>
<p><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p>
<h4 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序的进行。</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li>
<li>设置同步信号量s,初始为0</li>
<li>在“前操作”之后执行v(S)</li>
<li>在“后操作”之前执行P(S)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072117802.png"/>

<h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，</p>
<ol>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在“前操作”之后对相应的同步变量执行V操作</li>
<li>在“后操作”之前对相应的同步变量执行Р操作</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072118787.png"/>

<h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
<li>缓冲区是临界资源，各进程必须互斥地访问。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119845.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119979.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119956.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119961.png"/>

<h3 id="多生产者——多消费者"><a href="#多生产者——多消费者" class="headerlink" title="多生产者——多消费者"></a>多生产者——多消费者</h3><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123688.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123924.png"/>

<p>问题：可不可以不使用问题信号量？</p>
<p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p>
<p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p>
<p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p>
<ol>
<li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li>
<li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li>
</ol>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124996.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124492.png"/>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p>
<p>①允许多个读者可以同时对文件执行读操作;</p>
<p>②只允许一个写者往文件中写信息;</p>
<p>③任一写者在完成写操作之前不允许其他读者或写者工作;</p>
<p>④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125799.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125176.png"/>

<ul>
<li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125944.png"/>

<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。<br>其核心思想在于<strong>设置了一个计数器count用来记录当前正在访问共享文件的读进程数</strong>。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，<strong>如果需要实现“一气呵成”，自然应该想到用互斥信号量。</strong><br>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126626.png"/>

<p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<p>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p>
<blockquote>
<p>以下方式会出现死锁问题</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126279.png"/>
</blockquote>
<p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072127517.png"/>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程相当于对临界区资源进行抽象而编写的一个类。</strong></p>
<p>管程是一种特殊的软件模块，有这些部分组成:</p>
<p>1.局部于管程的共享数据结构说明; （一个类）</p>
<p>2.对该数据结构进行操作的一组过程; （类中的方法）</p>
<p>3．对局部于管程的共享数据设置初始值的语句; （类中的变量）</p>
<p>4.管程有一个名字。 （类名）</p>
<p>管程的基本特征:</p>
<p>1．局部于管程的数据只能被局部于管程的过程所访问; （类中变量有自己的作用范围）</p>
<p>**2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** <strong>这种互斥特性是由编译器来实现的。</strong></p>
<p><strong>3．每次仅允许一个进程在管程内执行某个内部过程。</strong></p>
<blockquote>
<h4 id="java中类似于管程的机制（单例模式）"><a href="#java中类似于管程的机制（单例模式）" class="headerlink" title="java中类似于管程的机制（单例模式）"></a>java中类似于管程的机制（单例模式）</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072128379.png"/>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p>
<p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p>
<h4 id="死锁，饥饿，死循环的区别"><a href="#死锁，饥饿，死循环的区别" class="headerlink" title="死锁，饥饿，死循环的区别"></a>死锁，饥饿，死循环的区别</h4><ul>
<li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li>
<li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072129588.png"/>

<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求 和 保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>)</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</p>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li>
<li><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072130399.png"/>

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061307159.png"/>

<p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081538138.png"/>

<h2 id="相对地址和绝对地址"><a href="#相对地址和绝对地址" class="headerlink" title="相对地址和绝对地址"></a>相对地址和绝对地址</h2><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong><br>编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>
<p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p>
<h2 id="三种装入模式"><a href="#三种装入模式" class="headerlink" title="三种装入模式"></a>三种装入模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061302897.png"/>

<h3 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h3><p>这种方式的灵活性很差，只适用于单道程序环境，早期还没有操作系统的阶段使用的就是这种方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061316431.png"/>

<h3 id="可重定位装入"><a href="#可重定位装入" class="headerlink" title="可重定位装入"></a>可重定位装入</h3><p>这种方式的特点是我们给这个作业&#x2F;进程分配的这些地址空间必须是连续的，并且这个作业必须一次全部装入内存</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317740.png"/>

<h3 id="动态运行时装入"><a href="#动态运行时装入" class="headerlink" title="动态运行时装入"></a>动态运行时装入</h3><p>CPU在对一个内存地址进行访问的时候会把逻辑地址和重定位寄存器当中存放的起始地址进行相加得到最终可以访问的地址</p>
<p>想让进程的数据在运行过程当中发生移动是很方便的，只需要修改重定位寄存器的值就可以</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317519.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317630.png"/>

<h2 id="程序运行逻辑"><a href="#程序运行逻辑" class="headerlink" title="程序运行逻辑"></a>程序运行逻辑</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081539943.png"/>

<p>这些目标模块文件当中已经包含了这些代码所对应的那些指令，而这些指令的编址都是逻辑地址。每一个模块的逻辑地址编址都是相互独立的，都从0开始</p>
<p>链接把这些目标模块组装起来形成一个完整的装入模块</p>
<p>在链接这一步，除了我们自己编写的这些目标模块需要链接以外，还需要把它们所调用到的一些库函数（如printf）也链接起来</p>
<h3 id="程序运行前—静态连接"><a href="#程序运行前—静态连接" class="headerlink" title="程序运行前—静态连接"></a>程序运行前—静态连接</h3><p>就是我们刚才所提到的这种方式，在形成装入模块之后就确定了这个装入模块的完整的逻辑地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061319738.png"/>

<h3 id="装入时—动态连接"><a href="#装入时—动态连接" class="headerlink" title="装入时—动态连接"></a>装入时—动态连接</h3><p>采用这种方式的话，这个进程的完整的逻辑地址是一边装入一边形成的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061320350.png"/>

<h3 id="运行时—动态连接"><a href="#运行时—动态连接" class="headerlink" title="运行时—动态连接"></a>运行时—动态连接</h3><p>需要用到某一个模块的时候再把它调入内存，装入的同时进行链接</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321161.png"/>

<h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321531.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061323512.png"/>

<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<ol>
<li><p>操作系统负责内存空间的分配与回收</p>
</li>
<li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></p>
</li>
</ol>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 </p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061326837.png"/>

<p>绝对装入是在编译的时候就产生了绝对地址，或者说在程序员写程序的时候直接就写了绝对地址。这个地址转换是由编译器而不是操作系统完成的</p>
<p>可重定位装入中地址转换的过程由装入程序负责进行，而装入程序也是操作系统的一部分</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111342928.png"/>

<h4 id="上下寄存器"><a href="#上下寄存器" class="headerlink" title="上下寄存器"></a>上下寄存器</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111342779.png"/>

<h4 id="重定位寄存器"><a href="#重定位寄存器" class="headerlink" title="重定位寄存器"></a>重定位寄存器</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111343667.png"/>

<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111344101.png"/>

<h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。<br>后来人们引入了<strong>覆盖技术，用来解决“程小超过物理内存总和”的问题</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111346095.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111346097.png"/>

<blockquote>
<p>A这个模块会依次调用B模块和C模块。注意是依次调用，B模块和C模块只可能被A模块在不同的时间段调用，不可能是同时访问B和C这两个模块</p>
</blockquote>
<p>操作系统并不知道程序的调用结构，程序的调用结构必须由程序员显性地声明，操作系统根据程序员声明的调用结构&#x2F;覆盖结构完成自动覆盖</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111350389.png"/>

<p>第二章讲处理机调度的时候讲过一个处理机调度层次的概念，分为高级调度，中级调度和低级调度。其中中级调度就是为了实现交换技术而使用的一种调度策略</p>
<p>换出外存的进程相关的PCB会保留在内存当中并且插入到挂起队列里</p>
<p>为什么进程的PCB要常驻内存呢？因为进程被换出外存之后，必须要通过某种方式记录下进程到底是放在外存的什么位置，这个信息记录在对应的PCB当中，操作系统就可以根据PCB当中记录的这些信息对这些进程进行管理</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111350777.png"/>

<p>一个本来处于就绪态的进程被换出外存，这个进程就处于就绪挂起态</p>
<p>一个本来处于阻塞态的进程被换出外存，这个进程就处于阻塞挂起态</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111351844.png"/>

<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111351402.png"/>

<p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111352995.png"/>

<p>内存当中同一时刻只能有一道用户程序，它并不支持多道程序并发运行</p>
<p>因为系统中只会运行一个用户程序，即使这个用户程序出问题了也只会影响用户程序本身，或者说即使这个用户程序越界损坏操作系统的数据，这个数据一般来说也可以通过重启计算机就可以很方便地进行修复，所以说采用单一连续分配的系统当中不一定采取内存保护</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111353659.png"/>

<p>分区大小相等：如果有一个比较大的进程进入的话，如果这些分区的大小都不能满足这个大进程的需求，那么这个大进程就不能被装入这个系统，或者说只能采用覆盖技术在逻辑上来拓展各个分区的大小，而这显然又会增加一些系统开销</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111354699.png"/>

<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111354258.png"/>

<h5 id="动态分区存在的问题"><a href="#动态分区存在的问题" class="headerlink" title="动态分区存在的问题"></a>动态分区存在的问题</h5><ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111359562.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111400729.png"/>
</li>
<li><p>分区分配：<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111400169.png"/></p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111410550.png"/>

<ol start="4">
<li>分区回收：<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111411848.png"/></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111414369.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111414421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111415359.png"/>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>这几种情况本质上可以用一句话来进行总结：在进行内存分区回收的时候，如果说回收了之后发现有一些空闲分区是相邻的，那我们就需要把这些相邻的空闲分区全部合并</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111415841.png"/>

<p>紧凑技术其实就是把各个进程挪位，把它们全部攒到一起，挪出一个更大的连续空闲区间</p>
<p>动态重定位的方式最方便实现程序或者说进程在内存当中移动位置</p>
<p>紧凑之后需要修改各个进程的起始地址，进程的起始地址信息一般存放在进程对应的PCB当中，当进程要上CPU运行之前会把进程的起始地址信息放到重定位寄存器（基址寄存器）里</p>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111416487.png"/>

<p>动态分区分配算法：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区</p>
<p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块。因此这种方法会产生很多的外部碎片</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>又称 最大适应算法（Largest Fit）</p>
<p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p>
<p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有”大进程“到达，就没有内存分区可用了</p>
<h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</p>
<p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>假如说此时系统当中的内存使用情况如下图所示，把这些空闲分区按照地址递增的次序依次进行排列，排成一个循环链表</p>
<p>如果有一个需要5MB内存空间的进程到达，就从链头的位置开始查找直到找到合适的分区进行分配。同时更新链当中的结点，包括分区的大小，还有分区的起始地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111418851.png"/>

<p>采用邻近适应算法和首次适应算法只需要按照地址递增的次序进行排列。所以即使这里内存分区的大小发生了一个比较大的变化，但是我们依然不需要像最佳适应算法和最坏适应算法一样可能要对整个链表进行重新排列，算法的开销会比较小</p>
<p>接下来假如一个需要5MB内存空间的新进程到达，按照规则从上一次查找到的位置依次再往后查找即可。以后的过程都是类似的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111419898.png"/>

<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>
<p>综合来看，四种算法中，首次适应算法的效果反而更好</p>
</blockquote>
<h3 id="基本分页存储管理的概念"><a href="#基本分页存储管理的概念" class="headerlink" title="基本分页存储管理的概念"></a>基本分页存储管理的概念</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111420967.png"/>

<p>非连续分配：为用户进程分配的可以是一些分散的内存空间</p>
<h4 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111420848.png"/>

<p>内存里存放的无非就是各个进程的数据，包括进程的代码，进程的指令等等</p>
<h4 id="页表——重要的数据结构"><a href="#页表——重要的数据结构" class="headerlink" title="页表——重要的数据结构"></a>页表——重要的数据结构</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111421980.png"/>

<blockquote>
<p>内存块就是页框(page flame)</p>
</blockquote>
<h4 id="问题1：每个页表项占多少字节"><a href="#问题1：每个页表项占多少字节" class="headerlink" title="问题1：每个页表项占多少字节"></a>问题1：每个页表项占多少字节</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111422216.png"/>

<p>这里计算机分配存储空间是以字节为单位而不是以bit为单位，所以20bit至少要用3B来存储</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111428370.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111428490.png"/>

<p>一个页表项在逻辑上是包含了页号和块号这两个信息，但是在物理上它只需要存放块号这个信息，只有块号需要占用存储空间</p>
<h4 id="问题2：如何实现地址的转换"><a href="#问题2：如何实现地址的转换" class="headerlink" title="问题2：如何实现地址的转换"></a>问题2：如何实现地址的转换</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111431445.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111431771.png"/>

<p>页内偏移量：相对于页面的起始位置而言的偏移量是多少</p>
<h5 id="如何确定一个逻辑地址对应的页号，页内偏移量？"><a href="#如何确定一个逻辑地址对应的页号，页内偏移量？" class="headerlink" title="如何确定一个逻辑地址对应的页号，页内偏移量？"></a>如何确定一个逻辑地址对应的页号，页内偏移量？</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111432887.png"/>

<h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111433183.png"/>

<h3 id="基本地址变化机构"><a href="#基本地址变化机构" class="headerlink" title="基本地址变化机构"></a>基本地址变化机构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111434511.png"/>

<p>基本地址变换机构是基本分页存储管理中用于实现逻辑地址到物理地址转换的一组硬件机构</p>
<h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>在分页存储管理当中如果要把逻辑地址转换成物理地址的话，总共需要做4件事：</p>
<p>1.知道逻辑地址对应的页号</p>
<p>2.知道逻辑地址对应的页内偏移量</p>
<p>3.知道逻辑地址对应的页面在内存当中存放的位置到底是多少</p>
<p>4.根据页面在内存当中的起始位置和页内偏移量就可以得到最终的物理地址</p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个<strong>页表寄存器</strong>（PTR),<strong>存放页表在内存中的起始地址F和页表长度M</strong>。进程未执行时，页表的始址和页表长度放在**进程控制块（PCB)**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<blockquote>
<p>注意：<strong>页面大小是2的整数幂</strong></p>
<p>设页面大小为L,逻辑地址A到物理地址E的变换过程如下：</p>
<p>操作系统会把内存分为系统区和用户区。系统区当中存放着操作系统对整个计算机软硬件进行管理的一些相关的数据结构，包括PCB</p>
<p>如果一个进程被调度需要上处理机运行，进程切换相关的那些内核程序就会把这个进程的运行环境给恢复。这些进程运行环境相关的信息本来是保存在PCB当中的，内核程序会把这些信息放到相应的一系列寄存器当中，包括页表寄存器。另外程序计数器PC也是需要恢复的，PC指向这个进程下一条需要执行的指令的逻辑地址。接下来看怎么把这个逻辑地址转换成实际的物理地址，即CPU怎么在内存当中找到接下来要执行的这一条指令</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111437646.png"/>

<p>采用分页存储管理方式的系统当中，逻辑地址结构肯定是固定不变的，在一个逻辑地址当中页号有多少位，页内偏移量有多少位操作系统都是知道的。所以只要知道了逻辑地址就可以很快地切分出页号和页内偏移量这两个部分</p>
<p>接下来会对页号的合法性进行一个检查，越界就会抛出中断由中断处理程序进行处理</p>
<blockquote>
<p>一个进程的页表长度M指的是这个进程的页表当中有M个页表项，也就意味着这个进程的页面总共有M页</p>
</blockquote>
<p>如果页号是合法的，接下来会用这个页号和页表始址来进行计算，找到这个页号对应的页表项到底是多少</p>
<p>页表当中的每一个页表项的长度是相同的。所以只要知道了页号，页表起始地址和每一个页表项的长度就可以算出我们想要访问的页号对应的页表项所存放的位置</p>
<p>既然知道了存放的内存块号，就可以用内存块号结合页内偏移量得到最终的物理地址，然后就可以顺利地访问逻辑地址所对应的内存单元了</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111441369.png"/>
</blockquote>
<p>该过程的文字描述如下</p>
<blockquote>
<ol>
<li><p>计算页号P和页内偏移量W（如果用十进制数手算，则 P&#x3D;A&#x2F;L，W&#x3D;A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号，页内偏移量）</p>
</li>
<li><p>比较页号P和页表长度M，若P ≥ M P\ge M<em>P</em>≥<em>M</em>，则产生越界中断，否则继续执行。（注意：页号从0开始的，而页表长度至少是1，因此 P&#x3D;M 时也会越界）</p>
</li>
<li><p>页表中页号P对应的页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度，页表长度，页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</p>
</li>
<li><p>计算E&#x3D;b*L+W,用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</p>
</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443343.png"/>

<h4 id="对页表项大小的进一步探讨"><a href="#对页表项大小的进一步探讨" class="headerlink" title="对页表项大小的进一步探讨"></a>对页表项大小的进一步探讨</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443247.png"/>

<p>页表项不能跨页框存储</p>
<p>如果说我们的这些页表项并不能装满整个页框的话，那在查找页表项的时候会造成一些麻烦</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443524.png"/>

<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表，又称联想寄存器（TLB,translation lookaside buffer),是一种访问速度比内存快很多的高速缓存（TLB不是内存！),用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111522029.png"/>

<blockquote>
<p>进程最先要访问的逻辑地址是(0，0)</p>
<p>首先进行越界异常的检查，该页号需要和页表寄存器当中的页表长度对比</p>
<p>接下来就会查询快表，由于快表此时的内容是空的，因此在快表中找不到页号为0对应的页表项，快表没有命中。接下来就不得不去访问内存当中存放的慢表，通过页表始址和页号计算出对应的页表项存放的位置</p>
<p>查询完慢表之后就可以知道0号页面所存放的内存块号是600，再通过内存块号和页内偏移量就可以得到最终的物理地址，最后就可以访问这个逻辑地址所对应的内存单元了</p>
<p>注意在访问了这个页表项之后同时也会把该页表项复制一份放到快表当中</p>
<p>接下来要访问的逻辑地址是(0，4)</p>
<p>同样地刚开始会进行越界异常的判断，发现没有越界</p>
<p>接下来会根据页号来查询快表以确认这个页号所对应的页表项是否在快表当中，由于刚才已经复制到了快表当中，因此这次的查询就可以命中。系统可以直接知道0号页面存放的页面是600，所以接下来就不需要查询内存当中的慢表而是直接用内存块号和页内偏移量得到最终想要访问的物理地址然后进行访存</p>
<p><strong>（0，0）前面指的是页号，后面指的是页内偏移量</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111524247.png"/>

<h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><blockquote>
<ol>
<li><p>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较</p>
</li>
<li><p>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
</li>
<li><p>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p>
</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us,访问一次内存耗时100us。若快表的命中率为90%,那么访问一个逻辑地址的平均耗时是多少？</p>
<p>(1+100)*0.9+(1+100+100)*0.1&#x3D;111us</p>
<p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是</p>
<p>（1+100)*0.9+(100+100)*0.1&#x3D; 110.9us</p>
<p>若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111528656.png"/>
</blockquote>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络(3)-传输层与应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-01 16:21:55 / 修改时间：22:36:18" itemprop="dateCreated datePublished" datetime="2023-02-01T16:21:55+08:00">2023-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层提供的服务及功能"><a href="#传输层提供的服务及功能" class="headerlink" title="传输层提供的服务及功能"></a>传输层提供的服务及功能</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011631465.png"/>

<p><strong>传输层的功能如下:</strong><br><strong>1)传输层提供应用进程之间的逻辑通信(即端到端的通信)。</strong></p>
<ul>
<li>与网络层的区别是，网络层提供的是主机之间的逻辑通信。</li>
<li>从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址。</li>
<li>但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称<code>端到端</code>的逻辑通信。</li>
<li>这里<code>“逻辑通信”</code>的意思是:传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有–条水平方向的物理连接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011642474.png"/>

<p><strong>2)复用和分用。</strong></p>
<ul>
<li>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据;</li>
<li>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>传输层的复用分用功能与网络层的复用分用功能不同。</strong></li>
<li>网络层的<code>复用</code>是指发送方不同协议的数据都可以封装成IP数据报发送出去,</li>
<li>网络层的<code>分用</code>是指接收方的网络层在剥去首部后把数据交付给相应的协议。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643998.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011643442.png"/>

<p><strong>3)传输层还要对收到的报文进行差错检测(首部和数据部分)。</strong></p>
<ul>
<li>网络层只检查IP数据报的首部，不检验数据部分是否出错。</li>
</ul>
<p><strong>4)提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。</strong></p>
<ul>
<li>网络层无法同时实现两种协议(即在网络层要么只提供面向连接的服务，如虚电路;要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式)。</li>
</ul>
<h2 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a><strong>传输层的寻址与端口</strong></h2><h3 id="（1）端口的作用"><a href="#（1）端口的作用" class="headerlink" title="（1）端口的作用"></a>（1）端口的作用</h3><ul>
<li>端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li>
<li>端口是传输层<code>服务访问点</code>(TSAP)，它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，只不过<code>IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程</code>。</li>
<li><code>数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口</code>。</li>
<li>在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。</li>
<li>传输层使用的是软件端口。</li>
</ul>
<h3 id="（2）端口号的分类"><a href="#（2）端口号的分类" class="headerlink" title="（2）端口号的分类"></a>（2）端口号的分类</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011652356.png"/>

<h3 id="（3）套接字"><a href="#（3）套接字" class="headerlink" title="（3）套接字"></a>（3）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a></h3><p>在网络中通过IP地址来标识和区别不同的主机，<code>通过端口号来标识和区分一台主机中的不同应用进程</code>。在网络中采用发送方和接收方的<code>套接字(Socket)</code>组合来识别<code>端点</code>。</p>
<p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。<br>$$<br>套接字Socket&#x3D;(主机IP地址，端口号)<br>$$</p>
<h2 id="无连接UDP和面向连接TCP服务"><a href="#无连接UDP和面向连接TCP服务" class="headerlink" title="无连接UDP和面向连接TCP服务"></a>无连接UDP和面向连接TCP服务</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011702423.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>面向</th>
<th>说明</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td>TCP面向连接的传输控制协议</td>
<td>面向连接（可靠）</td>
<td>传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等。（监控管理）</td>
<td><strong>可靠，面向连接，时延大，适用于大文件。</strong>【TCP主要适用于可靠性更重要的场合，如文件传输协议（FTP)、超文本传输协议（HTTP)、远程登录（TELNET)等。】</td>
</tr>
<tr>
<td>UDP无连接的用户数据报协议</td>
<td>面向无连接（不可靠）</td>
<td>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。</td>
<td><strong>不可靠，无连接，时延小，适用于小文件。</strong>【UDP的应用主要包括小文件传送协议（TFTP)、DNS、SNMP和实时传输协议（RTP)。】</td>
</tr>
</tbody></table>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p>
<h4 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h4><ol>
<li>UDP是无连接的，减少开销和发送数据之前的时延。</li>
<li>UDP使用最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的，适合一次性传输少量数据的网络应用。</li>
<li>UDP无拥塞控制，适合很多实时应用。</li>
<li>UDP首部开销小，8B,TCP20B。</li>
</ol>
<p>应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011708708.png"/>

<p><strong>为什么应用开发人员宁愿在UDP之上构建应用，也不选择TCP?既然TCP提供可靠的服务，而UDP不提供，那么TCP总是首选吗?答案是否定的，因为有很多应用更适合用UDP，主要是因为UDP具有如下优点:</strong></p>
<p><strong>1)UDP无须建立连接。</strong></p>
<ul>
<li>UDP不会引入建立连接的时延。</li>
<li>试想如果DNS运行在TCP而非UDP.上，那么DNS的<code>速度</code>会慢很多。</li>
<li>HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，<code>可靠性</code>是至关重要的。</li>
</ul>
<p><strong>2)无连接状态。</strong></p>
<ul>
<li>TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。</li>
<li>而UDP不维护连接状态，也不跟踪这些参数。</li>
<li>因此，<code>某些专用应用服务器使用UDP</code>时，<code>一般都能支持更多的活动客户机</code>。</li>
</ul>
<p><strong>3)分组首部开销小。</strong></p>
<ul>
<li><code>TCP</code>有<code>20B</code>的<code>首部</code>开销，而<code>UDP</code>仅有<code>8B</code>的开销。</li>
</ul>
<p><strong>4)应用层能更好地控制要发送的数据和发送时间。</strong></p>
<ul>
<li>UDP没有拥塞控制，因此网络中的拥塞<code>不会影响主机的发送效率</code>。</li>
<li><code>某些实时应用要求以稳定的速度发送</code>，能容忍一些数据的丢失，但<code>不允许有较大的时延</code>，而UDP正好满足这些应用的需求。</li>
</ul>
<p><strong>5)UDP常用于一次性传输较少数据的网络应用</strong></p>
<ul>
<li>如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。</li>
<li>UDP也常用于多媒体应用(如IP电话、实时视频会议、流媒体等)，显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。</li>
</ul>
<p><strong>6)UDP提供尽最大努力的交付，即不保证可靠交付</strong></p>
<ul>
<li>但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成。</li>
<li><code>应用实体可以根据应用的需求来灵活设计自己的可靠性机制</code>。</li>
</ul>
<p><strong>7)UDP是面向报文的。</strong></p>
<ul>
<li><p>发送方UDP对<code>应用层交下来的报文</code>，在添加首部后就向下交付给IP层，<br><code>既不合并，也不拆分</code>，而是保留这些报文的边界;</p>
</li>
<li><p>接收方UDP对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。</p>
</li>
<li><p>因此<code>报文不可分割，是UDP数据报处理的最小单位</code>。</p>
</li>
</ul>
<h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011724860.png"/>

<p><strong>各字段意义如下：</strong></p>
<ul>
<li>1)源端口。源端口号。在需要对方回信时选用，不需要时可用全0。</li>
<li>2)目的端口。目的端口号。这在终点交付报文时必须使用到。</li>
<li>3)长度。UDP数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)。</li>
<li>4)校验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。</li>
</ul>
<h4 id="当传输层从IP层收到UDP数据报时"><a href="#当传输层从IP层收到UDP数据报时" class="headerlink" title="当传输层从IP层收到UDP数据报时"></a>当传输层从IP层收到UDP数据报时</h4><p>根据首部中的目的端口，把UDP数据报通过相应的端口.上交给应用进程</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011729465.png"/>

<p>如果接收方UDP发现收到的报文中的目的端口号不正确(即不存在对应于端口号的应用进程)，那么就丢弃该报文，并由ICMP发送“端口不可达”<code>差错报文给发送方</code>。</p>
<h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><ul>
<li>伪首部和全0字节是不发送的，仅供校验使用</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742344.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011742289.png"/>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h4><ol>
<li><p>TCP是面向连接（虚连接）的传输层协议。(打call)</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。[可靠有序，不丢不重]</p>
</li>
<li><p>TCP提供全双工通信。<br> 发送缓存:准备发送的数据已发送但尚未收到确认的数据<br> 接收缓存:按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</p>
</li>
<li><p>TCP面向字节流<br> TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p>
</li>
</ol>
<p>  （流：流入到进程或从进程流出的字节序列。）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011748224.png"/>

<h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><ul>
<li><code>TCP传送的数据单元称为报文段</code>。一个TCP报文段分为TCP首部和TCP数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中</li>
<li>其首部的前20B是固定的。TCP报文段的首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度为4B的整数倍。</li>
<li>TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011749892.png"/>

<ul>
<li>1)<code>源端口和目的端口字段</code>。各占2B。端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现。</li>
<li>2)<code>序号字段</code>。占4B。TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011750146.png"/>

<ul>
<li>3)<code>确认号字段</code>。占4B,是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表明到序号N- 1为止的所有数据都已正确收到。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753161.png"/>

<ul>
<li>4)<code>数据偏移(即首部长度)</code>。占4位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位(以4B为计算单位)。因此当此字段的值为15时，达到TCP首部的最大长度60B.</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753880.png"/>

<ul>
<li>5)<code>保留字段</code>。占6位，保留为今后使用，但目前应置为0，该字段可以忽略不计。</li>
<li>6)<code>紧急位URG</code>。URG&#x3D; 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。但<code>URG需要和紧急指针配套使用</code>，即<code>数据从第一个字节到紧急指针所指字节</code>就是<code>紧急数据</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011753219.png"/>

<ul>
<li>7)<code>确认位ACK</code>。只有当ACK&#x3D; 1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.</li>
<li>8)<code>推送位PSH (Push)</code>。 接收TCP收到PSH&#x3D; 1的报文段，就尽快地交付给接收应用进程而不再等到整个缓存都填满后再向上交付。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754971.png"/>

<ul>
<li>9)<code>复位位RST (Reset)</code>。RST&#x3D;1时，表明TCP连接中出现严重差错(如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</li>
<li>10)<code>同步位SYN</code>。同步SYN&#x3D; 1表示这是一个<code>连接请求或连接接收报文</code>。当<code>SYN=1, ACK=0</code>时，表明这是一个<code>连接请求</code>报文，对方若同意建立连接，则在响应报文中使用<code>SYN=1, ACK=1</code>。即SYN&#x3D; 1表示这是一个连接请求或连接接收报文。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754021.png"/>

<ul>
<li>11)<code>终止位FIN (Finish)</code>。用来释放一个连接。FIN&#x3D; 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</li>
<li>12)<code>窗口字段</code>。占2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。<br>例如，假设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的接收方方还有接收1000B数据(字节序号为701 ~1700)的接收缓存空间。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011754063.png"/>

<ul>
<li>13)<code>校验和</code>。占2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6，其他的和UDP一样)。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43914604/article/details/105453096">UDP协议</a></li>
<li>14)<code>紧急指针字段</code>。占16 位，指出在本报文段中紧急数据共有多少字节(紧急数据放在本报文段数据的最前面)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302011755349.png"/>

<p>15)<code>选项字段</code>。长度可变。TCP最初只规定了一种选项，即最大报文段长度(Maximum SegmentSize，MSS)。MSS是TCP报文段中的数据字段的最大长度。窗口扩大、时间戳、选择确认<br>16)<code>填充字段</code>。这是为了使整个首部长度是4B的整数倍。填充0</p>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><ul>
<li>TCP是面向连接的协议，因此每个TCP连接都有三个阶段:<code>连接建立、数据传送和连接释放</code>。</li>
<li><code>TCP连接的管理就是使运输连接的建立和释放都能正常进行</code>。</li>
</ul>
<p><strong>在TCP连接建立的过程中，要解决以下三个问题:</strong></p>
<ul>
<li>1)要使每一方都能够确知对方的存在。</li>
<li>2)要允许双方协商一些参数(如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等)。</li>
<li>3)能够对运输实体资源( 如缓存大小、连接表中的项目等)进行分配。</li>
</ul>
<p>每条TCP连接通过通信两端的<code>两个端点( 即两个套接字)</code>确定。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012046974.png"/>

<h4 id="TCP的三次握手-连接的建立"><a href="#TCP的三次握手-连接的建立" class="headerlink" title="*TCP的三次握手-连接的建立"></a>*TCP的三次握手-连接的建立</h4><ul>
<li>seq为序号字段，标明本次报文段数据部分的第一个字节的序号</li>
<li>ack是<code>确认号字段</code>，告诉对方我接下来应该接收的数据是从字节序号ack开始的数据</li>
<li>ACK是确认位,0时<code>确认号字段ack</code>无效，1时<code>确认号字段ack</code>有效</li>
<li>SYN是同步位</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012047854.png"/>

<ul>
<li>第一步:客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号 seq&#x3D; x(连接请求报文不携带数据，但要消耗一个序号)。</li>
<li>第二步:服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1,确认号字段的值为x+ 1, 并且服务器随机产生起始序号seq &#x3D; y(确认报文不携带数据,但也要消耗-一个序号)。确认报文段同样不包含应用层数据。</li>
<li>第三步:当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1,序号字段为x+1,确认号字段ack&#x3D;y+ 1。该报文段可以携带数据，若不携带数据则不消耗序号。<br>成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。</li>
</ul>
<p><strong>TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。</strong></p>
<ul>
<li>服务器端的资源是在完成第二次握手时分配的</li>
<li>而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</li>
</ul>
<h5 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h5><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。</p>
<p>攻击者发送TCP SYN,SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。</p>
<p>攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p>
<h4 id="TCP的四次挥手-连接的释放"><a href="#TCP的四次挥手-连接的释放" class="headerlink" title="*TCP的四次挥手-连接的释放"></a>*TCP的四次挥手-连接的释放</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012058140.png"/>

<ul>
<li>第一步:客户机打算关闭连接时，向其TCP发送一个连接释放报文段， 并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1, <code>seq=u, 它等于前面已传送过的数据的最后一个字节的序号加1</code> (FIN报文段即使不携带数据，也要消耗一个序号)。<br>TCP 是全双工的，即可以想象为一条TCP连接上有两条数据通路。<br>发送FIN报文时，发送FIN的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</li>
<li>第二步:服务器收到连接释放报文段后即发出确认，<code>确认号是ack=u+ 1,而这个报文段自己的序号是v,等于它前面已传送过的数据的最后一个字节的序号加1</code>。<br>此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。<br>但服务器若发送数据，客户机仍要接收，即<code>从服务器到客户机这个方向的连接并未关闭</code>。</li>
<li>第三步:若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其<code>发出FIN= 1的连接释放报文段</code>。</li>
<li>第四步:<code>客户机收到连接释放报文段后，必须发出确认</code>。在确认报文段中，ACK字段被置为1，确认号ack&#x3D;w+1,序号seq&#x3D;u+1.此时TCP连接还未释放，<code>必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态</code>。</li>
</ul>
<h4 id="TCP连接建立和释放的总结"><a href="#TCP连接建立和释放的总结" class="headerlink" title="TCP连接建立和释放的总结"></a>TCP连接建立和释放的总结</h4><ul>
<li><ol>
<li>连接建立。分为3步:<br>① SYN&#x3D;1，seq&#x3D;x。<br>② SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ack&#x3D;x+ 1。<br>③ ACK&#x3D;1，seq&#x3D;x+1, ack&#x3D;y+ 1。</li>
</ol>
</li>
<li><ol start="2">
<li>释放连接。分为4步:<br>① FIN&#x3D;1, seq&#x3D; u<br>② ACK&#x3D;1, seq&#x3D;v, ack&#x3D;u+ 1。<br>③ FIN&#x3D;1，ACK&#x3D;1, seq&#x3D;w，ack&#x3D;u+ 1。<br>④ ACK&#x3D;1, seq&#x3D;u+1, ack&#x3D;w+ 1。</li>
</ol>
</li>
</ul>
<p>关于连接和释放，ACK、 SYN、 FIN 一定等于1</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012102975.png"/>

<h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103517.png"/>

<h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103897.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012103883.png"/>

<h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012104058.png"/>

<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul>
<li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为<code>接收窗口rwnd</code>, 即<code>调整TCP报文段首部中的“窗口”字段值</code>，来限制发送方向网络注入报文的速率。</li>
<li>同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<code>拥塞窗口cwnd</code>，其大小与网络的带宽和时延密切相关。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012110668.png"/>

<ul>
<li><code>例如</code>，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A。</li>
<li>rwnd 即接收方允许连续接收的最大能力，单位是字节。</li>
<li>发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存溢出。</li>
<li>当然，<code>A的发送窗口的实际大小取rwnd和cwnd中的最小值</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118546.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012118055.png"/>

<p><strong>传输层和数据链路层的流量控制的区别是:</strong></p>
<ul>
<li>传输层定义<code>端到端</code>用户之间的流量控制，数据链路层定义<code>两个中间的相邻结点</code>的流量控制。</li>
<li>另外，<code>数据链路层</code>的滑动窗口协议的<code>窗口</code>大小<code>不能动态变化</code>，<code>传输层</code>的则可以<code>动态变化</code>。</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="1-什么是拥塞控制？"><a href="#1-什么是拥塞控制？" class="headerlink" title="1. 什么是拥塞控制？"></a>1. 什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">拥塞控制</a>？</h5><ul>
<li>所谓<code>拥塞控制，是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</code>。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。</li>
</ul>
<h5 id="2-拥塞控制与流量控制的区别"><a href="#2-拥塞控制与流量控制的区别" class="headerlink" title="2. 拥塞控制与流量控制的区别"></a>2. 拥塞控制与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">流量控制</a>的区别</h5><ul>
<li><code>拥塞控制</code>是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li><code>流量控制</code>往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012119412.png"/>

<ul>
<li><strong>例如：</strong></li>
<li>某个链路的传输速率为10Gb&#x2F;s,某巨型机向一台PC以1Gb&#x2F;s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行<code>流量控制</code>。</li>
<li>但若有100万台PC在此链路上以1Mb&#x2F;s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</li>
</ul>
<p><strong>为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下4种算法:<code>慢开始、拥塞避免、快重传、快恢复。</code></strong></p>
<h5 id="3-拥塞控制的4种算法"><a href="#3-拥塞控制的4种算法" class="headerlink" title="3. 拥塞控制的4种算法"></a>3. 拥塞控制的4种算法</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012121629.png"/>

<h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012122103.png"/>

<ul>
<li>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd&#x3D; 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加1,即增大一个 MSS.用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</li>
</ul>
<blockquote>
<p>例如，A向B发送数据，发送时A的拥塞窗口为2,那么A一次可以发送两个TCP报文段，经过一个RTT后(也称一个<code>传输轮次</code>)，A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。</p>
</blockquote>
<ul>
<li>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</li>
</ul>
<h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><ul>
<li>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过- -一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。</li>
<li>根据cwnd的大小执行不同的算法，可归纳如下:<br>●当cwnd &lt; ssthresh时，使用慢开始算法。<br>●当 cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>●当cwnd &#x3D; sthresh时，既可使用慢开始算法，又可使用拥塞避免算法(通常做法)。</li>
</ul>
<p><strong>网络拥塞的处理</strong></p>
<ul>
<li><p>网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生(未按时收到确认，重传计时器超时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。<br>然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
</li>
<li><p>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></p>
</li>
<li><p>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></p>
</li>
</ul>
<blockquote>
<p>在慢开始和拥塞避免算法中使用了<code>“乘法减小”和“加法增大”方法</code>。</p>
<ul>
<li><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</li>
<li><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢<br>增大，以防止网络过早出现拥塞。</li>
</ul>
</blockquote>
<h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><p><strong>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</strong></p>
<ul>
<li>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</li>
</ul>
<h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><p><strong>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</strong></p>
<ul>
<li><code>快恢复算法</code>的原理如下:</li>
<li>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</li>
<li>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</li>
<li><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</li>
</ul>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012127416.png"/>

<ul>
<li>在<code>流量控制</code>中，发送方发送数据的量由接收方决定，而在<code>拥塞控制</code>中，则由发送方自己通过检测网络状况来决定。</li>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<blockquote>
<p><code>注意：</code> <code>发送方发送窗口的实际大小</code>由<code>流量控制</code>和<code>拥塞控制</code>共同决定。<br>因此，当题目中同时出现接收端窗口(rwnd) 和拥塞窗口(cwnd) 时，发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012144530.png"/>

<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>客户&#x2F;服务器模型（Client&#x2F;Server)<br>P2P模型（Peer-to-peer)</p>
<h3 id="c-x2F-s模型（客户-x2F-服务器模型）"><a href="#c-x2F-s模型（客户-x2F-服务器模型）" class="headerlink" title="c&#x2F;s模型（客户&#x2F;服务器模型）"></a>c&#x2F;s模型（客户&#x2F;服务器模型）</h3><p>服务器：提供计算服务的设备。</p>
<ol>
<li><p>永久提供服务</p>
</li>
<li><p>永久性访问地址&#x2F;域名</p>
</li>
</ol>
<p>客户机：请求计算服务的主机。</p>
<ol>
<li><p>与服务器通信，使用服务器提供的服务</p>
</li>
<li><p>间歇性接入网络</p>
</li>
<li><p>可能使用动态IP地址</p>
</li>
<li><p>不与其他客户机直接通信</p>
</li>
</ol>
<p>应用：Web,文件传输FTP,远程登录，电子邮件</p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><ul>
<li><p>在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一一对计算机一称为<code>对等方(Peer)</code>， 直接相互通信。</p>
</li>
<li><p>P2P 模型从本质上来看仍然使用客户&#x2F;服务器方式，每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
</li>
<li><p>当前比较流行的P2P应用有PPlive、Bittorrent 和电驴等。</p>
</li>
<li><p>不存在永远在线的服务器</p>
</li>
<li><p>每个主机既可以提供服务，也可以请求服务</p>
</li>
<li><p>任意端系统&#x2F;节点之间可以直接通讯</p>
</li>
<li><p>节点间歇性接入网络</p>
</li>
<li><p>节点可能改变IP地址</p>
</li>
<li><p>可扩展性好</p>
</li>
<li><p>网络健壮性强</p>
</li>
</ul>
<p><strong>与C&#x2F;S模型相比，P2P 模型的优点主要体现如下:</strong></p>
<ul>
<li>1)减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率(例如，播放流媒体时对服务器的压力过大，而通过P2P模型，可以利用大量的客户机来提供服务)。</li>
<li>2)多个客户机之间可以直接共享文档。</li>
<li>3)可扩展性好，传统服务器有响应和带宽的限制，因此只能接受- -定 数量的请求。</li>
<li>4)网络健壮性强，单个结点的失效不会影响其他部分的结点。</li>
</ul>
<p><code>P2P模型也有缺点</code>。在获取服务的同时,还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。<br>例如，经常进行P2P下载还会对硬盘造成较大的损伤。据某互联网调研机构统计，当前P2P程序已占互联网50%~90%的流量，使网络变得非常拥塞，因此各大ISP (互联网服务2提供商，如电信、网通等)通常都对P2P应用持反对态度。</p>
<h2 id="DNS-域名解析系统"><a href="#DNS-域名解析系统" class="headerlink" title="DNS(域名解析系统)"></a>DNS(域名解析系统)</h2><ul>
<li><code>域名系统(Domain Name System, DNS)</code>是因特网使用的命名系统，用来<code>把便于人们记忆的具有特定含义的主机名(如www.BitHachi.com)转换为便于机器处理的IP地址</code>。</li>
<li>相对于IP地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的计算机。</li>
<li>DNS系统采用客户&#x2F;服务器模型，其协议运行在<code>UDP</code>之上，使用<code>53</code>号端口。</li>
<li>从概念上可将DNS分为3部分:<code>层次域名空间、域名服务器和解析器</code>。</li>
</ul>
<p>某台主机访问网站<a target="_blank" rel="noopener" href="http://www.bithachi.cn网站为例,dns的大致流程/">www.bithachi.cn网站为例，DNS的大致流程</a></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148576.png"/>

<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul>
<li><code>因特网采用层次树状结构的命名方法</code>。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即<code>域名(Domain Name)</code>。</li>
<li><code>域(Domain)</code>是名字空间中一个可被管理的划分。</li>
<li>域还可以划分为子域，而子域还可以继续划分为子域的子域，这样就形成<br>了顶级域、二级域、三级域等。</li>
</ul>
<p><strong>在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理。</strong></p>
<ul>
<li>例如，管理CN域的中国将EDU.CN子域授权给中国教育和科研计算机网(CERNET)来管理。</li>
<li>比如我的域名bithachi.cn是一个二级域名，我可以任意分配三级域名，比如1001.bithachi.cn和1002.bithachi.cn，这两个网址是可以访问的，小项目。</li>
</ul>
<p><strong>域名空间的树状结构：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012148271.png"/>

<p>每个域名都由<code>标号</code>序列组.成，而各标号之间用点<code>(“.”)</code>隔开。</p>
<p>$$<br><a target="_blank" rel="noopener" href="http://www.bithachi.cn/">www.BitHachi.cn</a>. &#x3D;&gt;(三级域名).(二级域名).(顶级域名).<br>$$<br>最后的一个点叫<strong>根</strong></p>
<p><strong>关于域名中的标号有以下几点需要注意:</strong></p>
<ul>
<li>1)标号中的英文<code>不区分大小写</code>。.</li>
<li>2)标号中除连字符(-) 外不能使用其他的标点符号。</li>
<li>3)每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符。</li>
<li>4)级别最低的域名写在最左边，级别最高的顶级域名写在最右边。</li>
</ul>
<p><code>顶级域名(Top Level Domain, TLD)</code>分为如下三大类:</p>
<ul>
<li>1)国家顶级域名(nTLD)。国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，.uk”表示英国。</li>
<li>2)通用顶级域名(gTLD)。 常见的有“.com” (公司)、“.net” (网络服务机构)、“.org”(非营利性组织)和“.gov” (国家或政府部门)等。</li>
<li>3)基础结构域名。<code>这种顶级域名只有一个，即arpa,用于反向域名解析</code>，因此又称反向域名。<code>反向域名解析与通常的正向域名解析相反，提供IP地址到域名的对应</code>，反向域名格式如：X.X.X.in-addr.arpa。很多网络服务提供商要求访问的IP地址具有反向域名解析的结果，否则不提供服务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">国家顶级域名下注册的二级域名均由该国家自行确定。</span><br></pre></td></tr></table></figure>

<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><ul>
<li><code>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型</code>。</li>
<li>域名到IP地址的解析是由运行在域名服务器上的程序完成的，<code>一个服务器所负责管辖的(或有权限的)范围称为区(不以“域”为单位)</code>，各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，每个区设置相应的<code>权限域名服务器</code>，用来保存该区中的所有主机的域名到IP地址的映射。</li>
<li>每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器。</li>
<li>DNS使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上。</li>
<li>采用分布式设计的DNS，是一个在因特网上实现分布式数据库的精彩范例。主要有4种类型的域名服务器。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012150621.png"/>

<h4 id="（1）根域名服务器"><a href="#（1）根域名服务器" class="headerlink" title="（1）根域名服务器"></a>（1）根域名服务器</h4><ul>
<li><code>根域名服务器</code>是<code>最高层次</code>的域名服务器，所有的<code>根域名服务器</code>都知道<code>所有</code>的<code>顶级域名服务器的IP地址</code>。</li>
<li>根域名服务器也是最重要的域名服务器，不管是哪个<code>本地域名服务器</code>，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先要求助于<code>根域名服务器</code>。</li>
<li>因特网上有<code>13个根域名服务器</code>，尽管我们将这13个根域名服务器中的每个都视为单个服务器，但<code>每个“服务器”实际上是冗余服务器的集群</code>，以提供安全性和可靠性。</li>
<li>需要注意的是，<code>根域名服务器</code>用来<code>管辖顶级域(如.com)</code>， 通常它并不直接把待查询的域名直接转换成IP地址，而是<code>告诉本地域名服务器</code>下一步应当找哪个<code>顶级域名服务器</code>进行查询。</li>
</ul>
<h4 id="（2）顶级域名服务器"><a href="#（2）顶级域名服务器" class="headerlink" title="（2）顶级域名服务器"></a>（2）顶级域名服务器</h4><ul>
<li>这些域名服务器负责<code>管理在该顶级域名服务器注册的所有二级域名</code>。</li>
<li>收到DNS查询请求时,就给出相应的回答(可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址)。</li>
</ul>
<h4 id="（3）授权域名服务器-权限域名服务器"><a href="#（3）授权域名服务器-权限域名服务器" class="headerlink" title="（3）授权域名服务器(权限域名服务器)"></a>（3）授权域名服务器(权限域名服务器)</h4><ul>
<li><code>每台主机</code>都必须在<code>授权域名服务器</code>处登记。为了更加可靠地工作，一台主机最好至少有两个授权域名服务器。</li>
<li>实际上，许多<code>域名服务器</code>都<code>同时</code>充当<code>本地域名服务器</code>和<code>授权域名服务器</code>。</li>
<li><code>授权域名服务器</code>总能将其管辖的<code>主机名</code>转换为该主机的<code>IP地址</code>。</li>
</ul>
<h4 id="（4）本地域名服务器"><a href="#（4）本地域名服务器" class="headerlink" title="（4）本地域名服务器"></a>（4）本地域名服务器</h4><ul>
<li>本地域名服务器对域名系统非常重要。</li>
<li>每个因特网服务提供者(ISP)， 或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。</li>
<li><code>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</code>。</li>
<li>事实上，我们在Windows系统中配置<code>“本地连接”</code>时，就需要填写DNS地址，这个地址就是<code>本地DNS (域名服务器)的地址</code>。</li>
</ul>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><ul>
<li><code>域名解析是指把域名映射成为IP地址或把IP地址映射成域名的过程。前者称为正向解析，后者称为反向解析。</code></li>
<li>当客户端需要域名解析时，通过本机的DNS客户端构造一个<code>DNS请求报文</code>，以<code>UDP数据报</code>方式发往<code>本地域名服务器</code>。</li>
<li>域名解析有两种方式:<code>递归查询</code>和<code>递归与迭代</code>相结合的查询。</li>
</ul>
<h4 id="递归查询方式"><a href="#递归查询方式" class="headerlink" title="递归查询方式"></a>递归查询方式</h4><ul>
<li><strong>递归查询的过程如下图所示</strong>， 由于该方法给根域名服务造成的负载过大，所以在实际中几乎不使用。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152913.png"/>

<p><strong>常用递归与迭代相结合的查询方式如下图所示，该方式分为两个部分。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012152357.png"/>

<p><strong>(1)<code>主机</code>向<code>本地域名服务器</code>的查询采用的是<code>递归</code>查询</strong></p>
<ul>
<li>也就是说，如果<code>本地主机</code>所询问的<code>本地域名服务器</code>不知道被查询域名的IP 地址，那么<code>本地域名服务器</code>就以<code>DNS客户</code>的身份，向<code>根域名服务器</code>继续发出<code>查询请求报文</code>(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。</li>
<li>在这种情况下，<code>本地域名服务器</code>只需向<code>根域名服务器查询</code>一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的[见图6.6(a)中的步骤③~⑥]。</li>
<li>在步骤⑦中，<code>本地域名服务器</code>从<code>根域名服务器</code>得到了所需的<code>IP地址</code>,最后在步骤⑧中，<code>本地域名服务器</code>把查询结果告诉<code>主机</code>m.xyz.com.</li>
</ul>
<p><strong>(2)<code>本地域名服务器</code>向<code>根域名服务器</code>的查询采用<code>迭代</code>查询</strong></p>
<ul>
<li>当<code>根域名服务器</code>收到<code>本地域名服务器</code>发出的<code>迭代查询请求报文</code>时，要么给出所要查询的IP地址，要么告诉<code>本地域名服务器</code>:“你下一步应当向哪个<code>顶级域名服务器</code>进行查询”。</li>
<li>然后让<code>本地域名服务器</code>向这个<code>顶级域名服务器</code>进行后续的查询，如图6.6(b)所示。</li>
<li>同样，<code>顶级域名服务器</code>收到查询报文后，要么给出所要查询的IP地址，要么告诉<code>本地域名服务器</code>下一步应向哪个·权限域名服务器·查询。</li>
<li>最后，知道所要<code>解析的域名的IP地址</code>后，把这个<code>结果返回</code>给发起查询的<code>主机</code>。</li>
</ul>
<p><strong><code>下面举例说明域名解析的过程:</code></strong><br><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012153295.png"/>

<blockquote>
<ul>
<li>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<code>高速缓存</code>。</li>
<li>当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速<br>缓存中。这样，当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问。</li>
<li>因为<code>主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息</code>。</li>
</ul>
</blockquote>
<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><ul>
<li>文件传输协议( File Transfer Protocol, FTP)是因特网上使用得最广泛的<code>文件传输协议。</code></li>
<li>FTP提供<code>交互式的访问</code>，允许客户指明文件的类型与格式，并允许文件具有<code>存取权限</code>。</li>
<li>它屏蔽了各计算机系统的细节，因而适合于在异构网络中的<code>任意计算机之间传送文件</code>。</li>
</ul>
<p><strong>FTP提供以下功能:</strong><br>①提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力。<br>②<code>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</code>。<br>③以<code>匿名FTP</code>的方式提供<code>公用文件共享</code>的能力。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154629.png"/>

<h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><ul>
<li>FTP采用客户&#x2F;服务器（C&#x2F;S）的工作方式，它使用TCP可靠的传输服务。</li>
<li>一个FTP服务器进程可同时为多个客户进程提供服务。</li>
<li>依照FTP协议提供服务，进行文件传送的计算机就是<code>FTP服务器</code>。</li>
<li>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是<code>FTP客户端</code>。</li>
<li><code>FTP的服务器进程</code>由两大部分组成:<br><code>一个主进程，负责接收新的请求;</code><br><code>若干从属进程，负责处理单个请求。</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012154870.png"/>

<hr>

<p><strong>其工作步骤如下:</strong><br>①打开熟知端口21 (控制端口)，使客户进程能够连接上。<br>②等待客户进程发连接请求。<br>③启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。<br>④回到等待状态，继续接收其他客户进程的请求。</p>
<hr>

<ul>
<li>FTP服务器必须在整个会话期间保留用户的状态信息。<br>特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。</li>
</ul>
<h3 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h3><ul>
<li>FTP在工作时使用两个<code>并行的TCP连接</code>:<br>一个是<code>控制连接(端口号21)</code>，<br>一个是<code>数据连接(端口号20)</code>。</li>
<li>使用两个不同的端口号可使协议更加简单和更容易实现。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155883.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012155920.png"/>

<p><strong>1.控制连接</strong></p>
<ul>
<li>服务器监听21号端口，等待客户连接，建立在这个端口.上的连接称为控制连接，<code>控制连接用来传输控制信息(如连接请求、传送请求等)</code>，并且<code>控制信息都以7位ASCII格式传送</code>。</li>
<li>FTP客户发出的<code>传送请求</code>，<code>通过控制连接发送给服务器端的控制进程,但控制连接并不用来传送文件。</code></li>
<li>在传输文件时还可以使用控制连接(如客户在传输中途发一个中止传输的命令)，因此控制连接在整个会话期间一直保持打开状态。</li>
</ul>
<p><strong>2.数据连接</strong></p>
<ul>
<li><code>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。</code></li>
<li><code>数据连接</code>用来<code>连接客户端和服务器端的数据传送进程</code>，<code>数据传送进程</code>实际<code>完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</code></li>
</ul>
<hr>
<ul>
<li>因为FTP使用了一个分离的控制连接，所以<code>也称FTP的控制信息是带外(Out-of-band) 传送的。</code></li>
<li>使用FTP时，<code>若要修改服务器上的文件，则需要先将此文件传送到本地主机,然后再将修改后的文件副本传送到原服务器</code>。</li>
<li>网络文件系统(NFS)允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</li>
</ul>
<h2 id="SMTP-POP3-IMAP-MIME…"><a href="#SMTP-POP3-IMAP-MIME…" class="headerlink" title="SMTP,POP3,IMAP,MIME…."></a>SMTP,POP3,IMAP,MIME….</h2><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><ul>
<li>一个电子邮件分为<code>信封和内容</code>两大部分，邮件<code>内容</code>又<code>分为首部和主体</code>两部分。</li>
<li>RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。</li>
<li>用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。</li>
<li><code>邮件内容的首部包含一些首部行</code>，<code>每个首部行由一个关键字后跟冒号再后跟值组成。</code>有些关键字是必需的，有些则是可选的。最重要的关键字是To:和Subject。</li>
<li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。<br>电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名<br>如<a href="mailto:&#x61;&#x62;&#x63;&#x40;&#x63;&#x73;&#107;&#x61;&#x6f;&#121;&#x61;&#110;&#x2e;&#99;&#111;&#109;">&#x61;&#x62;&#x63;&#x40;&#x63;&#x73;&#107;&#x61;&#x6f;&#121;&#x61;&#110;&#x2e;&#99;&#111;&#109;</a>,其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的 。这也就保证了<a href="mailto:&#97;&#x62;&#x63;&#64;&#x63;&#x73;&#107;&#x61;&#x6f;&#121;&#x61;&#x6e;&#x2e;&#99;&#111;&#x6d;">&#97;&#x62;&#x63;&#64;&#x63;&#x73;&#107;&#x61;&#x6f;&#121;&#x61;&#x6e;&#x2e;&#99;&#111;&#x6d;</a> 这个邮件<br>地址在整个因特网上是唯一的。</li>
<li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。</li>
<li>还有一个必填的关键字是From,但它通常由邮件系统自动填入。</li>
<li>首部与主体之间用一个空行进行分割。典型的邮件内容如下:</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157298.png"/>

<h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><ul>
<li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157757.png"/>

<hr>

<ul>
<li>一个 电子邮件系统应具有三个最主要的组成构件：<br>用户代理(User Agent)<br>邮件服务器<br>电子邮件使用的协议，如SMTP、POP3 (或IMAP)等。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012157575.png"/>

<p><code>用户代理(UA):</code>用户与电子邮件系统的接口。</p>
<ul>
<li>用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的功能。</li>
<li>通常情况下，用户代理就是一个运行在PC.上的程序，常见的有Outlook、Foxmail 和Thunderbird等。</li>
</ul>
<p><code>邮件服务器:</code>组成电子邮件系统的核心。</p>
<ul>
<li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况(已交付、被拒绝、丢失等)。</li>
<li>邮件服务器采用客户&#x2F;服务器方式工作，但它能够同时充当客户和服务器。</li>
<li>例如，当邮件服务器A向邮件服务器B发送邮件时，A就作为SMTP客户，而B是SMTP服务器;反之，当B向A发送邮件时，B就是SMTP客户，而A就是SMTP服务器。</li>
</ul>
<p><strong>邮件发送协议和读取协议</strong>:</p>
<ul>
<li><code>邮件发送协议</code>用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用的是<code>SMTP</code>;</li>
<li><code>邮件读取协议</code>用于用户代理从邮件服务器读取邮件，如<code>POP3</code>。</li>
<li>SMTP采用的是“推”(Push)的通信方式，即在用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP客户端主动将邮件“推”送到SMTP服务器端。</li>
<li>POP3采用的是“拉”(Pull)的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
</ul>
<h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158446.png"/>

<ul>
<li>发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定 时间对邮件缓存扫描一次。<br>如发现有邮件，就使用SMTP的熟知端口号(25) 与接收方邮件服务器的SMTP服务器建立TCP连接。</li>
<li>连接建立后，接收方SMTP服务器发出220 Service ready (服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li>
<li>SMTP不使用中间邮件服务器。<br>TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远。<br>接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012158231.png"/>

<p><strong>邮件发送</strong></p>
<ul>
<li>连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL 命令后面有发件人的地址。如MAIL FROM: <a href="mailto:hoopdog@hust.edu.cn">hoopdog@hust.edu.cn</a>。</li>
<li>若SMTP服务器已准备好接收邮件，则回答250 OK。</li>
<li>接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令，格式为RCPTTO: &lt;收件人地址&gt;。<br>每发送一个 RCPT命令，都应有相应的信息从SMTP服务器返回，如250 OK或550 No such user here (无此用户)。<br>RCPT命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。</li>
<li>获得0K的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。<br>正常情况下，SMTP服务器回复信息是354 Start mail input; end with . 。表示回车换行。此时SMTP客户端就可开始传送邮件内容，并用. (两个回车，中间一个点)表示邮件内容的结束。</li>
</ul>
<p><strong>释放连接</strong></p>
<ul>
<li>邮件发送完毕后，SMTP客户应发送QUIT命令。</li>
<li>SMTP服务器返回的信息是221 (服务关闭)，表示SMTP同意释放TCP连接。邮件传送的全部过程就此结束。</li>
</ul>
<h4 id="MIME—多用途网络邮件扩充"><a href="#MIME—多用途网络邮件扩充" class="headerlink" title="MIME—多用途网络邮件扩充"></a>MIME—多用途网络邮件扩充</h4><ul>
<li>由于SMTP只能传送一定长度的ASCII码，许多其他非英语国家的文字(如中文、俄文，甚至带重音符号的法文或德文)就无法传送，且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充( Multipurpose Internet MailExtensions，MIME)。</li>
<li>MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。也就是说，MIME邮件可在现有的电子邮件程序和协议下传送。MIME与SMTP的关系如图</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012159989.png"/>

<p><strong>MIME主要包括以下三部分内容:</strong></p>
<ul>
<li>①5个新的邮件首部字段，包括MIME版本、内容 描述、内容标识、内容传送编码和内容类型。</li>
<li>②定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>③定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ul>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200877.png"/>

<ul>
<li>邮局协议( Post Office Protocol, POP) 是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3。</li>
<li>POP3 采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
<li>POP也使用客户&#x2F;服务器的工作方式，在传输层使用TCP,端口号为110。接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序。</li>
<li>POP有两种工作方式:<code>“下载并保留”和“下载并删除”。</code><br>在<code>“下载并保留”</code>方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件;<br>使用<code>“下载并删除”</code>方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。</li>
</ul>
<h4 id="IMAP-因特网报文存取协议"><a href="#IMAP-因特网报文存取协议" class="headerlink" title="IMAP-因特网报文存取协议"></a>IMAP-因特网报文存取协议</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012200164.png"/>

<ul>
<li>另一个邮件接收协议是<code>因特网报文存取协议(IMAP)</code>,它比POP复杂得多，IMAP为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此<code>IMAP服务器维护了会话用户的状态信息</code>。</li>
<li>IMAP的另一特性是<code>允许用户代理只获取报文的某些部分</code>，例如可以只读取一个报文的首部,或一个多部分MIME报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。</li>
</ul>
<h3 id="万维网的电子邮件"><a href="#万维网的电子邮件" class="headerlink" title="万维网的电子邮件"></a>万维网的电子邮件</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012201443.png"/>

<ul>
<li>随着万维网的流行，目前出现了很多基于万维网的电子邮件，如Hotmail、Gmail 等。</li>
<li>这种电子邮件的特点是，用户浏览器与Hotmail或Gmail的邮件服务器之间的邮件发送或接收使用的是HTTP，而<code>仅在不同邮件服务器之间传送邮件时才使用SMTP.</code></li>
</ul>
<h2 id="万维网（www）和HTTP协议"><a href="#万维网（www）和HTTP协议" class="headerlink" title="*万维网（www）和HTTP协议"></a>*万维网（www）和HTTP协议</h2><h3 id="万维网WWW协议"><a href="#万维网WWW协议" class="headerlink" title="万维网WWW协议"></a>万维网WWW协议</h3><p>URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置</p>
<p>HTTP用来将这些资源传送给用户</p>
<p>HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012202965.png"/>

<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>服务器通过TCP 80端口来监听HTTP请求</p>
<p><strong>注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分</strong>，其他音频视频等待用户下一步请求之后再传输</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203168.png"/>

<h4 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012203522.png"/>

<h4 id="HTTP的连接方式-持久连接和非持久连接"><a href="#HTTP的连接方式-持久连接和非持久连接" class="headerlink" title="HTTP的连接方式-持久连接和非持久连接"></a>HTTP的连接方式-持久连接和非持久连接</h4><p>非持久连接在TCP三次握手的<strong>第三次握手时发生</strong>，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。<br>缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始</p>
<p>持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012204214.png"/>

<h4 id="持久连接的两种方式——非流水线和流水线"><a href="#持久连接的两种方式——非流水线和流水线" class="headerlink" title="持久连接的两种方式——非流水线和流水线"></a>持久连接的两种方式——非流水线和流水线</h4><p>非流水线就是发一个，确认一个，才能再发下一个<br>流水线就是一个个连着发，然后多个确认<br>和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下</p>
<h4 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h4><p>开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样</p>
<p>请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取&#x2F;删除等等<br>URL就是之间说的资源标识符<br>版本是指使用的是什么版本的HTTP协议</p>
<p>CRLF相当于我们程序里面的<code>；</code>，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205051.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202302012205842.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据库原理知识点总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-20 16:28:28 / 修改时间：18:15:53" itemprop="dateCreated datePublished" datetime="2022-12-20T16:28:28+08:00">2022-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">数据库原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><p><strong>数据库技术</strong>是信息系统的核心和基础</p>
<h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><p>数据库的4个基本概念：</p>
<ol>
<li><p>数据（data）:数据库中存储的基本对象</p>
</li>
<li><p>数据库（DataBase、DB）:<strong>长期存储在计算机内、有组织的、可共享的大量数据的集合</strong></p>
</li>
<li><p>数据库管理系统（DataBase Management System、DBMS）:科学地<strong>组织</strong>和<strong>存储</strong>数据、高效地<strong>获取</strong>和<strong>维护</strong>数据。</p>
<ol>
<li><p>数据定义功能（DDL）</p>
</li>
<li><p>数据组织、存储和管理 </p>
</li>
<li><p>数据操纵功能（DML）</p>
</li>
<li><p>数据库的事物管理和运行管理 </p>
</li>
<li><p>数据库的建立和维护功能</p>
</li>
</ol>
</li>
<li><p>数据库系统（DataBase System 、DBS）:</p>
<ul>
<li><p>数据库</p>
</li>
<li><p>数据库管理系统</p>
</li>
<li><p>应用程序</p>
</li>
<li><p>数据库管理员</p>
</li>
</ul>
</li>
</ol>
<h3 id="数据库技术的产生和发展"><a href="#数据库技术的产生和发展" class="headerlink" title="数据库技术的产生和发展"></a>数据库技术的产生和发展</h3><p>数据管理：对数据进行<strong>分类、组织、编码、存储、检索和维护</strong></p>
<p>数据管理技术的发展过程：</p>
<ul>
<li><strong>人工管理阶段</strong>（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%89%B9%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">批处理</a>，20世纪50年代中之前）</li>
<li><strong>文件系统阶段</strong>（联机实时处理、批处理，20世纪50年代末—60年代中）</li>
<li><strong>数据库系统阶段</strong>（联机实时处理、分布处理、批处理，20世纪60年代末—现在）</li>
</ul>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ol>
<li>数据结构化</li>
<li>数据的共享性高、冗余度低且易扩充</li>
<li>数据独立性高 </li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
<p>数据的最小存取单位是<strong>数据项</strong>，用<strong>数据模型</strong>来描述</p>
<h4 id="数据库的三级模式与两层映像"><a href="#数据库的三级模式与两层映像" class="headerlink" title="数据库的三级模式与两层映像"></a><strong>数据库的三级模式与两层映像</strong></h4><p><strong>内模式</strong>：对应于物理层数据抽象，它是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<p><strong>模式</strong>：对应于逻辑层数据抽象，它是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
<p><strong>外模式</strong>：对应于视图层数据抽象，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</p>
<p>为了能够在系统内部实现3个抽象层次的数据之间的联系和转换，数据库管理系统提出了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。正是这两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>映像</th>
</tr>
</thead>
<tbody><tr>
<td><strong>逻辑独立性</strong></td>
<td>是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变</td>
<td>外模式&#x2F;模式映像</td>
</tr>
<tr>
<td><strong>物理独立性</strong></td>
<td>是指用户的应用程序与数据库的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用改变</td>
<td>模式&#x2F;内模式映像</td>
</tr>
</tbody></table>
<p><strong>数据管理系统提供的数据控制功能</strong>：</p>
<ol>
<li>数据的安全性保护</li>
<li>数据的完整性保护</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ol>
<p>数据的安全性保护：保护数据以防止不合法的使用造成数据的泄密和破坏</p>
<p>数据的完整性保护：保护数据的正确性、有效性和相容性</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>常用的数据模型：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型</p>
<h3 id="数据模型分类"><a href="#数据模型分类" class="headerlink" title="数据模型分类"></a>数据模型分类</h3><p>概念模型：也称信息模型，用于数据库设计，E-R模型、OO模型</p>
<p>逻辑模型：层次模型、网状模型、<strong>关系模型</strong>、面向对象数据模型、对象关系数据数据模型、半结构化数据模型。DBMS实现</p>
<p>物理模型：用来描述数据的物理存储结构和存储方式、在磁盘或磁带上的存储方式和存取方法</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>表示方法：<strong>实体—联系方法</strong> <strong>：E-R图</strong> E-R方法也称为E-R模型</p>
<p>实体：客观存在并可相互区别的事物称为实体</p>
<p>属性：实体所具有的某一特性称为属性</p>
<p><span style="color:red"><strong>码：唯一标识实体的属性集称为 码</strong></span></p>
<p><strong>实体之间的联系</strong>：<strong>一对一、一对多、多对多</strong></p>
<p>用<strong>E-R图</strong>来描述现实世界的概念模型</p>
<h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><ol>
<li><p>数据结构：描述数据库的组成对象，以及对象之间的联系，<strong>对系统静态特性的描述</strong></p>
</li>
<li><p>数据操作：对数据库中各种对象的实例允许执行的<strong>操作的集合</strong>，包括<strong>操作</strong>及有关的<strong>操作规则</strong>，<strong>对系统动态特性的描述</strong></p>
<p>数据操作的类型：<strong>查询</strong>，<strong>更新</strong>（插入、删除、修改）</p>
</li>
<li><p>数据的完整性约束条件</p>
</li>
</ol>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><p>层次模型用<strong>树形结构</strong>来表示各类实体以及实体间的联系， 典型代表：IMS</p>
<p>特点：只能直接处理一对多的实体联系</p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）数据结构比较简单清晰 <br>（2）查询效率高，性能优于关系模型 ，不低于网状模型（3）提供良好的完整性支持</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）多对多联系表示不自然 <br>（2）插入和删除限制多 <br>（3）查询子女结点必须通过双亲节点 <br>（4）层次命令趋于程序化</td>
</tr>
</tbody></table>
<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>网状数据库系统采用<strong>网状模型</strong>作为数据库的组织方式，典型代表：DBTG（亦称CODASYL系统）</p>
<p>层次模型是网状模型的一个特例，用网状模型<strong>间接</strong>表示多对多联系（将多对多联系直接分解成一对多联系）</p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）更为直观地描述现实世界，如一个结点可以有多个双亲 <br>（2）具有良好的性能，存取效率较高</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）结构复杂 <br>（2）DDL、DML语言复杂 <br>（3）记录之间联系是通过存取路径实现，用户必须了解系统结构的细节</td>
</tr>
</tbody></table>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="*关系模型"></a>*关系模型</h3><p>关系数据库系统采用<strong>关系模型</strong>作为数据的组织方式</p>
<p>用户观点下，关系模型中数据的逻辑结构是一张<strong>二维表</strong>，它由行和列组成</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>关系</td>
<td>一个关系对应通常说的一张表</td>
</tr>
<tr>
<td>元组</td>
<td>表中的一行即为一个元组</td>
</tr>
<tr>
<td>属性</td>
<td>表中的一列即为一个属性</td>
</tr>
<tr>
<td><strong>码</strong></td>
<td><strong>唯一标识实体的属性集称为码</strong></td>
</tr>
<tr>
<td><strong>主码</strong></td>
<td><strong>也称码键，表中的某个属性组，它可以唯一确定一个元组</strong></td>
</tr>
<tr>
<td>域</td>
<td>是一组具有相同数据类型的值的集合，属性的取值范围来自某个域</td>
</tr>
<tr>
<td>分量</td>
<td>元组中的一个属性值</td>
</tr>
</tbody></table>
<p>数据操作是集合操作，操作对象和操作结果都是<strong>关系</strong></p>
<h4 id="关系模式：对关系的描述"><a href="#关系模式：对关系的描述" class="headerlink" title="关系模式：对关系的描述"></a><strong>关系模式：对关系的描述</strong></h4><p>关系必须是规范化的：关系的每一个分量必须是一个不可分的数据项，<strong>不允许表中还有表</strong></p>
<p>关系的完整性约束：</p>
<ol>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义完整性</strong></li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li><p>建立在严格的数学概念的基础上</p>
</li>
<li><p>概念单一（实体和各类联系都用关系表示，对数据的检索结果也是关系）</p>
</li>
<li><p>关系模型的存取路径对用户透明（更高的数据独立性，更好的安全保密性，简化程序员的工作和数据库开发建立的工作）</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>存取路径对用户透明，查询效率往往不如格式化数据模型 </li>
<li>为提高性能，需对用户的查询请求进行优化，增加开发数据库管理系统的难度</li>
</ol>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><p>数据库系统通常采用<strong>三级模式</strong>结构，数据库系统内部的系统结构</p>
<p>最终用户角度：（1）单用户结构 （2）主从式结构 （3）分布式结构 （4）客户—服务器结构 （5）浏览器—应用服务器 &#x2F; 数据库服务器多层结构</p>
<h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><p>型：对某一类数据的结构和属性的说明</p>
<p>值：是型的一个具体赋值</p>
<p><strong>模式：数据库逻辑结构和特征的描述</strong></p>
<p>实例：模式的一个具体值</p>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>外模式（子模式）</strong></td>
<td>数据库用户使用的<strong>局部</strong>数据的逻辑结构和特征的描述，数据库用户的数据视图<br><strong>一个数据库可以有多个外模式</strong><br /><strong>模式与外模式：</strong>一对多，外模式通常是模式的子集<br /><strong>外模式与应用：</strong>一对多，一个应用程序中只能使用一个外模式<br />用途：（1）保护数据库安全性 （2）每个用户只能看见和访问所对应的外模式中的数据</td>
</tr>
<tr>
<td><strong>模式</strong></td>
<td>数据库中全体数据的<strong>逻辑结构和特征</strong>的描述，所有用户的公共数据视图<br><strong>一个数据库只有一个模式</strong></td>
</tr>
<tr>
<td><strong>内模式（存储模式）</strong></td>
<td>数据物理结构和存储方式的描述，数据在数据库内部的表示方式<br /><strong>一个数据库只有一个内模式</strong></td>
</tr>
</tbody></table>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>为了能够在系统内部实现3个抽象层次的数据之间的联系和转换，数据库管理系统提出了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。正是这两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>映像</th>
</tr>
</thead>
<tbody><tr>
<td><strong>逻辑独立性</strong></td>
<td>每一个外模式，数据库系统都有一个外模式 &#x2F; 模式映像，定义外模式与模式之间的对应关系<br>是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变</td>
<td>外模式&#x2F;模式映像</td>
</tr>
<tr>
<td><strong>物理独立性</strong></td>
<td>定义数据全局逻辑结构与存储结构之间的对应关系<br />数据库中模式 &#x2F; 内模式映像是<strong>唯一的</strong><br />是指用户的应用程序与数据库的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用改变</td>
<td>模式&#x2F;内模式映像</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>（1）数据库 （2）数据库管理系统 （3）应用程序 （4）数据库管理员 （5）硬件平台及数据库 （6）软件 （7）人员</p>
<h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>单一的数据结构：关系，逻辑结构：二维表</p>
<p>域：一组具有相同数据类型的值的集合</p>
<p>笛卡尔积：可表示为一张二维表，表中的每列对应一个域</p>
<p><strong>关系：笛卡尔积的有限子集</strong></p>
<p><strong>码：唯一标识实体的属性集称为码</strong></p>
<p><strong>主码：表中的某个属性组，它可以唯一确定一个元组</strong></p>
<hr>

<p>一个关系的候选码可以有多个，但主码只能有一个</p>
<p>（1）候选码：<strong>若关系中的某一属性组的值能唯一地标识一个元组</strong>，则称该属性组为候选码。简单的情况：候选码只包含一个属性</p>
<p>（2）全码：关系模式的所有属性组是这个关系模式的候选码，称为全码</p>
<p>（3）主码：若一个关系有多个候选码，则选定其中一个为主码</p>
<p>（4）主属性：候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性</p>
<p>（5）三类关系：</p>
<hr>

<p>1.基本关系（基本表或基表）：实际存在的表，实际存储数据的逻辑表示</p>
<p>2.查询表：查询结果对应的表</p>
<p>3.视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模式是型，关系是值，关系模式是对关系的描述：1.元组集合的结构 2.完整性约束条件</p>
<p>关系模式可以形式化地表示为：R (U,D,DOM,F)</p>
<p>R：关系名，U：组成该关系的属性名集合，D：U中属性所来自的域 DOM：属性向域的映像集合 F：属性间数据的依赖关系的集合</p>
<p>关系模式是对关系的描述，静态的稳定的</p>
<p>关系是关系模式在某一时刻的状态或内容，动态的、随时间不断变化的</p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p>
<h3 id="关系模型和存储结构"><a href="#关系模型和存储结构" class="headerlink" title="关系模型和存储结构"></a>关系模型和存储结构</h3><p>关系数据库的物理组织：交给操作系统 or 申请若干个大文件</p>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><p><strong>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积</strong></p>
<p><span style="color:red">5种基本操作：<strong>选择、投影、并、差、笛卡尔积</strong></span></p>
<p>更新操作：插入、删除、修改</p>
<p>关系操作特点：操作的对象和结果都是集合，<strong>一次一集合</strong>的方式</p>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询，运算对象和运算结果都是<strong>关系</strong></p>
<p><strong>关系代数中的连接操作是由选择和笛卡尔积操作组合而成</strong></p>
<h2 id="关系模型中的三类完整性约束"><a href="#关系模型中的三类完整性约束" class="headerlink" title="*关系模型中的三类完整性约束"></a>*关系模型中的三类完整性约束</h2><p>关系代数语言：用<strong>对关系的运算</strong>来表达查询要求 ISBL</p>
<p>关系演算语言：用<strong>谓词</strong>来表达查询要求（元组关系演算语言和域关系演算语言） APLHA QUEL</p>
<p>具有关系代数和关系演算双重特点的语言：SQL（Structured Query Language）结构化查询语言</p>
<p>关系模型必须满足的完整性约束条件称为关系的两个<strong>不变性</strong>，应该由关系系统自动支持</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性规则：若属性A是基本关系R的主属性，则属性A不能取空值</p>
<p>例如：选修（学号，课程号，成绩）</p>
<p>“学号，课程号”为主码，这两个属性都不能取空值</p>
<p>关系模型中以主码作为唯一标识符，<strong>主码中的属性即主属性不能取空值</strong></p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>定义：指如果属性（或属性组）F是关系R的外码，且对应了关系S的主码K（R和S可以是同一个关系），那么对于R中的每个元组中的F上的值，必须满足：<br>（1） 要么F取空值<br>（2） 要么等于S中某个元组的主码的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">	学生（学号，姓名）</span><br><span class="line">	课程（课程号，课程名）</span><br><span class="line">	选修（学号，课程号，成绩）</span><br></pre></td></tr></table></figure>

<p>选修表中的学号就称为选修表的一个外码，它对应的是学生表中的学号。</p>
<p>并且称选修关系为<code>参照关系</code>，而学生关系为<code>被参照关系</code>。</p>
<p>显然，在选修关系中的学号，必须是学生表里真正存在的学号，且选修表里的课程号，也必须是课程表里真正存在的课程号。这就是参照完整性的一个典型表现了。</p>
<p>参照完整性规则的说明：</p>
<ul>
<li>关系R和S不一定是不同的关系</li>
<li>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li>
<li>外码并不一定要与相应的主码同名</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所设计的数据必须满足的语义要求</p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="*关系代数"></a>*关系代数</h2><p>更具体的请看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dreaming_coder/article/details/108043502">https://blog.csdn.net/dreaming_coder/article/details/108043502</a></p>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询，运算对象和运算结果都是<strong>关系</strong></p>
<p>关系代数的运算符</p>
<p>（1）集合运算符（从行的角度进行）：并 差 交 笛卡尔积</p>
<p>（2）专门的关系运算符（涉及行和列）： 选择 投影 连接 除</p>
<p>选择 σ：从行的角度进行的运算</p>
<p>投影 π：从列的角度进行运算，不仅消除某些列，而且还可能取消某些元组（避免重复行）</p>
<p>连接：1.等值连接 2.自然连接</p>
<p><strong>一般的连接操作都是从行的角度进行运算。自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</strong></p>
<p>自然连接是一种特殊的等值连接：1.两个关系中进行比较的分量必须是相同的属性组 2.在结果中把重复的属性列去掉</p>
<p>外连接：把悬浮元组也保存在结果关系中，而在其他属性上填空值，就叫外连接</p>
<p>除运算：同时从行和列角度进行运算</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,rating from s where s.id = c.studentid and rating&gt;60;</span><br></pre></td></tr></table></figure>


<p>$$<br>π_{sname , rating} (σ_{rating&gt;60}(s⋈c ))<br>$$</p>
<h1 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h1><p>SQL：结构化查询语言，关系数据库的标准语言</p>
<p>SQL可分为<strong>数据定义、数据查询、数据更新、数据控制</strong>四大部分</p>
<p>SQL特点：（1）综合统一 （2）高度非过程化 （3）面向<strong>集合</strong>的操作方式 （4）独立的语言 嵌入式语言 （5）语言简洁，易学易用</p>
<p>数据查询：SELECT</p>
<p>数据定义：CREATE、DROP、ALTER</p>
<p>数据操纵：INSERT、UPDATE、DELETE</p>
<p>数据控制：GRANT、REVOKE</p>
<p>基本表、存储文件、视图</p>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>模式（CREATE SCHEMA，DROP SCHEMA）</p>
<p>表（CREATE TABLE，DROP TABLE，ALTER TABLE）</p>
<p>视图（CREATE VIEW， DROP VIEW）</p>
<p>索引（CREATE INDEX， DROP INDEX，ALTER INDEX）</p>
<h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>定义模式实际上定义了一个命名空间</p>
<p>定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
<p>删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</p>
<h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><p>定义基本表：CREATE TABLE</p>
<p>SQL中域的概念用<strong>数据类型</strong>来实现</p>
<p>每一个基本表都属于一个模式，一个模式包含多个基本表</p>
<p>设置搜索路径：SET search_path TO “S-T”,PUBLIC;</p>
<p>修改：ALTER TABLE （ADD、 DROP COLUMN、DROP CONSTRAINT、 ALTER COLUMN）</p>
<p>删除：DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]</p>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><p>建立索引的目的：加快查询速度</p>
<p>B+树索引具有动态平衡的优点，HASH索引具有查找速度快的特点</p>
<p>用户建立索引，系统维护、使用索引</p>
<p>建立：CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;</p>
<p>修改：ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
<p>删除：DROP INDEX &lt;索引名&gt;</p>
<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>记录数据库中所有定义信息：关系模式、视图、索引、完整性约束、各类用户对数据库的操作权限、统计信息</p>
<p>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新<strong>数据字典</strong>中的相应信息</p>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>SELECT FROM WHERE GROUP BY HAVING ORDER BY</p>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>（1）选择表中的若干列</p>
<p>查询经过计算的值：使用列<strong>别名</strong>改变查询结果的列标题</p>
<p>（2）选择表中的若干元组</p>
<p>DISTINCT 去掉重复的行</p>
<p>比较大小 确定范围 确定集合 字符匹配 涉及空值的查询 多重条件查询</p>
<p>%：任意长度的字符串</p>
<p>_：任意单个字符</p>
<p>（3）ORDER BY子句</p>
<p>可以按一个或多个属性列排序</p>
<p>（4）聚集函数</p>
<p>COUNT、SUM、AVG、MAX、MIN</p>
<p>（5）GROUP BY子句</p>
<p>HAVING必须在GROUP BY里面，而WHERE是整个查询的结果</p>
<p><strong>WHERE子句是不能用聚集函数作为条件表达式</strong></p>
<p><strong>HAVING短语与WHERE子句作用对象不同</strong>，WHERE子句作用与基表或视图，从中选择满足条件的元组，HAVING短语作用于组，从中选择满足条件的组</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询：同时涉及两个以上的表的查询</p>
<p>（1）等值与非等值连接</p>
<p>连接操作的执行过程：嵌套循环法、排序合并法、索引连接</p>
<p>（2）自身连接</p>
<p>一个表与其自己进行连接</p>
<p>（3）外连接</p>
<p>左外连接，保留左边的内容</p>
<p>（4）多表连接</p>
<p>多表连接：两个以上的表进行连接</p>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>一个SELECT-FROM-WHERE子句称为一个查询块</p>
<p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<p>SQL语言允许多层嵌套查询，子查询不能使用ORDER BY子句</p>
<p>不相关子查询 相关子查询</p>
<p>（1）带有IN谓词的子查询</p>
<p>（2）带有比较运算符的子查询</p>
<p>（3）带有ANY（SOME）或ALL谓词的子查询</p>
<p>使用ANY或ALL谓词时必须同时使用比较运算</p>
<p>（4）带有EXISTS谓词的子查询</p>
<p>不返回如何数据，只产生逻辑值</p>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>并操作、交操作、差操作</p>
<h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><p>如果子查询中没有聚集函数，派生表可以不指定属性列</p>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>（1）插入元组</p>
<p>INSERT INTO &lt;表名&gt; VALUES</p>
<p>（2）插入子查询结果</p>
<p>INSERT INTO &lt;表名&gt; 子查询</p>
<p>实体完整性、参照完整性、用户定义的完整性（NOT NULL约束，UNIQUE约束，值域约束）</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>（1）修改某一个元组的值</p>
<p>（2）修改多个元组的值</p>
<p>（3）带子查询的修改语句</p>
<p>实体完整性、主码不允许修改、用户定义的完整性（NOT NULL约束，UNIQUE约束，值域约束）</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>（1）删除某一个元组的值</p>
<p>（2）删除多个元组的值</p>
<p>（3）带子查询的删除语句</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>虚表，是一个或几个基本表（或视图）导出的表</p>
<p>只存放视图的定义，不存放视图对应的数据</p>
<p>基表中的数据发生变化 ，从视图中查询出的数据也随之改变</p>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p>（1）建立视图</p>
<p>CREATE VIEW xxx AS xxx [WITH CHECK OPTION];</p>
<p>基于多个基表的视图、基于视图的视图、带表达式的视图、分组视图</p>
<p>（2）删除视图</p>
<p>DROP VIEW &lt;视图名&gt; [CASCADE]</p>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图消解法</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>允许对<strong>行列子集视图</strong>进行更新</p>
<p>对其他类型视图的更新不同系统由不同限制</p>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>视图能够<strong>简化</strong>用户操作</p>
<p>视图使用户能以<strong>多种角度</strong>看待同一数据</p>
<p>视图对重构数据库提供了一定的逻辑独立性</p>
<p>视图能够对机密数据提供安全保护</p>
<p>适当利用视图可以更清晰的表达查询</p>
<h1 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h1><p>数据库的安全性是指保护数据库以防止不合法使用所造成的<strong>数据泄漏、更改或破坏</strong></p>
<h2 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h2><h3 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h3><p>（1）非授权用户对数据库的恶意存取和破坏</p>
<p>（2）数据库中重要或敏感的数据被泄漏</p>
<p>（3）安全环境的脆弱性</p>
<h3 id="安全标准简介"><a href="#安全标准简介" class="headerlink" title="安全标准简介"></a>安全标准简介</h3><p>（1）TCSEC标准：安全策略，责任，保证，文档</p>
<p>D级 最小保护，C1 自主安全保护，C2 受控的存取保护（自主存取控制）</p>
<p>B1 标记安全保护（强制存取控制）， B2 结构化保护， B3 安全域， A1 验证设计</p>
<p>（2）CC标准</p>
<h2 id="数据安全性控制"><a href="#数据安全性控制" class="headerlink" title="数据安全性控制"></a>数据安全性控制</h2><p>数据库安全控制的常用方法：<strong>用户标识和鉴定、存取控制、视图、审计、数据加密</strong></p>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><p>静态口令鉴别：密码</p>
<p>动态口令鉴别：验证码，一次一密</p>
<p>生物特征鉴别：指纹，眼角膜，FaceID</p>
<p>智能卡鉴别</p>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>自主存取控制 C2</p>
<p>强制存取控制 B1</p>
<h3 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h3><p>通过SQL的GRANT语句和REVOKE语句实现</p>
<p>用户权限组成：数据对象和操作类型</p>
<p>定义存取权限称为<strong>授权</strong></p>
<p>关系数据库系统中存取控制对象：</p>
<p>（1）数据库模式</p>
<p>模式（CREATE SCHEMA）基本表（CREATE TABLE ，ALTER TABLE） 视图（CREATE VIEW） 索引（CREATE INDEX）</p>
<p>（2）数据</p>
<p>基本表和视图（SELECT INSERT UPDATE DELETE REFERENCES ALL PRIVILEGES）</p>
<p>属性列（SELECT INSERT UPDATE REFERENCES ALL PRIVILEGES）</p>
<h3 id="授权：授予与回收"><a href="#授权：授予与回收" class="headerlink" title="授权：授予与回收"></a>授权：授予与回收</h3><p>GRANT：将对指定操作对象的指定操作权限授予指定的用户</p>
<p>不允许循环授权</p>
<p>REVOKE：收回权限</p>
<h3 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h3><p>数据库角色：被命名的一组与数据库操作相关的权限</p>
<h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p>
<p>主体是系统中的活动实体，客体是系统中的被动实体，受主体操纵</p>
<p>敏感度标记：<strong>绝密（TS）&gt;&#x3D; 机密（S）&gt;&#x3D; 可信（C）&gt;&#x3D; 公开（P）</strong></p>
<p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p>
<p>强制存取控制规则</p>
<p>（1）主体的许可证级别大于或等于客体的密级时，该主体才能<strong>读</strong>取相应的客体</p>
<p>（2）主体的许可证级别小于或等于客体的密级时，该主体才能<strong>写</strong>相应的客体</p>
<p>实现强制存取控制首先要实现自主存取控制</p>
<h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护，间接地实现支持存取谓词的用户权限定义</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>审计：启用一个专用的审计日志，将用户对数据库的所有操作记录在上面，审计员利用审计日志，监控数据库中的各种行为，找到非法存取数据的人、时间和内容</p>
<p>用户级审计、系统级审计</p>
<h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>数据加密是防止数据库中数据在<strong>存储和传输</strong>中失密的有效手段</p>
<p>加密方法：存储加密和传输加密</p>
<h2 id="其他安全性"><a href="#其他安全性" class="headerlink" title="其他安全性"></a>其他安全性</h2><p>推理控制、隐蔽信道、数据隐私保护</p>
<h1 id="第五章-数据完整性"><a href="#第五章-数据完整性" class="headerlink" title="第五章 数据完整性"></a>第五章 数据完整性</h1><p><strong>数据库的完整性：保护数据的正确性、有效性和相容性</strong></p>
<p>为维护数据库的完整性。数据库管理系统必须：（1）提供定义完整性约束条件的机制 （2）提供完整性检查的方法 （3）违约处理</p>
<h2 id="实体完整性-1"><a href="#实体完整性-1" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>实体完整性定义：关系模型的实体完整性，单属性构成的码：列级约束条件，表级约束条件，多个属性构成的码：表级约束条件</p>
<p>全表扫描，建立<strong>索引</strong>加快速度 B+树索引</p>
<h2 id="参照完整性-1"><a href="#参照完整性-1" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>FOREIGN KEY短语定义外码，REFERENCES短语指明这些外码参照表的哪些主码</p>
<p>违约处理：拒绝执行、级联操作、设置为空值</p>
<h2 id="用户定义的完整性-1"><a href="#用户定义的完整性-1" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><p>用户定义完整性：针对某一具体应用的数据必须满足的语义要求</p>
<p>（1）属性上的约束条件：列值非空，列值唯一，检查列值是否满足一个条件表达式</p>
<p>（2）元组上的约束条件：CHECK短语定义元组上的约束条件，即元组级的限制</p>
<h2 id="完整性约束命名字句"><a href="#完整性约束命名字句" class="headerlink" title="完整性约束命名字句"></a>完整性约束命名字句</h2><p>CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</p>
<p>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>通过声明性断言来指定更具一般性的约束</p>
<p>CREATE ASSERTION &lt;断言名&gt; &lt;CHECK子句&gt;</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>CREATE TRIGGER</p>
<p>触发器又叫做<strong>事件-条件-动作</strong>规则</p>
<p>触发器由触发事件激活</p>
<p>执行顺序：（1）执行该表上的BEFORE触发器 （2）激活触发器的SQL语句 （3）执行该表上的AFTER触发器</p>
<p>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</p>
<h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><p>关系数据库逻辑设计—关系数据库的规范化理论</p>
<p><strong>第一范式（1NF）：每个分量必须是不可分开的数据项</strong>，无重复的列</p>
<p>数据依赖是一个关系内部属性与属性之间的一种约束关系，可分为<strong>函数依赖</strong>和<strong>多值依赖</strong></p>
<p><strong>数据冗余、更新异常、插入异常、删除异常</strong></p>
<p>原因：由存在于模式中的某些数据依赖引起</p>
<p>解决方法：用规范化理论改造关系模式来消除不合适的数据依赖（分解）</p>
<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>X函数确定Y，Y函数依赖于X，记作X—&gt;Y</strong></p>
<p>函数依赖是指关系模式R的所有关系实例均要满足的约束条件，是语义范畴的概念</p>
<p>X—&gt;Y，但 Y 不属于 X，则称X—&gt;Y是<strong>非平凡的函数依赖</strong></p>
<p>X—&gt;Y，但 Y 属于 X（Y是X的子集），则称X—&gt;Y是<strong>平凡的函数依赖</strong>，平凡函数依赖必成立</p>
<p>若X—&gt;Y，则X称为这个函数依赖的<strong>决定因素</strong></p>
<ol>
<li>**完全函数依赖 **</li>
<li><strong>部分函数依赖</strong></li>
<li><strong>传递函数依赖</strong></li>
</ol>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><ol>
<li>候选码 </li>
<li>主码 </li>
<li>主属性 </li>
<li>非主属性 </li>
<li>全码 </li>
<li>外码</li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一级别的关系模式的集合</p>
<p><strong>1NF 包含 2NF 包含 3NF 包含 BCNF 包含 4NF 包含 5NF</strong></p>
<p>一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong></p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具，规范化实质上是概念的单一化</p>
<p>一个关系模式不属于2NF，会产生插入异常、删除异常、修改复杂的问题</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第二范式（2NF）</strong></td>
<td><strong>关系模式R属于1NF，并且每一个非主属性都完全函数依赖于任何一个候选码（即不存在非主属性部分函数依赖于候选码），则R属于2NF</strong></td>
</tr>
<tr>
<td><strong>第三范式（3NF）</strong></td>
<td><strong>关系模式R&lt;U,F&gt;属于1NF，若R中不存在非主属性Z对码X的传递函数依赖，则称R&lt;U,F&gt;属于3NF</strong></td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td><strong>在关系模式R&lt;U,F&gt;中，如果每一个决定属性集都包含候选码，则R属于BCNF</strong></td>
</tr>
</tbody></table>
<p>关系模式的规范化：一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式集合</p>
<h4 id="关系数据库的规范化是数据库逻辑设计的工具"><a href="#关系数据库的规范化是数据库逻辑设计的工具" class="headerlink" title="关系数据库的规范化是数据库逻辑设计的工具"></a>关系数据库的规范化是数据库逻辑设计的工具</h4><p>1NF—&gt;2NF：消除非主属性对码的部分函数依赖</p>
<p>2NF—&gt;3NF：消除非主属性对码的传递函数依赖</p>
<p>3NF—&gt;BCNF：消除主属性对码的部分和传递函数依赖</p>
<p>BCNF—&gt;4NF：消除非平凡且非函数依赖的多值依赖</p>
<p>1NF—&gt;BCNF：消除决定因素非码的非平凡函数依赖</p>
<p>不能说规范化程度越高的关系模式就越好</p>
<h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><p>需求分析和概念设计独立于任何数据库管理系统，逻辑设计和物理设计与选用的数据库管理系统密切相关</p>
<p>需求分析阶段：综合各个用户的应用需求</p>
<p>概念设计阶段：<strong>概念模式</strong>（信息时间模型），用E-R图来描述</p>
<p>逻辑设计阶段：<strong>逻辑模式、外模式</strong></p>
<p>物理设计阶段：<strong>内模式</strong></p>
<p>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模式，形成数据库<strong>逻辑模式</strong></p>
<p>根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的<strong>外模式</strong></p>
<p>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库<strong>内模式</strong></p>
<h3 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h3><p><strong>需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护</strong></p>
<p>需求分析和概念结构设计独立于任何数据库管理系统</p>
<p>逻辑设计和物理设计与选用的数据库管理系统密切相关</p>
<h3 id="数据库设计过程中的各级模式"><a href="#数据库设计过程中的各级模式" class="headerlink" title="数据库设计过程中的各级模式"></a>数据库设计过程中的各级模式</h3><p>需求分析：综合各个用户的应用需求</p>
<p>概念设计阶段：E-R图</p>
<p>逻辑设计阶段：逻辑模式 外模式</p>
<p>物理设计阶段：内模式</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求分析就是分析用户的需求</p>
<p>分析方法：结构化分析方法</p>
<p>数据字典是关于数据库中的数据描述，即元数据</p>
<p>数据字典的内容：数据项、数据结构、数据流、数据存储、处理过程</p>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><h3 id="7-3-1-概念模型"><a href="#7-3-1-概念模型" class="headerlink" title="7.3.1 概念模型"></a>7.3.1 概念模型</h3><p>描述概念模型的工具 E-R模型</p>
<h3 id="7-3-2-E-R模型"><a href="#7-3-2-E-R模型" class="headerlink" title="7.3.2 E-R模型"></a>7.3.2 E-R模型</h3><p>实体之间的联系：一对一（1:1）、一对多（1:n）、多对多（m:n）</p>
<p>联系的度：参与联系的实体型的数目</p>
<p>E-R图提供了表示实体型、属性和联系的方法</p>
<h3 id="7-3-3-概念结构设计"><a href="#7-3-3-概念结构设计" class="headerlink" title="7.3.3 概念结构设计"></a>7.3.3 概念结构设计</h3><p>两条准则：（1）属性必须是不可分的数据项，不能包含其他属性 （2）属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系</p>
<p>E-R图的集成一般需要两步</p>
<p>（1）合并</p>
<p>子系统E-R图之间的冲突主要有三类：属性冲突、命名冲突、结构冲突</p>
<p>（2）修改和重构</p>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><h3 id="7-4-1-E-R图向关系模型的转换"><a href="#7-4-1-E-R图向关系模型的转换" class="headerlink" title="7.4.1 E-R图向关系模型的转换"></a>7.4.1 E-R图向关系模型的转换</h3><p>（1）1:1联系转换为一个独立的关系模式</p>
<p>（2）1:1联系与任意一端合并</p>
<p>（3）1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</p>
<p>（4）一个m:n联系转换为一个关系模式，取m，n端的码作为独立关系的组合码，再加自有属性</p>
<p>（5）三个或三个以上实体间的一个<strong>多元联系</strong>转换为一个关系模式</p>
<p>（6）具有相同码的关系模式可合并</p>
<h3 id="7-4-2-数据模型的优化"><a href="#7-4-2-数据模型的优化" class="headerlink" title="7.4.2 数据模型的优化"></a>7.4.2 数据模型的优化</h3><p>无通用规则，数据库逻辑设计的结果不是唯一的</p>
<h3 id="7-4-3-设计用户子模式"><a href="#7-4-3-设计用户子模式" class="headerlink" title="7.4.3 设计用户子模式"></a>7.4.3 设计用户子模式</h3><p>（1）使用更符合用户习惯的别名 （2）针对不同级别的用户定义不同的视图，以保证系统的安全性 （3）简化用户对系统的使用</p>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><p>数据库在物理设备上的<strong>存储结构与存取方法</strong>称为数据库的物理结构，它依赖于选定的数据库管理系统</p>
<p>数据库管理系统常用存取方法：B+树索引存取方法、Hash索引存取方法、聚簇存取方法</p>
<p>确定数据库物理结构主要确定数据的<strong>存放位置</strong>和<strong>存储结构</strong></p>
<p>确定数据的存放位置和存储结构要综合考虑<strong>存取时间、存储空间利用率和维护代价</strong></p>
<h1 id="单元测试笔记"><a href="#单元测试笔记" class="headerlink" title="单元测试笔记"></a>单元测试笔记</h1><h2 id="单元测试2"><a href="#单元测试2" class="headerlink" title="单元测试2"></a>单元测试2</h2><p>关系代数中的连接操作是由<strong>选择和笛卡尔积</strong>操作组合而成</p>
<p>关系数据模型的基本数据结构是<strong>关系</strong></p>
<p>关系R中能唯一标识一个元组的是它的 <strong>主码、全码、候选码</strong></p>
<p>关系是动态的、随时间变化的，关系模式是静态的、稳定的</p>
<h2 id="单元测试4"><a href="#单元测试4" class="headerlink" title="单元测试4"></a>单元测试4</h2><p>安全性控制的防范对象是<strong>非法用户</strong>，防止他们对数据库数据的存取</p>
<p>数据库安全审计系统提供了一种<strong>事后检查</strong>的安全机制。</p>
<p>在数据库的安全性控制中，授权对象的约束粒度越小，授权子系统就越灵活</p>
<h2 id="单元测试5"><a href="#单元测试5" class="headerlink" title="单元测试5"></a>单元测试5</h2><p>实体完整性规则检查的内容包括：检查主码值是否唯一,如果不唯一就拒绝插入或修改，检查主码的各个属性值是否为空,只要有一个为空就拒绝插入或修改</p>
<p>触发器只能定义在基本表上</p>
<h2 id="单元测试6"><a href="#单元测试6" class="headerlink" title="单元测试6"></a>单元测试6</h2><p>算法：按以下步骤求候选键：<br>1.只在FD右部出现的属性，不属于候选码;<br>2.只在FD左部出现的属性，一定存在于某候选码当中;<br>3.外部属性一定存在于任何候选码当中;<br>4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码</p>
<p>关系模式R的整个属性组是码,则R满足的最高范式至少是<strong>3NF</strong></p>
<p>关系规范化中的删除异常是指<strong>不该删除的数据被删除</strong></p>
<p>关系数据库的规范化理论主要解决的问题是<strong>如何构造合适的数据逻辑结构</strong></p>
<p>在关系数据库设计中,设计关系模式是数据库设计中<strong>逻辑结构设计阶段</strong>的任务</p>
<h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><p>子模式（外模式）DDL用来描述数据库的局部逻辑结构</p>
<p>SQL中的视图提高了数据库系统的安全性</p>
<p>候选码：若关系中的某一属性组的值能够唯一确定一个元组，则该属性组为候选码</p>
<p>主码：若一个关系有多个候选码，选定一个作为主码</p>
<p>外码：设关系R的一个属性组F，F不是关系R的主码，若F与关系S的主码相对应，则称F是关系R的外码</p>
<p>一个关系的候选码可以有多个，但主码只有一个</p>
<p>每一个实体对应一个关系模式</p>
<p>每个m：n联系对应一个关系模式</p>
<p>概念结构设计的方法有四种：自顶向下、自底向上、逐步扩张、混合策略</p>
<p>设计步骤：（1）进行数据抽象，设计局部E-R模型，即设计局部示图 （2）集成各局部E-R模型，形成全局E-R模型，即视图的集成</p>
<p>在数据库中，产生数据不一致的根本原因是未对数据进行完整性控制</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
