<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MEIDE&#39;S BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MEIDE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据库原理知识点总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-20 16:28:28 / 修改时间：18:15:53" itemprop="dateCreated datePublished" datetime="2022-12-20T16:28:28+08:00">2022-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">数据库原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><p><strong>数据库技术</strong>是信息系统的核心和基础</p>
<h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><p>数据库的4个基本概念：</p>
<ol>
<li><p>数据（data）:数据库中存储的基本对象</p>
</li>
<li><p>数据库（DataBase、DB）:<strong>长期存储在计算机内、有组织的、可共享的大量数据的集合</strong></p>
</li>
<li><p>数据库管理系统（DataBase Management System、DBMS）:科学地<strong>组织</strong>和<strong>存储</strong>数据、高效地<strong>获取</strong>和<strong>维护</strong>数据。</p>
<ol>
<li><p>数据定义功能（DDL）</p>
</li>
<li><p>数据组织、存储和管理 </p>
</li>
<li><p>数据操纵功能（DML）</p>
</li>
<li><p>数据库的事物管理和运行管理 </p>
</li>
<li><p>数据库的建立和维护功能</p>
</li>
</ol>
</li>
<li><p>数据库系统（DataBase System 、DBS）:</p>
<ul>
<li><p>数据库</p>
</li>
<li><p>数据库管理系统</p>
</li>
<li><p>应用程序</p>
</li>
<li><p>数据库管理员</p>
</li>
</ul>
</li>
</ol>
<h3 id="数据库技术的产生和发展"><a href="#数据库技术的产生和发展" class="headerlink" title="数据库技术的产生和发展"></a>数据库技术的产生和发展</h3><p>数据管理：对数据进行<strong>分类、组织、编码、存储、检索和维护</strong></p>
<p>数据管理技术的发展过程：</p>
<ul>
<li><strong>人工管理阶段</strong>（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%89%B9%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">批处理</a>，20世纪50年代中之前）</li>
<li><strong>文件系统阶段</strong>（联机实时处理、批处理，20世纪50年代末—60年代中）</li>
<li><strong>数据库系统阶段</strong>（联机实时处理、分布处理、批处理，20世纪60年代末—现在）</li>
</ul>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ol>
<li>数据结构化</li>
<li>数据的共享性高、冗余度低且易扩充</li>
<li>数据独立性高 </li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
<p>数据的最小存取单位是<strong>数据项</strong>，用<strong>数据模型</strong>来描述</p>
<h4 id="数据库的三级模式与两层映像"><a href="#数据库的三级模式与两层映像" class="headerlink" title="数据库的三级模式与两层映像"></a><strong>数据库的三级模式与两层映像</strong></h4><p><strong>内模式</strong>：对应于物理层数据抽象，它是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<p><strong>模式</strong>：对应于逻辑层数据抽象，它是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
<p><strong>外模式</strong>：对应于视图层数据抽象，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</p>
<p>为了能够在系统内部实现3个抽象层次的数据之间的联系和转换，数据库管理系统提出了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。正是这两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>映像</th>
</tr>
</thead>
<tbody><tr>
<td><strong>逻辑独立性</strong></td>
<td>是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变</td>
<td>外模式&#x2F;模式映像</td>
</tr>
<tr>
<td><strong>物理独立性</strong></td>
<td>是指用户的应用程序与数据库的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用改变</td>
<td>模式&#x2F;内模式映像</td>
</tr>
</tbody></table>
<p><strong>数据管理系统提供的数据控制功能</strong>：</p>
<ol>
<li>数据的安全性保护</li>
<li>数据的完整性保护</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ol>
<p>数据的安全性保护：保护数据以防止不合法的使用造成数据的泄密和破坏</p>
<p>数据的完整性保护：保护数据的正确性、有效性和相容性</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>常用的数据模型：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型</p>
<h3 id="数据模型分类"><a href="#数据模型分类" class="headerlink" title="数据模型分类"></a>数据模型分类</h3><p>概念模型：也称信息模型，用于数据库设计，E-R模型、OO模型</p>
<p>逻辑模型：层次模型、网状模型、<strong>关系模型</strong>、面向对象数据模型、对象关系数据数据模型、半结构化数据模型。DBMS实现</p>
<p>物理模型：用来描述数据的物理存储结构和存储方式、在磁盘或磁带上的存储方式和存取方法</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>表示方法：<strong>实体—联系方法</strong> <strong>：E-R图</strong> E-R方法也称为E-R模型</p>
<p>实体：客观存在并可相互区别的事物称为实体</p>
<p>属性：实体所具有的某一特性称为属性</p>
<p><span style="color:red"><strong>码：唯一标识实体的属性集称为 码</strong></span></p>
<p><strong>实体之间的联系</strong>：<strong>一对一、一对多、多对多</strong></p>
<p>用<strong>E-R图</strong>来描述现实世界的概念模型</p>
<h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><ol>
<li><p>数据结构：描述数据库的组成对象，以及对象之间的联系，<strong>对系统静态特性的描述</strong></p>
</li>
<li><p>数据操作：对数据库中各种对象的实例允许执行的<strong>操作的集合</strong>，包括<strong>操作</strong>及有关的<strong>操作规则</strong>，<strong>对系统动态特性的描述</strong></p>
<p>数据操作的类型：<strong>查询</strong>，<strong>更新</strong>（插入、删除、修改）</p>
</li>
<li><p>数据的完整性约束条件</p>
</li>
</ol>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><p>层次模型用<strong>树形结构</strong>来表示各类实体以及实体间的联系， 典型代表：IMS</p>
<p>特点：只能直接处理一对多的实体联系</p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）数据结构比较简单清晰 <br>（2）查询效率高，性能优于关系模型 ，不低于网状模型（3）提供良好的完整性支持</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）多对多联系表示不自然 <br>（2）插入和删除限制多 <br>（3）查询子女结点必须通过双亲节点 <br>（4）层次命令趋于程序化</td>
</tr>
</tbody></table>
<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>网状数据库系统采用<strong>网状模型</strong>作为数据库的组织方式，典型代表：DBTG（亦称CODASYL系统）</p>
<p>层次模型是网状模型的一个特例，用网状模型<strong>间接</strong>表示多对多联系（将多对多联系直接分解成一对多联系）</p>
<table>
<thead>
<tr>
<th>优缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>（1）更为直观地描述现实世界，如一个结点可以有多个双亲 <br>（2）具有良好的性能，存取效率较高</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）结构复杂 <br>（2）DDL、DML语言复杂 <br>（3）记录之间联系是通过存取路径实现，用户必须了解系统结构的细节</td>
</tr>
</tbody></table>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="*关系模型"></a>*关系模型</h3><p>关系数据库系统采用<strong>关系模型</strong>作为数据的组织方式</p>
<p>用户观点下，关系模型中数据的逻辑结构是一张<strong>二维表</strong>，它由行和列组成</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>关系</td>
<td>一个关系对应通常说的一张表</td>
</tr>
<tr>
<td>元组</td>
<td>表中的一行即为一个元组</td>
</tr>
<tr>
<td>属性</td>
<td>表中的一列即为一个属性</td>
</tr>
<tr>
<td><strong>码</strong></td>
<td><strong>唯一标识实体的属性集称为码</strong></td>
</tr>
<tr>
<td><strong>主码</strong></td>
<td><strong>也称码键，表中的某个属性组，它可以唯一确定一个元组</strong></td>
</tr>
<tr>
<td>域</td>
<td>是一组具有相同数据类型的值的集合，属性的取值范围来自某个域</td>
</tr>
<tr>
<td>分量</td>
<td>元组中的一个属性值</td>
</tr>
</tbody></table>
<p>数据操作是集合操作，操作对象和操作结果都是<strong>关系</strong></p>
<h4 id="关系模式：对关系的描述"><a href="#关系模式：对关系的描述" class="headerlink" title="关系模式：对关系的描述"></a><strong>关系模式：对关系的描述</strong></h4><p>关系必须是规范化的：关系的每一个分量必须是一个不可分的数据项，<strong>不允许表中还有表</strong></p>
<p>关系的完整性约束：</p>
<ol>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义完整性</strong></li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li><p>建立在严格的数学概念的基础上</p>
</li>
<li><p>概念单一（实体和各类联系都用关系表示，对数据的检索结果也是关系）</p>
</li>
<li><p>关系模型的存取路径对用户透明（更高的数据独立性，更好的安全保密性，简化程序员的工作和数据库开发建立的工作）</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>存取路径对用户透明，查询效率往往不如格式化数据模型 </li>
<li>为提高性能，需对用户的查询请求进行优化，增加开发数据库管理系统的难度</li>
</ol>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><p>数据库系统通常采用<strong>三级模式</strong>结构，数据库系统内部的系统结构</p>
<p>最终用户角度：（1）单用户结构 （2）主从式结构 （3）分布式结构 （4）客户—服务器结构 （5）浏览器—应用服务器 &#x2F; 数据库服务器多层结构</p>
<h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><p>型：对某一类数据的结构和属性的说明</p>
<p>值：是型的一个具体赋值</p>
<p><strong>模式：数据库逻辑结构和特征的描述</strong></p>
<p>实例：模式的一个具体值</p>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>外模式（子模式）</strong></td>
<td>数据库用户使用的<strong>局部</strong>数据的逻辑结构和特征的描述，数据库用户的数据视图<br><strong>一个数据库可以有多个外模式</strong><br /><strong>模式与外模式：</strong>一对多，外模式通常是模式的子集<br /><strong>外模式与应用：</strong>一对多，一个应用程序中只能使用一个外模式<br />用途：（1）保护数据库安全性 （2）每个用户只能看见和访问所对应的外模式中的数据</td>
</tr>
<tr>
<td><strong>模式</strong></td>
<td>数据库中全体数据的<strong>逻辑结构和特征</strong>的描述，所有用户的公共数据视图<br><strong>一个数据库只有一个模式</strong></td>
</tr>
<tr>
<td><strong>内模式（存储模式）</strong></td>
<td>数据物理结构和存储方式的描述，数据在数据库内部的表示方式<br /><strong>一个数据库只有一个内模式</strong></td>
</tr>
</tbody></table>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>为了能够在系统内部实现3个抽象层次的数据之间的联系和转换，数据库管理系统提出了两层映像：外模式&#x2F;模式映像，模式&#x2F;内模式映像。正是这两层映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>映像</th>
</tr>
</thead>
<tbody><tr>
<td><strong>逻辑独立性</strong></td>
<td>每一个外模式，数据库系统都有一个外模式 &#x2F; 模式映像，定义外模式与模式之间的对应关系<br>是指用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，应用程序不用改变</td>
<td>外模式&#x2F;模式映像</td>
</tr>
<tr>
<td><strong>物理独立性</strong></td>
<td>定义数据全局逻辑结构与存储结构之间的对应关系<br />数据库中模式 &#x2F; 内模式映像是<strong>唯一的</strong><br />是指用户的应用程序与数据库的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用改变</td>
<td>模式&#x2F;内模式映像</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>（1）数据库 （2）数据库管理系统 （3）应用程序 （4）数据库管理员 （5）硬件平台及数据库 （6）软件 （7）人员</p>
<h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>单一的数据结构：关系，逻辑结构：二维表</p>
<p>域：一组具有相同数据类型的值的集合</p>
<p>笛卡尔积：可表示为一张二维表，表中的每列对应一个域</p>
<p><strong>关系：笛卡尔积的有限子集</strong></p>
<p><strong>码：唯一标识实体的属性集称为码</strong></p>
<p><strong>主码：表中的某个属性组，它可以唯一确定一个元组</strong></p>
<hr>

<p>一个关系的候选码可以有多个，但主码只能有一个</p>
<p>（1）候选码：<strong>若关系中的某一属性组的值能唯一地标识一个元组</strong>，则称该属性组为候选码。简单的情况：候选码只包含一个属性</p>
<p>（2）全码：关系模式的所有属性组是这个关系模式的候选码，称为全码</p>
<p>（3）主码：若一个关系有多个候选码，则选定其中一个为主码</p>
<p>（4）主属性：候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性</p>
<p>（5）三类关系：</p>
<hr>

<p>1.基本关系（基本表或基表）：实际存在的表，实际存储数据的逻辑表示</p>
<p>2.查询表：查询结果对应的表</p>
<p>3.视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模式是型，关系是值，关系模式是对关系的描述：1.元组集合的结构 2.完整性约束条件</p>
<p>关系模式可以形式化地表示为：R (U,D,DOM,F)</p>
<p>R：关系名，U：组成该关系的属性名集合，D：U中属性所来自的域 DOM：属性向域的映像集合 F：属性间数据的依赖关系的集合</p>
<p>关系模式是对关系的描述，静态的稳定的</p>
<p>关系是关系模式在某一时刻的状态或内容，动态的、随时间不断变化的</p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p>
<h3 id="关系模型和存储结构"><a href="#关系模型和存储结构" class="headerlink" title="关系模型和存储结构"></a>关系模型和存储结构</h3><p>关系数据库的物理组织：交给操作系统 or 申请若干个大文件</p>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><p><strong>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积</strong></p>
<p><span style="color:red">5种基本操作：<strong>选择、投影、并、差、笛卡尔积</strong></span></p>
<p>更新操作：插入、删除、修改</p>
<p>关系操作特点：操作的对象和结果都是集合，<strong>一次一集合</strong>的方式</p>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询，运算对象和运算结果都是<strong>关系</strong></p>
<p><strong>关系代数中的连接操作是由选择和笛卡尔积操作组合而成</strong></p>
<h2 id="关系模型中的三类完整性约束"><a href="#关系模型中的三类完整性约束" class="headerlink" title="*关系模型中的三类完整性约束"></a>*关系模型中的三类完整性约束</h2><p>关系代数语言：用<strong>对关系的运算</strong>来表达查询要求 ISBL</p>
<p>关系演算语言：用<strong>谓词</strong>来表达查询要求（元组关系演算语言和域关系演算语言） APLHA QUEL</p>
<p>具有关系代数和关系演算双重特点的语言：SQL（Structured Query Language）结构化查询语言</p>
<p>关系模型必须满足的完整性约束条件称为关系的两个<strong>不变性</strong>，应该由关系系统自动支持</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性规则：若属性A是基本关系R的主属性，则属性A不能取空值</p>
<p>例如：选修（学号，课程号，成绩）</p>
<p>“学号，课程号”为主码，这两个属性都不能取空值</p>
<p>关系模型中以主码作为唯一标识符，<strong>主码中的属性即主属性不能取空值</strong></p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>定义：指如果属性（或属性组）F是关系R的外码，且对应了关系S的主码K（R和S可以是同一个关系），那么对于R中的每个元组中的F上的值，必须满足：<br>（1） 要么F取空值<br>（2） 要么等于S中某个元组的主码的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">	学生（学号，姓名）</span><br><span class="line">	课程（课程号，课程名）</span><br><span class="line">	选修（学号，课程号，成绩）</span><br></pre></td></tr></table></figure>

<p>选修表中的学号就称为选修表的一个外码，它对应的是学生表中的学号。</p>
<p>并且称选修关系为<code>参照关系</code>，而学生关系为<code>被参照关系</code>。</p>
<p>显然，在选修关系中的学号，必须是学生表里真正存在的学号，且选修表里的课程号，也必须是课程表里真正存在的课程号。这就是参照完整性的一个典型表现了。</p>
<p>参照完整性规则的说明：</p>
<ul>
<li>关系R和S不一定是不同的关系</li>
<li>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li>
<li>外码并不一定要与相应的主码同名</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所设计的数据必须满足的语义要求</p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="*关系代数"></a>*关系代数</h2><p>更具体的请看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dreaming_coder/article/details/108043502">https://blog.csdn.net/dreaming_coder/article/details/108043502</a></p>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询，运算对象和运算结果都是<strong>关系</strong></p>
<p>关系代数的运算符</p>
<p>（1）集合运算符（从行的角度进行）：并 差 交 笛卡尔积</p>
<p>（2）专门的关系运算符（涉及行和列）： 选择 投影 连接 除</p>
<p>选择 σ：从行的角度进行的运算</p>
<p>投影 π：从列的角度进行运算，不仅消除某些列，而且还可能取消某些元组（避免重复行）</p>
<p>连接：1.等值连接 2.自然连接</p>
<p><strong>一般的连接操作都是从行的角度进行运算。自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</strong></p>
<p>自然连接是一种特殊的等值连接：1.两个关系中进行比较的分量必须是相同的属性组 2.在结果中把重复的属性列去掉</p>
<p>外连接：把悬浮元组也保存在结果关系中，而在其他属性上填空值，就叫外连接</p>
<p>除运算：同时从行和列角度进行运算</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,rating from s where s.id = c.studentid and rating&gt;60;</span><br></pre></td></tr></table></figure>


<p>$$<br>π_{sname , rating} (σ_{rating&gt;60}(s⋈c ))<br>$$</p>
<h1 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h1><p>SQL：结构化查询语言，关系数据库的标准语言</p>
<p>SQL可分为<strong>数据定义、数据查询、数据更新、数据控制</strong>四大部分</p>
<p>SQL特点：（1）综合统一 （2）高度非过程化 （3）面向<strong>集合</strong>的操作方式 （4）独立的语言 嵌入式语言 （5）语言简洁，易学易用</p>
<p>数据查询：SELECT</p>
<p>数据定义：CREATE、DROP、ALTER</p>
<p>数据操纵：INSERT、UPDATE、DELETE</p>
<p>数据控制：GRANT、REVOKE</p>
<p>基本表、存储文件、视图</p>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>模式（CREATE SCHEMA，DROP SCHEMA）</p>
<p>表（CREATE TABLE，DROP TABLE，ALTER TABLE）</p>
<p>视图（CREATE VIEW， DROP VIEW）</p>
<p>索引（CREATE INDEX， DROP INDEX，ALTER INDEX）</p>
<h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>定义模式实际上定义了一个命名空间</p>
<p>定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
<p>删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</p>
<h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><p>定义基本表：CREATE TABLE</p>
<p>SQL中域的概念用<strong>数据类型</strong>来实现</p>
<p>每一个基本表都属于一个模式，一个模式包含多个基本表</p>
<p>设置搜索路径：SET search_path TO “S-T”,PUBLIC;</p>
<p>修改：ALTER TABLE （ADD、 DROP COLUMN、DROP CONSTRAINT、 ALTER COLUMN）</p>
<p>删除：DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]</p>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><p>建立索引的目的：加快查询速度</p>
<p>B+树索引具有动态平衡的优点，HASH索引具有查找速度快的特点</p>
<p>用户建立索引，系统维护、使用索引</p>
<p>建立：CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;</p>
<p>修改：ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
<p>删除：DROP INDEX &lt;索引名&gt;</p>
<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>记录数据库中所有定义信息：关系模式、视图、索引、完整性约束、各类用户对数据库的操作权限、统计信息</p>
<p>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新<strong>数据字典</strong>中的相应信息</p>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>SELECT FROM WHERE GROUP BY HAVING ORDER BY</p>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>（1）选择表中的若干列</p>
<p>查询经过计算的值：使用列<strong>别名</strong>改变查询结果的列标题</p>
<p>（2）选择表中的若干元组</p>
<p>DISTINCT 去掉重复的行</p>
<p>比较大小 确定范围 确定集合 字符匹配 涉及空值的查询 多重条件查询</p>
<p>%：任意长度的字符串</p>
<p>_：任意单个字符</p>
<p>（3）ORDER BY子句</p>
<p>可以按一个或多个属性列排序</p>
<p>（4）聚集函数</p>
<p>COUNT、SUM、AVG、MAX、MIN</p>
<p>（5）GROUP BY子句</p>
<p>HAVING必须在GROUP BY里面，而WHERE是整个查询的结果</p>
<p><strong>WHERE子句是不能用聚集函数作为条件表达式</strong></p>
<p><strong>HAVING短语与WHERE子句作用对象不同</strong>，WHERE子句作用与基表或视图，从中选择满足条件的元组，HAVING短语作用于组，从中选择满足条件的组</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询：同时涉及两个以上的表的查询</p>
<p>（1）等值与非等值连接</p>
<p>连接操作的执行过程：嵌套循环法、排序合并法、索引连接</p>
<p>（2）自身连接</p>
<p>一个表与其自己进行连接</p>
<p>（3）外连接</p>
<p>左外连接，保留左边的内容</p>
<p>（4）多表连接</p>
<p>多表连接：两个以上的表进行连接</p>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>一个SELECT-FROM-WHERE子句称为一个查询块</p>
<p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<p>SQL语言允许多层嵌套查询，子查询不能使用ORDER BY子句</p>
<p>不相关子查询 相关子查询</p>
<p>（1）带有IN谓词的子查询</p>
<p>（2）带有比较运算符的子查询</p>
<p>（3）带有ANY（SOME）或ALL谓词的子查询</p>
<p>使用ANY或ALL谓词时必须同时使用比较运算</p>
<p>（4）带有EXISTS谓词的子查询</p>
<p>不返回如何数据，只产生逻辑值</p>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>并操作、交操作、差操作</p>
<h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><p>如果子查询中没有聚集函数，派生表可以不指定属性列</p>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>（1）插入元组</p>
<p>INSERT INTO &lt;表名&gt; VALUES</p>
<p>（2）插入子查询结果</p>
<p>INSERT INTO &lt;表名&gt; 子查询</p>
<p>实体完整性、参照完整性、用户定义的完整性（NOT NULL约束，UNIQUE约束，值域约束）</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>（1）修改某一个元组的值</p>
<p>（2）修改多个元组的值</p>
<p>（3）带子查询的修改语句</p>
<p>实体完整性、主码不允许修改、用户定义的完整性（NOT NULL约束，UNIQUE约束，值域约束）</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>（1）删除某一个元组的值</p>
<p>（2）删除多个元组的值</p>
<p>（3）带子查询的删除语句</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>虚表，是一个或几个基本表（或视图）导出的表</p>
<p>只存放视图的定义，不存放视图对应的数据</p>
<p>基表中的数据发生变化 ，从视图中查询出的数据也随之改变</p>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p>（1）建立视图</p>
<p>CREATE VIEW xxx AS xxx [WITH CHECK OPTION];</p>
<p>基于多个基表的视图、基于视图的视图、带表达式的视图、分组视图</p>
<p>（2）删除视图</p>
<p>DROP VIEW &lt;视图名&gt; [CASCADE]</p>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图消解法</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>允许对<strong>行列子集视图</strong>进行更新</p>
<p>对其他类型视图的更新不同系统由不同限制</p>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>视图能够<strong>简化</strong>用户操作</p>
<p>视图使用户能以<strong>多种角度</strong>看待同一数据</p>
<p>视图对重构数据库提供了一定的逻辑独立性</p>
<p>视图能够对机密数据提供安全保护</p>
<p>适当利用视图可以更清晰的表达查询</p>
<h1 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h1><p>数据库的安全性是指保护数据库以防止不合法使用所造成的<strong>数据泄漏、更改或破坏</strong></p>
<h2 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h2><h3 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h3><p>（1）非授权用户对数据库的恶意存取和破坏</p>
<p>（2）数据库中重要或敏感的数据被泄漏</p>
<p>（3）安全环境的脆弱性</p>
<h3 id="安全标准简介"><a href="#安全标准简介" class="headerlink" title="安全标准简介"></a>安全标准简介</h3><p>（1）TCSEC标准：安全策略，责任，保证，文档</p>
<p>D级 最小保护，C1 自主安全保护，C2 受控的存取保护（自主存取控制）</p>
<p>B1 标记安全保护（强制存取控制）， B2 结构化保护， B3 安全域， A1 验证设计</p>
<p>（2）CC标准</p>
<h2 id="数据安全性控制"><a href="#数据安全性控制" class="headerlink" title="数据安全性控制"></a>数据安全性控制</h2><p>数据库安全控制的常用方法：<strong>用户标识和鉴定、存取控制、视图、审计、数据加密</strong></p>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><p>静态口令鉴别：密码</p>
<p>动态口令鉴别：验证码，一次一密</p>
<p>生物特征鉴别：指纹，眼角膜，FaceID</p>
<p>智能卡鉴别</p>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>自主存取控制 C2</p>
<p>强制存取控制 B1</p>
<h3 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h3><p>通过SQL的GRANT语句和REVOKE语句实现</p>
<p>用户权限组成：数据对象和操作类型</p>
<p>定义存取权限称为<strong>授权</strong></p>
<p>关系数据库系统中存取控制对象：</p>
<p>（1）数据库模式</p>
<p>模式（CREATE SCHEMA）基本表（CREATE TABLE ，ALTER TABLE） 视图（CREATE VIEW） 索引（CREATE INDEX）</p>
<p>（2）数据</p>
<p>基本表和视图（SELECT INSERT UPDATE DELETE REFERENCES ALL PRIVILEGES）</p>
<p>属性列（SELECT INSERT UPDATE REFERENCES ALL PRIVILEGES）</p>
<h3 id="授权：授予与回收"><a href="#授权：授予与回收" class="headerlink" title="授权：授予与回收"></a>授权：授予与回收</h3><p>GRANT：将对指定操作对象的指定操作权限授予指定的用户</p>
<p>不允许循环授权</p>
<p>REVOKE：收回权限</p>
<h3 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h3><p>数据库角色：被命名的一组与数据库操作相关的权限</p>
<h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p>
<p>主体是系统中的活动实体，客体是系统中的被动实体，受主体操纵</p>
<p>敏感度标记：<strong>绝密（TS）&gt;&#x3D; 机密（S）&gt;&#x3D; 可信（C）&gt;&#x3D; 公开（P）</strong></p>
<p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p>
<p>强制存取控制规则</p>
<p>（1）主体的许可证级别大于或等于客体的密级时，该主体才能<strong>读</strong>取相应的客体</p>
<p>（2）主体的许可证级别小于或等于客体的密级时，该主体才能<strong>写</strong>相应的客体</p>
<p>实现强制存取控制首先要实现自主存取控制</p>
<h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护，间接地实现支持存取谓词的用户权限定义</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>审计：启用一个专用的审计日志，将用户对数据库的所有操作记录在上面，审计员利用审计日志，监控数据库中的各种行为，找到非法存取数据的人、时间和内容</p>
<p>用户级审计、系统级审计</p>
<h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>数据加密是防止数据库中数据在<strong>存储和传输</strong>中失密的有效手段</p>
<p>加密方法：存储加密和传输加密</p>
<h2 id="其他安全性"><a href="#其他安全性" class="headerlink" title="其他安全性"></a>其他安全性</h2><p>推理控制、隐蔽信道、数据隐私保护</p>
<h1 id="第五章-数据完整性"><a href="#第五章-数据完整性" class="headerlink" title="第五章 数据完整性"></a>第五章 数据完整性</h1><p><strong>数据库的完整性：保护数据的正确性、有效性和相容性</strong></p>
<p>为维护数据库的完整性。数据库管理系统必须：（1）提供定义完整性约束条件的机制 （2）提供完整性检查的方法 （3）违约处理</p>
<h2 id="实体完整性-1"><a href="#实体完整性-1" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>实体完整性定义：关系模型的实体完整性，单属性构成的码：列级约束条件，表级约束条件，多个属性构成的码：表级约束条件</p>
<p>全表扫描，建立<strong>索引</strong>加快速度 B+树索引</p>
<h2 id="参照完整性-1"><a href="#参照完整性-1" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>FOREIGN KEY短语定义外码，REFERENCES短语指明这些外码参照表的哪些主码</p>
<p>违约处理：拒绝执行、级联操作、设置为空值</p>
<h2 id="用户定义的完整性-1"><a href="#用户定义的完整性-1" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><p>用户定义完整性：针对某一具体应用的数据必须满足的语义要求</p>
<p>（1）属性上的约束条件：列值非空，列值唯一，检查列值是否满足一个条件表达式</p>
<p>（2）元组上的约束条件：CHECK短语定义元组上的约束条件，即元组级的限制</p>
<h2 id="完整性约束命名字句"><a href="#完整性约束命名字句" class="headerlink" title="完整性约束命名字句"></a>完整性约束命名字句</h2><p>CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</p>
<p>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>通过声明性断言来指定更具一般性的约束</p>
<p>CREATE ASSERTION &lt;断言名&gt; &lt;CHECK子句&gt;</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>CREATE TRIGGER</p>
<p>触发器又叫做<strong>事件-条件-动作</strong>规则</p>
<p>触发器由触发事件激活</p>
<p>执行顺序：（1）执行该表上的BEFORE触发器 （2）激活触发器的SQL语句 （3）执行该表上的AFTER触发器</p>
<p>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;</p>
<h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><p>关系数据库逻辑设计—关系数据库的规范化理论</p>
<p><strong>第一范式（1NF）：每个分量必须是不可分开的数据项</strong>，无重复的列</p>
<p>数据依赖是一个关系内部属性与属性之间的一种约束关系，可分为<strong>函数依赖</strong>和<strong>多值依赖</strong></p>
<p><strong>数据冗余、更新异常、插入异常、删除异常</strong></p>
<p>原因：由存在于模式中的某些数据依赖引起</p>
<p>解决方法：用规范化理论改造关系模式来消除不合适的数据依赖（分解）</p>
<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>X函数确定Y，Y函数依赖于X，记作X—&gt;Y</strong></p>
<p>函数依赖是指关系模式R的所有关系实例均要满足的约束条件，是语义范畴的概念</p>
<p>X—&gt;Y，但 Y 不属于 X，则称X—&gt;Y是<strong>非平凡的函数依赖</strong></p>
<p>X—&gt;Y，但 Y 属于 X（Y是X的子集），则称X—&gt;Y是<strong>平凡的函数依赖</strong>，平凡函数依赖必成立</p>
<p>若X—&gt;Y，则X称为这个函数依赖的<strong>决定因素</strong></p>
<ol>
<li>**完全函数依赖 **</li>
<li><strong>部分函数依赖</strong></li>
<li><strong>传递函数依赖</strong></li>
</ol>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><ol>
<li>候选码 </li>
<li>主码 </li>
<li>主属性 </li>
<li>非主属性 </li>
<li>全码 </li>
<li>外码</li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一级别的关系模式的集合</p>
<p><strong>1NF 包含 2NF 包含 3NF 包含 BCNF 包含 4NF 包含 5NF</strong></p>
<p>一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong></p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具，规范化实质上是概念的单一化</p>
<p>一个关系模式不属于2NF，会产生插入异常、删除异常、修改复杂的问题</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第二范式（2NF）</strong></td>
<td><strong>关系模式R属于1NF，并且每一个非主属性都完全函数依赖于任何一个候选码（即不存在非主属性部分函数依赖于候选码），则R属于2NF</strong></td>
</tr>
<tr>
<td><strong>第三范式（3NF）</strong></td>
<td><strong>关系模式R&lt;U,F&gt;属于1NF，若R中不存在非主属性Z对码X的传递函数依赖，则称R&lt;U,F&gt;属于3NF</strong></td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td><strong>在关系模式R&lt;U,F&gt;中，如果每一个决定属性集都包含候选码，则R属于BCNF</strong></td>
</tr>
</tbody></table>
<p>关系模式的规范化：一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式集合</p>
<h4 id="关系数据库的规范化是数据库逻辑设计的工具"><a href="#关系数据库的规范化是数据库逻辑设计的工具" class="headerlink" title="关系数据库的规范化是数据库逻辑设计的工具"></a>关系数据库的规范化是数据库逻辑设计的工具</h4><p>1NF—&gt;2NF：消除非主属性对码的部分函数依赖</p>
<p>2NF—&gt;3NF：消除非主属性对码的传递函数依赖</p>
<p>3NF—&gt;BCNF：消除主属性对码的部分和传递函数依赖</p>
<p>BCNF—&gt;4NF：消除非平凡且非函数依赖的多值依赖</p>
<p>1NF—&gt;BCNF：消除决定因素非码的非平凡函数依赖</p>
<p>不能说规范化程度越高的关系模式就越好</p>
<h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><p>需求分析和概念设计独立于任何数据库管理系统，逻辑设计和物理设计与选用的数据库管理系统密切相关</p>
<p>需求分析阶段：综合各个用户的应用需求</p>
<p>概念设计阶段：<strong>概念模式</strong>（信息时间模型），用E-R图来描述</p>
<p>逻辑设计阶段：<strong>逻辑模式、外模式</strong></p>
<p>物理设计阶段：<strong>内模式</strong></p>
<p>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模式，形成数据库<strong>逻辑模式</strong></p>
<p>根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的<strong>外模式</strong></p>
<p>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库<strong>内模式</strong></p>
<h3 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h3><p><strong>需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护</strong></p>
<p>需求分析和概念结构设计独立于任何数据库管理系统</p>
<p>逻辑设计和物理设计与选用的数据库管理系统密切相关</p>
<h3 id="数据库设计过程中的各级模式"><a href="#数据库设计过程中的各级模式" class="headerlink" title="数据库设计过程中的各级模式"></a>数据库设计过程中的各级模式</h3><p>需求分析：综合各个用户的应用需求</p>
<p>概念设计阶段：E-R图</p>
<p>逻辑设计阶段：逻辑模式 外模式</p>
<p>物理设计阶段：内模式</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求分析就是分析用户的需求</p>
<p>分析方法：结构化分析方法</p>
<p>数据字典是关于数据库中的数据描述，即元数据</p>
<p>数据字典的内容：数据项、数据结构、数据流、数据存储、处理过程</p>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><h3 id="7-3-1-概念模型"><a href="#7-3-1-概念模型" class="headerlink" title="7.3.1 概念模型"></a>7.3.1 概念模型</h3><p>描述概念模型的工具 E-R模型</p>
<h3 id="7-3-2-E-R模型"><a href="#7-3-2-E-R模型" class="headerlink" title="7.3.2 E-R模型"></a>7.3.2 E-R模型</h3><p>实体之间的联系：一对一（1:1）、一对多（1:n）、多对多（m:n）</p>
<p>联系的度：参与联系的实体型的数目</p>
<p>E-R图提供了表示实体型、属性和联系的方法</p>
<h3 id="7-3-3-概念结构设计"><a href="#7-3-3-概念结构设计" class="headerlink" title="7.3.3 概念结构设计"></a>7.3.3 概念结构设计</h3><p>两条准则：（1）属性必须是不可分的数据项，不能包含其他属性 （2）属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系</p>
<p>E-R图的集成一般需要两步</p>
<p>（1）合并</p>
<p>子系统E-R图之间的冲突主要有三类：属性冲突、命名冲突、结构冲突</p>
<p>（2）修改和重构</p>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><h3 id="7-4-1-E-R图向关系模型的转换"><a href="#7-4-1-E-R图向关系模型的转换" class="headerlink" title="7.4.1 E-R图向关系模型的转换"></a>7.4.1 E-R图向关系模型的转换</h3><p>（1）1:1联系转换为一个独立的关系模式</p>
<p>（2）1:1联系与任意一端合并</p>
<p>（3）1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</p>
<p>（4）一个m:n联系转换为一个关系模式，取m，n端的码作为独立关系的组合码，再加自有属性</p>
<p>（5）三个或三个以上实体间的一个<strong>多元联系</strong>转换为一个关系模式</p>
<p>（6）具有相同码的关系模式可合并</p>
<h3 id="7-4-2-数据模型的优化"><a href="#7-4-2-数据模型的优化" class="headerlink" title="7.4.2 数据模型的优化"></a>7.4.2 数据模型的优化</h3><p>无通用规则，数据库逻辑设计的结果不是唯一的</p>
<h3 id="7-4-3-设计用户子模式"><a href="#7-4-3-设计用户子模式" class="headerlink" title="7.4.3 设计用户子模式"></a>7.4.3 设计用户子模式</h3><p>（1）使用更符合用户习惯的别名 （2）针对不同级别的用户定义不同的视图，以保证系统的安全性 （3）简化用户对系统的使用</p>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><p>数据库在物理设备上的<strong>存储结构与存取方法</strong>称为数据库的物理结构，它依赖于选定的数据库管理系统</p>
<p>数据库管理系统常用存取方法：B+树索引存取方法、Hash索引存取方法、聚簇存取方法</p>
<p>确定数据库物理结构主要确定数据的<strong>存放位置</strong>和<strong>存储结构</strong></p>
<p>确定数据的存放位置和存储结构要综合考虑<strong>存取时间、存储空间利用率和维护代价</strong></p>
<h1 id="单元测试笔记"><a href="#单元测试笔记" class="headerlink" title="单元测试笔记"></a>单元测试笔记</h1><h2 id="单元测试2"><a href="#单元测试2" class="headerlink" title="单元测试2"></a>单元测试2</h2><p>关系代数中的连接操作是由<strong>选择和笛卡尔积</strong>操作组合而成</p>
<p>关系数据模型的基本数据结构是<strong>关系</strong></p>
<p>关系R中能唯一标识一个元组的是它的 <strong>主码、全码、候选码</strong></p>
<p>关系是动态的、随时间变化的，关系模式是静态的、稳定的</p>
<h2 id="单元测试4"><a href="#单元测试4" class="headerlink" title="单元测试4"></a>单元测试4</h2><p>安全性控制的防范对象是<strong>非法用户</strong>，防止他们对数据库数据的存取</p>
<p>数据库安全审计系统提供了一种<strong>事后检查</strong>的安全机制。</p>
<p>在数据库的安全性控制中，授权对象的约束粒度越小，授权子系统就越灵活</p>
<h2 id="单元测试5"><a href="#单元测试5" class="headerlink" title="单元测试5"></a>单元测试5</h2><p>实体完整性规则检查的内容包括：检查主码值是否唯一,如果不唯一就拒绝插入或修改，检查主码的各个属性值是否为空,只要有一个为空就拒绝插入或修改</p>
<p>触发器只能定义在基本表上</p>
<h2 id="单元测试6"><a href="#单元测试6" class="headerlink" title="单元测试6"></a>单元测试6</h2><p>算法：按以下步骤求候选键：<br>1.只在FD右部出现的属性，不属于候选码;<br>2.只在FD左部出现的属性，一定存在于某候选码当中;<br>3.外部属性一定存在于任何候选码当中;<br>4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码</p>
<p>关系模式R的整个属性组是码,则R满足的最高范式至少是<strong>3NF</strong></p>
<p>关系规范化中的删除异常是指<strong>不该删除的数据被删除</strong></p>
<p>关系数据库的规范化理论主要解决的问题是<strong>如何构造合适的数据逻辑结构</strong></p>
<p>在关系数据库设计中,设计关系模式是数据库设计中<strong>逻辑结构设计阶段</strong>的任务</p>
<h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><p>子模式（外模式）DDL用来描述数据库的局部逻辑结构</p>
<p>SQL中的视图提高了数据库系统的安全性</p>
<p>候选码：若关系中的某一属性组的值能够唯一确定一个元组，则该属性组为候选码</p>
<p>主码：若一个关系有多个候选码，选定一个作为主码</p>
<p>外码：设关系R的一个属性组F，F不是关系R的主码，若F与关系S的主码相对应，则称F是关系R的外码</p>
<p>一个关系的候选码可以有多个，但主码只有一个</p>
<p>每一个实体对应一个关系模式</p>
<p>每个m：n联系对应一个关系模式</p>
<p>概念结构设计的方法有四种：自顶向下、自底向上、逐步扩张、混合策略</p>
<p>设计步骤：（1）进行数据抽象，设计局部E-R模型，即设计局部示图 （2）集成各局部E-R模型，形成全局E-R模型，即视图的集成</p>
<p>在数据库中，产生数据不一致的根本原因是未对数据进行完整性控制</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络(2)-数据链路层与网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-11 14:32:53" itemprop="dateCreated datePublished" datetime="2022-12-11T14:32:53+08:00">2022-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-16 20:22:16" itemprop="dateModified" datetime="2023-01-16T20:22:16+08:00">2023-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>结点</strong>：主机、路由器</p>
<p><strong>链路</strong>：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p>
<p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p>
<p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p>
<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。（简单来说就是将网络层的数据报进行再次封装搬运给物理层</p>
<p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。<strong>其主要作用是加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：<strong>标头（Head）和数据（Data）</strong>。<br>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。<br><strong>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。</strong>因此，整个<strong>”帧”最短为64字节，最长为1518字节</strong>。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做<strong>MAC地址</strong>。长度为6字节，共48比特，通常用十六进制表示法，地址的每个字节被表示为一对十六进制数</p>
<p>每个适配器具有一个<strong>唯一的MAC地址</strong>，不随位置发生变化（就像人的身份证，而IP则像人的邮政地址）</p>
<h3 id="广播的概念"><a href="#广播的概念" class="headerlink" title="广播的概念"></a>广播的概念</h3><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121916196.png"/>

<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>
<h2 id="数据链路层的功能概述"><a href="#数据链路层的功能概述" class="headerlink" title="数据链路层的功能概述"></a>数据链路层的功能概述</h2><p>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。有连接一定有确认！</p>
<p>功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）。</p>
<p>功能三：组帧。</p>
<p>功能四：流量控制。限制发送方哦~</p>
<p>功能五：差错控制（帧错&#x2F;位错）。</p>
<p>因为物理层可能会把数据弄丢，所以数据链路层需要进行一些设置来使得物理层可以可靠的传输数据</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121818959.png"/>

<h2 id="ARP协议（地址解析协议）"><a href="#ARP协议（地址解析协议）" class="headerlink" title="ARP协议（地址解析协议）"></a>ARP协议（地址解析协议）</h2><p><strong>ARP协议</strong>：完成主机或路由器IP地址到MAC地址的映射【解决下一跳走哪的问题】（专门用于寻找MAC地址的协议）</p>
<p>每个节点的ARP模块都在它的RAM中有一个ARP表，包含IP地址到MAC地址的映射关系，每个表项还包含TTL字段，表示表项过期时间（ARP表是自动创建的，如果某节点与子网断开连接，它的表项最终会从留在子网中的节点的表中删除。通常一个表项的过期时间是20分钟）</p>
<p>主机向其ARP模块提供一个IP地址，ARP模块返回IP地址对应的MAC地址<br>（注释：在OSI七层模型中，ARP属于链路层模型，所以这里也先简单介绍一下，构建知识体系）</p>
<h3 id="ARP协议使用过程："><a href="#ARP协议使用过程：" class="headerlink" title="ARP协议使用过程："></a>ARP协议使用过程：</h3><p>检查<strong>ARP高速缓存</strong>，有对应表项则写入<strong>MAC帧</strong>，没有则用目的MAC地址为<strong>FF-FF-FF-FF-FF</strong>的帧封装并<span style="color:red"><strong>广播ARP请求分组</strong></span>，<strong>同一局域网</strong>中所有主机都能收到该请求。目的主机收到请求后就会向源主机<span style="color:green"><strong>单播一个ARP响应分组</strong></span>，源主机收到后将此映射<strong>写入ARP缓存</strong>（10-20min更新一次）。</p>
<h3 id="ARP协议4中典型情况："><a href="#ARP协议4中典型情况：" class="headerlink" title="ARP协议4中典型情况："></a>ARP协议4中典型情况：</h3><ol>
<li>主机A发给<strong>本网络</strong>上的主机B：用ARP找到主机B的硬件地址；</li>
<li>主机A发给<strong>另一网络</strong>上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址；</li>
<li>路由器发给<strong>本网络</strong>的主机A：用ARP找到主机A的硬件地址；</li>
<li>路由器发给<strong>另一网络</strong>的主机B：用ARP找到本网络上的一个路由器的硬件地址。</li>
</ol>
<h2 id="封装成帧、帧定界、帧同步"><a href="#封装成帧、帧定界、帧同步" class="headerlink" title="封装成帧、帧定界、帧同步"></a>封装成帧、帧定界、帧同步</h2><p><strong>透明传输</strong>就是为了防止<strong>特殊的数据无法正常传输</strong>的的情况的发生，比如说在封装成帧的过程中，可能出现数据中的某些标记符与开始&#x2F;结束标记符恰巧重复的情况，如果不加以处理，那么会导致无法判定帧的开始于结束。</p>
<p><strong>封装成帧</strong>：就是在一段数据的前后部分添加<strong>首部和尾部</strong>，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据资许加控制信息，他们的一个重要作用：<strong>帧定界</strong>（确定赖的界限）。</p>
<p><strong>帧同步</strong>：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p>
<p><strong>组帧的四种方法</strong>：1.字符计数法，2.字符（节）填充法，3.零比特填充法，4.违规编码法。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121823925.png"/>

<h2 id="透明传输的概念"><a href="#透明传输的概念" class="headerlink" title="透明传输的概念"></a>透明传输的概念</h2><p>透明传输：是<strong>指不管所传数据是什么样的比特组合，都应当能够在链路上传送</strong>。因此，链路层就“看不见”有什么妨碍数据的东西。</p>
<p>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p>
<h2 id="透明传输的实现方法"><a href="#透明传输的实现方法" class="headerlink" title="透明传输的实现方法"></a>透明传输的实现方法</h2><h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><p>就是在帧的首部做计数，这个字符记录了当前帧有多少个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧</span><br><span class="line">比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121853613.png"/>



<h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p>就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，<strong>开始和结束的对应的字符不一样</strong><br>但有可能出现数据内某段比特流数据正好<strong>与标记字段重复</strong>，从而导致误判断的情况</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121855920.png"/>

<p><strong>解决方法：添加转义字符。即对于那些与标记字符重复的数据流，在它们的前面添加一段转义字符，这样接收方在解析帧时，看到这些转义字符就不会认为那些特殊的数据当成帧的开始&#x2F;结束了。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121902833.png"/>

<h3 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121902052.png"/>

<h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><p>因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就<strong>不会与数据冲突</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121903762.png"/>



<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><h3 id="何为差错"><a href="#何为差错" class="headerlink" title="何为差错"></a>何为差错</h3><p>数据链路层的差错检测的是<strong>比特</strong>的错误<br>需要注意的是，即使采用差错检测比特，也还是可能有未检出比特差错的情况。<br>因此，主要是选择一个差错检测方案，使得这种事件发生的概率很小</p>
<p>概括来说，传输中的差错都是由于噪声引起的。</p>
<p><strong>全局性</strong> ：1.由于线路本身电气特性所产生的<strong>随机噪声</strong>（热噪声）,是信道固有的，随机存在的。<br>                    解决办法：提高信噪比来减少或避免干扰。（对传感器下手）</p>
<p><strong>局部性</strong> ：2.外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。<br>                    解决办法：通常利用编码技术来解决。</p>
<p>链路层为网络层提供服务：<strong>无确认无连接服务，有确认无连接服务，有确认面向连接服务。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121906841.png"/>

<h4 id="为什么要在数据链路层进行差错控制？"><a href="#为什么要在数据链路层进行差错控制？" class="headerlink" title="为什么要在数据链路层进行差错控制？"></a>为什么要在数据链路层进行差错控制？</h4><p>因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费</p>
<h3 id="检错编码（奇偶校验码，循环冗余码CRC）"><a href="#检错编码（奇偶校验码，循环冗余码CRC）" class="headerlink" title="检错编码（奇偶校验码，循环冗余码CRC）"></a>检错编码（奇偶校验码，循环冗余码CRC）</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>奇偶校验：只需包含1个附加比特。</p>
<p>对于偶校验，选择一个值，使得所有比特中1出现偶数次。</p>
<p>对于奇校验，选择一个值，使得所有比特中1出现奇数次。接收方通过检测1出现的次数判断是否出现差错。如果出现偶数个比特差错，则检验不出</p>
<p><strong>缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121909365.png"/>



<h4 id="循环冗余编码（CRC）"><a href="#循环冗余编码（CRC）" class="headerlink" title="循环冗余编码（CRC）"></a>循环冗余编码（CRC）</h4><p>发送方和接收方协商一个r+1比特的生成多项式(G)，要起其最高比特位为1。发送方通过在d比特的数据后附加r比特，使得整个(d+r)比特的值能够被G整除。接收方用G去除(d+r)比特，如果余数非0，则出现差错</p>
<p>可能难以理解，这边举个实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：要发送的数据是1101011011,采用CRC校验，生成多项式是10011,那么最终发送的数据应该是？</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121919348.png"/>

<p>进行异或算法：<strong>同0异1</strong></p>
<p>TIPS：多项式N位，阶为N-1。</p>
<p><strong>接收方收到数据后进行检测</strong></p>
<p>把收到的每一个帧都除以同样的除数，然后检查得到的余数R。</p>
<p>1.余数为0,判定这个帧没有差错，接受。</p>
<p>2.余数为不为0,判定这个帧有差错（无法确定到位）,丢弃。FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。</p>
<p>在数据链路层仅仅使用循环穴余检验CRC差错检测技术，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”。“可靠传输”：数据链路层发送端发送什么，接收端就收到什么。链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。</p>
<h3 id="纠错编码（海明码）"><a href="#纠错编码（海明码）" class="headerlink" title="纠错编码（海明码）"></a>纠错编码（海明码）</h3><h4 id="第一步-确认校验码位数r"><a href="#第一步-确认校验码位数r" class="headerlink" title="第一步 确认校验码位数r"></a>第一步 确认校验码位数r</h4><p>海明码不等式：<br>$$<br>2^r \geq k+r+1 (r为冗余信息位，k为信息位)<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若要发送的数据：D=101101</span><br><span class="line">数据的位数k=6</span><br><span class="line">满足不等式的最小r为4,</span><br><span class="line">也就是D=101101的海明码应该有6+4=10位，</span><br><span class="line">其中原数据6位，效验码4位。</span><br></pre></td></tr></table></figure>

<h4 id="第二步-确定校验码和数据的位置"><a href="#第二步-确定校验码和数据的位置" class="headerlink" title="第二步 确定校验码和数据的位置"></a>第二步 确定校验码和数据的位置</h4><p>注释：<br>1.为什么是10为数据位？因为4位校验码+6位信息位&#x3D;10位<br>2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121935057.png"/>

<h4 id="第三步-求出校验码的值"><a href="#第三步-求出校验码的值" class="headerlink" title="第三步 求出校验码的值"></a>第三步 求出校验码的值</h4><p>注释</p>
<ol>
<li><p>先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注</p>
</li>
<li><p>然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位</p>
</li>
</ol>
<p>这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121937540.png"/>

<p>然后计算异或值，比如说这里D1&#x3D;1,D2&#x3D;0,D4&#x3D;1,D5&#x3D;0,就是p1要同时和<strong>0</strong>,<strong>1</strong>，<strong>0</strong>,<strong>1</strong>进行异或之后得到0，为了标识我加粗原始计算数据<br>举例：<strong>0</strong>和<strong>1</strong>异或得1,1和<strong>0</strong>异或得1,1和<strong>1</strong>异或得0，那么p1和0异或得0，p1就是0了</p>
<p>3.其他同理，按顺序计算出P2,P3,P4,然后填入表格</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121940537.png"/>

<h4 id="第四步-检测并纠错"><a href="#第四步-检测并纠错" class="headerlink" title="第四步 检测并纠错"></a>第四步 检测并纠错</h4><p>就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121941617.png"/>

<h2 id="数据链路层的流量控制和可靠传输"><a href="#数据链路层的流量控制和可靠传输" class="headerlink" title="数据链路层的流量控制和可靠传输"></a>数据链路层的流量控制和可靠传输</h2><p>流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费<br>可靠传输是发送端发送什么，接收端就要受到什么</p>
<h3 id="停止等待协议（Stop-and-Wait）"><a href="#停止等待协议（Stop-and-Wait）" class="headerlink" title="停止等待协议（Stop-and-Wait）"></a>停止等待协议（Stop-and-Wait）</h3><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。所以就需要有停止-等待协议</p>
<p>注释：丢包-物理线路故障、设备故障、病毒攻击、路由信息<br>错误等原因，会导致数据包的丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方）,一方接收数据(接收方）。</span><br><span class="line"></span><br><span class="line">因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。</span><br><span class="line"></span><br><span class="line">“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</span><br></pre></td></tr></table></figure>

<h4 id="停止等待协议—无差错情况"><a href="#停止等待协议—无差错情况" class="headerlink" title="停止等待协议—无差错情况"></a>停止等待协议—无差错情况</h4><p>注释：因为一次就一个，所以用0和1标记ack（确认序号）就行</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121944092.png"/>

<h4 id="停止等待协议—有差错情况"><a href="#停止等待协议—有差错情况" class="headerlink" title="停止等待协议—有差错情况"></a>停止等待协议—有差错情况</h4><p>使用一个超时计时器，每发一帧就开始计时，设置时间略长于一个RTT（往返时延）。</p>
<p>发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延：<br>$$<br>RTT &#x3D; 传播时延*2+处理时间（有时可直接忽略）<br>$$<br><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121946606.png"/></p>
<h5 id="ACK丢失"><a href="#ACK丢失" class="headerlink" title="ACK丢失"></a>ACK丢失</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121947459.png"/>

<h5 id="ACK迟到"><a href="#ACK迟到" class="headerlink" title="ACK迟到"></a>ACK迟到</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121948655.png"/>

<p>停止等待协议的特点</p>
<ol>
<li>简单</li>
<li>信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121949044.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121950756.png"/>

<h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3><p>因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率</p>
<p>注释：<br>累计确认：就是收到一个确认帧，那么<strong>它和它之前的所有帧</strong>都默认已收到，反之，如果某个确认帧没收到，那么<strong>它和它之后的所有帧</strong>都默认丢失（即使收到了也丢掉），进行重传</p>
<h4 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h4><ol>
<li><p>上层的调用</p>
<p>上层要发送数据时，发送方先检查发送窗口是否已满，<strong>如果未满</strong>，则产生一个帧并将其发送；<strong>如果窗口已满</strong>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）。</p>
</li>
<li><p>收到一个ACK</p>
<p>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧</p>
</li>
<li><p>超时时间</p>
<p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认赖的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>此图发送2帧时丢失，<strong>所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK</strong>，</p>
<p>直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧，</p>
<p>如果所示，GBN的形式就像排队，接收端为所有帧“预定”了接收位置，如果接收端发送的数据因为某些原因没有接收到，即使收到了这一帧后面所有的帧，<strong>这些“排在后面的”帧也要被丢弃</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212121958226.png"/>

<p>发送窗口不能无限大，与使用的编号的比特数有关，二进制表示。<br>很简单，就是1比特编号0和1,<br>同理2比特编号0-3，二进制表示就是00，01，10，11。<br>如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了<br>GBN的优缺点也显而易见，优点是相对于上面的停止等待协议，明显提高了信道利用率，缺点是因为重传机制的原因，导致已经收到数据却需要强行丢弃，进而造成浪费</p>
<h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h3><p>吸取了GBN协议的教训，我们打算尝试只重传错误的帧，这样的话就不用浪费资源把已经收到的帧再重传一次了。</p>
<p>在GBN中，仅有接收端有一个窗口来存放数据帧，在SR中，两者都有窗口了。</p>
<p>和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（注释：缓存不可能无限大）</p>
<p><strong>注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口；它可以继续接受窗口范围内排在2帧后面的数据帧，直至最后2帧收到后一次性确认窗口内的所有已经收到的帧，再移动窗口。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122003758.png"/>

<p>同样的，因为编号的问题，发送窗口不能无限大<br>当发送窗口最后和接受窗口<strong>大小相同</strong>时，利用率比较高</p>
<h2 id="介质访问控制技术"><a href="#介质访问控制技术" class="headerlink" title="介质访问控制技术"></a>介质访问控制技术</h2><p>虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率</p>
<p>就是让节点之间的通信不会进行相互干扰</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122017412.png"/>

<h3 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</strong></p>
<p>充分利用传输介质带宽，<strong>系统效率较高</strong>；由于技术比较成熟，实现也比较<strong>容易</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122018650.png"/>

<h3 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h3><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。</p>
<p>TDM的缺点就是利用率低，所以又衍生出了STDM</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122025593.png"/>

<h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><p>STDM的原则是先到先走，满了就发，相对于TDM提高了利用率</p>
<p>每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。<strong>STDM帧不是固定分配时隙，而是按需动态分配时隙。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122028591.png"/>

<h3 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h3><p>每个节点分配一种不同的编码，每个节点使用其唯一的编码来对发送的数据进行编码（如果精心选择编码，不同节点能同时传输）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122029336.png"/>

<h2 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h2><p>所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快</p>
<h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>帧到达节点时，立刻传输。如果发生碰撞，节点将立即(在完全传输碰撞帧后)以概率p重传。否则，等待一个帧传输时间，再以概率p重传。信道有效传输速率实际不是R bps，而是时隙ALOHA的一半</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122033941.png"/>

<p>时隙ALOHA协议<br>时间被划分为时隙，每个节点的时间同步，帧的传输只在时隙的开始时进行。如果发生碰撞，在下一个时隙开始时以概率p重传，否则等待一个时隙再以概率p重传…（信道有效传输速率实际不是R bps，而是0.37R bps）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122033818.png"/>

<h3 id="CSMA协议-载波侦听多路访问"><a href="#CSMA协议-载波侦听多路访问" class="headerlink" title="CSMA协议(载波侦听多路访问)"></a>CSMA协议(载波侦听多路访问)</h3><p><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>
<p><code>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</code></p>
<p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212122040654.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>1-坚持CSMA</td>
<td>发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听</td>
<td>立即发送，利用率高</td>
<td>如果多台设备同时监听，那么会发生冲突</td>
</tr>
<tr>
<td>非坚持CSMA</td>
<td>发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听</td>
<td>冲突发生的几率减少</td>
<td>因为需要等待，所以利用率不高</td>
</tr>
<tr>
<td>p-坚持CSMA</td>
<td>发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听</td>
<td>冲突减少的同时效率也比较高</td>
<td>即使发生冲突也要坚持发送数据，资源被浪费</td>
</tr>
</tbody></table>
<h3 id="CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）"><a href="#CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）" class="headerlink" title="CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）"></a>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞。</p>
<p>先侦听信道，如果没有其它节点在使用信道，则传输数据。但是有碰撞检测，如果发生碰撞，会停止传输剩下的数据，等待一个随机时间(通常比传输一帧短)后，再进行尝试。</p>
<p>知道自己发生碰撞的最长时间是2τ（两倍的<strong>传播时延</strong>），就是一去一回</p>
<p><strong>CS</strong>:载波侦听&#x2F;监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据</p>
<p><strong>MA</strong>:多点接入，表示许多计算机以多点接入的方式连接在一根总线上。【总线型网络】</p>
<p><strong>CD</strong>:碰撞检测（冲突检测）,“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。【半双工网络】</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301070108864.png"/>

<p>帧的传输时延至少要两倍于信号在总线中的传播时延</p>
<p>以太网规定最短帧长为64B,凡是长度小于64B的都是由于冲突而异常终止的无效帧<br>$$<br>帧长(bit)&#x2F;数据传输速率 \ge 2τ<br>$$</p>
<p>$$<br>最小帧长&#x3D;总线传播时延<em>数据传输速率</em>2<br>$$</p>
<p>$$<br>2τ*数据传输速率<br>$$</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301070108022.png"/>

<h3 id="CSMA-x2F-CA协议（载波监听多点接入-x2F-碰撞避免）"><a href="#CSMA-x2F-CA协议（载波监听多点接入-x2F-碰撞避免）" class="headerlink" title="CSMA&#x2F;CA协议（载波监听多点接入&#x2F;碰撞避免）"></a>CSMA&#x2F;CA协议（载波监听多点接入&#x2F;碰撞避免）</h3><ul>
<li>发送数据前，先检测信道是否空闲。</li>
<li>空闲则发出RTS(request to send),RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</li>
<li>接收端收到RTS后，将响应CTS(clear to send)。</li>
<li>发送端收到CTS后，开始发送数据帧（同时预约信道：发送方告知其他站点自己要传多久数据）。</li>
<li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧。</li>
<li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）。</li>
</ul>
<ol>
<li>预约信道</li>
<li>.ACK帧</li>
<li>RTS&#x2F;CTS帧（可选）</li>
</ol>
<h4 id="CSMA-x2F-CD-与-CSMA-x2F-CA的区别"><a href="#CSMA-x2F-CD-与-CSMA-x2F-CA的区别" class="headerlink" title="CSMA&#x2F;CD 与 CSMA&#x2F;CA的区别"></a>CSMA&#x2F;CD 与 CSMA&#x2F;CA的区别</h4><p>相同点：</p>
<p>CSMA&#x2F;CD与CSMA&#x2F;CA机制都从属于CSMA的思路，其核心是先听再说。换言之，两个在接入信道之前都须要 进行监听。当发现信道空闲后，才能进行接入。</p>
<p>不同点：</p>
<ol>
<li><p>传输介质不同：CSMA&#x2F;CD用于总线式以太网【有线】，而CSMA&#x2F;CA用于无线局域网【无线】。</p>
</li>
<li><p>载波检测方式不同：因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测（ED)、载波检测（CS)和能量载波混合检测三种检测信道空闲的方式。</p>
</li>
<li><p>CSMA&#x2F;CD检测冲突，CSMA&#x2F;CA避免冲突，二者出现冲突后都会进行有上限的重传。</p>
</li>
</ol>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><p>主要包括两大类，一个是<strong>轮询协议</strong>，另一个是<strong>令牌传递协议</strong></p>
<h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p>即选出一个代表，由他控制所有的传输，但会存在以下问题</p>
<ul>
<li>轮询开销：在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销</li>
<li>等待延迟：就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应</li>
<li>单点故障：很好理解，就是代表挂了</li>
</ul>
<h3 id="令牌传输协议"><a href="#令牌传输协议" class="headerlink" title="令牌传输协议"></a>令牌传输协议</h3><p>在节点之间没有收发数据的需求时，令牌在节点之间循环。</p>
<p>发送数据的流程</p>
<ol>
<li>当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&gt;占用）</li>
<li>再将令牌与数据帧结合，让其在节点构成的环之间流动</li>
<li>不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌</li>
<li>最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍<br>问题基本和轮询协议相同</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301070107881.png"/>

<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的概念"><a href="#局域网的概念" class="headerlink" title="局域网的概念"></a>局域网的概念</h3><p>局域网（Local Area Network):简称LAN,是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<ol>
<li><p>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p>
</li>
<li><p>特点2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb&#x2F;s~10Gb&#x2F;s)。</p>
</li>
<li><p>特点3：通信延迟时间短，误码率低，可靠性较高。</p>
</li>
<li><p>特点4：各站为平等关系，共享传输信道。</p>
</li>
<li><p>特点5：多采用分布式控制和广播式通信，能进行广播和组播。</p>
</li>
</ol>
<p>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</p>
<h3 id="局域网额网络拓扑结构"><a href="#局域网额网络拓扑结构" class="headerlink" title="局域网额网络拓扑结构"></a>局域网额网络拓扑结构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071403070.png"/>

<h3 id="局域网的传播介质"><a href="#局域网的传播介质" class="headerlink" title="局域网的传播介质"></a>局域网的传播介质</h3><table>
<thead>
<tr>
<th>局域网</th>
<th>常用介质</th>
</tr>
</thead>
<tbody><tr>
<td>有线局域网</td>
<td>双绞线，同轴电缆，光纤</td>
</tr>
<tr>
<td>无线局域网</td>
<td>电磁波</td>
</tr>
</tbody></table>
<h3 id="局域网介质访问方法"><a href="#局域网介质访问方法" class="headerlink" title="局域网介质访问方法"></a>局域网介质访问方法</h3><ol>
<li>CSMA&#x2F;CD常用于<strong>总线型局域网</strong>，也用于树型网络</li>
<li>令牌总线常用于<strong>总线型局域网</strong>，也用于树型网络它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</li>
<li>令牌环用于<strong>环形局域网</strong>，如令牌环网</li>
</ol>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><ol>
<li>以太网 以太网是应用最为广泛的局域网，包括标准以太网（10Mbps)、快速以太网（100Mbps)、千兆以太网（1000Mbps)和10G以太网，它们都符合IEEE802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA&#x2F;CD.</li>
<li>令牌环网物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。已是“明日黄花”。</li>
<li>FDDI网（Fiber Distributed Data Interface)物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。</li>
<li>ATM网（Asynchronous Transfer Mode)较新型的单元交换技术，使用53字节固定长度的单元进行交换。</li>
<li>无线局域网（Wireless Local Area Network;WLAN)采用IEEE802.11标准。</li>
</ol>
<h3 id="IEEE802标准"><a href="#IEEE802标准" class="headerlink" title="IEEE802标准"></a>IEEE802标准</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071409987.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071408948.png"/>

<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网（Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的<strong>基带总线局域网规范</strong>，是当今现有局域网采用的最通用的通信协议标准。以太网络使用<strong>CSMA&#x2F;CD(载波监听多路访问及冲突检测）</strong>技术。</p>
<p>以太网在局域网各种技术中占统治性地位：</p>
<ol>
<li>造价低廉（以太网网卡不到100块）;</li>
<li>是应用最广泛的局域网技术；</li>
<li>比令牌环网、ATM网便宜，简单；</li>
<li><strong>满足网络速率要求：10Mb&#x2F;s~10Gb&#x2F;s</strong></li>
</ol>
<h3 id="以太网两个标准："><a href="#以太网两个标准：" class="headerlink" title="以太网两个标准："></a>以太网两个标准：</h3><p>DIX EthernetV2:第一个局域网产品（以太网）规约。</p>
<p>IEEE802.3:IEEE802委员会802.3工作组制定的第一个IEEE的以太网标准。（帧格式有一丢丢改动）</p>
<h3 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h3><p>无连接：发送方和接收方之间无“握手过程”。</p>
<p>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</p>
<p>以太网只实现无差错接收，不实现可靠传输。</p>
<h3 id="以太网的发展"><a href="#以太网的发展" class="headerlink" title="以太网的发展"></a>以太网的发展</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071411204.png"/>

<h3 id="以太网适配器和MAC地址"><a href="#以太网适配器和MAC地址" class="headerlink" title="以太网适配器和MAC地址"></a>以太网适配器和MAC地址</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071412168.png"/>



<h3 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h3><p>注释：</p>
<ol>
<li>这里的mac层指的是数据链路层</li>
<li>之前说过数据链路层将上一层ip数据包加头加尾<br>头就是目标地址（6字节），源地址（6字节），类型（2字节）<br>尾就是FCS（帧检验序列），（4字节）</li>
<li>前导码<strong>不是MAC帧的一部分</strong>，目的是使时钟同步</li>
<li>为什么数据长度时46~1500？<br>因为有最小传输字节64字节，mac占用6+6+2+4&#x3D;18，所以数据最小为64-18&#x3D;46，1500则是规定的默认最大字节，没有理由</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071413876.png"/>

<h3 id="其他以太网"><a href="#其他以太网" class="headerlink" title="其他以太网"></a>其他以太网</h3><h4 id="10BASE-T以太网："><a href="#10BASE-T以太网：" class="headerlink" title="10BASE-T以太网："></a>10BASE-T以太网：</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071414584.png"/>

<h4 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071415991.png"/>



<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071415479.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071415763.png"/>

<h3 id="两种无线局域网"><a href="#两种无线局域网" class="headerlink" title="两种无线局域网"></a>两种无线局域网</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071416831.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071417439.png"/>

<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>广域网（WAN,WideAreaNetwork),通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。<br>广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网（Interne是世界范围内最大的广域网。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301071418972.png"/>

<h2 id="PPP协议（Point-to-Point-Protocol）"><a href="#PPP协议（Point-to-Point-Protocol）" class="headerlink" title="PPP协议（Point-to-Point Protocol）"></a>PPP协议（Point-to-Point Protocol）</h2><p>PPP协议是目前<strong>使用最广泛</strong>的数据链路层协议，拨号基本都是PPP协议<br>PPP协议<strong>仅支持全双工</strong>链路</p>
<h3 id="PPP协议需要满足的要求"><a href="#PPP协议需要满足的要求" class="headerlink" title="PPP协议需要满足的要求"></a>PPP协议需要满足的要求</h3><ul>
<li><strong>简单</strong>：对于链路层的帧，无需纠错，无需序号，无需流量控制。</li>
<li><strong>封装成帧</strong>：帧定界符</li>
<li><strong>透明传输</strong>：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充。</li>
<li><strong>多种网络层协议</strong>：封装的IP数据报可以采用多种协议。</li>
<li><strong>多种类型链路</strong>：串行&#x2F;并行，同步&#x2F;异步，电&#x2F;光….</li>
<li><strong>差错检测</strong>：错就丢弃。</li>
<li><strong>检测连接状态</strong>：链路是否正常工作。</li>
<li><strong>最大传送单元</strong>：数据部分最大长度MTU。</li>
<li><strong>网络层地址协商</strong>：知道通信双方的网络层地址。</li>
<li><strong>数据压缩协商</strong>：</li>
</ul>
<h3 id="PPP协议不需要满足的要求"><a href="#PPP协议不需要满足的要求" class="headerlink" title="PPP协议不需要满足的要求"></a>PPP协议不需要满足的要求</h3><ul>
<li><strong>纠错</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>序号</strong></li>
<li><strong>不支持多点线路</strong></li>
</ul>
<h3 id="PPP协议组成成分以及功能"><a href="#PPP协议组成成分以及功能" class="headerlink" title="PPP协议组成成分以及功能"></a>PPP协议组成成分以及功能</h3><ol>
<li>一个将IP数据报封装到串行链路（同步串行&#x2F;异步串行）的方法。</li>
<li>链路控制协议LCP:建立并维护数据链路连接。<strong>身份验证</strong></li>
<li>网络控制协议NCP:PPP支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>
</ol>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081709387.png"/>

<h2 id="HDLC协议（High-Level-Data-Link-Control）"><a href="#HDLC协议（High-Level-Data-Link-Control）" class="headerlink" title="HDLC协议（High-Level Data Link Control）"></a>HDLC协议（High-Level Data Link Control）</h2><p>高级数据链路控制（High-Level Data Link Control或简称HDLC),是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织（ISO)根据IBM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的.数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p>
<p><strong>采用全双工通信</strong></p>
<p>所有帧采用<strong>CRC检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高。</p>
<h3 id="HDLC的三种站"><a href="#HDLC的三种站" class="headerlink" title="HDLC的三种站"></a>HDLC的三种站</h3><ol>
<li>主站的主要功能是发送命令（包括数据信息）帧、接收响应帧，并负责对整个链路的控制系统的初启流程的控制、差错检测或恢复等。</li>
<li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li>
<li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li>
</ol>
<h4 id="三种数据操作方式："><a href="#三种数据操作方式：" class="headerlink" title="三种数据操作方式："></a>三种数据操作方式：</h4><ol>
<li>正常响应方式</li>
<li>异步平衡方式</li>
<li>异步响应方式</li>
</ol>
<h3 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081713486.png"/>

<h2 id="PPP协议和HDLC协议对比"><a href="#PPP协议和HDLC协议对比" class="headerlink" title="PPP协议和HDLC协议对比"></a>PPP协议和HDLC<strong>协议对比</strong></h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081713039.png"/>

<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>使用网桥时，由于网桥会根据mac地址进行过滤，所以<strong>不会形成冲突域</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081714389.png"/>

<h4 id="两种网桥"><a href="#两种网桥" class="headerlink" title="两种网桥"></a>两种网桥</h4><h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><p>通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时<strong>数据对应的地址</strong>和<strong>网桥自己的接口</strong>，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了</p>
<h5 id="原路由网桥"><a href="#原路由网桥" class="headerlink" title="原路由网桥"></a>原路由网桥</h5><p>在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>网桥接口越来越多，网桥就变成了交换机<br>交换机的任务是接收入链路层帧并将它们转发到出链路<br>交换机自身对节点透明：某节点向另一节点寻址一个帧，顺利地将该帧发送进LAN，而不知道这个帧经过了某个交换机的接收与转发</p>
<p>1）交换机转发与过滤<br>过滤：交换机决定一个帧是应该转发还是应该丢弃<br>转发：决定一个帧应该被导向哪个接口</p>
<p>2）自学习(即插即用)<br>交换机表是自动、动态、自治地建立的，没有来自网络管理员或配置协议的任何干预。换句话说，交换机是自学习的<br>交换机表初始为空<br>源地址为DD-DD-DD-DD-DD-DD的帧从接口x到达时，如果不存在则新建一项；存在则更新当前时间<br>如果一段时间后，在x接口没有来自DD-DD-DD-DD-DD-DD的帧，则将该表项删除</p>
<h4 id="直通式交换机"><a href="#直通式交换机" class="headerlink" title="直通式交换机"></a>直通式交换机</h4><p>查完目的地址（6B)就立刻转发。<br>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</p>
<h4 id="存储转发式交换机"><a href="#存储转发式交换机" class="headerlink" title="存储转发式交换机"></a>存储转发式交换机</h4><p>将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<br>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</p>
<h3 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081716097.png"/>

<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><table>
<thead>
<tr>
<th>OSI参考模型</th>
<th>各层次的传输单元</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>报文</td>
</tr>
<tr>
<td>传输层</td>
<td>报文段</td>
</tr>
<tr>
<td>网络层</td>
<td>IP数据报，分组（如果IP数据报太大就切割成分组）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧</td>
</tr>
<tr>
<td>物理层</td>
<td>比特流</td>
</tr>
</tbody></table>
<p>网络层的主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层的传输单位是*<strong>数据报</strong></p>
<h2 id="路由选择与分组转发"><a href="#路由选择与分组转发" class="headerlink" title="路由选择与分组转发"></a>路由选择与分组转发</h2><p>路由器主要完成两个功能:是<code>路由选择 (确定哪一 条路径)</code>，二是<code>分组转发 (当一个分组 到达时所采取的动作)</code>。</p>
<ul>
<li>1)<strong>路由选择</strong>。指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑<br>的变化情况，动态地改变所选择的路由。</li>
<li>2)分组转发。指路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li>
</ul>
<p><code>路由表</code>是根据<code>路由选择算法</code>得出的，而<code>转发表</code>是从<code>路由表</code>得出的。<br><code>路由表</code>则需要对<code>网络拓扑变化的计算最优化</code>,<code>转发表</code>的结构应当使<code>查找过程最优化</code>。<br>在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</p>
<h2 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h2><p>所谓<code>异构网络互联</code>，是指将两个以上的不同的计算机网络，通过一定的方法， 用一种或多种通信处理设备(即中间设备)相互连接起来，以构成更大的网络系统。中间设备又称<code>中间系统</code>或<code>中继系统</code>。<br>根据所在的层次，<code>中继系统</code>分为以下4种:</p>
<ul>
<li>1)物理层中继系统:中继器，集线器(Hub)。</li>
<li>2)数据链路层中继系统:网桥或交换机。</li>
<li>3)网络层中继系统:路由器。</li>
<li>4)网络层以上的中继系统:网关。</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><code>网络互联</code>通常是指用<code>路由器</code>进行网络互联和路由选择。<br><code>路由器</code>是一一台专用计算机，用于在互联网中进行&#96;路由选择。</p>
<ul>
<li>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为<code>拥塞</code>。</li>
<li><code>判断网络是否进入拥塞状态的方法</code>是，观察网络的<code>吞吐量与网络负载的关系</code>:如果随着<code>网络负载的增加</code>，<code>网络的吞吐量明显小于正常的吞吐量</code>，那么网络就可能已进入“<code>轻度拥塞”</code>状态;如果<code>网络的负载继续增大</code>，而网络的<code>吞吐量下降到零</code>，那么网络就可能已进入<code>死锁状态</code>。</li>
<li><code>拥塞控制的作用是确保子网能够承载所达到的流量</code>，这是一一个全局性的过程，涉及各方面的行为:主机、路由器及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞。</li>
<li><code>流量控制</code>和<code>拥塞控制</code>的<code>区别</code>:</li>
<li>·<code>流量控制</code>往往是指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li><code>拥塞控制</code>必须确保通信子网能够传送待传送的数据，是一一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。</li>
<li><code>拥塞控制的方法有两种</code>:<br>1)·<code>开环控制</code>。在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。这是一种<code>静态</code>的预防方法。一旦整个系统启动并运行，中途就不再需要修改。开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度决策等。所有这些手段的共性是，在做决定时不考虑当前网络的状态。<br>2)<code>闭环控制</code>。事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。闭环控制是基于反馈环路的概念，是一种<code>动态</code>的方法。</li>
</ul>
<h2 id="传输单元名词解析"><a href="#传输单元名词解析" class="headerlink" title="传输单元名词解析"></a>传输单元名词解析</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301081723792.png"/>

<ul>
<li>这里探讨的电路交换、报文交换、分组交换，我们可以把这三种交换方式的交换数据单位看成一个整体去理解，不要过分去细究以上几种传输单元名词与这三种交换方式的关系。</li>
</ul>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>就类似于打电话，两端建立起有效通路</p>
<ul>
<li>在进行数据传输前，两个结点之间必须先建立一条专用 (双方独占)的物理通信路径(由通信双方之间的交换设备和链路逐段连接而成)，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束后才被释放。</li>
<li>因此，电路交换技术分为三个阶段:<code>连接建立、数据传输和连接释放</code>。</li>
<li>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输的过程中，<code>用户始终占用端到端的固定传输带宽</code>。</li>
</ul>
<p>电路交换技术的<strong>优点如下</strong><br>1)<code>通信时延小</code>。由于通信线路为通信双方用户专用，数据直达，因此传输数据的时延非常小。当传输的数据量较大时，这-优点非常 明显。<br>2)<code>有序传输</code>。双方通信时按发送顺序传送数据，不存在失序问题。<br>3)<code>没有冲突</code>。不同的通信双方拥有不同的信道，不会出现争用物理信道的问题。<br>4)<code>适用范围广</code>。电路交换既适用于传输模拟信号，又适用于传输数字信号。<br>5)<code>实时性强</code>。通信双方之间的物理通路一旦建立， 双方就可以随时通信。<br>6)<code>控制简单</code>。电路交换的交换设备(交换机等)及控制均较简单。</p>
<p>电路交换技术的<strong>缺点如下</strong><br>1)<code>建立连接时间长</code>。电路交换的平均连接建立时间对计算机通信来说太长。<br>2)<code>线路独占，使用效率低</code>。电路交换连接建立后，物理通路被通信双方独占，即使通信线<br>路空闲，也不能供其他用户使用，因而信道利用率低。<br>3)<code>灵活性差</code>。只要在通信双方建立的通路中的任何一点出了故障，就必须重新拨号建立新<br>的连接，这对十分紧急和重要的通信是很不利的。<br>4)<code>难以规格化</code>。电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互<br>进行通信，也难以在通信过程中进行<code>差错控制</code>。</p>
<p>注意，电路建立后，除源结点和目的结点外，电路上的任何结点都采取<code>“直通方式”</code>接收数<br>据和发送数据，即不会存在存储转发所耗费的时间。</p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101259668.png"/>

<ul>
<li>数据交换的单位是报文，报文携带有源地址，目标地址，数据等信息。</li>
<li><code>报文交换的主要特点是</code>：存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。 中文名报文交换，外文名Message switching。</li>
<li>报文交换技术的<code>优点</code>如下:<br>1)<code>无须建立连接</code>。报文交换不需要为通信双方预先建立一条专用的通信线路，不存在建立<br>连接时延，用户可以随时发送报文。<br>2)<code>动态分配线路</code>。当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择<br>一条合适的空闲线路，将报文发送出去。<br>3)<code>提高线路可靠性</code>。如果某条传输路径发生故障，那么可重新选择另一条路径传输数据，<br>因此提高了传输的可靠性。<br>4)<code>提高线路利用率</code>。通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地<br>部分占有这条物理通道，因而大大提高了通信线路的利用率。<br>5)<code>提供多目标服务</code>。一个报文可以同时发送给多个目的地址，这在电路交换中是很难实现的。</li>
<li>报文交换技术的<code>缺点</code>如下:<br>1)由于数据进入交换结点后要经历存储、转发这一过程，因此会引起<code>转发时延</code>(包括接收<br>报文、检验正确性、排队、发送时间等)。<br>2)报文交换对报文的大小没有限制，这就要求<code>网络结点需要有较大的缓存空间</code>。</li>
</ul>
<p>注意:报文交换主要使用在早期的电报通信网中，现在较少使用，通常被较先进的<strong>分组交换</strong>方式所取代。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101300956.png"/>

<ul>
<li>同报文交换一样，分组交换也采用存储转发方式，但解决了报文交换中大报文传输的问题。分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息(如源地址、目的地址和编号信息等)，构成分组(Packet)。 网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。到达目地之后的数据分组再重新组合起来，形成一条完整的数据。</li>
<li>分组交换的<code>优点</code>如下:<br>1)<code>无建立时延</code>。不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。<br>2)<code>线路利用率高</code>。通信双方不是固定占有- -条通信线路，而是在不同的时间一-段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。<br>3)<code>简化了存储管理(相对于报文交换)</code>。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。<br>4)<code>加速传输</code>。分组是逐个传输的，可以使后-一个分组的存储操作与前一一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组所 需的缓冲区比传输一次报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的概率及时间也必然少得多。<br>5)<code>减少了出错概率和重发数据量</code>。因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。</li>
<li>分组交换的<code>缺点</code>如下:<br>1)<code>存在传输时延</code>。尽管分组交换比报文交换的传输时延少，但相对于电路交换仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。<br>2)<code>需要传输额外的信息量</code>。每个小数据块都要加上源地址、目的地址和分组编号等信息，从而构成分组，因此使得传送的信息量增大了5%~10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。<br>3)<code>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组</code>，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</li>
<li><code>分组交换</code>根据其<code>通信子网向端点系统提供的服务</code>，还可进一步分为<code>面向连接的虚电路</code>方式和<br><code>无连接的数据报方式</code>。这两种服务方式都由网络层提供。要注意<code>数据报方式</code>和<code>虚电路方式</code>是<code>分组 交换的两种方式</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101301443.png"/>

<h4 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h4><p><strong>无连接</strong>：无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。<br><strong>每个分组携带源和目的地址</strong><br><strong>路由器根据分组的目的地址转发分组</strong>：基于路由协议&#x2F;算法构建转发表；检索转发表；每个分组独立选路。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101305131.png"/>

<p>作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有<code>序号的数据单元</code>，并在网络层加上地址等控制信息后形成数据报分组(即网络层PDU)。<code>中 间结点存储分组</code>很短一段时间，找到<code>最佳的路由</code>后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按·<code>不同的顺序到达目的结点</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101307025.png"/>

<h4 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301101308057.png"/>

<ul>
<li>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的<code>虚电路号</code>分配给该虛电路，以区别于本系统中的其他虚电路。在传送数据时，<code>每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号</code>，以区别于其他虚电路上的分组。在虚电路网络中的每个结点上都维持–张<code>虚电路表</code>，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。<code>数据的传输是双向进行的</code>，上述信息是在虚电路的建立过程中确定的。</li>
<li><code>虚电路之所以是“虚”的，是因为这条电路不是专用的·</code>，每个结点到其他结点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。</li>
</ul>
<h4 id="数据报服务和虛电路服务的比较"><a href="#数据报服务和虛电路服务的比较" class="headerlink" title="数据报服务和虛电路服务的比较"></a>数据报服务和虛电路服务的比较</h4><table>
<thead>
<tr>
<th></th>
<th>数据报服务</th>
<th>虚电路服务</th>
</tr>
</thead>
<tbody><tr>
<td>连接的建立</td>
<td>不需要</td>
<td>必须有</td>
</tr>
<tr>
<td>目的地址</td>
<td>每个分组都有完整的目的地址</td>
<td>仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td>
</tr>
<tr>
<td>路由选择</td>
<td>每个分组独立地进行路由选择和转发</td>
<td>属于同一条虚电路的分组按照同一路由转发</td>
</tr>
<tr>
<td>分组顺序</td>
<td>不保证分组的有序到达</td>
<td>保证分组的有序到达</td>
</tr>
<tr>
<td>可靠性</td>
<td>不保证可靠通信，可靠性由用户主机来保证</td>
<td>可靠性由网络保证</td>
</tr>
<tr>
<td>对网络故障的适应性</td>
<td>出故障的结点丢失分组，其他分组的路径选择发生变化时可以正常传输</td>
<td>所有经过故障结点的虚电路均不能正常工作</td>
</tr>
<tr>
<td>差错处理和流量控制</td>
<td>由用户主机进行流量控制，不保证数据报的可靠性</td>
<td>可有分组交换网负责，也可由用户主机负责</td>
</tr>
</tbody></table>
<h2 id="报文交换与分组交换的时间消耗比较"><a href="#报文交换与分组交换的时间消耗比较" class="headerlink" title="报文交换与分组交换的时间消耗比较"></a>报文交换与分组交换的时间消耗比较</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301122005748.png"/>

<h2 id="电路交换、报文交换、分组交换的交换方式比较"><a href="#电路交换、报文交换、分组交换的交换方式比较" class="headerlink" title="电路交换、报文交换、分组交换的交换方式比较"></a>电路交换、报文交换、分组交换的交换方式比较</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301122006956.png"/>

<h2 id="路由算法分类与路由表"><a href="#路由算法分类与路由表" class="headerlink" title="路由算法分类与路由表"></a>路由算法分类与路由表</h2><p><code>路由器转发分组</code>是通过<code>路由表</code>转发的，而<code>路由表</code>是通过<code>各种算法</code>得到的。从能否随网络的通<br>信量或拓扑自适应地进行调整变化来划分，<code>路由算法</code>可分为两大类：<code>静态路由与动态路由</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301142205301.png"/>

<h3 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h3><table>
<thead>
<tr>
<th>路由算法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>静态路由算法（非自适应路由算法）</td>
<td>管理员手工配置路由信息<br>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。<br />路由更新慢，不适用大型网络。</td>
</tr>
<tr>
<td>动态路由算法（自适应路由算法）</td>
<td>路由器间彼此交换信息，按照路由算法优化出路由表项。<br />路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。<br />算法复杂，增加网络负担。</td>
</tr>
</tbody></table>
<h4 id="动态路由的两种算法：链路状态路由算法和距离向量路由算法"><a href="#动态路由的两种算法：链路状态路由算法和距离向量路由算法" class="headerlink" title="动态路由的两种算法：链路状态路由算法和距离向量路由算法"></a>动态路由的两种算法：链路状态路由算法和距离向量路由算法</h4><table>
<thead>
<tr>
<th>动态路由算法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>全局性</td>
<td>链路状态路由算法OSPF<br />所有路由器掌握完整的网络拓扑和链路费用信息</td>
</tr>
<tr>
<td>分散性</td>
<td>距离向量路由算法RIP<br />路由器只掌握物理相连的邻居及链路费用</td>
</tr>
</tbody></table>
<ul>
<li>链路状态路由算法和距离向量路由算法的<code>比较</code></li>
<li><code>在距离-向量路由算法中</code>，每个结点仅与它的直接<code>邻居</code>交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计。</li>
<li><code>在链路状态路由算法中</code>，每个结点通过<code>广播</code>的方式与所有<code>其他结点</code>交谈，但它仅告诉它们与它直接相连的链路的费用。</li>
<li>相较之下，距离-向量路由算法有可能遇到路由环路等问题。</li>
</ul>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>(1)因特网规模很大出现一些问题和消耗</p>
<p>(2)许多单位不想让外界知道自己的路由选择协议，但还想连入因特网</p>
<p><strong>自治系统AS</strong>:在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。</p>
<p>一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</p>
<table>
<thead>
<tr>
<th>路由选择协议</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内部网关协议IGP</td>
<td>一个AS内使用的RIP、OSPF</td>
</tr>
<tr>
<td>外部网关协议EGP</td>
<td>AS之间使用的BGP</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161941137.png"/>

<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h3 id="IP数据报的三种传输方式"><a href="#IP数据报的三种传输方式" class="headerlink" title="IP数据报的三种传输方式"></a>IP数据报的三种传输方式</h3><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p>一对一</p>
<p>单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式。</p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>一对多</p>
<p>广播是指发送数据包到同一广播域或子 网内的所有设备的一种数据传输方式， 是一种点对多点传输方式。</p>
<h4 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h4><p>一对特定多</p>
<p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种<strong>点对多点</strong>传输方式。</p>
<ul>
<li>为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制。</li>
<li>使用多个单播传送来仿真组播总是可能的，但这会引起主机上大量的处理开销和网络上太多的交通量。</li>
<li><code>人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收</code>。</li>
</ul>
<p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一《自不同的物理网络（如果有组播路由器的支持）。运行组播协议的路由器</p>
<h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3><p>如何才能发给同一组主机相同的数据呢？这就需要了解一下IP组播地址，他就是干这个的。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161953518.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161959346.png"/>

<h3 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h3><h4 id="IGMP-国际组管理协议"><a href="#IGMP-国际组管理协议" class="headerlink" title="IGMP-国际组管理协议"></a>IGMP-国际组管理协议</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301161959297.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162000044.png"/>

<h4 id="IGMP工作的两个阶段"><a href="#IGMP工作的两个阶段" class="headerlink" title="IGMP工作的两个阶段"></a>IGMP工作的两个阶段</h4><ol>
<li><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>
</li>
<li><p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。 只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机 应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p>
</li>
</ol>
<p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p>
<h3 id="组播路由"><a href="#组播路由" class="headerlink" title="组播路由"></a>组播路由</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162009778.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162010848.png"/>

<h3 id="组播路由选择选择协议常用的三种路由算法"><a href="#组播路由选择选择协议常用的三种路由算法" class="headerlink" title="组播路由选择选择协议常用的三种路由算法"></a>组播路由选择选择协议常用的三种路由算法</h3><ol>
<li><p>基于链路状态的路由选择</p>
</li>
<li><p>基于距离-向量的路由选择</p>
</li>
<li><p>协议无关的组播（稀疏&#x2F;密集）</p>
</li>
</ol>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><ul>
<li>支持移动性的因特网体系结构与协议共称为移动IP,它是为了满足移动结点(计算机、服务、网段等)在移动中保持其连接性而设计的。</li>
<li>更确切地说，移动IP技术是指<code>移动结点以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变。</code></li>
<li>移动IP的目标是把分组自动地投递给移动结点。一个移动结点是把其连接点从一个网络或子网改变到另-一个网络或子网的主机。</li>
<li>使用移动IP，<code>一个移动结点可以在不改变其IP地址的情况下改变其驻留位置。</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162013000.png"/>

<h3 id="移动IP相关术语"><a href="#移动IP相关术语" class="headerlink" title="移动IP相关术语"></a>移动IP相关术语</h3><p>移动IP技术是移动结点（计算机&#x2F;服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p>
<ul>
<li><strong>移动结点</strong>具有永久IP地址的移动设备。</li>
<li><strong>归属代理（本地代理）</strong>一个移动结点拥有的就“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</li>
<li><strong>外部代理（外地代理）</strong>在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</li>
<li><strong>永久地址（归属地址&#x2F;主地址）</strong>移动站点在归属网络中的原始地址。</li>
<li><strong>转交地址（辅地址）</strong>移动站点在外部网络使用的临时地址。</li>
</ul>
<h3 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162016144.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162016198.png"/>

<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162018903.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162018688.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162019444.png"/>

<h2 id="三个设备之间的区别"><a href="#三个设备之间的区别" class="headerlink" title="三个设备之间的区别"></a>三个设备之间的区别</h2><ul>
<li>路由器可以互联两个不同网络层协议的网段。</li>
<li>网桥可以互联两个物理层和链路层不同的网段。</li>
<li>集线器不能互联两个物理层不同的网段。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>能否隔离冲突域</th>
<th>能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td>物理层设备【傻瓜】<br />（中继器、集线器）</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>链路层设备【路人】<br />（网桥、交换机）</td>
<td>能</td>
<td>否</td>
</tr>
<tr>
<td>网络层设备【大佬】<br />（路由器）</td>
<td>能</td>
<td>能</td>
</tr>
</tbody></table>
<h2 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202301162021091.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络(1)-概述与物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-06 15:07:47" itemprop="dateCreated datePublished" datetime="2022-11-06T15:07:47+08:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-11 17:00:44" itemprop="dateModified" datetime="2022-12-11T17:00:44+08:00">2022-12-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><p>计算机网络：是一个将分散的、具有独立功能的计算机系统</span>，通过<span style="color:red">通信设备与线路</span>连接起来，有功能完善的<span style="color:red">软件</span>实现<span style="color:green">资源共享和信息传递</span>的系统</p>
<p>计算机网络是<span style="color:red">互联的，自治的</span>的计算机集合。</p>
<ul>
<li>互联：互联互通 通信链路</li>
<li>自治：无主从关系</li>
</ul>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ol>
<li><p>数据通信（连通性）</p>
<p>数据通信是计算机网络最基本和最重要的功能，实现联网计算机之间的各种信息传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理</p>
</li>
<li><p>资源共享（硬件，软件，数据）</p>
<ul>
<li>资源共享可以是软件共享、数据共享和硬件共享</li>
<li>计算机网络中的资源互通有无，分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</li>
</ul>
</li>
<li><p>分布式处理（多台计算机各自承担同一工作任务的不同部分）</p>
<ul>
<li>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其它计算机系统，让它帮你处理，从而利用空闲计算机资源以提高整个系统的利用率</li>
</ul>
</li>
<li><p>提高可靠性</p>
<ul>
<li>计算机网络中的各台计算机可以通过网络互为替代机，当一台计算机崩了，可以让另一台计算机来完成它的工作</li>
</ul>
</li>
<li><p>负载均衡</p>
<ul>
<li>将工作任务均衡的分配给计算机网络中的各台计算机</li>
</ul>
</li>
<li><p>…</p>
</li>
</ol>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><p><strong>组成部分</strong>：硬件、软件、协议</p>
<ul>
<li>硬件主要由主机(也称端系统)，通信链路(如双绞线、光纤)、交换设备(如路由、交换机等)和通信处理机(如网卡)等组成</li>
<li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件(如网络操作系统、邮件收发程序、FTP程序、聊天程序等)。</li>
<li>协议是计算机网络的核心，协议规定了网络传输数据时所遵循的规范。就如同我们现实生活中的法律一样，网络世界也必须遵循一定的规则。</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ol>
<li><p>边缘部分 用户直接使用（C&#x2F;S方式、P2P方式）</p>
<ul>
<li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信(如传输数据、音频或视频)和资源共享</li>
</ul>
</li>
<li><p>核心部分 为边缘部分服务</p>
<p>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</p>
</li>
</ol>
<p><strong>功能组成</strong>：</p>
<ol>
<li>通信子网 实现数据通信</li>
<li>资源子网 实现资源共享&#x2F;数据处理</li>
</ol>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ol>
<li>按分布范围分：<code>广域网WAN</code> <code>城域网MAN</code> <code>局域网WAN</code> <code>个人区域网PAN</code>（广域网是交换技术，局域网是广播技术）</li>
<li>按使用者分：<code>公用网</code> <code>专用网</code></li>
<li>按交换技术分：<code>电路交换</code> <code>报文交换</code> <code>分组交换</code></li>
<li>按拓扑结构分：<code>总线型</code> <code>星型</code> <code>环形</code> <code>网状型</code></li>
<li>按传输技术分：<code>广播式网络：共享公共通信信道</code> <code>点对点网络：</code></li>
</ol>
<h1 id="计算机网络的标准化工作"><a href="#计算机网络的标准化工作" class="headerlink" title="计算机网络的标准化工作"></a>计算机网络的标准化工作</h1><h2 id="标准化的分类"><a href="#标准化的分类" class="headerlink" title="标准化的分类"></a>标准化的分类</h2><p>法定标准：由权威机构制定的正式的、合法的标准 <strong><span style="color:red">OSI</span></strong></p>
<p>事实标准：某些公司的产品在竞争中占据了主流 <strong><span style="color:red">TCP&#x2F;IP</span></strong></p>
<h2 id="标准化工作"><a href="#标准化工作" class="headerlink" title="标准化工作"></a>标准化工作</h2><p>RFC(Request For Comments) 因特网标准的形式</p>
<p>RFC要上升为因特网正式标准的四个阶段</p>
<p>因特网草案（Internet Draft）：这个阶段还不是RFC文档</p>
<p>建议标准（Proposed Standard）：从这个阶段开始成为RFC文档</p>
<p><del>草案标准（Draft Standard）：近年已取消</del></p>
<p>因特网标准（Internet Standard）</p>
<h2 id="标准化工作的相关组织"><a href="#标准化工作的相关组织" class="headerlink" title="标准化工作的相关组织"></a>标准化工作的相关组织</h2><p><strong>国际标准化组织ISO</strong> OSI参考模型、HDLC协议</p>
<p><strong>国际电信联盟ITU</strong> 指定通信标准</p>
<p><strong>国际电气电子工程师协会IEEE</strong> 学术机构、IEEE802系列标准、5G</p>
<p><strong>Internet工程任务组IETF</strong> 负责因特网相关标准的制定 RFC</p>
<h1 id="速率相关性能指标"><a href="#速率相关性能指标" class="headerlink" title="速率相关性能指标"></a>速率相关性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率即数据率或称数据传输率或比特率</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>表示</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td>比特</td>
<td>1&#x2F;0</td>
<td>位</td>
</tr>
</tbody></table>
<p>连接在计算机网络上的主机在数字信道上传送数据位数的速率</p>
<p>单位是<code>b/s</code> <code>kb/s</code> <code>Mb/s</code> <code>Gb/s</code> <code>Tb/s</code></p>
<p><span style="color:red">注意：速率单位的转化是10^3 ，而存储单位的转化是1024<br>其中的，存储容量1Byte（字节）&#x3D;8bit（比特）<br>1KB&#x3D;2^10B&#x3D;1024B&#x3D;1024*8b</span></p>
<table>
<thead>
<tr>
<th>名称</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>千</td>
<td>1kb&#x2F;s&#x3D;10^3b&#x2F;s</td>
</tr>
<tr>
<td>兆</td>
<td>1Mb&#x2F;s&#x3D;10^3kb&#x2F;s&#x3D;10^6b&#x2F;s</td>
</tr>
<tr>
<td>吉</td>
<td>1Gb&#x2F;s&#x3D;10^3Mb&#x2F;s&#x3D;10^6kb&#x2F;s&#x3D;10^9b&#x2F;s</td>
</tr>
<tr>
<td>太</td>
<td>1Tb&#x2F;s&#x3D;10^3Gb&#x2F;s&#x3D;10^6Mb&#x2F;s&#x3D;10^9kb&#x2F;s&#x3D;10^12b&#x2F;s</td>
</tr>
</tbody></table>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><ol>
<li><p>“带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz)。</p>
</li>
<li><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b&#x2F;s,kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s。<br><strong>网络设备所支持的最高速度</strong></p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235333.png"/>

<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>表示在<span style="color:red">单位时间内通过某个网络（或信道、接口）的数据量</span>。单位b&#x2F;s,kb&#x2F;s,Mb&#x2F;s等。</p>
<p>速率就是实际网速，带宽是理论网速，吞吐量是一个或多个设备的综合速率，比如说1000m宽带的路由器连着三部手机，每部手机都是10mb&#x2F;s看片，那么速率就是10mb&#x2F;s，带宽是宽带的1000m，路由器吞吐量是30mb&#x2F;s，即三者之和</p>
<h1 id="时延、时延带宽积、RTT和利用率"><a href="#时延、时延带宽积、RTT和利用率" class="headerlink" title="时延、时延带宽积、RTT和利用率"></a>时延、时延带宽积、RTT和利用率</h1><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>指数据（报文&#x2F;分组&#x2F;比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>计算公式</th>
</tr>
</thead>
<tbody><tr>
<td>发送时延</td>
<td>数据从主机到信道上所用的时间</td>
<td>发送的数据长度&#x2F;信道速率（发送速率）</td>
</tr>
<tr>
<td>传播时延</td>
<td>数据在信道上传播所花费的时间</td>
<td>信道长度&#x2F;电磁波在信道上传播的速率</td>
</tr>
<tr>
<td>排队时延</td>
<td>数据在路由器前等待前面数据处理的时间</td>
<td>无计算方式</td>
</tr>
<tr>
<td>处理时延</td>
<td>数据在路由器中处理需求的时间</td>
<td>无计算方式</td>
</tr>
</tbody></table>
<p>使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延</p>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>公式：时延带宽积（bit）&#x3D;传播时延（s）x带宽（b&#x2F;s）</p>
<p>时延带宽积又称为<span style="color:red">比特为单位的链路长度</span></p>
<p>意思是链路上有多少比特的数据</p>
<h2 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h2><p>发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延</p>
<p>RTT越大，在收到确认之前，可以发送的数据越多</p>
<p>RTT&#x3D;<strong>传播时延</strong>x2+处理时间(有时可能直接忽略)</p>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>信道利用率&#x3D;有数据通过<strong>时间</strong>&#x2F;（有+无）数据通过<strong>时间</strong></p>
<h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p>网络利用率&#x3D;所有信道利用率加权求平均值</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235459.png"/>

<h1 id="分层结构，协议，接口，服务"><a href="#分层结构，协议，接口，服务" class="headerlink" title="分层结构，协议，接口，服务"></a>分层结构，协议，接口，服务</h1><p>网络为什么要分层：</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行<span style="color:red">激活</span></li>
<li>要告诉网络如何识别目的主机</li>
<li>发起通信的计算机要查明目的的主机是否开机，并且与网络连接是否正常</li>
<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作</li>
<li>确保差错和意外可以解决。</li>
<li>等等</li>
</ol>
<h2 id="正式认识分层结构"><a href="#正式认识分层结构" class="headerlink" title="正式认识分层结构"></a>正式认识分层结构</h2><ol>
<li>实体：第n层中的活动元素称为<span style="color:red">n层实体</span>。一层的实体叫<span style="color:red">对等实体</span></li>
<li>协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。</li>
<li>接口（访问服务店SAP）：上层使用下层服务的入口</li>
<li>服务：下层为相邻上层提供的功能调用</li>
</ol>
<p><strong>SDU服务数据单元：为完成用户所要求的功能而应传送的数据。</strong><br><strong>PCI协议控制信息：控制协议操作的信息。</strong><br><strong>协议数据单元：对等层次之间传送的数据单位。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235911.png"/>

<ul>
<li><p>网络体系结构是从功能上描述计算机网络结构。</p>
</li>
<li><p>计算机网络体系结构简称网络体系结构是分层结构。</p>
</li>
<li><p>每层遵循某个&#x2F;些网络协议以完成本层功能。</p>
</li>
<li><p>计算机网络体系结构是计算机网络的各层及其协议的集合。</p>
</li>
<li><p>第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</p>
</li>
<li><p>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</p>
</li>
<li><p>体系结构是抽象的，而实现是指能运行的一些软件和硬件。</p>
</li>
</ul>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>计算机网络分层结构：</p>
<p>7层OSI参考模型（法定标准）</p>
<p>4层TCP&#x2F;IP参考模型（事实标准）</p>
<p>5层体系结构</p>
<h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><p>ISO&#x2F;OSI参考模型</p>
<p>1-3通信子网（数据通信） 5-7资源子网（数据处理）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>7.应用层</td>
<td>Application Layer</td>
<td>直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等</td>
</tr>
<tr>
<td>6.表示层</td>
<td>Presentation Layer</td>
<td>把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息</td>
</tr>
<tr>
<td>5.会话层</td>
<td>Session Layer</td>
<td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接</td>
</tr>
<tr>
<td>4.传输层</td>
<td>Transport Layer</td>
<td>负责端到端通讯，可靠传输，不可靠传输 ，差错控制，流量控制，复用分用</td>
</tr>
<tr>
<td>3.网络层</td>
<td>Network Layer</td>
<td>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。<br />负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制<br />路由选择、流量控制、差错控制、拥塞控制</td>
</tr>
<tr>
<td>2.数据链路层</td>
<td>Data Link Layer</td>
<td>主要任务是把网络层传下来的数据报组装成帧。数据链路层&#x2F;链路层的传输单位是帧。<br />帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)<br />成帧、差错控制、流量控制、访问（接入）控制</td>
</tr>
<tr>
<td>1.物理层</td>
<td>Physical Layer</td>
<td>主要任务是在物理媒体上实现比特流的透明传输。物理层传输单位是比特。<br />定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快<br />透明传输、定义接口特性、定义传输模式、定义传输速率、比特同步</td>
</tr>
</tbody></table>
<h2 id="OSI流程简介"><a href="#OSI流程简介" class="headerlink" title="OSI流程简介"></a>OSI流程简介</h2><p>网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）<br>数据链路层不仅需要加头部，还需要加尾部<br>物理层什么都不加，只管发送数据（比特流）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235931.png"/>

<h2 id="TCP-x2F-IP参考模型"><a href="#TCP-x2F-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h2><p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221210235958.png"/>面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。</p>
<p>而面向无连接没有这么多阶段，它直接进行数据传输。</p>
<table>
<thead>
<tr>
<th></th>
<th>ISO&#x2F;OSI参考模型</th>
<th>TCP&#x2F;IP模型</th>
</tr>
</thead>
<tbody><tr>
<td>网络层</td>
<td>无连接+面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>传输层</td>
<td>面向连接</td>
<td>无连接+面向连接</td>
</tr>
</tbody></table>
<h2 id="五层参考模型及其传输过程简介"><a href="#五层参考模型及其传输过程简介" class="headerlink" title="五层参考模型及其传输过程简介"></a>五层参考模型及其传输过程简介</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000036.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000126.png"/>

<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111430252.png"/>

<h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。<br>这就叫做”实体层”，逼格高一点的叫法就是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%89%A9%E7%90%86%E5%B1%82&spm=1001.2101.3001.7020">物理层</a>。它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。<br>至于0和1的信号是什么，还轮不到物理层还决定。</p>
<p>物理层解决如何在连接各种计算机的传输媒体上<span style="color:red">传输数据比特流</span>，而不是指具体的传输媒体。</p>
<p>物理层主要任务：确定与传输媒体<span style="color:blue">接口</span>有关的一些特性  ——定义标准</p>
<p><strong>1.机械特性：</strong>定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况</p>
<p><strong>2.电气特性：</strong>规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</p>
<p><strong>3.功能特性：</strong>指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</p>
<p>**4.规程特性（过程特性）:**定义各条物理线路的工作规程和时序关系。</p>
<h2 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000151.png"/>

<h3 id="三种通讯方式-单工，半双工，全双工"><a href="#三种通讯方式-单工，半双工，全双工" class="headerlink" title="三种通讯方式 (单工，半双工，全双工)"></a>三种通讯方式 (单工，半双工，全双工)</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>定义</th>
<th>需要信道条数</th>
</tr>
</thead>
<tbody><tr>
<td>单工通信</td>
<td>Simplex</td>
<td>只有一个方向的通信而没有反方向的交互</td>
<td>一条</td>
</tr>
<tr>
<td>半双工通信</td>
<td>half-duplex</td>
<td>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收</td>
<td>两条</td>
</tr>
<tr>
<td>全双工通信</td>
<td>duplex</td>
<td>通信双方可以同时发送和接受信息</td>
<td>两条</td>
</tr>
</tbody></table>
<h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><table>
<thead>
<tr>
<th>传输方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>串行传输</td>
<td>速度慢，省钱，适合远距离</td>
</tr>
<tr>
<td>并行传输</td>
<td>速度快，耗钱，适合近距离</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000718.png"/>

<h3 id="数据、信号、信源、信宿、信道"><a href="#数据、信号、信源、信宿、信道" class="headerlink" title="数据、信号、信源、信宿、信道"></a>数据、信号、信源、信宿、信道</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000730.png"/>

<h2 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h2><h3 id="码元（Symbol）"><a href="#码元（Symbol）" class="headerlink" title="码元（Symbol）"></a>码元（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Symbol&spm=1001.2101.3001.7020">Symbol</a>）</h3><p>定义：码元是指用一个<span style="color:red"><strong>固定时长的信号波形（数字脉冲）</strong></span>,代表不同<strong>离散数值</strong>的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<strong>k进制码元</strong>，而该时长称为<strong>码元宽度</strong>。当<strong>码元的离散状态</strong>有M个时（M大于2),此时码元为<strong>M进制码元</strong>。</p>
<p>1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p>
<p>个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000819.png"/>

<h3 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h3><p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。分为<strong>码元传输速率</strong>和<strong>信息传输速率</strong></p>
<ol>
<li><p>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为<strong>脉冲个数或信号变化的次数</strong>）,单位是**波特（Baud)**。1波特表示数字通信系统每秒传输一码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</p>
<p><strong>1s传输多少个码元： 1Baud &#x3D; 1bit&#x2F;s</strong></p>
</li>
<li><p>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数）,单位是比特&#x2F;秒（b&#x2F;s)。</p>
<p><strong>1s传输多少个比特</strong></p>
</li>
<li><p>关系：若一个码元携带nbit的信息量，则MBaud的码元传输速率所对应的信息传输速率为<br>$$<br>M*n(bit&#x2F;s)<br>$$</p>
</li>
</ol>
<p>码元可以理解为几个比特的<strong>集合</strong>，所以信息传输速率（网速）&#x3D;码元传输速率x码元所带信息量（多少比特）<br>码元所带信息量（比特数）&#x3D;log2（码元进制数）</p>
<h3 id="带宽（Band-Width）"><a href="#带宽（Band-Width）" class="headerlink" title="带宽（Band Width）"></a>带宽（Band Width）</h3><p>带宽：表示在单位时间内从网络中的某一点到另一点所能通过的<strong>“最高数据率”</strong>，常用来表示网络的通信线路所能传输数据的能力。单位是b&#x2F;s。</p>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>某一数字通信系统传输的是四进制码元，4s传输了8000个码元，求系统的码元传输速率是多少？信息传输速率是多少？</p>
<p>若另一通信系统传输的是十六进制码元，6s传输了7200个码元，求他的码元传输速率是多少？信息传输速率是多少？并指出哪个系统传输速率快？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2000Baud,4000b/s;</span><br><span class="line">1200Baud,4800b/s;</span><br><span class="line">十六进制更快</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000852.png"/>

<p>系统传输的是比特流，通常比较的是信息传输速率，所以传输十六进制码元的通信系统传输速率较快，如果用该系统去传输四进制码元会有更高的码元传输速率。</p>
<h2 id="奈式准则（Nyquist）"><a href="#奈式准则（Nyquist）" class="headerlink" title="奈式准则（Nyquist）"></a>奈式准则（Nyquist）</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="（1）失真"><a href="#（1）失真" class="headerlink" title="（1）失真"></a>（1）失真</h4><p>一般而言，由于各方面的影响，信号在信道上传输是不稳定的，会产生误差，即失真。</p>
<p>影响失真程度的因素：</p>
<ol>
<li>码元传输速率  </li>
<li>信号传输距离 </li>
<li>噪声干扰</li>
<li>#传输媒体质量</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211000920.png"/>

<h4 id="（2）失真的一种现象-码间串扰"><a href="#（2）失真的一种现象-码间串扰" class="headerlink" title="（2）失真的一种现象-码间串扰"></a>（2）失真的一种现象-码间串扰</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211001129.png"/>

<h3 id="香农准则内容"><a href="#香农准则内容" class="headerlink" title="香农准则内容"></a>香农准则内容</h3><p>奈氏准则：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2WBaud,W是信道带宽，单位是Hz。<br>$$<br>理想低通信道下的极限数据传输率&#x3D;2Wlog_2V(b&#x2F;s)<br>$$</p>
<ol>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的<strong>频带越宽</strong>（即能通过的信号高频分量越多）,就可以用更高的速率进行码元的有效传输。</li>
<li><strong>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</strong></li>
<li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</li>
</ol>
<p>通过下面实例来理解：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img/img/20221211002121.png"/>

<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。信噪比&#x3D;信号的平均功率&#x2F;噪声的平均功率，常记为S&#x2F;N,并用分贝（dB)作为度量单位，即：<br>$$<br>信噪比(dB) &#x3D; 10log_10(S&#x2F;N)<br>$$<br>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。<br>$$<br>信道的极限传输速率&#x3D;Wlog_2(1+S&#x2F;N)(b&#x2F;s)<br>$$<br>其中<strong>S&#x2F;N</strong>就是所谓信噪比</p>
<p>S:是信道所传信号的平均功率</p>
<p>N:是信道内的高斯噪声功率</p>
<ol>
<li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li>
<li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</li>
<li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。</li>
<li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li>
<li>从香农定理可以看出，若信道带宽W或信噪比S&#x2F;N没有上限（不可能）,那么信道的极限信息传输速率也就没有上限。</li>
</ol>
<h2 id="基带信号和宽带-x2F-带通信号（Base-band，pass-band）"><a href="#基带信号和宽带-x2F-带通信号（Base-band，pass-band）" class="headerlink" title="基带信号和宽带&#x2F;带通信号（Base band，pass band）"></a>基带信号和宽带&#x2F;带通信号（Base band，pass band）</h2><ul>
<li>根据原始电信号的特征，基带信号可分为数字基带信号和模拟基带信号（相应地，信源也分为数字信源和模拟信源）其由信源决定</li>
<li>宽带信号的定义是传输速度达到200kbps或以上,不管模拟信号还是数字信号只要满足就可算作宽带信号。</li>
</ul>
<p>计算机网络中用的基带信号是<strong>数字信号</strong></p>
<table>
    <tr>
        <td rowspan=2>
          信道上传送的信号
        </td>
        <td>基带信号</td>
        <td>将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。
来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信
            号。基带信号就是发出的<b>直接表达了要传输的信息的信号</b>，比如我们说话的声波就是
基带信号。</td>
    </tr>
    <tr>
        <td>宽带信号</td>
        <td>将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。
把<b>基带信号经过载波调制后</b>，把信号的<b>频率范围搬移到较高的频段以使在信道中传输</b>（即仅
在一段频率范围内能够通过信道)。</td>
    </tr>
</table>

<ul>
<li>在传输距离较<strong>近</strong>时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生变化）</li>
<li>在传输距离较<strong>远</strong>时，计算机网络采用<strong>宽带传输</strong>方式（远距离衰诚大，即使信号变化大也能最后过滤出来基带信号）</li>
</ul>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><ul>
<li><p>数据无论是数字的，还是模拟的，为了传输的目的都必须转变成信号。</p>
</li>
<li><p>把数据变换为数字信号的过程称为<strong>编码</strong>，把数据变换为模拟信号的过程称为<strong>调制</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111339740.png"/></li>
</ul>
<h3 id="编码（数据-gt-数字信号）"><a href="#编码（数据-gt-数字信号）" class="headerlink" title="编码（数据-&gt;数字信号）"></a>编码（数据-&gt;数字信号）</h3><p>将数据转化为<strong>数字信号</strong></p>
<ul>
<li><p>数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111318395.png"/>
</li>
<li><p>模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111321773.png"/></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>简述</th>
<th>缺陷</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单极性不归零编码</strong></td>
<td>只使用一个电压值，高电平表示1，低电平表示0</td>
<td>高1，低0</td>
<td>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步</td>
</tr>
<tr>
<td><strong>双极性不归零编码</strong></td>
<td>用幅值相等的正负电平表示二进制数1和0</td>
<td>正电1，负电0</td>
<td></td>
</tr>
<tr>
<td><strong>单极性归零编码</strong></td>
<td>发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平</td>
<td>变化1，其他时间为0<br>（反向不归零即相反）</td>
<td>信号电平在一个码元之内都要恢夏到零的这种编码成编码方式。<br>接收方根据跳变调整本方的时钟基准，这就为双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响</td>
</tr>
<tr>
<td><strong>双极性归零编码</strong></td>
<td>正负零三个电平，信号本身携带同步信息</td>
<td>正1，负0，默认平时</td>
<td></td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111322473.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>曼彻斯特编码</strong></td>
<td>【以太网的编码方式】单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0<br>这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0</td>
<td>高跳低1，低跳高0</td>
</tr>
<tr>
<td><strong>差分曼彻斯特编码</strong></td>
<td>抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。</td>
<td>逢1跳变</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111351400.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111328328.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>4B&#x2F;5B编码</strong></td>
<td>比特流中插入额外的比特以打破一连串的0或1,就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B&#x2F;5B。编码效率为80%。<br>只采用16种对应16种不同的4位码，其他的16种作为控制码（帧的开始和结束，线路的状态信息等）或保留。</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111353763.png"/>

<h3 id="调制（数据-gt-模拟信号）"><a href="#调制（数据-gt-模拟信号）" class="headerlink" title="调制（数据-&gt;模拟信号）"></a>调制（数据-&gt;模拟信号）</h3><p>常用的调制方法：调频(AM)，调频(FM)，调相(PM)</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111355023.png"/>



<h3 id="模拟数据-编码-为数字信号"><a href="#模拟数据-编码-为数字信号" class="headerlink" title="模拟数据 编码 为数字信号"></a>模拟数据 <code>编码</code> 为数字信号</h3><p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制(PCM),在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WV文件中均有应用。它主要包括三步：抽样、量化、编码。</p>
<ul>
<li><strong>抽样</strong>：对模拟信号周期性扫描，把时间上 <strong>连续</strong> 的信号变成时间上 <strong>离散</strong> 的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样</li>
</ul>
<p>$$<br>  f_{采样频率} \geq 2f_{信号最高频率 } （采样频率越大，则采取到的数据更接近原数据）<br>$$</p>
<ul>
<li><p><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把<strong>连续</strong>的<strong>电平幅值</strong>转换为<strong>离散</strong>的<strong>数字量</strong>。</p>
</li>
<li><p><strong>编码</strong>：把量化的结果转换为与之对应的<strong>二进制编码</strong></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111428000.png"/>

<h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据<code>调制</code>为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式：模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<p>简单的说就是将信号放大，避免在传输过程中失真太严重</p>
<h2 id="传输介质及其分类"><a href="#传输介质及其分类" class="headerlink" title="传输介质及其分类"></a>传输介质及其分类</h2><p>传输介质也称传输媒体&#x2F;传输媒介，它就是数据传输系统中在<strong>发送设备和接收设备之间的物理通路。</strong></p>
<p><strong>传输媒体并不是物理层</strong>。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111624253.png"/>

<h2 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>双绞线价格<strong>便宜</strong>，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于<strong>模拟传输</strong>，要用放<strong>大器放大衰减的信号</strong>；对于<strong>数字传输</strong>，要用<strong>中继器</strong>将失真的信号整形。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111625815.png"/>

<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>基本分为两类：50Ω同轴电缆和75Ω同轴电缆。其中，<strong>50Ω同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆</strong>，它在局域网中得到广泛应用；7<strong>5Ω同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111626179.png"/>

<h3 id="双绞线和同轴电缆的差别"><a href="#双绞线和同轴电缆的差别" class="headerlink" title="双绞线和同轴电缆的差别"></a>双绞线和同轴电缆的差别</h3><p>由于外导体屏蔽层的作用，同轴电缆抗干扰特性比双绞线好，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示1,无光脉冲表示0。而可见光的频率大约是108MHz,因此光纤通信系统的带宽远远大于目前其他各种传输媒体的带宽。</p>
<p><span style="color:gray">光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲；在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</span></p>
<p>光纤主要由<strong>纤芯（实心的！)和包层构成</strong>，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现<strong>全反射</strong>，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111630018.png"/>

<h4 id="单模与多模"><a href="#单模与多模" class="headerlink" title="单模与多模"></a>单模与多模</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111631155.png"/>



<h4 id="光纤的特点"><a href="#光纤的特点" class="headerlink" title="光纤的特点"></a>光纤的特点</h4><p>1.传输损耗小，中继距离长，对远距离传输特别经济。</p>
<p>2.抗雷电和电磁干扰性能好。</p>
<p>3.无串音干扰，保密性好，也不易被窃听或截取数据。</p>
<p>4.体积小，重量轻。</p>
<h2 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111632000.png"/>



<h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p><strong>诞生原因</strong>：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p>
<p><strong>中继器的功能</strong>：对信号进行<strong>再生和还原</strong>，<strong>对衰减的信号进行放大</strong>，保持与原数据相同，以增加信号传输的距离，延长网络的长度。（备注：放大器放大衰减的模拟信号）</p>
<p>中继器的两端：两端的网络部分是网段，而不是子网，适用于完全相同的<strong>两类网络</strong>的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。中继器两端的网段一定要是同一个协议。（中继器不会存储转发）</p>
<p><strong>5-4-3规则</strong>：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111636007.png"/>



<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p><strong>集线器的功能</strong>：对信号进行<strong>再生放大转发</strong>，对<strong>衰减的信号进行放大</strong>，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/img/202212111637092.png"/>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">软件设计师笔记(11)-数据库设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 20:07:03" itemprop="dateCreated datePublished" datetime="2022-10-22T20:07:03+08:00">2022-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-10-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-%E4%B8%8B%E5%8D%88%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-10-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-%E4%B8%8B%E5%8D%88%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">软件设计师笔记(10)-数据流图(下午题）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-20 22:03:27" itemprop="dateCreated datePublished" datetime="2022-10-20T22:03:27+08:00">2022-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-9-%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E6%A0%87%E5%87%86%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-9-%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E6%A0%87%E5%87%86%E5%8C%96/" class="post-title-link" itemprop="url">软件设计师笔记(9)-多媒体基础与知识产权标准化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-20 21:33:56 / 修改时间：22:02:55" itemprop="dateCreated datePublished" datetime="2022-10-20T21:33:56+08:00">2022-10-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多媒体基础知识"><a href="#多媒体基础知识" class="headerlink" title="多媒体基础知识"></a>多媒体基础知识</h1><h2 id="音频相关概念"><a href="#音频相关概念" class="headerlink" title="音频相关概念"></a>音频相关概念</h2><img src="https://s1.imagehub.cc/images/2022/10/20/image4ee03ae9628e6ac4.png" alt="image4ee03ae9628e6ac4.png" border="0" />

<h2 id="图像相关概念"><a href="#图像相关概念" class="headerlink" title="图像相关概念"></a>图像相关概念</h2><img src="https://s1.imagehub.cc/images/2022/10/20/imagee9e38c233770eec0.png" alt="imagee9e38c233770eec0.png" border="0" />

<h2 id="媒体的种类"><a href="#媒体的种类" class="headerlink" title="媒体的种类"></a>媒体的种类</h2><img src="https://s1.imagehub.cc/images/2022/10/20/image5cb5a51bb2ea65f4.png" alt="image5cb5a51bb2ea65f4.png" border="0" />

<h2 id="相关的计算"><a href="#相关的计算" class="headerlink" title="相关的计算"></a>相关的计算</h2><img src="https://s1.imagehub.cc/images/2022/10/20/image26669aadf7bf77e9.png" alt="image26669aadf7bf77e9.png" border="0" />

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><img src="https://s1.imagehub.cc/images/2022/10/20/image2672b0b50b15d0dd.png" alt="image2672b0b50b15d0dd.png" border="0" />

<h2 id="常见的多媒体标准"><a href="#常见的多媒体标准" class="headerlink" title="常见的多媒体标准"></a>常见的多媒体标准</h2><img src="https://s1.imagehub.cc/images/2022/10/20/imagec673c5e87078ca79.png" alt="imagec673c5e87078ca79.png" border="0" />

<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><ul>
<li>空间冗余（几何冗余）</li>
<li>时间冗余</li>
<li>视觉冗余</li>
<li>信息熵冗余</li>
<li>结构冗余</li>
<li>知识冗余</li>
</ul>
<h2 id="有损压缩与无损压缩"><a href="#有损压缩与无损压缩" class="headerlink" title="有损压缩与无损压缩"></a>有损压缩与无损压缩</h2><img src="https://s1.imagehub.cc/images/2022/10/20/imageba2e258046af3839.png" alt="imageba2e258046af3839.png" border="0" />

<h1 id="知识产权"><a href="#知识产权" class="headerlink" title="知识产权"></a>知识产权</h1><h2 id="保护范围与对象"><a href="#保护范围与对象" class="headerlink" title="保护范围与对象"></a>保护范围与对象</h2><table>
<thead>
<tr>
<th>法律法规名称</th>
<th>保护对象及范围</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>著作权法（版权）</td>
<td>著作权<br>文学、绘画、摄影等作品</td>
<td>1.不需要申请，作品完成即开始保护<br>2.绘画或摄影作品原件出售（赠予）著作权还归原作者，原件拥有者有：所有权、展览权</td>
</tr>
<tr>
<td>软件著作权法<br/>计算机软件保护条例</td>
<td>软件著作权<br/>软件作品</td>
<td>1.不需要申请，作品完成即开始保护<br/>2.登记制度便于举证</td>
</tr>
<tr>
<td>专利法</td>
<td>专利权</td>
<td>需要申请，专利权有效期是从申请日开始计算</td>
</tr>
<tr>
<td>商标法</td>
<td>商标权</td>
<td>需要申请，核准之日起商标受保护</td>
</tr>
<tr>
<td>反对不正当竞争法</td>
<td>商业秘密权</td>
<td>1.商业秘密包括技术与经营两个方面<br/>2.必须有保密措施才能认定商业秘密</td>
</tr>
</tbody></table>
<h2 id="保护期限"><a href="#保护期限" class="headerlink" title="保护期限"></a>保护期限</h2><img src="https://s1.imagehub.cc/images/2022/10/20/imageaadfd9e55b5e5e84.png" alt="imageaadfd9e55b5e5e84.png" border="0" />

<h2 id="知识产权人确定"><a href="#知识产权人确定" class="headerlink" title="知识产权人确定"></a>知识产权人确定</h2><img src="https://s1.imagehub.cc/images/2022/10/20/image6cdc7f58341771c2.png" alt="image6cdc7f58341771c2.png" border="0" />

<img src="https://s1.imagehub.cc/images/2022/10/20/image6dcab6d003c93d40.png" alt="image6dcab6d003c93d40.png" border="0" />

<h2 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h2><ol>
<li>中国公民、法人或者其他组织的作品，不论是否发表，都享有著作权。</li>
<li>开发软件所用的思想、处理过程、操作方法或者数学概念不受保护</li>
<li>著作权法不适用于下列情形：<ul>
<li>法律、法规，国家机关的决议、决定、命令和其他具有立法、行政、司法质的	文件，及其官方正式译文；</li>
<li>时事新闻；</li>
<li>历法、通用数表、通用表格和公式。</li>
</ul>
</li>
</ol>
<img src="https://s1.imagehub.cc/images/2022/10/20/imagef7d2927a32266f7c.png" alt="imagef7d2927a32266f7c.png" border="0" />

<h1 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h1><h2 id="标准的分类"><a href="#标准的分类" class="headerlink" title="标准的分类"></a>标准的分类</h2><ul>
<li>国际标准 : ISO、IEC等国际标准化组织</li>
<li>国家标准 : GB（国标的拼音首字母）一中国、ANSI一美国、BS一英国、JIS一日本</li>
<li>区域标准 : 又称为地区标准，如PASC一太平洋地区标准会议、CEN一欧洲标 准委员会、ASAC一亚洲标隹咨询委员会、ARSO一目洲地区标准化组织（考试不会涉及到，故不关注）</li>
<li>行业标准 : GJB一中国军用标准、MIT-S一美国军用标准、IEEE一美国电气 电子工程师协会</li>
<li>地方标准 : 国家的地方一级行政机构制订的标准</li>
<li>企业标准 : 企业内部定的标准，有的时候也叫企业规范</li>
<li>项目规范</li>
</ul>
<h2 id="标准的编号"><a href="#标准的编号" class="headerlink" title="标准的编号"></a>标准的编号</h2><p>通过标准的代号能够区分是属于什么样的标准。</p>
<ul>
<li>国际、国外标准代号 : 标准代号+专业类号+顺序号+年代号</li>
<li>我国国家标准代号 : 强制性标准代号为 GB、推荐性标准代号为 GB&#x2F;T、指导性标准代号为 GB&#x2F;Z 、实物标准代号GSB</li>
<li>行业标准代号 : 由汉语拼音大写字母组成 ( 如电子行业为 S J )</li>
<li>通过排除法分析行业标准。</li>
<li>地方标准代号 : 由DB加上省级行政区划代码的前两位</li>
<li>企业标倠代号 : 由Q加上企业代号组成</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/16/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-8-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/16/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-8-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">软件设计师笔记(8)-程序设计语言与语言处理程序基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-16 12:30:50" itemprop="dateCreated datePublished" datetime="2022-10-16T12:30:50+08:00">2022-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-20 21:32:37" itemprop="dateModified" datetime="2022-10-20T21:32:37+08:00">2022-10-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序设计语言与语言处理程序基础"><a href="#程序设计语言与语言处理程序基础" class="headerlink" title="程序设计语言与语言处理程序基础"></a>程序设计语言与语言处理程序基础</h1><img src="https://s1.imagehub.cc/images/2022/10/16/image753ce8bf5f3410fe.png" alt="image753ce8bf5f3410fe.png" border="0" />

<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul>
<li><p>解释型程序：</p>
<p>解释型语言是指源代码不需要预先进行编译，在运行时，要先进行解释再运行。解释型语言执行效率低，但跨平台性好。<br>举例：比如Java程序执行过程，我们写好代码，直接运行即可（运行前有解释的过程）。</p>
<p>Java、Python等都是解释型语言</p>
</li>
<li><p>编译型程序：</p>
<p>编译型语言是指程序在执行之前需要一个专门的编译过程，把程序源文件编译为机器语言的文件，运行时不需要重新编译，执行效率高，但缺点是，编译型语言依赖编译器，跨平台性差。<br>举例：比如C语言程序的执行过程，要先将后缀为.c的源文件通过编译、链接为后缀为.exe的可执行文件，才能运行。</p>
<p>C语言、C++等都是编译型语言</p>
</li>
</ul>
<img src="https://s1.imagehub.cc/images/2022/10/16/image84a0ca0825a829af.png" alt="image84a0ca0825a829af.png" border="0" />

<ul>
<li>程序员编写的源程序首先进行词法分析，就是检查语言的关键字是否出现词法错误。</li>
<li>语法分析，词法正确，检查词法连接成的语法是否出现语法错误。</li>
<li>语义分析，往往只能分析出一部分错误，有些错误是无法通过机械化方式分析出来。这也是一些程序的bug始终是难以杜绝的通过机器检查的方式难以发现。</li>
<li>代码优化，具体操作是如何匹配相应的系统使整个代码的效率提高。</li>
<li>目标代码的生成需要转化成目标程序。</li>
<li>目标代码往往指可执行的代码，涉及到底层硬件的一些东西，相当于转换成机器可执行的东西。</li>
<li>当然有些语言不需要编译就能直接在操作系统上执行的代码，而是转换成一种中间代码，比如说JAVA等就是走的这种体系，它们要有专用的虚拟机来支持它们的运行。当然这样子做是好处的，它们可以屏蔽不同的操作系统不同的硬件带来的程序目标代码的差异，从而实现跨平台特性。</li>
</ul>
<h2 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h2><p>一个形式文法是一个有序四元组 G &#x3D; ( V , T , S , P )  其中:</p>
<ol>
<li>V: 非终结符。不是语言组成部分, 不是最终结果, 可理解为占位符。</li>
<li>T: 终结符。是语言的组成部分, 是最终结果。 V ∩ T &#x3D; ∅ </li>
<li>S: 起始符。是语言的开始符号。</li>
<li>P: 产生式。用终结符替代非终结符的规则。形如 α → β</li>
</ol>
<p>正则闭包：（也就是所有幂的组合）<br>$$<br>A^+&#x3D;A^1\cup A^2\cup A^3 \cup A^4 \cup… \cup A^n \cup …<br>$$<br>闭包：(在正则闭包的基础上，加上A^0 &#x3D; {ε})<br>$$<br>A^* &#x3D; A^0 \cup A^+<br>$$<br>例如：<br>$$<br>a^*&#x3D;[a,aa,aaa,…,ε],而(ab)^*&#x3D;[ab,abab,ababab,…,ε]<br>$$</p>
<p>文法的类型分为0型、1型、2型、3型。</p>
<ul>
<li>0型文法又称短语文法。</li>
<li>1型文法又称上下文有关文法。</li>
<li>2型文法又称上下文无关文法。</li>
<li>3型文法又称正规文法。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>别称</th>
<th>说明</th>
<th>对应自动机</th>
</tr>
</thead>
<tbody><tr>
<td>0型</td>
<td>短语文法</td>
<td>G的每一条产生式α-&gt;β满足a属于V的正则闭包，且至少含有一个非终结符，而β属于V的闭包</td>
<td>图灵机</td>
</tr>
<tr>
<td>1型</td>
<td>上下文有关文法</td>
<td>G的任何产生式α-&gt;β满足|α|&lt;&#x3D;|β|，仅仅S-&gt;ε例外，但S不得出现在任何产生式右部</td>
<td>线性界限自动机</td>
</tr>
<tr>
<td>2型</td>
<td>上下文无关文法</td>
<td>G的任何产生式为A-&gt;β，A为非终结符，β为V的闭包</td>
<td>非确定的下推自动机</td>
</tr>
<tr>
<td>3型</td>
<td>正规文法</td>
<td>G的任何产生式为A-&gt;α B或A-&gt;α，α属于非终结符的闭包，A、B都属于非终结符</td>
<td>有限自动机</td>
</tr>
</tbody></table>
<p>用来进行语法规则的推导，通过推导树，我们可以了解到一种语法能够表达的串以及能够构造的句型是什么样子。</p>
<p>例 :  文法  G &#x3D; ( { a , b } , { S , A } , S , P )  ，其中:  </p>
<p>S → aAS ∣ a ; </p>
<p>A → SbA∣ SS ∣ ba  。  </p>
<p>请 构 造 句 型 a a b A a 的 推 导 树 。</p>
<p>文法G中{a,b}表示终结符，一般为小写字母。{S,A}表示非终结符，该种符号能够推导出其它符号。S就是其实符，P就是文法的产生式，即题目中形如α → β这类式子。</p>
<p>本体可见 </p>
<hr>
<p>S → aAS </p>
<p>而 A → SbA</p>
<p>所以原式变成：a（SbA）S</p>
<p>又因为 S → a，将所有的S换为a</p>
<p>得：S → aabAa</p>
<hr>
<p>先将题目中文法的产生式分解出来S → aAS ; S → a ; A → SbA ; A → SS ; A → ba<br>推导树就是类二叉树，最终取得的树的叶子节点需要符合aabAa就行了。<br>通过文法的产生式构成推导树，根的标记是S。</p>
<img src="https://s1.imagehub.cc/images/2022/10/16/image54095f2b66eb478e.png" alt="image54095f2b66eb478e.png" border="0" />

<h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><img src="https://s1.imagehub.cc/images/2022/10/16/image0a160d3bacfbe5c1.png" alt="image0a160d3bacfbe5c1.png" border="0" />

<img src="https://s1.imagehub.cc/images/2022/10/20/image6c17fceae8278dfe.png" alt="image6c17fceae8278dfe.png" border="0" />

<img src="https://s1.imagehub.cc/images/2022/10/20/image605afec652bdf5fc.png" alt="image605afec652bdf5fc.png" border="0" />

<h2 id="程序语言基础"><a href="#程序语言基础" class="headerlink" title="程序语言基础"></a>程序语言基础</h2><p>前缀表达式（+ab）</p>
<p>中缀表达式（a+b）</p>
<p>后缀表达式（ab-）</p>
<p>例如：(a-b)*(c+5)后缀式是</p>
<p>ab-c5+*</p>
<h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><p>传值调用：<br>将实参的值传递给形参，实参可以是变量、常量和表达式。不可以实现形参和实参间双向传递数据的效果<br>传引用（地址）调用：<br>将实参的地址传递给形参，形参必须有地址，实参不能是常量（值）,表达式可以实现形参和实参间双向传递数据的效果，即改变形参的值同时也改变了实参的值。</p>
<h2 id="程序语言基础-各种程序语言特点"><a href="#程序语言基础-各种程序语言特点" class="headerlink" title="程序语言基础-各种程序语言特点"></a>程序语言基础-各种程序语言特点</h2><img src="https://s1.imagehub.cc/images/2022/10/20/image6358b21559f18432.png" alt="image6358b21559f18432.png" border="0" />

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">软件设计师笔记(7)-数据结构与算法基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-15 21:37:27" itemprop="dateCreated datePublished" datetime="2022-10-15T21:37:27+08:00">2022-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-16 20:14:18" itemprop="dateModified" datetime="2022-10-16T20:14:18+08:00">2022-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h1><img src="https://s1.imagehub.cc/images/2022/10/15/image51b40b93b84d0e67.png" alt="image51b40b93b84d0e67.png" border="0" />

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><table>
<thead>
<tr>
<th>数组类型</th>
<th>存储地址计算</th>
</tr>
</thead>
<tbody><tr>
<td>一维数组a[n]</td>
<td>a[i]的存储地址为：a+i*len</td>
</tr>
<tr>
<td>二维数组a[m][n]</td>
<td>a[i][j]的存储地址（按行存储）为：a+(i*n+j)*len<br>a[i][j]的存储地址（按列存储）为：a+(j*m+i)*len</td>
</tr>
</tbody></table>
<h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><table>
<thead>
<tr>
<th>稀疏矩阵</th>
<th>示意图</th>
<th>要点（考试直接代入选项即可，不用记公式）</th>
</tr>
</thead>
<tbody><tr>
<td>上三角矩阵</td>
<td><img src="https://s1.imagehub.cc/images/2022/10/15/imagec906378e9d8229fb.png" alt="imagec906378e9d8229fb.png" border="0" /></td>
<td>在矩阵中下标分别为i和j的元素，对应的一维数组的下标计算公式为：(2n - i + 1) * i&#x2F;2 + j</td>
</tr>
<tr>
<td>下三角矩阵</td>
<td><img src="https://s1.imagehub.cc/images/2022/10/15/imageb813d9a211068020.png" alt="imageb813d9a211068020.png" border="0" /></td>
<td>在矩阵中下标分别为i和j的元素，对应的一维数组的下标计算公式为：(i + 1) * i&#x2F;2 + j</td>
</tr>
</tbody></table>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>等待补充</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">软件设计师笔记(6)-面向对象技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-14 16:00:30" itemprop="dateCreated datePublished" datetime="2022-10-14T16:00:30+08:00">2022-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-15 21:23:22" itemprop="dateModified" datetime="2022-10-15T21:23:22+08:00">2022-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象技术"><a href="#面向对象技术" class="headerlink" title="*面向对象技术"></a>*面向对象技术</h1><p>本节内容是考试的重点</p>
<img src="https://s1.imagehub.cc/images/2022/10/14/image3c246187eb8bb105.png" alt="image3c246187eb8bb105.png" border="0" />

<h2 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h2><ul>
<li>对象：<strong>属性（数据）+方法（操作）</strong>+对象ID</li>
<li>类（实体类&#x2F;控制类&#x2F;边界类）</li>
<li>继承与泛化：复用机制</li>
<li>封装：隐藏对象的属性和实现细节，仅对外公开接口</li>
<li>多态：不同对象收到<strong>同样的消息产</strong>生不同的结果</li>
<li>接口：一种特殊的类，他只有方法定义没有实现</li>
<li>重载：一个类可以有多个<strong>同名而参数类型不同的方法</strong></li>
<li>模板类</li>
<li>消息和消息通信：消息是异步通信的</li>
</ul>
<h3 id="面向对象设计7大原则"><a href="#面向对象设计7大原则" class="headerlink" title="面向对象设计7大原则"></a>面向对象设计7大原则</h3><ul>
<li>单一职责原则：设计目的单一的类</li>
<li>开放-封闭原则：对扩展开放，对修改封闭</li>
<li>李氏（Liskov）替换原则：子类可以替换父类</li>
<li>依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要面向实现编程。</li>
<li>接口隔离原则：使用多个专门的接口比使用单一的总接口要好</li>
<li>组合重用原则：要尽量使用组合，而不是继承关系达到重用目的。</li>
<li>迪米特（Demeter）原则（最少知识法则）：一个对象应当对其他对象有尽可能少的了解</li>
</ul>
<h2 id="UML（通用建模语言）"><a href="#UML（通用建模语言）" class="headerlink" title="*UML（通用建模语言）"></a>*UML（通用建模语言）</h2><table>
<thead>
<tr>
<th>图名</th>
<th>包含内容</th>
</tr>
</thead>
<tbody><tr>
<td>结构图</td>
<td><span style="color:red;font-weight:bold">类图</span><br>对象图<br># 包图<br/># 组合结构图（UML2.0新增内容）<br/>结构图<br/>部署图：软硬件之间映射<br/># 制品图</td>
</tr>
<tr>
<td>行为图</td>
<td><span style="color:red;font-weight:bold">用例图：系统与外部参与者的交互</span><br/>顺序图：强调按时间顺序<br/>通信图（协作图）<br/># 定时图（UML2.0新增内容）<br/>状态图<br/>活动图：类似程序流图，并行行为<br/># 交互概念图</td>
</tr>
</tbody></table>
<h3 id="类图"><a href="#类图" class="headerlink" title="* 类图"></a>* 类图</h3><ul>
<li>依赖关系：一个事物发生变化影响另一个事物。</li>
<li>泛化关系：特殊&#x2F;一般关系（继承关系）</li>
<li>关联关系：描述了一组链，链是对象之间的连接。<ul>
<li>聚合关系：整体与部分生命周期不同。</li>
<li>组合关系：整体与部分生命周期相同。</li>
</ul>
</li>
<li>实现关系：接口与类之间的关系</li>
</ul>
<img src="https://s1.imagehub.cc/images/2022/10/14/image6048ef5257548366.png" alt="image6048ef5257548366.png" border="0" />

<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="* 设计模式的分类"></a>* 设计模式的分类</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><ul>
<li><span style="color:red;font-weight:bold">工厂方法（factory method）模式</span></li>
<li><span style="color:red;font-weight:bold">抽象工厂（abstract factory）模式</span></li>
<li>原型（prototype）模式</li>
<li><span style="color:red;font-weight:bold">单例（singleton）模式</span></li>
<li>构建器（builder）模式</li>
</ul>
<table>
<thead>
<tr>
<th>设计模式名称</th>
<th>需要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td><span style="color:red;font-weight:bold">Abstract factory&lt;<br/>抽象工厂模式</span></td>
<td>提供一个接口，可以创建一系列相关或相互依赖的对象而无需指定他们具体的类</td>
<td>生产成系列对象</td>
</tr>
<tr>
<td>Builder<br/>构建器模式</td>
<td>将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示</td>
<td>复杂对象构造</td>
</tr>
<tr>
<td><span style="color:red;font-weight:bold">Factory Method<br/>工厂方法模式</span></td>
<td>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟</td>
<td>动态生产对象</td>
</tr>
<tr>
<td>Prototype<br/>原型模式</td>
<td>用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象</td>
<td>克隆对象</td>
</tr>
<tr>
<td><span style="color:red;font-weight:bold">Singleton<br/>单列模式</span></td>
<td>保证一个类只有一个实例，并提供一个访问他的全局访问点</td>
<td>单实例</td>
</tr>
</tbody></table>
<h5 id="工厂模式（Factory-Method）"><a href="#工厂模式（Factory-Method）" class="headerlink" title="工厂模式（Factory Method）"></a>工厂模式（Factory Method）</h5><p>工厂模式的意图是：定义一个创建对象的接口，但由子类决定需要实例化哪一个类工厂方法使得子类实例化的过程推迟。</p>
<img src="https://s1.imagehub.cc/images/2022/10/15/image.png" alt="image.png" border="0" />

<ul>
<li>Product：产品角色定义产品的接口。</li>
<li>ConcreteProduct：真实的产品，实现接口Product的类。</li>
<li>Creator：工厂角色声明工厂方法（Factory Method)，返回一个产品</li>
<li>ConcreteCreator：真实的工厂实现Factory Method工厂方法，由客户调用，返回一个产品的实例。</li>
</ul>
<h5 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h5><p>抽象工厂模式的意图是：提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</p>
<img src="https://s1.imagehub.cc/images/2022/10/15/imageb6a57e0899ad799e.png" alt="imageb6a57e0899ad799e.png" border="0" />

<ul>
<li>AbstractFactory：抽象工厂，声明抽象产品的方法。</li>
<li>ConcreteFactory：具体工厂，执行生成抽象产品的方法，生成一个具体的产品。</li>
<li>AbstractProduct：抽象产品，为一种产品声明接口。</li>
<li>Product：”具体产品，定义具体工厂生成的具体产品的对象，实现产品接口，</li>
<li>Client：客户，我们的应用程序使用抽象产品和抽象工厂生成对象。</li>
</ul>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><ul>
<li><span style="color:red;font-weight:bold">适配器（adapter）模式</span></li>
<li><span style="color:red;font-weight:bold">桥接（bridge）模式</span></li>
<li><span style="color:red;font-weight:bold">组合（composite）模式</span></li>
<li><span style="color:red;font-weight:bold">装饰（decorator）模式</span></li>
<li>外观（facade）模式</li>
<li>享元（flyweight）模式</li>
<li>代理（proxy）模式</li>
</ul>
<table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td><span style="color:red;font-weight:bold">Adapter<br/>适配器模式</span></td>
<td>将一个类的接口转换成用户希望得到的另一种接口，他使原本不相容的接口得以协同工作</td>
<td>转换接口</td>
</tr>
<tr>
<td><span style="color:red;font-weight:bold">Bridge<br/>桥接模式</span></td>
<td>将类的抽象部分和他的实现部分分离开来，使他们可以独立的变化</td>
<td>继承树拆分</td>
</tr>
<tr>
<td><span style="color:red;font-weight:bold">Composite<br/>组合模式</span></td>
<td>将对象组合成树型结构以表示“整体-部分”的层次结构使得用户对单个对象和组合对象的使用具有一致性</td>
<td>树形目录结构</td>
</tr>
<tr>
<td><span style="color:red;font-weight:bold">Decorator<br/>装饰模式</span></td>
<td>动态地给一个对绿添加一些颜外的职责。它提供了用子类 广展功能的 下灵活的替代，比派生一个子类更加灵活</td>
<td>附加职责</td>
</tr>
<tr>
<td>Facade<br/>外观模式</td>
<td>是义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用</td>
<td>对外统一接口</td>
</tr>
<tr>
<td>Flyweight<br/>享元模式</td>
<td>提供支持大量细粒度对象共事的有效方法</td>
<td>文章共事文字对象</td>
</tr>
<tr>
<td>Proxy<br/>代理模式</td>
<td>为其他对象提供一种代理以控制这个对象的访问</td>
<td></td>
</tr>
</tbody></table>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><ul>
<li><span style="color:red;font-weight:bold">职责链（chain of responsibility）模式</span></li>
<li><span style="color:red;font-weight:bold">命令（command）模式</span></li>
<li><span style="color:red;font-weight:bold">解释器（interpreter）模式</span></li>
<li>选代器（iterator）模式</li>
<li>中介者（mediator）模式</li>
<li>备忘录（memento）模式</li>
<li><span style="color:red;font-weight:bold">观察者（observer）模式</span></li>
<li>状态（state）模式</li>
<li><span style="color:red;font-weight:bold">策略（strategy）模式</span></li>
<li>操板方法（template method）模式</li>
<li>访问者（visitor）模式</li>
</ul>
<table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Chain of Responsibility<br>职责链模式</td>
<td>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合，将接收对象链接起来，在链中传请求，直到有一个对象处理这个请求</td>
<td>传递职责</td>
</tr>
<tr>
<td>Command<br/>命令模式</td>
<td>将一个请求封装为一个对象，从而可用不同的请求对户进行参数化，将请求排队或记录请求日志，支持可销的操作</td>
<td>日志记录，可撤销</td>
</tr>
<tr>
<td>Interpreter<br/>解释器模式</td>
<td>给定一种语言，定义它的文法表示，并定义一个解释该解释器用来根据文法表示来解释语言中的句子</td>
<td>虚拟机的机制</td>
</tr>
<tr>
<td>Iterator<br/>迭代器模式</td>
<td>提供一种方法来原序访间一个聚合对象中的各个元素而不需要暴量该对象的内部表示</td>
<td>数据库数据集</td>
</tr>
<tr>
<td>Mediator<br/>中介者模式</td>
<td>一个中介对象来封装一系列的对象交互，它使各对将要显式地相互调用，从而达到低精合，还可以独他改变对象间的交互</td>
<td>不直接引用</td>
</tr>
<tr>
<td>Memento<br/>备忘录模式</td>
<td>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态</td>
<td></td>
</tr>
<tr>
<td>Observer<br/>观察者模式</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态生改变时，所有依赖于它的对象都得到通知并自动更新</td>
<td>联动</td>
</tr>
<tr>
<td>State<br/>状态模式</td>
<td>允许一个对象在其内部状态改变时改变它的行为</td>
<td>状态变成类</td>
</tr>
<tr>
<td>Strategy<br/>策略模式</td>
<td>定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化</td>
<td>多方案切换</td>
</tr>
<tr>
<td>Template Method<br/>模板方法模式</td>
<td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可置新定义算法的专特定步量</td>
<td></td>
</tr>
<tr>
<td>Visitor<br/>访问者模式</td>
<td>表示一个作用于某对象结构中的各元素的操作，使得在不变各元素的类的前提下定义作用于这些完素的新操作</td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/10/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-5-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/10/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0-5-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">软件设计师笔记(5)-系统开发基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-10 22:18:04" itemprop="dateCreated datePublished" datetime="2022-10-10T22:18:04+08:00">2022-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-13 22:38:15" itemprop="dateModified" datetime="2022-10-13T22:38:15+08:00">2022-10-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统开发基础"><a href="#系统开发基础" class="headerlink" title="系统开发基础"></a>系统开发基础</h1><img src="https://s1.imagehub.cc/images/2022/10/10/imagec7b2c307d463c0ab.png" alt="imagec7b2c307d463c0ab.png" border="0" />

<h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>以线性的顺序将软件开发的过程分成好几个阶段。</p>
<p>其中的软件设计分为概要设计，详细设计</p>
<ul>
<li><p>瀑布模型的优点：</p>
</li>
<li><ul>
<li>为项目提供了按阶段划分的检查点</li>
<li>当前一个阶段完成后，只需要去关注后续阶段</li>
<li>它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导</li>
</ul>
</li>
<li><p>瀑布模型的缺点：</p>
</li>
<li><ul>
<li>各个阶段之间产生大量的文档，极大地增加了工作量</li>
<li>由于开发模型是线型的，用户只有等到整个过程的末期才能见到开发结果，从而增加了开发风险</li>
<li>不适应用户需求的变化，并且在需求分析阶段不可能完全获取</li>
<li>在软件开发前期未发现的错误传到后面的开发活动中时，可能会扩散，进而可能会导致整个软件项目开发失败</li>
</ul>
</li>
<li><p>所以，瀑布模型适用于需求明确或很少变更的项目</p>
</li>
</ul>
<img src="https://s1.imagehub.cc/images/2022/10/12/image6451f5d9b57ac033.png" alt="image6451f5d9b57ac033.png" border="0" />

<h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>是瀑布模型的升级版本，以重视测试为基础。</p>
<p>在单元测试中，主要是对编码进行测试，以详细设计说明书为基础，以此类推。最终的验收测试是以用户为基准的测试。</p>
<p>缺点及将测试放在了编码之后。</p>
<img src="https://s1.imagehub.cc/images/2022/10/13/image9705510f35aa9bc4.png" alt="image9705510f35aa9bc4.png" border="0" />

<h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>专门用于面向对象的模型</p>
<ul>
<li>是一种以用户需求为动力，以对象为驱动地模型，主要用于描述面向对象的软件开发过程，该模型认为软件开发过程自下而上的，各阶段是相互迭代和无间隙的。</li>
<li>无间隙是指在开发活动中，分析、设计和编码之间不存在明显的边界</li>
</ul>
<img src="https://s1.imagehub.cc/images/2022/10/13/imagec3e726ed4e502615.png" alt="imagec3e726ed4e502615.png" border="0" />

<h3 id="原型化模型"><a href="#原型化模型" class="headerlink" title="原型化模型"></a>原型化模型</h3><ul>
<li><p>快速原型是利用原型辅助软件开发的一种新思想</p>
</li>
<li><p>经过简单快速分析，快速建造一个可以运行的软件原型，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的用户需求基础上开发客户满意的软件产品</p>
</li>
<li><p>原型可以为三类：</p>
</li>
<li><ul>
<li>探索型原型：主要用于需求分析阶段，目的是要弄清用户的需求，并探索各种方案的可行性。它主要针对开发目标模糊，用户与开发人员对项目都缺乏经验的情况，通过对原型的开发来明确用户的需求</li>
<li>实验型原型：主要用于设计阶段，考核实现方案是否合适，能否实现。对于大型系统，若对设计方案心中没有把握时，可通过这种原型来证实设计方案的正确性</li>
<li>演化型原型：主要用于及早向用户提交一个原型系统，该原型系统或者包含系统的框架，或者包含系统的主要功能，在得到用户的认可后，将原型系统不断扩充演变为最终的软件系统</li>
</ul>
</li>
<li><p>它将原型的思想扩展到软件开发的全过程</p>
</li>
</ul>
<h3 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h3><ul>
<li><p>也称为变换模型，根据用户的基本需求，通过快速分析构造出一个初始可运行版本(原型)，然后根据用户在使用原型的过程中提出的意见和建议对原型进行改进，获得原型的新版本。重复这一过程，最终可得到令用户满意的软件产品</p>
</li>
<li><p>快速原型模型时“抛弃式”的，演化模型是“渐进式”原型方法。演化模型特别适用于对软件需求缺乏准确认识的情况</p>
</li>
<li><p>演化模型的优点：</p>
</li>
<li><ul>
<li>很早就可以验证是否符合产品需求</li>
<li>风险管理可以在早期就获得项目进程数据，可据此对后续的开发进度作出比较切实的估算，增加项目成功的机率</li>
<li>经验教训能反馈于本产品的下一个循环过程，提高质量效率</li>
<li>心理上，开发人员早日见到产品的雏形，是一种鼓舞</li>
<li>使用户可以在新的一批功能开发测试后，立即参加验证，以便提供非常有价值的反馈</li>
</ul>
</li>
<li><p>演化模型的缺点</p>
</li>
<li><ul>
<li>产品需求在一开始并不安全弄清楚的话，会给总体设计带来困难及削弱产品设计的完整性，并影像产品性能的优化</li>
<li>如果缺乏严格的过程管理，这个生命周期模型可能退化为一种原始的无计划的“试 - 错 - 改”模式</li>
<li>用户接触开发中的尚未测试稳定的功能，可能对用户产生负面的影响</li>
</ul>
</li>
</ul>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><ul>
<li><p>将瀑布模型和演化模型相结合，综合了两者的优点，并增加了风险分析。它以原型为基础，沿着螺线自内向外旋转，每旋转一圈都要经过制订计划、风险分析、实施工程及客户评价等活动，并开发原型的一个新版本。经过若干次螺旋上升的过程，得到最终的系统</p>
</li>
<li><p>螺旋模型的优点：</p>
</li>
<li><ul>
<li>设计上灵活，可以在项目的各个阶段进行变更</li>
<li>以小的分段来构建大型系统，使成本计算变得简单容易</li>
<li>客户始终参与每个阶段的开发，保证了项目不偏离正确方向</li>
<li>随着项目推进，客户始终掌握项目的最新信息，从而能够和管理层有效地交互</li>
</ul>
</li>
<li><p>螺旋模型地缺点：</p>
</li>
<li><ul>
<li>需要具有相当丰富地风险评估经验和专门知识，如果未能够及时标识风险，势必造成重大损失</li>
<li>过多地迭代次数会增加开发成本，延迟提交时间</li>
</ul>
</li>
<li><img src="https://s1.imagehub.cc/images/2022/10/13/imageab3de0d2f7aa2b58.png" alt="imageab3de0d2f7aa2b58.png" border="0" /></li>
</ul>
<h3 id="统一过程-UP-x2F-RUP"><a href="#统一过程-UP-x2F-RUP" class="headerlink" title="统一过程**(UP&#x2F;RUP)**"></a>统一过程**(UP&#x2F;RUP)**</h3><ul>
<li><p>是一个通用过程框架，可以用于种类广泛的软件系统、不同的应用领域、不同的组织类型、不同的性能水平和不同的项目规模</p>
</li>
<li><p>UP是基于构件的，软件系统建模时，UP使用的时UML</p>
</li>
<li><p>与其他软件过程相比，UP具有三个显著的特点：</p>
</li>
<li><ul>
<li>用例驱动</li>
<li>以体系结构为中心</li>
<li>迭代和增量</li>
</ul>
</li>
<li><p>UP中的软件过程在时间上被分解为四个阶段：</p>
</li>
<li><ul>
<li>初始阶段</li>
<li>细化阶段</li>
<li>构建阶段</li>
<li>交付阶段</li>
</ul>
</li>
<li><p>每个阶段结束时都要安排一次技术评审，以确定这个阶段的目标是否已经达到</p>
</li>
</ul>
<img src="https://s1.imagehub.cc/images/2022/10/13/image531c0a7b2d7ad4b8.png" alt="image531c0a7b2d7ad4b8.png" border="0" />

<h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><ul>
<li><p>敏捷开发更强调程序员团队与业务专家之间的紧密协作、面对面沟通、频繁交付新的软件版本、紧凑而自我组织型的团队、能够和好的适应需求变化的代码编写和团队组织方法，也更注重人的作用</p>
</li>
<li><p>常见的敏捷开发方法：</p>
</li>
<li><ul>
<li>极限编程(XP)：<strong>费用严格控制方法</strong></li>
<li>自适应软件开发（ASD）：<strong>猜测、合作和学习</strong></li>
<li>开放式源码：<strong>异地开发</strong></li>
<li>水晶方法：<strong>用最少的纪律约束</strong></li>
<li>FDD（功用驱动开发）：<strong>首席带类程序员（大佬带小弟）</strong></li>
<li>scrum（并列争球法）：<strong>定义重复人员去解决重复方法</strong></li>
</ul>
</li>
<li><p>从开发者的角度，主要的关注点：</p>
</li>
<li><ul>
<li>短平快会议</li>
<li>小版本发布</li>
<li>较少的文档</li>
<li>合作为重</li>
<li>客户直接参与</li>
<li>自动化测试</li>
<li>适应性计划调整</li>
<li>结对编程</li>
</ul>
</li>
<li><p>从管理者的角度，主要的关注点</p>
</li>
<li><ul>
<li>测试驱动开发</li>
<li>持续集成</li>
<li>重构</li>
</ul>
</li>
</ul>
<img src="https://s1.imagehub.cc/images/2022/10/13/imagee030755ceb94562b.png" alt="imagee030755ceb94562b.png" border="0" />

<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><table>
    <tr>
        <td rowspan="4">黑盒测试法</td>
        <td>等价类划分</td>
    </tr>
    <tr>
        <td>边界值分析</td>
    </tr>
    <tr>
        <td>错误推测</td>
    </tr>
    <tr>
        <td>因果图</td>
    </tr>
    <tr>
        <td rowspan="5">等价类划分</td>
        <td>语句覆盖</td>
    </tr>
    <tr>
        <td>判定覆盖</td>
    </tr>
    <tr>
        <td>条件覆盖</td>
    </tr>
    <tr>
        <td>条件判定覆盖</td>
    </tr>
    <tr>
        <td>边路径覆盖</td>
    </tr>
    <tr>
        <td>灰盒测试法</td>
    </tr>
</table>

<h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><ul>
<li>确定无效与有效等价类</li>
<li>设计用例尽可能多的覆盖有效类</li>
<li>设计用例只覆盖一个无效类</li>
</ul>
<h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><ul>
<li>处理边界情况时最容易出错</li>
<li>选取的测试数据应该恰好等于，稍小于或者稍大于边界值</li>
</ul>
<h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><table>
    <tr>
        <td>桌前检查</td>
    </tr>
    <tr>
        <td>代码审查</td>
    </tr>
    <tr>
        <td>代码走查</td>
    </tr>
</table>

<h3 id="V模型的测试内容"><a href="#V模型的测试内容" class="headerlink" title="V模型的测试内容"></a>V模型的测试内容</h3><img src="https://s1.imagehub.cc/images/2022/10/13/image08e843d56a4ba6e7.png" alt="image08e843d56a4ba6e7.png" border="0" />

<h3 id="McCabe复杂度（环路复杂度）"><a href="#McCabe复杂度（环路复杂度）" class="headerlink" title="McCabe复杂度（环路复杂度）"></a>McCabe复杂度（环路复杂度）</h3><p>计算有向图的环路复杂度公式为：<br>$$<br>V(G)&#x3D;m-n+2&#x3D;边数-点数+2<br>$$<br>其中V（G）是有向图G中的环路个数，m是G中的有向弧数，n是G中的节点数</p>
<p>即说明需要多少测试用例。</p>
<img src="https://s1.imagehub.cc/images/2022/10/13/image8364a49d3e207969.png" alt="image8364a49d3e207969.png" border="0" />

<h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><table>
    <tr>
        <td rowspan=3>可维护性因素决定</td>
        <td>可理解性</td>
    </tr>
    <tr>
        <td>可测试性</td>
    </tr>
    <tr>
        <td>可修改性</td>
    </tr>
    <tr>
        <td rowspan=4>软件维护类型</td>
        <td>改正性维护（25%）</td>
    </tr>
    <tr>
        <td>适应性维护（20%）</td>
    </tr>
    <tr>
        <td>预防性维护（5%）</td>
    </tr>
    <tr>
        <td>完善性维护<span style="color:red">（50%）</span></td>
    </tr>
</table>

<p><strong>适应性维护</strong>，指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。</p>
<p><strong>完善性维护</strong>。扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</p>
<h2 id="软件文档"><a href="#软件文档" class="headerlink" title="软件文档"></a>软件文档</h2><h3 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h3><ul>
<li>可行性研究和项目任务书</li>
<li>需求规格说明</li>
<li>功能规格说明</li>
<li>设计规格说明（包括程序和数据规格说明）</li>
<li>开发计划</li>
<li>软件集成和测试计划</li>
<li>质量保证计划、标准、进度</li>
<li>安全和测试信息</li>
</ul>
<h3 id="产品文档（用户）"><a href="#产品文档（用户）" class="headerlink" title="产品文档（用户）"></a>产品文档（用户）</h3><ul>
<li>培训手册</li>
<li>参考手册和用户指南</li>
<li>软件支持手册</li>
<li>产品手册和信息广告</li>
</ul>
<h3 id="管理文档"><a href="#管理文档" class="headerlink" title="管理文档"></a>管理文档</h3><ul>
<li>开发过程的每个阶段的进度和进程变更的记录</li>
<li>软件变更情况的记录</li>
<li>相对于开发的判定记录</li>
<li>职责定义</li>
</ul>
<h2 id="外部和内部质量"><a href="#外部和内部质量" class="headerlink" title="外部和内部质量"></a>外部和内部质量</h2><table>
    <tr>
        <td>功能性</td>
        <td>混合性<br>准确性<br>互操作性<br>安全保密性<br></td>
        <td>功能性的依从性</td>
    </tr>
    <tr>
        <td>可靠性</td>
        <td>成熟性<br>容错性<br>易恢复性</td>
        <td>可靠性的依从性</td>
    </tr>
    <tr>
        <td>*易用性</td>
        <td>易理解性<br>易学性<br>易操作性<br>吸引性</td>
        <td>易用性的依从性</td>
    </tr>
    <tr>
        <td>效率</td>
        <td>时间特性<br>资源利用性</td>
        <td>效率依从性</td>
    </tr>
    <tr>
        <td>维护性</td>
        <td>易分析性<br>易改变性<br>稳定性<br>易测试性</td>
        <td>维护性的依从性</td>
    </tr>
    <tr>
        <td>可移植性</td>
        <td>适应性<br>易安装性<br>共存性<br>易替换性</td>
        <td>可移植性的依从性</td>
    </tr>
</table>

<h2 id="软件过程改进CMMI"><a href="#软件过程改进CMMI" class="headerlink" title="软件过程改进CMMI"></a>软件过程改进CMMI</h2><img src="https://s1.imagehub.cc/images/2022/10/13/image7dbcac9b39815f92.png" alt="image7dbcac9b39815f92.png" border="0" />

<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>风险暖光度（Risk Exposure):计算方法是风险出现的概率乘以风险可能造成的损失。</p>
<img src="https://s1.imagehub.cc/images/2022/10/13/imagedd08f005c92e45bd.png" alt="imagedd08f005c92e45bd.png" border="0" />



<h3 id="九大知识领域"><a href="#九大知识领域" class="headerlink" title="九大知识领域"></a>九大知识领域</h3><ol>
<li>范围管理</li>
<li><span style="color:red">时间管理</span></li>
<li>成本管理</li>
<li>质量管理</li>
<li>人力资源管理</li>
<li>沟通管理</li>
<li><span style="color:red">风险管理</span></li>
<li>采购管理</li>
<li>整体管理</li>
</ol>
<h4 id="时间管理-关键路径法"><a href="#时间管理-关键路径法" class="headerlink" title="时间管理-关键路径法"></a>时间管理-关键路径法</h4><p>关键路径法是在制订进度计划时使用的一种进度网络分析技术，关路线法沿着项目进度网络路线进行正向与反向分析，从而计算出所有计划活动理论上的最早开始与完成日期、最迟开始与完成日期，不考虑任何资源限制。<br>总时差（松驰时间）：在不延误总工期的前提下，该活动的机动时间活动的总时差等于该活动最迟完成时间与最早完成时间之差，或该活动最迟开始时间与最早开始时间之差。</p>
<h4 id="前导图法（单代号网络图，PDM）"><a href="#前导图法（单代号网络图，PDM）" class="headerlink" title="前导图法（单代号网络图，PDM）"></a>前导图法（单代号网络图，PDM）</h4><p>求工期最长的那条路</p>
<img src="https://s1.imagehub.cc/images/2022/10/13/image9eec0c4475edda45.png" alt="image9eec0c4475edda45.png" border="0" />

<h4 id="箭线图法（双代号网络图，ADM）"><a href="#箭线图法（双代号网络图，ADM）" class="headerlink" title="箭线图法（双代号网络图，ADM）"></a>箭线图法（双代号网络图，ADM）</h4><img src="https://s1.imagehub.cc/images/2022/10/13/imagea34e95fb362eece5.png" alt="imagea34e95fb362eece5.png" border="0" />


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
