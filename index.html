<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/meideblog/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MEIDE&#39;S BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MEIDE&#39;S BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MEIDE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>MEIDE'S BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MEIDE'S BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/15/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Spring面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-15 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-15T13:26:38+08:00">2024-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-17 01:19:49" itemprop="dateModified" datetime="2024-05-17T01:19:49+08:00">2024-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 是一个轻量级的IoC 和AOP 容器框架。是为Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML 的配置、基于注解的配置、基于Java 的配置。<br>主要由以下几个模块组成：<br>Spring Core ：核心类库，提供IOC 服务；<br>Spring Context：提供框架式的Bean 访问方式，以及企业级功能（JNDI、定时任务等）；<br>Spring AOP：AOP 服务；<br>Spring DAO：对JDBC 的抽象，简化了数据访问异常的处理；<br>Spring ORM：对现有的ORM 框架的支持；<br>Spring Web：提供了基本的面向Web 的综合特性，例如多方文件上传；<br>Spring MVC：提供面向Web 应用的Model-View-Controller 实现。</p>
<h2 id="Autowired和Resource关键字的区别？"><a href="#Autowired和Resource关键字的区别？" class="headerlink" title="Autowired和Resource关键字的区别？"></a>Autowired和Resource关键字的区别？</h2><p>@Resource 和@Autowired 都是做bean 的注入时使用，其实@Resource 并不是Spring 的注解，它的包是javax.annotation.Resource ，需要导入，但是Spring 支持该注解的注入。<br>1、共同点<br>两者都可以写在字段和setter 方法上。两者如果都写在字段上，那么就不需要再写setter 方法。<br>2、不同点<br>（ 1 ）@Autowired@Autowired 为Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired；只按照byType 注入。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null 值，可以设置它的required 属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier 注解一起使用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>@Resource 默认按照ByName 自动注入，由J2EE 提供，需要导入包javax.annotation.Resource。</p>
<p>@Resource 有两个重要的属性： name 和type，而Spring 将@Resource 注解的name 属性解析为</p>
<p>bean 的名字，而type 属性则解析为bean 的类型。所以，如果使用name 属性，则使用byName的自动注入策略，而使用type 属性时则使用byType 自动注入策略。如果既不指定name 也不指定type 属性，这时将通过反射机制使用byName 自动注入策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="comment">// 下面两种@Resource 只要使用一种即可</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的setter 方法</span></span><br><span class="line">上<span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Resource 装配顺序：<br>①如果同时指定了name 和type，则从Spring 上下文中找到唯一匹配的bean 进行装配，找不到则抛出异常。<br>②如果指定了name ，则从上下文中查找名称（id）匹配的bean 进行装配，找不到则抛出异常。<br>③如果指定了type，则从上下文中找到类似匹配的唯一bean 进行装配，找不到或是找到多个，都会抛出异常。<br>④如果既没有指定name ，又没有指定type，则自动按照byName 方式进行装配；如果没有匹配， 则回退为一个原始类型进行匹配，如果匹配则自动装配。<br>@Resource 的作用相当于@Autowired，只不过@Autowired 按照byType 自动注入。</p>
<h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p><strong>构造器注入</strong>将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</p>
<p>优点： 对象初始化完成后便可获得可使用的对象。<br>缺点： 当需要注入的对象很多时，构造器参数列表将会很长； 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</p>
<h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>setter方法注入loC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。<br>优点：灵活。可以选择性地注入需要的对象。<br>缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</p>
<h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>接口注入依赖类必须实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。<br>优点接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。<br>缺点： 侵入性太强，不建议使用。<br>PS：什么是侵入行？ 如果类A 要使用别人提供的一个功能，若为了使用这功能，需要在自己的<br>类中增加额外的代码，这就是侵入性。</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>MVC：MVC 是一种设计模式<br>MVC 的原理图：</p>
<ul>
<li>M-Model 模型（完成业务逻辑：由javaBean 构成，service+dao+entity）</li>
<li>V-View 视图（做界面的展示jsp ，html…… ）</li>
<li>C-Controller 控制器（接收请求—〉调用模型—〉根据结果派发页面）</li>
</ul>
<p>springMVC 是一个MVC 的开源框架，springMVC&#x3D;struts2+spring ，springMVC 就相当于是Struts2加上spring 的整合，</p>
<p>可以简单地把springMVC 理解为是spring 的一个模块（类似AOP ，IOC 这样的模块），网络上经常会说springMVC 和spring 无缝集成，其实springMVC<br>就是spring 的一个子模块，所以根本不需要同spring 进行整合。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405160110946.png"/>

<ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView。</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View。</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<p>以下组件通常使用框架提供实现：</p>
<p>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p>
<p>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。</p>
<p>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p>
<p><strong>组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong></p>
<p>作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
<p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p>
<p>作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p><strong>3、处理器适配器HandlerAdapter</strong></p>
<p>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p><strong>4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong></p>
<p>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>
<p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong></p>
<p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>
<p><strong>6、视图View(需要工程师开发jsp…)</strong></p>
<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>
<h3 id="下边两个组件通常情况下需要开发："><a href="#下边两个组件通常情况下需要开发：" class="headerlink" title="下边两个组件通常情况下需要开发："></a>下边两个组件通常情况下需要开发：</h3><p>Handler：处理器，即后端控制器用controller表示。</p>
<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>
<h2 id="SpringMVC常用的注解"><a href="#SpringMVC常用的注解" class="headerlink" title="SpringMVC常用的注解"></a>SpringMVC常用的注解</h2><p>@RequestMapping：用于处理请求url 映射的注解，可用于类或方法上。用于类上，则表示类<br>中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http 请求的json 数据，将json 转换为java 对象。</p>
<p>@ResponseBody：注解实现将conreoller 方法返回对象转化为json 对象响应给客户。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块<br>所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的<br>重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p>
<p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP 就会使用<br>JDK 动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK 动态代理，转而使<br>用CGlib 动态代理生成一个被代理对象的子类来作为代理。</p>
<h3 id="Spring-AOP-和-Aspect-AOP-有什么区别？"><a href="#Spring-AOP-和-Aspect-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 Aspect] AOP 有什么区别？"></a>Spring AOP 和 Aspect] AOP 有什么区别？</h3><p>Spring AOP 是属于运行时增强，而AspectJ 是编译时增强。Spring AOP 基于代理（Proxying），而AspectJ 基于字节码操作（Bytecode Manipulation）。</p>
<p>Spring AOP 已经集成了AspectJ ，AspectJ 应该算得上是Java 生态系统中最完整的AOP 框架了。AspectJ 相比于Spring AOP 功能更加强大，但是Spring AOP 相对来说更简单。</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它<br>比SpringAOP 快很多。</p>
<h3 id="在SpringAOP中，关注点和横切关注的区别是什么？"><a href="#在SpringAOP中，关注点和横切关注的区别是什么？" class="headerlink" title="在SpringAOP中，关注点和横切关注的区别是什么？"></a>在SpringAOP中，关注点和横切关注的区别是什么？</h3><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<p>那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP 的位置。</p>
<p>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
<h3 id="通知-与-通知的类型"><a href="#通知-与-通知的类型" class="headerlink" title="通知 与 通知的类型"></a>通知 与 通知的类型</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的<br>代码段。<br>Spring切面可以应用五种类型的通知：</p>
<ul>
<li>before: 前置通知，在一个方法执行前被调用。</li>
<li>after: 在方法执行之后调用的通知，无论方法执行是否成功。</li>
<li>after-returning: 仅当方法成功完成后执行的通知。</li>
<li>after-throwing: 在方法抛出异常退出时执行的通知。</li>
<li>around: 在方法执行之前和之后调用的通知。</li>
</ul>
<h2 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h2><p>IOC 就是控制反转，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖IoC 容器来动态注入对象需要的外部资源。</p>
<p>最直观的表达就是，IOC 让对象的创建不用去new 了，可以由spring 自动生产，使用java的反射机制，根据配置文件在运行时动态地去创建对象以及管理对象，并调用对象的方法的。</p>
<p>Spring 的IOC 有三种注入方式：构造器注入、setter 方法注入、根据注解注入。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161629381.png"/>

<h2 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h2><p>首先说一下Servlet 的生命周期：实例化，初始init，接收请求service，销毁destroy；</p>
<p>Spring 上下文中的Bean 生命周期也类似，如下：</p>
<h3 id="实例化Bean-："><a href="#实例化Bean-：" class="headerlink" title="实例化Bean ："></a>实例化Bean ：</h3><p>对于BeanFactory 容器，当客户向容器请求一个尚未初始化的bean 时，或初始化bean 的时候需要注入另一个尚未初始化的依赖时， 容器就会调用createBean 进行实例化。对于ApplicationContext 容器，当容器启动结束后，通过获取BeanDefinition 对象中的信息，实例化所有的bean。</p>
<h3 id="设置对象属性（依赖注入）："><a href="#设置对象属性（依赖注入）：" class="headerlink" title="设置对象属性（依赖注入）："></a>设置对象属性（依赖注入）：</h3><p>实例化后的对象被封装在BeanWrapper 对象中，紧接着，Spring 根据BeanDefinition 中的信<br>息以及通过BeanWrapper 提供的设置属性的接口完成依赖注入。</p>
<h3 id="处理Aware-接口："><a href="#处理Aware-接口：" class="headerlink" title="处理Aware 接口："></a>处理Aware 接口：</h3><p>接着，Spring 会检测该对象是否实现了xxxAware 接口，并将相关的xxxAware 实例注入Bean ：</p>
<ol>
<li>如果这个Bean 已经实现了BeanNameAware 接口，会调用它实现的setBeanName(String beanId）方法，此处传递的就是Spring 配置文件中Bean 的id 值；</li>
<li>如果这个Bean 已经实现了BeanFactoryAware 接口，会调用它实现的setBeanFactory(）方法，传递的是Spring 工厂自身。</li>
<li>如果这个Bean 已经实现了ApplicationContextAware 接口，会调用<br>setApplicationContext(ApplicationContext）方法，传入Spring上下文</li>
</ol>
<h3 id="BeanPostProcessor："><a href="#BeanPostProcessor：" class="headerlink" title="BeanPostProcessor："></a>BeanPostProcessor：</h3><p>如果想对Bean 进行一些自定义的处理，那么可以让Bean 实现了BeanPostProcessor 接口，那<br>将会调用postProcessBeforeInitialization(Object obj, Strings）方法。</p>
<h3 id="InitializingBean-与init-method-："><a href="#InitializingBean-与init-method-：" class="headerlink" title="InitializingBean 与init-method ："></a>InitializingBean 与init-method ：</h3><p>如果Bean 在Spring 配置文件中配置了init-method 属性，则会自动调用其配置的初始化方法。</p>
<h3 id="BeanPostProcessor：-1"><a href="#BeanPostProcessor：-1" class="headerlink" title="BeanPostProcessor："></a>BeanPostProcessor：</h3><p>如果这个Bean 实现了BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, Strings）方法；由于这个方法是在Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>
<p><strong>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个Bean 了。</strong></p>
<h3 id="DisposableBean-："><a href="#DisposableBean-：" class="headerlink" title="DisposableBean ："></a>DisposableBean ：</h3><p>当Bean 不再需要时，会经过清理阶段，如果Bean 实现了DisposableBean 这个接口，会调用其实现的destroy(）方法；</p>
<h3 id="destroy-method-："><a href="#destroy-method-：" class="headerlink" title="destroy-method ："></a>destroy-method ：</h3><p>最后，如果这个Bean 的Spring 配置中配置了destroy-method 属性，会自动调用其配置的销<br>毁方法。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161641151.png"/>

<h2 id="Spring支持的几种bean的作用域？"><a href="#Spring支持的几种bean的作用域？" class="headerlink" title="Spring支持的几种bean的作用域？"></a>Spring支持的几种bean的作用域？</h2><p>Spring 容器中的bean 可以分为5 个范围：</p>
<ol>
<li>singleton：默认，每个容器中只有一个bean 的实例，<strong>单例的模式</strong>由<strong>BeanFactory 自身来维护</strong>。</li>
<li>prototype：<strong>为每一个bean 请求提供一个实例。</strong></li>
<li>request：<strong>为每一个网络请求创建一个实例</strong>，在请求完成以后，<strong>bean 会失效并被垃圾回收器回收</strong>。</li>
<li>session：与request 范围类似，<strong>确保每个session 中有一个bean 的实例</strong>，<strong>在session 过期后， bean 会随之失效</strong>。</li>
<li>global-session：全局作用域，global-session 和Portlet 应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet 共用全局的存储变量的话，那么这全局变量需要存储在global-session 中。全局作用域与Servlet 中的session 作用域效果相同。</li>
</ol>
<h2 id="Spring基于xml注入bean的几种方式？"><a href="#Spring基于xml注入bean的几种方式？" class="headerlink" title="Spring基于xml注入bean的几种方式？"></a>Spring基于xml注入bean的几种方式？</h2><p>（ 1 ）Set 方法注入；<br>（ 2）构造器注入：①通过index 设置参数的位置；②通过type 设置参数类型；<br>（ 3）静态工厂注入；<br>（ 4）实例工厂；</p>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><ul>
<li><p><strong>简单工厂模式：</strong></p>
<p>Spring 中的BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p>
</li>
<li><p><strong>工厂模式：</strong></p>
<p>Spring 中的FactoryBean 就是典型的工厂方法模式，实现了FactoryBean 接口的bean 是一类叫做factory 的bean。其特点是，spring 在使用getBean() 调用获得该bean 时，会自动调用该bean 的getObject() 方法，所以返回的不是factory 这个bean，而是这个bean.getOjbect() 方法的返回值。</p>
</li>
<li><p><strong>单例模式：</strong></p>
<p>在spring 中用到的单例模式有： scope&#x3D;”singleton” ，注册式单例模式，bean 存放于Map 中。bean name 当做key ，bean 当做value。</p>
</li>
<li><p><strong>原型模式：</strong></p>
<p>在spring 中用到的原型模式有： scope&#x3D;”prototype” ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。迭代器模式：在Spring 中有个CompositeIterator 实现了Iterator ，Iterable 接口和Iterator接口，这两个都是迭代相关的接口。可以这么认为，实现了Iterable 接口，则表示某对象是可被迭代的。Iterator 接口相当于是一个迭代器，实现了Iterator 接口，等于具体定义了这个可被迭代的对象是如何进行迭代的。</p>
</li>
<li><p><strong>代理模式：</strong></p>
<p>Spring 中经典的AOP，就是使用动态代理实现的，分JDK 和CGlib 动态代理。</p>
</li>
<li><p><strong>适配器模式：</strong></p>
<p>Spring 中的AOP 中AdvisorAdapter 类，它有三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapterThrowsAdviceAdapter。Spring会根据不同的AOP 配置来使用对应的Advice，与策略模式不同的是，一个方法可以同时拥有多个Advice。Spring 存在很多以Adapter 结尾的，大多数都是适配器模式。</p>
</li>
<li><p><strong>观察者模式：</strong></p>
<p>Spring 中的Event 和Listener。spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自EventObject。spring 事件监听器：ApplicationListener，该接口继承了EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。</p>
</li>
<li><p><strong>模板模式：</strong></p>
<p>Spring 中的org.springframework.jdbc.core.JdbcTemplate 就是非常经典的模板模式的应用，里面的execute 方法，把整个算法步骤都定义好了。</p>
</li>
<li><p><strong>责任链模式：</strong></p>
<p>DispatcherServlet 中的doDispatch() 方法中获取与请求匹配的处理<br>器HandlerExecutionChain ，this.getHandler() 方法的处理使用到了责任链模式。</p>
</li>
</ul>
<p>注意：这里只是列举了部分设计模式，其实里面用到了还有享元模式、建造者模等。可选择性地回答，主要是怕你回答了迭代器模式，然后继续问你，结果你一问三不知，那就尴了干了。</p>
<h2 id="Spring中ApplicationContext和BeanFactory的区别"><a href="#Spring中ApplicationContext和BeanFactory的区别" class="headerlink" title="Spring中ApplicationContext和BeanFactory的区别"></a>Spring中ApplicationContext和BeanFactory的区别</h2><h3 id="包目录不同"><a href="#包目录不同" class="headerlink" title="包目录不同"></a><strong>包目录不同</strong></h3><p>spring-beans.jar 中org.springframework.beans.factory.BeanFactory<br>spring-context.jar 中org.springframework.context.ApplicationContext</p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>BeanFactory 是不支持国际化功能的，因为BeanFactory 没有扩展Spring 中MessageResource 接口。相反，由于ApplicationContext 扩展了MessageResource 接口，因而具有消息处理的能力（ i18N ）。</p>
<h3 id="强大事件机制（Event）"><a href="#强大事件机制（Event）" class="headerlink" title="强大事件机制（Event）"></a>强大事件机制（Event）</h3><p>基本上牵涉到事件（Event）方面的设计，就离不开观察者模式ApplicationContext 的事件机制主要通过ApplicationEvent 和ApplicationListener 这两个接口来提供的，和Java swing 中的事件机制一样。即当ApplicationContext 中发布一个事件时，所有扩展了ApplicationListener的Bean 都将接收到这个事件，并进行相应的处理。</p>
<h3 id="底层资源的访问"><a href="#底层资源的访问" class="headerlink" title="底层资源的访问"></a>底层资源的访问</h3><p>ApplicationContext 扩展了ResourceLoader（资源加载器）接口，从而可以用来加载多个Resource ，而BeanFactory 是没有扩展ResourceLoader。</p>
<h3 id="对Web应用的支持"><a href="#对Web应用的支持" class="headerlink" title="对Web应用的支持"></a>对Web应用的支持</h3><p>与BeanFactory通常以编程的方式被创建，ApplicationContext能以声明的方式创建，如使用ContextLoader。当然你也可以使用 ApplicationContext的实现方式之一，以编程的方式创建ApplicationContext 实例。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><ol>
<li>BeanFactroy 采用的是延迟加载形式来注入Bean 的，即只有在使用到某个Bean 时（调用getBean())，才对该Bean 进行加载实例化。这样，我们就不能发现一些存在的spring 的配置问题。而ApplicationContext 则相反，它是在容器启动时，一次性创建了有的Bean。<br>这样，在容器启动时，我们就可以发现Spring 中存在的配置错误。</li>
<li>BeanFactory 和ApplicationContext 都支持BeanPostProcessor、BeanFactoryPostProcessor 的使用。两者之间的区别是：BeanFactory 需要手动注册，而ApplicationContext 则是自动注册。</li>
</ol>
<p>可以看到，ApplicationContext 继承了BeanFactory ，BeanFactory 是Spring 中比较原始的Factory，它不支持AOP、Web 等Spring 插件。而ApplicationContext 不仅包含了BeanFactory的所有功能，还支持Spring 的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。BeanFactory 是Spring 框架的基础设施面向Spring 本身；而ApplicationContext 面向使用Spring 的开发者，相BeanFactory 提供了更多面向实际应用的功能，几乎所有场合都可以直接使用ApplicationContext，而不是底层的BeanFactory。</p>
<h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><p>BeanFactory 类型的有XmlBeanFactory，它可以根据XML 文件中定义的内容，创建相应的Bean。<br>ApplicationContext 类型的常用容器有：</p>
<ol>
<li>ClassPathXmlApplicationContext：从ClassPath 的XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</li>
<li>FileSystemXmlApplicationContext：由文件系统中的XML 配置文件读取上文。</li>
<li>XmlWebApplicationContext：由Web 应用的XML 文件读取上下文。例如我们在SpringMVC 使用的情况。</li>
</ol>
<h2 id="Spring-框架中的单例-Bean-是线程安全的吗？"><a href="#Spring-框架中的单例-Bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的吗？"></a>Spring 框架中的单例 Bean 是线程安全的吗？</h2><p>Spring 框架并没有对单例Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例Bean 的线程安全和并发问题，需要开发者自行去搞定。</li>
<li>单例的线程安全问题，并不是Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例Bean 或多例Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的Spring Bean 并没有可变的状态，所以在某种程度上说Spring 的单例Bean 是线程安全的。如果你的Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态Bean 的作用域（Scope）由Singleton 变更为Prototype。</p>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405161935493.png"/>

<ol>
<li>首先A 完成初始化第一步并将自己提前曝光出来（通过ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象B，此时就会去尝试get(B)，这个时候发现B 还没有被创建出来；</li>
<li>然后B 就走创建流程，在B 初始化的时候，同样发现自己依赖C ，C 也没有被创建出来；</li>
<li>这个时候C 又开始初始化进程，但是在初始化的过程中发现自己依赖A，于是尝试get(A)。这个时候由于A 已经添加至缓存中（一般都是添加至三级缓存<strong>singletonFactories</strong>），通过ObjectFactory 提前曝光，所以可以通过ObjectFactory#getObject() 方法来拿到A 对象。C拿到A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</li>
<li>回到B ，B 也可以拿到C 对象，完成初始化，A 可以顺利拿到B 完成初始化。到这里整个链路就已经完成了初始化过程了。</li>
</ol>
<p>关键字：三级缓存，提前曝光。</p>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="事务的隔离级别（MYSQL）"><a href="#事务的隔离级别（MYSQL）" class="headerlink" title="事务的隔离级别（MYSQL）"></a>事务的隔离级别（MYSQL）</h3><h4 id="事务的传播等级"><a href="#事务的传播等级" class="headerlink" title="事务的传播等级"></a>事务的传播等级</h4><p>Spring 事务定义了7 种传播机制：</p>
<ol>
<li>PROPAGATION_REQUIRED：默认的Spring 事务传播级别，若当前存在事务，则加入该事务，<br> 若不存在事务，则新建一个事务。</li>
<li>PAOPAGATION_REQUIRE_NEW：若当前没有事务，则新建一个事务。若当前存在事务，<strong>则新</strong><br> <strong>建一个事务，新老事务相互独立。</strong>外部事务抛出异常回滚不会影响内部事务的正常提交。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，<strong>则嵌套在当前事务中执行</strong>。如果当前没有事务，<br> 则新建一个事务，<strong>类似于REQUIRE_NEW。</strong></li>
<li>PROPAGATION_SUPPORTS：支持当前事务，若当前不存在事务，<strong>以非事务的方式执行</strong>。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务的方式执行，若当前存在事务，<strong>则把当前事务</strong><br> <strong>挂起</strong>。</li>
<li>PROPAGATION_MANDATORY：<strong>强制事务执行，</strong>若当前不存在事务，则抛出异常.</li>
<li>PROPAGATION_NEVER：<strong>以非事务的方式执行，</strong>如果当前存在事务，则抛出异常。</li>
</ol>
<p>Spring 事务传播级别一般不需要定义，默认就是PROPAGATION_REQUIRED，除非在嵌套事务的<br>  情况下需要重点了解。</p>
<h3 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h3><ul>
<li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</li>
</ul>
<h3 id="事务管理有哪些优点"><a href="#事务管理有哪些优点" class="headerlink" title="事务管理有哪些优点"></a>事务管理有哪些优点</h3><ul>
<li>它为不同的事务API（如JTA, JDBC, Hibernate, JPA, 和JDO）提供了统一的编程模型。</li>
<li>它为编程式事务管理提供了一个简单的API 而非一系列复杂的事务API（如JTA).</li>
<li>它支持声明式事务管理。</li>
<li>它可以和Spring 的多源数据访问技术很好地融合。</li>
</ul>
<h3 id="事务三要素"><a href="#事务三要素" class="headerlink" title="事务三要素"></a>事务三要素</h3><ul>
<li><strong>数据源：</strong>表示具体的事务性资源，是事务的真正处理者，如MySQL 等。</li>
<li><strong>事务管理器：</strong>像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</li>
<li><strong>事务应用和属性配置：</strong>像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</li>
</ul>
<h3 id="事务注解的本质"><a href="#事务注解的本质" class="headerlink" title="事务注解的本质"></a>事务注解的本质</h3><p>@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置的事务行为。大致来说具有两方面功能， 一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为</p>
<p>声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性增强（advice），来驱动事务完成。</p>
<p>@Transactional 注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的<br>所有方法。如果此时方法上也标注了，则方法上的优先级高。另外注意方法一定要是public 的。</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>Spring Boot 优点非常多，如：<br>一、独立运行<br>Spring Boot 而且内嵌了各种servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到<br>容器中，Spring Boot 只要打成一个可执行的jar 包就能独立运行，所有的依赖包都在一个jar 包<br>内。</p>
<p>二、简化配置<br>spring-boot-starter-web 启动器自动依赖其他组件，减少了maven 的配置。</p>
<p>三、自动配置<br>Spring Boot 能根据当前类路径下的类、jar 包来自动配置bean，如添加一个<br>spring-boot-starter- web 启动器就能拥有web 的功能，无需其他配置。</p>
<p>四、无代码生成和XML 配置<br>Spring Boot 配置过程中无代码生成，也无需XML 配置文件就能完成所有配置工作，这一切都是借<br>助于条件注解完成的，这也是Spring4.x 的核心功能之一。</p>
<p>五、应用监控<br>Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。</p>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p>启动类上面的注解是@SpringBootApplication，它也是Spring Boot 的核心注解，主要组合包含了以下3个注解：</p>
<ul>
<li>@SpringBootConfiguration：组合了@Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D;{ DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan ：Spring 组件扫描。</li>
</ul>
<h2 id="Spring-Boot有哪几种方式？"><a href="#Spring-Boot有哪几种方式？" class="headerlink" title="Spring Boot有哪几种方式？"></a>Spring Boot有哪几种方式？</h2><p>1）打包用命令或者放到容器中运行<br>2）用Maven&#x2F;Gradle 插件运行<br>3）直接执行main 方法运行</p>
<h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><p>Starters 是什么：<br>Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA 访问数据库，只要加入spring-boot-starter-data-jpa 启动器依赖就能使用了。Starters 包含了许多项目中需要用到的依赖，它们能快速持续地运行，都是一系列得到支持的管理传递性依赖。</p>
<h3 id="Starters-命名："><a href="#Starters-命名：" class="headerlink" title="Starters 命名："></a>Starters 命名：</h3><p>Spring Boot 官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的启动器不能以spring-boot 开头命名，它们都被Spring Boot 官方保留。一般一个第三方的应该这样命名，像mybatis 的mybatis-spring-boot-starter。</p>
<ul>
<li>spring-boot-starter-web 嵌入tomcat 和web 开发需要servlet 与jsp 支持</li>
<li>spring-boot-starter-data-jpa 数据库支持</li>
<li>spring-boot-starter-data-redis redis 数据库支持</li>
<li>spring-boot-starter-data-solr solr 支持</li>
<li>mybatis-spring-boot-starter 第三方的mybatis 集成starter</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170118378.png"/>

<h2 id="Spring-Boot-的核心配置文件"><a href="#Spring-Boot-的核心配置文件" class="headerlink" title="Spring Boot 的核心配置文件"></a>Spring Boot 的核心配置文件</h2><ul>
<li>pring Boot 的核心配置文件是application 和bootstrap 配置文件。</li>
<li>application 配置文件这个容易理解，主要用于Spring Boot 项目的自动化配置。</li>
<li>bootstrap 配置文件有以下几个应用场景。<ul>
<li>使用Spring Cloud Config 配置中心时，这时需要在bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li>
<li>一些固定的不能被覆盖的属性；</li>
<li>一些加密&#x2F;解密的场景；</li>
</ul>
</li>
</ul>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>基于SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML 里，解除sql 与程序代码的耦合，便于统一管理；提供XML 标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC 相比，减少了50%以上的代码量，消除了JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好地与各种数据库兼容（因为MyBatis 使用JDBC 来连接数据库，所以只要JDBC 支持的数据库MyBatis 都支持）。</li>
<li>能够与Spring 很好地集成；</li>
<li>提供映射标签，支持对象与数据库的ORM 字段关系映射；提供对象关系映射标签，支持对象关键组件维护。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1.<br>   SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL 语句的功底有一定要求。<br>2. SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h2 id="｛｝和-｛｝的区别是什么？"><a href="#｛｝和-｛｝的区别是什么？" class="headerlink" title="#｛｝和$｛｝的区别是什么？"></a>#｛｝和$｛｝的区别是什么？</h2><p>#{｝是预编译处理，${｝是字符串替换。</p>
<p>Mybatis 在处理#{｝时，会将sql 中的#{｝替换为？号，调用PreparedStatement 的set 方法来赋值；</p>
<p>Mybatis 在处理${｝时，就是把${｝替换成变量的值。使用#{｝可以有效地防止SQL 注入，提高系统安全性。</p>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用RowBounds 对象进行分页，它是针对ResultSet 结果集执行的内存分页，而非物理分页。可以在sql 内直接拼写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页，比如：MySQL 数据的时候，在原有SQL 后面拼写limit。</p>
<p>分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>
<p>第二种是使用sql 列的别名功能，将列的别名书写为对象属性名。</p>
<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一<br>赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h2 id="实现一对一有几种方式？具体怎么操作的？"><a href="#实现一对一有几种方式？具体怎么操作的？" class="headerlink" title="实现一对一有几种方式？具体怎么操作的？"></a>实现一对一有几种方式？具体怎么操作的？</h2><p>有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次， 通过在resultMap<br>里面配置association 节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去在另外一个表里面查询数据，也是<br>通过association 配置，但另外一个表的查询通过select 属性配置。</p>
<h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis 仅支持association 关联对象和collection 关联集合对象的延迟加载，association 指的就<br>是一对一，collection 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加<br>载lazyLoadingEnabled&#x3D;true|false。</p>
<blockquote>
<p>它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke(）方法发现a.getB(）是null 值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName(）方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
</blockquote>
<h2 id="Mybatis-的缓存机制："><a href="#Mybatis-的缓存机制：" class="headerlink" title="Mybatis 的缓存机制："></a>Mybatis 的缓存机制：</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170045709.png"/>

<h3 id="一级缓存localCache"><a href="#一级缓存localCache" class="headerlink" title="一级缓存localCache"></a>一级缓存localCache</h3><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL ，<br>MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的SQL 语句，会优先命中一级缓<br>存， 避免直接对数据库进行查询，提高性能。</p>
<p>每个SqlSession 中持有了Executor，每个Executor 中有一个LocalCache。当用户发起查询<br>时， MyBatis 根据当前执行的语句生成MappedStatement，在Local Cache 进行查询，如果<br>缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local<br>Cache，最后返回结果给用户。具体实现类的类关系图如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170101103.png"/>

<ol>
<li>MyBatis 一级缓存的生命周期和SqlSession 一致。</li>
<li>MyBatis 一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis 的一级缓存最大范围是SqlSession 内部，有多个SqlSession 或者分布式的环境下， 数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession 内部，如果多个SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor 装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170107703.png"/>

<p>二级缓存开启后，同一个namespace 下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程为：</p>
<p>二级缓存 —&gt; 一级缓存 —&gt; 数据库</p>
<ol>
<li>MyBatis 的二级缓存相对于一级缓存来说，实现了SqlSession 之间缓存数据的共享，同时粒度更加细，能够到namespace 级别，通过Cache 接口实现类不同的组合，对Cache 的可控性也更强。</li>
<li>MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis 的Cache 接口实现，有一定的开发成本，直接使用Redis、Memcached 等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h2 id="Mybatis设计模式"><a href="#Mybatis设计模式" class="headerlink" title="Mybatis设计模式"></a>Mybatis设计模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405170110652.png"/>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">MYSQL面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-15 01:03:48" itemprop="dateModified" datetime="2024-05-15T01:03:48+08:00">2024-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h2><p>第一范式：列不可再分</p>
<p>第二范式：行可以唯一区分，主键约束</p>
<p>第三范式：表的非主属性不能依赖</p>
<p>与其他表的非主属性外键约束且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>
<h2 id="MYSQL数据库引擎"><a href="#MYSQL数据库引擎" class="headerlink" title="MYSQL数据库引擎"></a>MYSQL数据库引擎</h2><p>mysql 常用引擎包括：MYISAM、Innodb、Memory、MERGE</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405131951060.png"/>

<ul>
<li>MYISAM：<strong>全表锁</strong>，拥有较高的执行速度，<strong>不支持事务，不支持外键</strong>，并发性能差，占用空间相对较小，<strong>对事务完整性没有要求</strong>，以select、insert 为主的应用基本上可以使用这引擎</li>
<li>Innodb：<strong>行级锁</strong>，提供了具有提交、<strong>回滚和崩溃回复能力的事务安全，支持自动增长列</strong>，<strong>支持外键约束</strong>，并发能力强，占用空间是MYISAM 的2.5 倍，处理效率相对会差一些</li>
<li>Memory：全表锁，存储在内容中，速度快，<strong>但会占用和数据量成正比的内存空间</strong>且<strong>数据在mysql 重启时会丢失，默认使用HASH 索引</strong>，检索效率非常高，但<strong>不适用于精确查找</strong>，主要用于那些内容变化不频繁的代码表</li>
<li>MERGE：是一组MYISAM 表的组合</li>
</ul>
<h3 id="InnoDB-与-MyISAM-的区别"><a href="#InnoDB-与-MyISAM-的区别" class="headerlink" title="InnoDB 与 MyISAM 的区别"></a>InnoDB 与 MyISAM 的区别</h3><ol>
<li>InnoDB 支持事务，MyISAM 不支持，对于InnoDB 每一条SQL 语言都默认封装成事务，自<br>动提交，这样会影响速度，所以最好把多条SQL 语言放在begin 和commit 之间，组成一<br>个事务；</li>
<li>InnoDB 支持外键，而MyISAM 不支持。对一个包含外键的InnoDB 表转为MYISAM 会失败；</li>
<li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须有主键，通过主键索引效率很高。<br>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应<br>该过大，因为主键太大，其他索引也都会很大。而MyISAM 是非聚集索引，数据文件是分<br>离的， 索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而MyISAM<br>用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb 不支持全文索引，而MyISAM 支持全文索引，查询效率上MyISAM 要高；</li>
</ol>
<h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><p>什么是事务？ 多条 sql 语句，要么全部成功，要么全部失败。</p>
<p>事务的特征：数据库事务特征：</p>
<ul>
<li>原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功， 整个事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。</li>
<li>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A 转账100 元给B，不管操作是否成功，A 和B 的账户总额是不变的。</li>
<li>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</li>
<li>持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>官方介绍索引是帮助MySQL 高效获取数据的数据结构。更通俗地说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</li>
<li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</li>
<li>我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用树结构组织（多路搜索树，并不一定是二叉的）的索引。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ol>
<li>查询语句中不要使用select *</li>
<li>尽量减少子查询，使用关联查询（left join,right join,inner join）替代</li>
<li>减少使用IN 或者NOT IN ，使用exists ，not exists 或者关联查询语句替代</li>
<li>or 的查询尽量用union 或者union all 代替（在确认没有重复数据或者不用剔除重复数据时， union all 会更好）</li>
<li>应尽量避免在where 子句中使用！&#x3D;或〈〉操作符，<strong>否则将引擎放弃使用索引而进行全表扫描。</strong></li>
<li>应尽量避免在where 子句中对字段进行null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num 上设置默认值0，确保表中num列没有null 值，然后这样查询： select id from t where num&#x3D;0</li>
</ol>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>delete 和truncate 只删除<strong>表的数据不删除表的结构</strong></p>
<p>速度一般来说： drop&gt; truncate &gt;delete</p>
<p>delete 语句是dml，这个操作会放到rollback segement 中，事务提交之后才生效； 如果有相应的trigger，执行的时候将被触发. </p>
<p>truncate,drop 是ddl, 操作立即生效，原数据不放到rollback segment 中，不能回滚. 操作不触发trigger.</p>
<h2 id="试图"><a href="#试图" class="headerlink" title="试图"></a>试图</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易， 相比多表查询。</p>
<h2 id="内连接、左外连接、右外连接"><a href="#内连接、左外连接、右外连接" class="headerlink" title="内连接、左外连接、右外连接"></a>内连接、左外连接、右外连接</h2><ul>
<li><strong>内连接（Inner Join）：</strong>匹配2 张表中相关联的记录。</li>
<li><strong>左外连接（Left Outer Join）：</strong>除了匹配2 张表中相关联的记录外，还会匹配左表中剩余的记录，<strong>右表中未匹配到的字段用NULL 表示。</strong></li>
<li><strong>右外连接（Right Outer Join）：</strong>除了匹配2 张表中相关联的记录外，还会匹配右表中剩余的记录，<strong>左表中未匹配到的字段用NULL 表示。</strong>在判定左表和右表时，<strong>要根据表名出现在Outer Join 的左右位置关系。</strong></li>
</ul>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<p><strong>脏读（Dirty read ）：</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据” ，依据“脏数据”所做的操作可能是不正确的。</p>
<p><strong>丢失修改（ Lost to modify）：</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1 读取某表中的数据A&#x3D;20，事务2 也读取A&#x3D;20，事务1 修改A&#x3D;A-1，事务2 也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1 的修改被丢失。</p>
<p><strong>不可重复读（Unrepeatableread)：</strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>**幻读（Phantom read):**幻读与不可重复读类似。它发生在一个事务（T1)读取了几行数据，接着另一个并发事务（T2)插入了一些数据时。在随后的查询中，第一个事务（T1)就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p>不可重复读和幻读区别：<br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="SQL标准定义了四个隔离级别"><a href="#SQL标准定义了四个隔离级别" class="headerlink" title="SQL标准定义了四个隔离级别"></a>SQL标准定义了四个隔离级别</h3><ul>
<li>READ-UNCOMMITTED(读取未提交）:最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交）:允许读取并发事务已经提交的数据，可以阻止重读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读）:对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止重读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化）:最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止空读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>存储引擎的默认支持的隔离级别是 REPEATABLE-READ(可重读）。</p>
<p>这里需要注意的是：与SQL标准不同的地方在于InnoDB存储引擎在</p>
<p>REPEATABLE-READ(可重读）事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生，这与其他数据库系统（如SQLServer)是不同的。所以说InnoDB存储引擎的默认支持的隔离级别是</p>
<p>REPEATABLE-READ(可重读）已经可以完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化）隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是</p>
<p>READ-COMMITTED(读取提交内容）,但是你要知道的是InnoDB存储引擎默认使用REPEAaTABLE-READ(可重读）并不会有任何性能损失。</p>
<p>InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化）隔离级别。</p>
<h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL 单表记录数过大时，数据库的CRUD 性能会明显下降，一些常见的优化</p>
<p>措施如下：</p>
<h3 id="限定数据的范围"><a href="#限定数据的范围" class="headerlink" title="限定数据的范围"></a>限定数据的范围</h3><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h3 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h3><p>根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指数据表列的拆分，<strong>把一张列比较多的表拆分为多张表</strong>。</p>
<ul>
<li><strong>垂直拆分的优点：</strong>可以使得列数据变小，在查询时减少读取的Block数，减少1&#x2F;0次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong>主键会出现允余，需要管理穴余列，并会引起Join操作，可以通过在应用层 进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h3 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h3><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一组数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL 并发能力没有什么意义，所以<strong>水平拆分最好分库</strong>。</p>
<blockquote>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。《Java 工程师修炼之道》的作者推荐尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</p>
</blockquote>
<p>下面补充一下数据库分片的两种常见方案：</p>
<p>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的Sharding-JDBC、阿里的TDDL是两种比较常用的实现。</p>
<p>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分库分表之后，-id主键如何处理"><a href="#分库分表之后，-id主键如何处理" class="headerlink" title="分库分表之后， id主键如何处理"></a>分库分表之后， id主键如何处理</h3><p>因为要是分成多个表之后，每个表都是从1 开始累加，这样是不对的，我们需要一个全局唯一的id 来支持</p>
<p>生成全局id 有下面这几种方式：</p>
<ul>
<li><p>UUID:不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成一的名字的标示比如文件的名字。</p>
</li>
<li><p>数据库自增id：两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的id有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>
</li>
<li><p>利用redis生成id：性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
</li>
<li><p>Twitter的snowflake算法：Github地址：</p>
</li>
<li><p>美团的分布式生成系统：Leaf 是美团开源的分布式ID 生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper 等中间件。</p>
</li>
</ul>
<h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><ol>
<li><p>取得链接，使用到MySQL 中的连接器。</p>
</li>
<li><p>查询缓存，key 为SQL 语句，value 为查询结果，如果查到就直接返回。不建议使用次缓存， 在MySQL 8.0 版本已经将查询缓存删除，也就是说MySQL 8.0 版本后不存在此功能。</p>
</li>
<li><p>分析器，分为词法分析和语法分析。此阶段只是做一些SQL 解析，语法校验。所以一般语法错误在此阶段。</p>
</li>
<li><p>优化器，是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时候（join），决定各个表的连接顺序。</p>
</li>
<li><p>执行器，通过分析器让SQL 知道你要干啥，通过优化器知道该怎么做，于是开始执行语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行语句的时候还要判断是否具备此权限，没有权限就直接返回提示没有权限的错误；有权限则打开表，根据表的引擎定义，去使用这个引擎提供的接口，获取这个表的第一行，判断id 是否等于1。如果是，直接返回；如果不是继续调用引擎接口去下一行，重复相同的判断，直到取到这个表的最后一行，最后返回。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405142210161.png"/>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度</li>
<li>降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本</li>
</ul>
<p>缺点</p>
<ul>
<li><p>占用存储空间：素引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上</p>
</li>
<li><p>降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更从而减低的更新速度。否则索引指向的物理数据可能不对，这也是素引失效的原因</p>
</li>
</ul>
<h2 id="MySQL中varchar与char的区别？varchar-30-中的30代表的含义？"><a href="#MySQL中varchar与char的区别？varchar-30-中的30代表的含义？" class="headerlink" title="MySQL中varchar与char的区别？varchar(30)中的30代表的含义？"></a>MySQL中varchar与char的区别？varchar(30)中的30代表的含义？</h2><p>varchar与char的区别，char是一种固定长度的类型，varchar则是一种可变长度的类型。</p>
<p>varchar(30)中30的涵义最多存放30个字符。varchar(30)和（130)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为ORDER BY col 采用 fixed_length 计算col长度（memory引擎也一样）。</p>
<p>对效率要求高用char,对空间使用要求高用varchar。</p>
<h2 id="int-11-中的11代表什么含义？"><a href="#int-11-中的11代表什么含义？" class="headerlink" title="int(11)中的11代表什么含义？"></a>int(11)中的11代表什么含义？</h2><p>int(11)中的11,不影响字段存储的范围，只影响展示效果</p>
<h2 id="为什么-SELECT-COUNT-FROM-table在InnoDB比-MylSAM-慢？"><a href="#为什么-SELECT-COUNT-FROM-table在InnoDB比-MylSAM-慢？" class="headerlink" title="为什么 SELECT COUNT(*)FROM table在InnoDB比 MylSAM 慢？"></a>为什么 SELECT COUNT(*)FROM table在InnoDB比 MylSAM 慢？</h2><p>对于SELECT COUNT(*) FROM table语句，在没有WHERE条件的情况下，InnoDB比MyISAM可能会慢很多，尤其在大表的情况下。因为，InnoDB是去实时统计结果，会全表扫描；而MyISAM内部维持了一个计数器，预存了结果，所以直接返回即可。</p>
<h2 id="InnoDB与MyISAM区别？"><a href="#InnoDB与MyISAM区别？" class="headerlink" title="InnoDB与MyISAM区别？"></a>InnoDB与MyISAM区别？</h2><ul>
<li><p>在MySQL5.1及之前的版本中，MyISAM是默认的存储引擎，而在MySQL5.5版本以后<br>默认使用InnoDB存储引擎。</p>
</li>
<li><p>MyISAM不支持行级锁，换句话说，MyISAM会对整张表加锁，而不是针对行。同时，MyISAM不支持事务和外键。MyISAM可被压缩，存储空间较小，而且MyISAM在筛选大量数据时非常快。</p>
</li>
<li><p>InnoDB是事务型引擎，当事务异常提交时，会被回滚。同时，InnoDB支持行锁。此外，InnoDB需要更多存储空间，会在内存中建立其专用的缓冲池用于高速缓冲数据和索引。<br>InnoDB支持自动崩溃恢复特性。</p>
</li>
</ul>
<p>建议：一般情况下，个人建议优先选择InnoDB存储引擎，并且尽量不要将InnoDB与MyISAM混合使用。</p>
<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>索引列中的值必须是唯一的，不允许有空值。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列中的值必须是唯一的，但是允许为空值。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>只能在文本类型CHAR,VARCHAR,TEXT 类型字段上创建全文索引。字段长度比较大时，如果创建<br>普通索引，在进行like 模糊查询时效率比较低，这时可以创建全文索引。MyISAM 和InnoDB<br>中都可以使用全文索引。</p>
<h3 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h3><p>MySQL 在5.7 之后的版本支持了空间索引，而且支持OpenGIS 几何数据模型。MySQL 在空间索<br>引这方面遵循OpenGIS 几何数据模型规则。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>在文本类型如CHAR,VARCHAR,TEXT 类列上创建索引时，可以指定索引列的长度，但是数值类型<br>不能指定。</p>
<p>其他（按照索引列数量分类）</p>
<ol>
<li>单列索引</li>
<li>组合索引<br>组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则） 。一般情况下在条件允许的<br>情况下使用组合索引替代多个单列索引使用。</li>
</ol>
<h3 id="什么时候不要使用索引"><a href="#什么时候不要使用索引" class="headerlink" title="什么时候不要使用索引"></a>什么时候不要使用索引</h3><ol>
<li>经常增删改的列不要建立索引；</li>
<li>有大量重复的列不建立索引；</li>
<li>表记录太少不要建立索引。</li>
</ol>
<h3 id="主键与索引有什么区别？"><a href="#主键与索引有什么区别？" class="headerlink" title="主键与索引有什么区别？"></a>主键与索引有什么区别？</h3><p>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；<br>主键不允许为空值，唯一索引列允许空值；<br>一个表只能有一个主键，但是可以有多个唯一索引；<br>主键可以被<strong>其他表引用为外键，唯一索引</strong>列不可以；<br>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制（MVCC&#x3D;Multi-Version Concurrency Control），是一种用来解决读- 写冲突的无锁并发控制。也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。同时还可以解决脏读、幻读、不可重复读等事务隔离问题，但不能解决更新丢失问题。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理<br>主要是依赖记录中的3 个隐式字段、undo 日志、Read View 来实现的。</p>
<h2 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h2><ol>
<li>共享锁：不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响。</li>
<li>排他锁：一个写操作阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他<br>  用户读取正在写入的资源。</li>
<li>表锁：系统开销最小，会锁定整张表，MyISAM 使用表锁。</li>
<li>行锁：容易出现死锁，发生冲突概率低，并发高，InnoDB 支持行锁（必须有索引才能实现，<br>  否则会自动锁全表，那么就不是行锁了）。</li>
</ol>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定。读取数据时给加锁，其他事务无<br>法修改这些数据。修改删除数据时也要加锁，其他事务无法读取这些数据。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁<br>机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对<br>长事务而言，这样的开销往往无法承受。</p>
<p>乐观锁，大多是基于数据版本（Version）记录机制<br>实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是<br>通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新<br>时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比<br>对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>MySQL 行锁只能加在索引上，如果操作不走索引，就会升级为表锁。因为InnoDB 的行锁 是加在索引上的，如果不走索引，自然就没法使用行锁了，原因是InnoDB 是将primary key index 和相关的行数据共同放在B+ 树的叶节点。InnoDB 一定会有一个primary key ，secondary index 查找的时候，也是通过找到对应的primary ，再找对应的数据行。</p>
<p>当非唯一索引上记录数超过一定数量时，行锁也会升级为表锁。测试发现当非唯一索引相同的内容不少于整个表记录的二分之一时会升级为表锁。因为当非唯一索引相同的内容达到整个记录的二分之一时，索引需要的性能比全文检索还要大，查询语句优化时会选择不走索引，造成索引失效，行锁自然就会升级为表锁。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ol>
<li>设置获取锁的超时时间，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；</li>
<li>设置按照同一顺序访问资源，类似于串行执行；</li>
<li>避免事务中的用户交叉；</li>
<li>保持事务简短并在一个批处理中；</li>
<li>使用低隔离级别；</li>
<li>使用绑定链接。</li>
</ol>
<h2 id="如何做到高可用方案？"><a href="#如何做到高可用方案？" class="headerlink" title="如何做到高可用方案？"></a>如何做到高可用方案？</h2><p>MySQL 高可用，意味着不能一台MySQL 出了问题，就不能访问了。</p>
<ol>
<li>MySQL 高可用：分库分表，通过MyCat 连接多个MySQL</li>
<li>MyCat 也得高可用：Haproxy，连接多个MyCat</li>
<li>Haproxy 也得高可用：通过keepalived 辅助Haproxy</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="为了应对多请求缓存数据，缓解mysql压力而诞生"><a href="#为了应对多请求缓存数据，缓解mysql压力而诞生" class="headerlink" title="为了应对多请求缓存数据，缓解mysql压力而诞生"></a>为了应对多请求缓存数据，缓解mysql压力而诞生</h2><p>Redis主要数据存在内存中，通过设置超时时间来解决Redis在内存内数据不断膨胀问题<br>当内存压力太大时，通过随机算法删除内容释放空间（随机算法）<br>当超期数据太久于内存中未删除，遇到请求查询超期键值，则会立即删除该数据（被动触发，惰性删除）</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>①noeviction：返回错误，不会删除任何键值<br>②allkeys-lru：使用LRU算法删除最近最少使用的键值<br>③volatile-lru：使用LRU算法从设置了过期时间的键集合中删除最近最少使用的键值<br>④allkeys-random:从所有key随机删］除<br>⑤volatile-random：从设置了过期时间的键的集合中随机删除<br>⑥volat计e-ttl：从设置了过期时间的键中删除剩余时间最短的键<br>⑦volatile・lfu：从配置了过期时间的键中删除使用频率最少的键<br>⑧allkeys-lfu:从所有键中删除使用频率最少的键</p>
<h2 id="缓存击穿-缓存雪崩"><a href="#缓存击穿-缓存雪崩" class="headerlink" title="缓存击穿 缓存雪崩"></a>缓存击穿 缓存雪崩</h2><p>mysql被多次申请查询返回空数据从而使得redis无法缓存（缓存穿透&#x2F;缓存击穿）<br>mysql因为（大量）redis数据丢失或者数据删除导致大量请求涌向mysql导致mysql处理不过来请求（缓存雪崩）<br>解决方法：过期时间均匀分布+热点数据永不过期</p>
<h2 id="持久化-RDB-AOF"><a href="#持久化-RDB-AOF" class="headerlink" title="持久化 RDB AOF"></a>持久化 RDB AOF</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>redis因为出错导致丢失数据（需要通过持久化存储）<br>RDB：将全部遍历写入二进制连续文件rdb (周期性备份)<br>为了防止大量重复备份，redis提供了save配置参数解决问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 #900秒 内有一个写入即备份（由子进程进行）</span><br></pre></td></tr></table></figure>

<p>RDB数据不一致问题:因为数据库都是分钟级的，这种周期性备份还是容易丢数据</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久化:类似mysql的binlog，将写入操作记录下来，保存操作的数据会先写入缓冲区AOF_BUF (会存放SET SAOO RPUSH等)</p>
<p>AOF重写，为了防止AOF缓存数据过大问题：指令合并（子进程进行）</p>
<p>但是子进程进行会导致AOF重写数据不一致。所以需要将指令存放AOF_REWRITE_BUF缓冲区，将重写进程启动后的命令写入缓冲区，运行完毕回写进去</p>
<h3 id="主从节点"><a href="#主从节点" class="headerlink" title="主从节点"></a>主从节点</h3><p>为了防止Redis多次崩溃<br>主从：主节点主要负责写入数据，从节点主要负责读数据，做好数据同步，读写分离 提高性能。主节点崩了从节点就顶上（高可用集群）</p>
<ul>
<li>数据同步：若主节点生成的RDB文件同步期间又收到修改命令也会一并发给从节点</li>
<li>命令传播：若主节点有数据写入、删除、修改命令也会挨个发给从节点</li>
<li>版本控制：主节点发给从节点的数据会发送一份给缓存区，若从节点掉线了，从缓冲区的偏移量起发送同步数据</li>
</ul>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>哨兵：专门有几个节点负责当管理员，不负责写入，当节点掉线时，由哨兵选择一个从节点顶上主节点<br>    每隔10s哨兵都需要发送info命令问候主节点情况（有多少从节点）<br>    每隔1s ping命令问候全部节点，若出现节点掉线则启动故障转移。这时发现的哨兵认定主观下线，会问候其他哨兵，当少服从多数认为下线，则认定客观下线。具体需要多少个哨兵认定，可以自己定义。<br>    故障转移：选个新的主节点，让其他从节点从新主节点那同步数据，再把原来的主节点改为从节点<br>    新主节点选择标准：给不同节点设置优先级，配置高的的优先级越高，与断开节点链接越短的，复制偏移越高的。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>为了防止数据量过大（由于之前全都全量复制）</p>
<p>集群：合并大服务器</p>
<p>新节点加入问题：新节点加入必须由集群内某一节点发送MEET请求后，新节点回应PONG请求，再由集群内节点发送PING请求（类似TCP三次握手）</p>
<p>数据分配：数据量公平问题：划分16384个哈希桶（槽位Slot）由程序员分配每个集群节点负责的槽位量。数据读写时对数据进行哈希运算，存入对应到槽位。每次计算存入节点会通知集群内所有节点。使用二进制通知，负责的槽位为1，共2048字节。（这样会导致存入数据需要遍历查看存入数据需要是哪个redis节点负责。）由此 新建一个大数组来存储每个槽位由哪个节点负责。（数据索引）</p>
<p>需要每个槽位都有节点负责，集群才能正确上线。</p>
<p>数据读写时候，集群节点会先检查数据是否由自己负责，否则会发送MOVED错误给请求端，使其去寻找正确节点（发送槽号，IP，端口）自动运行，无须调用</p>
<p>为了防止节点掉线，从节点会充当集群内节点的Backup</p>
<h2 id="Redis实现消息队列"><a href="#Redis实现消息队列" class="headerlink" title="Redis实现消息队列"></a>Redis实现消息队列</h2><p>一般使用list结构作为队列，rpush生产消息，1pop消费消息。当1pop没有消息的时候，要适当<br>sleep一会再重试。</p>
<ul>
<li>面试官可能会问可不可以不用sleep呢？list还有个指令吸pop,在没有消息的时候，它会<br>阻塞住直到消息到来。</li>
<li>面试官可能还问能不能生产一次消费多次呢？使用pub&#x2F;sub主题订阅者模式，可以实现<br>1:N的消息队列。</li>
<li>面试官可能还问pub&#x2F;sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使<br>用专业的消息队列如rabbit MQ等</li>
<li>Redis 如何实现延时队列：使用SortedSet 拿时间戳做Score</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">JAVA面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 13:26:38" itemprop="dateCreated datePublished" datetime="2024-05-10T13:26:38+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-15 01:18:56" itemprop="dateModified" datetime="2024-05-15T01:18:56+08:00">2024-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">语言学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p><strong>面向过程：</strong>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候 一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象：</strong>是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的 特 性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1.int 是基本数据类型，Integer 是 int 的封装类，是引用类型。int 默认值是 0，而 Integer 默认值 是 null，所以 Integer 能区分出 0 和 null 的情况。一旦 java 看到 null，就知道这个引用 还没有指向某个 对象，在任何引用使用前，必须为其指定一个对象，否则会报错。 </p>
<p>2.基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间， 必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给 另 一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看得见。</p>
<p>虽然定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值。</p>
<p>在编译之后 都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是1 个字节。使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这 里不是指的 是 32&#x2F;64 位系统，而是指 CPU 硬件层面），具有高效存取的特点</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof需要非基本类 i 必须是引用类型，不能是基本类</p>
<p>注意：编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错，如果 不能 确定类型，则通过编译，具体看运行时定</p>
<p>在 JavaSE 规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将 返 回 false。</p>
<h2 id="Java自动装箱和拆箱"><a href="#Java自动装箱和拆箱" class="headerlink" title="Java自动装箱和拆箱"></a>Java自动装箱和拆箱</h2><p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;integer ）；调用方法：valueOf(int) 的方法 </p>
<p>拆箱就是自动将包装器类型转换为基本数据类型（integer–&gt;int ）。调用方法：intValue 的方法</p>
<p>在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之 间， </p>
<p>便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p>
<p>在某个范围内的整形数值的个数是有限的，而浮点数却不是。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重 写 （Override）从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。 子 类继承了父类原有的方法，但有时子类并不想原封不动地继承父类中的某个方法，所以在方法 名， 参数列表，返回类型（除过子类中方法的返回值是父类中方法返回值的子类时）</p>
<p>都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<ol>
<li>发生在父类与子类之间 </li>
<li>方法名，参数列表，返回类型（除过子类中方法的返回类 型 是父类中返回类型的子类）必须相同 </li>
<li>访问修饰符的限制一定要大于被重写方法的访问修饰符 (public&gt;protected&gt;default&gt;private) </li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法 申 明更加宽泛的检查性异常</li>
</ol>
<p>重载 （Overload ） 在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>
<ol>
<li>重载 Overload 是一个类中多态性的一种表现 </li>
<li>重载要求同名方法的参数列表不同 （参数类型，参数个数甚至是参数顺序） </li>
<li>重载的时候，返回值类型可以相同也可以不相同。 无法返回 型别作为重载函数的区分标准</li>
</ol>
<h2 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals 与 &#x3D;&#x3D;"></a>equals 与 &#x3D;&#x3D;</h2><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即 否实指相同一个对象。比较的是真正意义上的指针操作。 </p>
<ol>
<li>比较的是操作符两端的操作数是否是同一个对象。 </li>
<li>两边的操作数必须是同一类型的（可以 是 父子类之间）才能编译通过。 </li>
<li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则 为 true，如： int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0 都是相同的（为 true），因为他们都指 向地 址为 10 的堆。</li>
</ol>
<p>equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的， 所 以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是&#x3D;&#x3D;的判断。 </p>
<p>总结： 所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的 equals object 可能为 null 则空指针</p>
<p>在阿里的代码规范中只使用 equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“&#x3D;&#x3D;” ，替换成 equals</p>
<h2 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h2><p>Java 的集合有两类，一类是 List，还有一类是 Set。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多， 用这样 的方法就会比较</p>
<p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域， 每 个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对 象的 哈希码就可以确定该对象应该存储的哪个区域</p>
<p>hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当 集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物 理 位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较 了；如 果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其他的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只 需要一两次。</p>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String 是只读字符串，它并不是基本数据类型、而是一个对象。从底层源码来看是一个final 类型 的 字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。<strong>每次对 String 的操作都 会生成 新的 String 对象</strong></p>
<p>隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append方法 <strong>拼接</strong>+后面的字符。</p>
<p>StringBuffer 和 StringBuilder 他们俩都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到</p>
<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和 StringBuilder 来进行操作。 </p>
<p> StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁， 所以来是线程安全的。</p>
<p> StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h2 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h2><p>Array(数组)是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。 </p>
<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据，（因为删除数据以后，需要把后面所有的数据前移）</p>
<p>缺点：数组初始化必须指定初始化的长度，否则报错</p>
<p>List一是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。</p>
<p>List有两个重要的实现类：ArrayList和LinkedList</p>
<ul>
<li><p>ArrayList:可以看作是能够<strong>自动增长容量</strong>的数组</p>
</li>
<li><p>ArrayList的toArray方法返回一个数组</p>
</li>
<li><p>ArrayList的asList方法返回一个列表</p>
</li>
<li><p>ArrayList底层的实现是Array,数组扩容实现</p>
</li>
<li><p>ArrayList Clone() 是浅复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</span><br><span class="line">缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</span><br><span class="line">高并发的情况下，线程不安全。多个线程同时操作ArrayList ，会引发不可预知的异常或错误。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>LinkList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能，但在get与set方面弱于ArrayList.当然，这些对比都是指数据量很大或者操作很频繁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开拓内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</span><br><span class="line">缺点：因为LinkedList 要移动指针，所以查询操作性能比较低。</span><br></pre></td></tr></table></figure>



<p>当需要对数据进行随机访问的时候，选用ArrayList。<br>当需要对数据进行多次增加删除修改时，采用LinkedList。<br>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用ArrayList。<br>当然，绝大多数业务的场景下，使用ArrayList 就够了，但需要注意避免ArrayList 的扩容，以及非顺序的插入。</p>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>1、两者父类不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了</span><br><span class="line">同时实现了map、Cloneable(可复制）、Serializable(可序列化）这三个接口。</span><br></pre></td></tr></table></figure>

<p>2、对外提供的接口不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable比HashMap多提供了elments()和contains()两个方法。elments()方法</span><br><span class="line">继承自Hashtable的父类Dictionnary。elements()方法用于返回此Hashtable中的</span><br><span class="line">value的枚举。</span><br><span class="line">contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致</span><br><span class="line">事实上，contansValue()就只是调用了一下contains()方法。</span><br></pre></td></tr></table></figure>

<p>3、对null的支持不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:key和value都不能为null。</span><br><span class="line">HashMap:key可以为null,但是这样的key只能有一个，因为必须保证key的唯一性；可以有</span><br><span class="line">多个key值对应的value为null</span><br></pre></td></tr></table></figure>

<p>4、安全性不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员</span><br><span class="line">自已处理多线程的安全问题。</span><br><span class="line"></span><br><span class="line">Hashtable是线程安全的，它的每个方法上都有synchronized关键字，因此可直接用于多线程中。</span><br><span class="line"></span><br><span class="line">虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为</span><br><span class="line">大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap.</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因</span><br><span class="line">为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</span><br></pre></td></tr></table></figure>

<p>5、初始容量大小和每次扩充容量大小不同 、</p>
<p>6、计算hash值的方法不</p>
<h2 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h2><p>Collection 是集合类的上级接口，子接口有 Set、 List、LinkedList、ArrayList、Vector、Stack、 Set； Collections 是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各 种 集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
<h2 id="JAVA的四种引用（强弱软虚）"><a href="#JAVA的四种引用（强弱软虚）" class="headerlink" title="JAVA的四种引用（强弱软虚）"></a>JAVA的四种引用（强弱软虚）</h2><ul>
<li><p>强引用：强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用 弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<p>可用场景： Java 源码中的中的就是使用弱引用，一旦我不需要某个引用，JVM 会自动帮我处理它，这样我就不需要做其他操作。</p>
</li>
<li><p>软引用 软引用在程序内存不足时，会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf 这个引用也是强引用，它是指向 SoftReference 这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向 new String(&quot;str&quot;）的引用，也就是 SoftReference 类中 T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用</p>
<p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入<strong>ReferenceQueue中</strong>。</p>
<p>注意哦，其他引用是被JVM 回收后才被传入中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有<br>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;())</span><br></pre></td></tr></table></figure>

<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做<br>这类动作，但是这个方式既不安全又低效</p>
</li>
</ul>
<p>上述所说的几类引用，都是指对象本身的引用，而不是指Reference 的四个子类的引用(SoftReference 等）。</p>
<h2 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h2><p>“泛型” ，顾名思义， “泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iniData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="JAVA创建对象有几种方式"><a href="#JAVA创建对象有几种方式" class="headerlink" title="JAVA创建对象有几种方式"></a>JAVA创建对象有几种方式</h2><p>java中提供了以下四种创建对象的方式：</p>
<ul>
<li><p>new创建新对象</p>
</li>
<li><p>通过反射机制</p>
</li>
<li><p>采用clone机制</p>
</li>
<li><p>通过序列化机制</p>
<p>调用ObjectInputStream 类的readObject() 方法。<br>反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对象。</p>
</li>
</ul>
<h2 id="可能两个不相等的对象有相同的hashcode"><a href="#可能两个不相等的对象有相同的hashcode" class="headerlink" title="可能两个不相等的对象有相同的hashcode"></a>可能两个不相等的对象有相同的hashcode</h2><p>有可能.在产生hash 冲突时，两个不相等的对象就会有相同的hashcode 值.当hash 冲突产生时，一般有以下几种方式来处理：</p>
<ul>
<li><p>拉链法：每个哈希表节点都有一个next 指针，多个哈希表节点可以用next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>
</li>
<li><p>再哈希：又叫双哈希法，有多个不同的Hash 函数.当发生冲突时，使用第二个，第三个….等哈希函数计算地址，直到无冲突.</p>
</li>
</ul>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><ul>
<li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象.换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象.</li>
<li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>被final 修饰的类不可以被继承</li>
<li>被final 修饰的方法不可以被重写</li>
<li>被final 修饰的变量不可以被改变.如果修饰引用，那么表示引用不可变，引用指向的内<br>容可变.</li>
<li>被final 修饰的方法，JVM 会尝试将其内联，以提高运行效率</li>
<li>被final 修饰的常量，在编译阶段会存入常量池</li>
</ul>
<p>编译器对final 域要遵守的两个重排序规则更好：</p>
<p>在构造函数内对一个final 域的写入,随后把这个被构造对象的引用赋值给一个引用变量</p>
<p>这两个操作之间不能重排序初次读一个包含final 域的对象的引用，与随后初次读这个final 域</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态变量和静态方法.也就是被static 所修饰的变量&#x2F; 方法都属于类的静态资源，</p>
<p>类实例所共享除了静态变量和静态方法之外，static 也用于静态块，多用于初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//执行相关操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外static 也多用于修饰内部类，此时称之为静态内部类.最后一种用法就是静态导包，即import static .import static 是在JDK 1.5 之后引入的新特性，<br>可以用来指定导入某个类中的静态资源，并且不需要使用类名，可以直接使用资源名，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//System.out.println(Math.sin(20))；传统做法</span></span><br><span class="line">System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="a-x3D-a-b-与-a-x3D-b"><a href="#a-x3D-a-b-与-a-x3D-b" class="headerlink" title="a&#x3D;a+b 与 a+&#x3D;b"></a>a&#x3D;a+b 与 a+&#x3D;b</h2><p>+&#x3D;操作符会进行隐式自动类型转换，此处a+&#x3D;b 隐式的将加操作的结果类型强制转换为持有结果<br>的类型，而a&#x3D;a+b 则不会自动进行类型转换.如：</p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><strong>finally 的执行早于try 里面的return</strong></p>
<ol>
<li>不管有没有出现异常，finally 块中代码都会执行；</li>
<li>当try 和catch 中有return 时，finally 仍然会执行；</li>
<li>finally 是在return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally 执行前确定的；</li>
<li>finally 中最好不要包含return，否则程序会提前退出，返回值不是try 或catch 中保存的返回值。</li>
</ol>
<h2 id="Exception-与-Error-包结构"><a href="#Exception-与-Error-包结构" class="headerlink" title="Exception 与 Error 包结构"></a>Exception 与 Error 包结构</h2><p>Java 可抛出（Throwable）的结构分为三种类型：被检查的异常（CheckedException)，运行<br>时异常(RuntimeException)，错误（Error)。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>RuntimeException 及其子类都被称为运行时异常</p>
<p>常见的五种运行时异常：</p>
<ul>
<li>ClassCastException（类转换异常）</li>
<li>IndexOutOfBoundsException（数组越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArrayStoreException（数据存储异常，操作数组类型不一致）</li>
<li>BufferOverflowException</li>
</ul>
<h3 id="被检查异常"><a href="#被检查异常" class="headerlink" title="被检查异常"></a>被检查异常</h3><p>Exception 类本身，以及Exception 的子类中除了”运行时异常”之外的其他子类都属于被检查异常。</p>
<p>此类异常，要么通过throws 进行声明抛出，要么通过try-catch 进行捕获处理，否则不能通过编译。</p>
<p>例如 ：clone(）接口去克隆一个对象，而该对象对应的类没有实现Cloneable 接口，就会抛出<br>CloneNotSupportedException 异常。被检查异常通常都是可以恢复的。如：</p>
<ul>
<li>IOException</li>
<li>FileNotFoundException</li>
<li>SQLException</li>
</ul>
<p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的<br>FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对<br>象引用时没有确保对象非空而引起的NullPointerException 。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>定义: Error 类及其子类。</p>
<p>特点: 和运行时异常一样，编译器也不会对错误进行检查。</p>
<p>当资源不足、约束失败，或是或是其他程序无法继续运行的条件发生时，就产生错误。程序本身<br>无法修复这些错误的。例如，VirtualMachineError 就属于错误。出现这种错误会导致程序终止<br>运行。</p>
<p>OutOfMemoryError、ThreadDeath。</p>
<p>Java 虚拟机规范规定JVM 的内存分为好几块，比如堆，栈，程序计数器，方法区等</p>
<h2 id="OOM、SOF"><a href="#OOM、SOF" class="headerlink" title="OOM、SOF"></a>OOM、SOF</h2><p>OutOfMemoryError 异常</p>
<ul>
<li>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM）异常的可能。</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>运行时常量池溢出</li>
<li>方法区溢出</li>
</ul>
<p>SOF堆栈溢出 StackOverflow：</p>
<p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p>
<h2 id="线程、进程、程序"><a href="#线程、进程、程序" class="headerlink" title="线程、进程、程序"></a>线程、进程、程序</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h2 id="JAVA序列化中如果有写字段不想进行序列化"><a href="#JAVA序列化中如果有写字段不想进行序列化" class="headerlink" title="JAVA序列化中如果有写字段不想进行序列化"></a>JAVA序列化中如果有写字段不想进行序列化</h2><p>对于不想进行序列化的变量，使用transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化<br>时，被transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和<br>方法。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h3><p>NIO 即New IO，这个库是在JDK1.4 中才引入的。NIO 和IO 有相同的作用和目的，但实现方式不<br>同， NIO 主要用到的是块，所以NIO 的效率要比IO 高很多。在Java API 中提供了两套NIO ，一<br>套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h2 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h2><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象， 都能够调用它的任意一个方法。在java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。<br>动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的反射机制。(jdbc 就是典型的反射)</p>
<h3 id="反射的实现方式："><a href="#反射的实现方式：" class="headerlink" title="反射的实现方式："></a>反射的实现方式：</h3><p>第一步：获取Class 对象，有4 种方法：</p>
<ol>
<li><p>Class.forName(“类的路径”）</p>
</li>
<li><p>类名.class </p>
</li>
<li><p>对象名.getClass() </p>
</li>
<li><p>基本类型的包装类，可以调用包装类的Type 属性来获得该包装类的Class<br>对象</p>
</li>
<li><p>Class：表示正在运行的Java 应用程序中的类和接口注意： 所有获取对象的信息都需要Class类来实现。</p>
</li>
<li><p>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
</li>
<li><p>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限</p>
</li>
<li><p>Method：提供类或接口中某个方法的信息</p>
</li>
</ol>
<p>优点： </p>
<ul>
<li>能够运行时动态获取类的实例，提高灵活性； </li>
<li>与动态编译结合</li>
</ul>
<p>缺点： </p>
<ul>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</li>
</ul>
<p>解决方案： </p>
<ul>
<li>通过setAccessible(true)关闭JDK 的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多</li>
<li>ReflectASM 工具类，通过字节码生成的方式加快反射速度,相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</li>
</ul>
<h2 id="List，Set，Map"><a href="#List，Set，Map" class="headerlink" title="List，Set，Map"></a>List，Set，Map</h2><p><strong>List（对付顺序的好帮手）：</strong> List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p>
<p><strong>Set（注重独一无二的性质）：</strong>不允许重复的集合。不会有多个元素引用相同的对象。</p>
<p><strong>Map（用来搜索的专家）：</strong> 使用键值对存储。Map 会维护与Key 有关联的值。两个Key 可以引用相同的对象，但Key 不能重复，典型的Key 是String 类型，但也可以是任何对象。</p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast 机制是Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：当某一个线程A 通过iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程A 访问集合时，就会抛出ConcurrentModificationException 异常，产生fail-fast 事件。这里的操作主要是指add、remove 和clear ，对集合元素个数进行修改。</span><br></pre></td></tr></table></figure>



<p>解决办法：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<p>可以这么理解：在遍历之前，把modCount 记下来expectModCount，后面expectModCount去和modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出ConcurrentModificationException 异常。</p>
<h2 id="Hashtable-与-HashMap"><a href="#Hashtable-与-HashMap" class="headerlink" title="Hashtable 与 HashMap"></a>Hashtable 与 HashMap</h2><ol>
<li>都实现了Map、Cloneable、Serializable</li>
<li>HashMap 继承的是AbstractMap，并且AbstractMap 也实现了Map 接口。Hashtable 继承Dictionary。</li>
<li>Hashtable 中大部分public 修饰普通方法都是synchronized 字段修饰的，是线程安全的， HashMap 是非线程安全的。</li>
<li>Hashtable 的key 不能为null ，value 也不能为null，这个可以从Hashtable 源码中的put方法看到，判断如果value 为null 就直接抛出空指针异常</li>
<li>HashMap 的key 和value 都可以为null。在计算hash 值的时候，有判断，如果key&#x3D;&#x3D;null ，则其hash&#x3D;0 ；至于value 是否为null ，根本没有判断过。</li>
<li>Hashtable 直接使用对象的hash 值。hash 值是JDK 根据对象的地址或者字符串或者数字算出来的int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li>
<li>默认情况下，初始容量不同，Hashtable 的初始长度是11，之后每次扩充容量变为之前的2n+1（ n 为上一次的长度）<strong>而HashMap 的初始长度为16</strong> ，之后每次扩充变为原来的两倍。</li>
</ol>
<p>Hashtable 是线程安全，推荐使用HashMap 代替Hashtable；如果需要线程安全<br>高并发的话，推荐使用ConcurrentHashMap 代替Hashtable。这个回答完了，面试官可能会继续问：HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p>
<h3 id="HashMap-中的-key-可以用任何类吗"><a href="#HashMap-中的-key-可以用任何类吗" class="headerlink" title="HashMap 中的 key 可以用任何类吗"></a>HashMap 中的 key 可以用任何类吗</h3><p>平时可能大家使用得最多的就是使用String 作为HashMap 的key，但是现在我们想使用某个自定义类作为HashMap 的key，那就需要注意以下几点：</p>
<ul>
<li>如果类重写了equals 方法，它也应该重写hashCode 方法。</li>
<li>类的所有实例需要遵循与equals 和hashCode 相关的规则。</li>
<li>如果一个类没有使用equals，你不应该在hashCode 中使用它。</li>
<li>咱们自定义key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode 和equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h3 id="HashMap的长度为什么是2-n次方"><a href="#HashMap的长度为什么是2-n次方" class="headerlink" title="HashMap的长度为什么是2^n次方"></a>HashMap的长度为什么是2^n次方</h3><p>为了能让HashMap 存数据和取数据的效率高，尽可能地减少hash 值的碰撞，也就是说尽量把数据能均匀地分配，每个链表或者红黑树长度尽量相等。</p>
<p>我们首先可能会想到% 取模的操作来实现。</p>
<p>下面是回答的重点哟：</p>
<blockquote>
<p>取余（%）操作中如果除数是2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说hash % length &#x3D;&#x3D; hash &amp;(length - 1) 的前提是length 是2 的n 次方）。并且，采用二进制位操作&amp; ，相对于% 能够提高运算效率。<br>这就是为什么HashMap 的长度需要2 的N 次方了。</p>
</blockquote>
<h3 id="HashMap的数组的元素类型"><a href="#HashMap的数组的元素类型" class="headerlink" title="HashMap的数组的元素类型"></a>HashMap的数组的元素类型</h3><blockquote>
<p>java.util.Map$Entry。JDK1.7的HashMap中有内部类Entry实现Entry接口</p>
<p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口，并且TreeNode是Node的子类。</p>
</blockquote>
<h3 id="HashMap的映射关系的存储索引index如何计算"><a href="#HashMap的映射关系的存储索引index如何计算" class="headerlink" title="HashMap的映射关系的存储索引index如何计算"></a>HashMap的映射关系的存储索引index如何计算</h3><p>hash &amp; table.length-1</p>
<h3 id="为什么数组还需要链表？或问如何解决hash或-index-冲突问题？"><a href="#为什么数组还需要链表？或问如何解决hash或-index-冲突问题？" class="headerlink" title="为什么数组还需要链表？或问如何解决hash或[index]冲突问题？"></a>为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</h3><blockquote>
<p>答：为了解决hash和[index]冲突问题</p>
<p>（1）两个不相同的key的hashCode值本身可能相同</p>
<p>（2）两个不相同的key的hashCode值不同，但是经过hash()运算，结果相同</p>
<p>（3）两个hashCode不相同的key，经过hash()运算，结果也不相同，但是通过 hash &amp; table.length-1运算得到的[index]可能相同</p>
<p>那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p>
</blockquote>
<h3 id="HashMap的数组什么时候扩容？"><a href="#HashMap的数组什么时候扩容？" class="headerlink" title="HashMap的数组什么时候扩容？"></a>HashMap的数组什么时候扩容？</h3><blockquote>
<p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!&#x3D;null时，两个条件同时满足会扩容</p>
<p>JDK1.8版：当要添加新Entry对象时发现</p>
<p>（1）size达到threshold</p>
<p>（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容 ， **达到64会进行树化 **因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p>
<p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p>
</blockquote>
<h2 id="HashMap-与-ConcurrentHashMap-的异同"><a href="#HashMap-与-ConcurrentHashMap-的异同" class="headerlink" title="HashMap 与 ConcurrentHashMap 的异同"></a>HashMap 与 ConcurrentHashMap 的异同</h2><ol>
<li><p>都是key-value 形式的存储数据；</p>
</li>
<li><p>HashMap 是线程不安全的，ConcurrentHashMap 是JUC 下的线程安全的；</p>
</li>
<li><p>HashMap 底层数据结构是数组+ 链表（JDK 1.8 之前）。JDK 1.8 之后是数组+ 链表+ 红黑树。当链表中元素个数达到8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</p>
</li>
<li><p>HashMap 初始数组大小为16（默认），当出现扩容的时候，以0.75 *数组大小的方式进行扩容；</p>
</li>
<li><p>ConcurrentHashMap 在JDK 1.8 之前是采用分段锁来实现的Segment + HashEntry ，Segment 数组大小默认是16 ，2 的n 次方；JDK 1.8 之后，采用Node + CAS +Synchronized 来保证并发安全进行实现</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405110102488.png"/>

<h1 id="JAVA多线程与并发"><a href="#JAVA多线程与并发" class="headerlink" title="JAVA多线程与并发"></a>JAVA多线程与并发</h1><p>创建线程的常用三种方式：</p>
<ol>
<li>继承Thread 类</li>
<li>实现Runnable 接口</li>
<li>实现Callable 接口（ JDK1.5&gt;&#x3D;）</li>
<li>线程池方式创建</li>
</ol>
<p>通过继承Thread 类或者实现Runnable 接口、Callable 接口都可以实现多线程，不过实现Runnable接口与实现Callable 接口的方式基本相同，只是Callable 接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable 接口和实现Callable 接口归为一种方式。这种方式与继承Thread 方式之间的主要差别如下。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="Runnable-和Callable-接口优缺点"><a href="#Runnable-和Callable-接口优缺点" class="headerlink" title="Runnable 和Callable 接口优缺点"></a>Runnable 和Callable 接口优缺点</h3><p>优点：</p>
<ul>
<li>线程类只是实现了Runnable 或者Callable 接口，还可以继承其他类。这种方式下，多个线程</li>
<li>可以共享一个target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
<p>缺点：编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread() 方法</p>
<h3 id="Thread接口"><a href="#Thread接口" class="headerlink" title="Thread接口"></a>Thread接口</h3><p>优点：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread() 方法，直接使用this 即可获取当前线程<br>缺点：因为线程类已经继承了Thread 类，Java 语言是单继承的，所以就不能再继承其他父类了。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ol>
<li><p>使用退出标志，使线程正常退出，也就是当run 方法完成后线程终止。</p>
</li>
<li><p>使用stop 方法强行终止，但是不推荐这个方法，因为stop 和suspend 及resume 一样都是过期作废的方法。</p>
</li>
<li><p>使用interrupt 方法中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1.stop = <span class="literal">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h3><p><code>notify()</code> 方法用于唤醒在某个对象监视器上等待的单个线程。如果多个线程在等待，任何一个线程被唤醒是完全不确定的。如果需要唤醒所有等待的线程，可以使用 <code>notifyAll()</code> 方法。</p>
<ul>
<li>notify 可能会导致死锁，而notifyAll 则不会</li>
<li>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码使用notifyall，可以唤醒所有处于wait 状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li>
<li>wait() 应配合while 循环使用，不应使用if，务必在wait(）调用前后都检查条件，如果不满足，必须调用notify(）唤醒另外的线程来处理，自己继续wait(）直至条件满足再往下执行。</li>
<li>notify() 是对notifyAll(）的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是WaitSet 中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify(）下一个线程，并且自身需要重新回到WaitSet 中.</li>
</ul>
<h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h3><p>对于sleep(）方法，我们首先要知道该方法是属于Thread 类中的。而wait(）方法，则是属于Object 类中的。</p>
<p>sleep(）方法导致了程序暂停执行指定的时间，让出cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep(）方法的过程中，线程不会释放对象锁。</p>
<p>当调用wait(）方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用</p>
<p>notify(）方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</p>
<h2 id="volatile-可以保证有序性"><a href="#volatile-可以保证有序性" class="headerlink" title="volatile 可以保证有序性"></a>volatile 可以保证有序性</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile 修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，volatile 关键字会强制将修改的值立即写入主存。</p>
<p>2）禁止进行指令重排序。volatile 不是原子性操作</p>
<p><strong>保证部分有序性：</strong>当程序执行到volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p><code>由于flag 变量为volatile 变量，那么在进行指令重排序的过程的时候，不会修改其在代码中的位置，但其他的非volatile变量就无法保证其位置是否会变动</code></p>
<p>使用volatile 一般用于状态标记量和单例模式的双检锁</p>
<h3 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h3><ul>
<li>volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法和类级别的。</li>
<li>volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<h2 id="Thread类中的-start-和-run-区别"><a href="#Thread类中的-start-和-run-区别" class="headerlink" title="Thread类中的 start() 和 run() 区别"></a>Thread类中的 start() 和 run() 区别</h2><p>start(）方法被用来启动新创建的线程，而且start(）内部调用了run(）方法，</p>
<p>当你调用run(）方法的时候，只会是在原来的线程中调用，没有新的线程启动，start() 方法才会启动新线程。</p>
<h2 id="为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait,notify和notifyAll这些方法不在thread类里面？"></a>为什么wait,notify和notifyAll这些方法不在thread类里面？</h2><p>明显的原因是JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。</p>
<p>如果wait(）方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。</p>
<p>简单地说，由于wait ，notify 和notifyAll 都是锁级别的操作，所以把他们定义在Object 类中因为锁属于对象。</p>
<h2 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h2><ol>
<li>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify(）和notifyAll(）方法。</li>
<li>如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免wait 和notify 之间产生竞态条件。</li>
</ol>
<p>wait(）方法强制当前线程释放对象锁。这意味着在调用某对象的wait(）方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait(）方法。</p>
<p>在调用对象的notify(）和notifyAll(）方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify(）或notifyAll(）方法。</p>
<p>调用wait(）方法的原因通常是，调用线程希望某个特殊的状态（或变量）被设置之后再继续执行。调用notify(）或notifyAll(）方法的原因通常是，调用线程希望告诉其他等待中的线程：”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态（或变量）。</p>
<h2 id="Java-中-interrupted-和-islnterrupted方法的区别？"><a href="#Java-中-interrupted-和-islnterrupted方法的区别？" class="headerlink" title="Java 中 interrupted 和 islnterrupted方法的区别？"></a>Java 中 interrupted 和 islnterrupted方法的区别？</h2><p>interrupted() 和isInterrupted(）的主要区别是前者会将中断状态清除而后者不会。</p>
<p>Java 多线程的中断机制是用内部标识来实现的，调用Thread.interrupt(）来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted(）来检查中断状态时，中断状态会被清零。</p>
<p>而非静态方式法isInterrupted(）用来查询其他线程的中断状态且不会改变中断状态标识。</p>
<p>简单地说就是任何抛出InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有可能被其他线程调用中断来改变。</p>
<h2 id="Java中synchronized和ReentrantLock有什么不同？"><a href="#Java中synchronized和ReentrantLock有什么不同？" class="headerlink" title="Java中synchronized和ReentrantLock有什么不同？"></a>Java中synchronized和ReentrantLock有什么不同？</h2><p>相似点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，</span><br><span class="line">也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等，而进行线程阻塞和唤醒的代价是比较高的.</span><br></pre></td></tr></table></figure>



<p>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两种方式最大区别就是对于Synchronized 来说，它是java 语言的关键字，是原生语法层面的互斥，需要jvm 实现。</span><br><span class="line"></span><br><span class="line">而ReentrantLock 它是JDK 1.5 之后提供的API 层面的互斥锁，需要lock(）和unlock(）方法配合try/finally 语句块来完成。</span><br></pre></td></tr></table></figure>



<p>Synchronized 进过编译，会在同步块的前后分别形成monitorenter 和monitorexit 这两个字节码指令。在执行monitorenter 指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应地，在执行monitorexit 指令时会将锁计算器就减1，当计算器为0 时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<p>由于ReentrantLock 是java.util.concurrent 包下提供的一套互斥锁，相比<br>Synchronized ， ReentrantLock 类提供了一些高级功能，主要有以下3 项：</p>
<ol>
<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized 来说可以避免出现死锁的情况。</li>
<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized 锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true 设为公平锁，但公平锁表现的性能不是很好。</li>
<li>锁绑定多个条件，一个ReentrantLock 对象可以同时绑定多个对象。</li>
</ol>
<h2 id="保证线程的顺序执行"><a href="#保证线程的顺序执行" class="headerlink" title="保证线程的顺序执行"></a>保证线程的顺序执行</h2><p>可以用线程类的join(）方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>实际上先启动三个线程中哪一个都行， 因为在每个线程的run 方法中用join 方法限定了三个线程的执行顺序。</p>
<h2 id="SynchronizedMap和-ConcurrentHashMap有什么区别？"><a href="#SynchronizedMap和-ConcurrentHashMap有什么区别？" class="headerlink" title="SynchronizedMap和 ConcurrentHashMap有什么区别？"></a>SynchronizedMap和 ConcurrentHashMap有什么区别？</h2><p>SynchronizedMap(）和Hashtable 一样，实现上在调用map 所有方法时，都对整个map 进行同步。</p>
<p>而ConcurrentHashMap 的实现却更加精细，它对map 中的<strong>所有桶加了锁</strong>。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map 执行某些操作。</p>
<p>所以，ConcurrentHashMap 在性能以及安全性方面，明显比Collections.synchronizedMap(）更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map 时，如果其他线程试图对map 进行数据修改，也不会抛出ConcurrentModificationException。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。<br>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释得最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p>
<p>这个问题有值得一提的地方，就是远程安全也是有几个级别的：</p>
<p>（ 1）不可变<br>像String、Integer、Long 这些，都是final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<p>（ 2）绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>
<p>（ 3）相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector ，99%的情况下都会出现ConcurrentModificationException，也就是机制。</p>
<p>（ 4）线程非安全<br>ArrayList、LinkedList、HashMap 等都是线程非安全的类</p>
<h3 id="保证几个基本特征"><a href="#保证几个基本特征" class="headerlink" title="保证几个基本特征"></a>保证几个基本特征</h3><ul>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h2 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h2><p>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU 占用而不能保证使其他线程一定能占用CPU，执行yield(）的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="Java线程池中submit-和execute-方法有什么区别？"><a href="#Java线程池中submit-和execute-方法有什么区别？" class="headerlink" title="Java线程池中submit()和execute()方法有什么区别？"></a>Java线程池中submit()和execute()方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，</p>
<p> execute(）方法的返回类型是void，它定义在Executor 接口中， </p>
<p>而submit(）方法可以返回持有计算结果的Future 对象，它定义在ExecutorService 接口中，它扩展了Executor 接口，其它线程池类像ThreadPoolExecutor 和ScheduledThreadPoolExecutor 都有这些方法。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<blockquote>
<p>在Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。</p>
</blockquote>
<p>Java 6 之后synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p><strong>修饰实例方法： 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁修饰静态方法：</strong></p>
<p>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new 了多少个对象，只有一份）。所以如果一个线程A 调用一个实例对象的非静态synchronized 方法，而线程B 需要调用这个实例对象所属类的静态synchronized 方法，是允许的，不会发生互斥现象，</p>
<p>因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态方法占用的锁是当前实例对象锁。</p>
<p><strong>修饰代码块：</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
<p><strong>总结：</strong>synchronized 关键字加到static 静态方法和synchronized(class）代码块上都是给Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a) 因为JVM 中，字符串常量池具有缓存功能！</p>
<h2 id="Vector是一个线程安全类"><a href="#Vector是一个线程安全类" class="headerlink" title="Vector是一个线程安全类"></a>Vector是一个线程安全类</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。</p>
<p>Vector 是用同步方法来实现线程安全的， 而和它相似的ArrayList 不是线程安全的。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li>最大线程数maximumPoolSize</li>
<li>核心线程数corePoolSize</li>
<li>活跃时间keepAliveTime</li>
<li>阻塞队列workQueue</li>
<li>拒绝策略RejectedExecutionHandler</li>
</ol>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="线程池的理解"><a href="#线程池的理解" class="headerlink" title="线程池的理解"></a>线程池的理解</h3><p>（如果问到了这样的问题，可以展开地说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p>
<ol>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ol>
<h3 id="JAVA线程池中队列常用类型有哪些"><a href="#JAVA线程池中队列常用类型有哪些" class="headerlink" title="JAVA线程池中队列常用类型有哪些"></a>JAVA线程池中队列常用类型有哪些</h3><ul>
<li><p>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出）原则对元素进行排序。</p>
</li>
<li><p>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO(先进先出）排序元素，吞吐量通常要高于ArrayBlockingQueue。</p>
</li>
<li><p>SynchronousQueue 一个不存储元素的阻塞队列。</p>
</li>
<li><p>PriorityBlockingQueue 一个具有优先级的无限阻塞队。 也是基于最小二叉堆实现 </p>
</li>
<li><p>DelayQueue ：</p>
<ul>
<li>只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</li>
<li>DelayQueue是一个没有大小限制的队列，</li>
<li>因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
</ul>
</li>
</ul>
<p>这里能说出前三种也就差不多了，如果能说全那是最好。</p>
<h3 id="线程池核心线程数设置"><a href="#线程池核心线程数设置" class="headerlink" title="线程池核心线程数设置"></a>线程池核心线程数设置</h3><p>分为CPU 密集型和IO 密集型</p>
<p><strong>CPU：</strong>这种任务消耗的主要是CPU 资源，可以将线程数设置为N（ CPU 核心数）+1，比CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU 的空闲时间。</p>
<p><strong>IO密集型：</strong>这种任务应用起来，系统会用大部分的时间来处理I&#x2F;O 交互，而线程在处理I&#x2F;O 的时间段内不会占用CPU 来处理，这时就可以将CPU 交出给其他线程使用。因此在I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是：核心线程数&#x3D;CPU 核心数量*2。</p>
<h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><p>主要有4 种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li>
<li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常</li>
</ol>
<h2 id="JAVA程序是如何执行的"><a href="#JAVA程序是如何执行的" class="headerlink" title="JAVA程序是如何执行的"></a>JAVA程序是如何执行的</h2><ul>
<li><p>先把Java 代码编译成字节码，也就是把.java 类型的文件编译成.class 类型的文件。这个过程的大致执行流程：</p>
<p><strong>Java 源代码-&gt; 词法分析器-&gt; 语法分析器-&gt; 语义分析器-&gt; 字符码生成器-&gt; 最终生成字节码</strong></p>
<p>其中任何一个节点执行失败就会造成编译失败；</p>
</li>
<li><p>把class 文件放置到Java 虚拟机，这个虚拟机通常指的是Oracle 官方自带的Hotspot JVM；</p>
</li>
<li><p>Java 虚拟机使用类加载器（Class Loader）装载class 文件；</p>
</li>
<li><p>类加载完成之后，会进行字节码校验，字节码校验通过之后JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以Hotspot 虚拟机来说，它本身提供了JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。</p>
<p>Java 程序执行流程图如下：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405131631960.png"/></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>从JDK1.6 版本之后，synchronized 本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p>
<p>锁的状态从低到高依次为无锁－〉偏向锁－〉轻量级锁－〉重量级锁，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
<ul>
<li><p><strong>自旋锁：</strong>由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所以没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环， 可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10 次，可以使用-XX:PreBlockSpin 设置。</p>
</li>
<li><p><strong>自适应锁：</strong>自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p>
</li>
<li><p><strong>锁消除：</strong>锁消除指的是JVM 检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
</li>
<li><p><strong>锁粗化：</strong>锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围<strong>扩展到整个操作序列</strong>之外。</p>
</li>
<li><p><strong>偏向锁：</strong>当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS 来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以通过设置-XX:+UseBiasedLocking 开启偏向锁。</p>
</li>
<li><p><strong>轻量级锁：</strong>JVM 的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM 将会使用CAS 方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败， 当前线程就尝试自旋来获得锁。<br>整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。</p>
</li>
</ul>
<p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS 了，而轻量级锁主要就是通过CAS 修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li>互斥条件：一个资源每次只能被一个线程使用</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>指定获取锁的顺序，举例如下：</p>
<ol>
<li>比如某个线程只有获得A 锁和B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</li>
<li>获得锁的顺序是一定的，比如规定，只有获得A 锁的线程才有资格获取B 锁，按顺序获取锁就可以避免死锁！！！</li>
</ol>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写－读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p>例如上图线程A 与线程B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li><p>线程A 把本地内存A 更新过的共享变量刷新到主内存中去。</p>
</li>
<li><p>线程B 到主内存中去读取线程A 之前更新过的共享变量。</p>
</li>
</ol>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确地发送消息来显式进行通信。</p>
<p>在Java 中典型的消息传递方式，就是wait() 和notify() ，或者BlockingQueue 。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>hreadLocal 可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized 的做法是用空间来换时间。</p>
<p>ThreadLocal 有一个静态内部类ThreadLocalMap ，ThreadLocalMap 又包含了一个Entry 数组，Entry 本身是一个弱引用，他的key 是指向ThreadLocal 的弱引用，Entry 具备了保存key value键值对的能力。</p>
<p>弱引用的目的是防止内存泄漏，如果是强引用那么ThreadLocal 对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC 的时候被回收。</p>
<p>但是这样还是会存在内存泄漏的问题，假如key 和ThreadLocal 对象被回收之后，entry 中就存在key 为null，但是value 有值的entry 对象，但是永远没办法被访问到，同样除非线程结束运行。</p>
<p>但是只要ThreadLocal 使用恰当，在使用完之后调用remove 方法删除Entry 对象，实际上是不会出现这个问题的。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>随着CPU 和内存的发展速度差异的问题，导致CPU 的速度远快于内存，所以现在的CPU 加入了 高速缓存，高速缓存一般可以分为L1、L2、L3 三级缓存。基于上面的例子我们知道了这导致了 缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU 的重排序导致了原子性和有序性的问题，JMM 内存模型正是对多线程操作下的一系列规范约束， 因为不可能让程序员的代码去兼容所有的CPU，通过JMM 我们才屏蔽了不同硬件和操作系统内 存的访问差异， 这样保证了Java 程序在不同的平台下达到一致的内存访问效果，同时也是保证在 高效并发的时候程序能够正确执行。</p>
<h3 id="happen-before-规则"><a href="#happen-before-规则" class="headerlink" title="happen-before 规则"></a>happen-before 规则</h3><p>虽然指令重排提高了并发的性能，但是Java 虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意地改变执行位置，主要有以下几点：</p>
<ol>
<li>单线程每个操作，happen-before 于该线程中任意后续操作</li>
<li>volatile 写happen-before 与后续对这个变量的读</li>
<li>synchronized 解锁happen-before 后续对这个锁的加锁</li>
<li>final 变量的写happen-before 于final 域对象的读，happen-before 后续对final 变量的读</li>
<li>传递性规则，A 先于B ，B 先于C，那么A 一定先于C 发生</li>
</ol>
<p>主内存可以认为就是物理内存，Java 内存模型中实际就是虚拟机内存的一部分。而工作内存就是CPU 缓存，他有可能是寄存器也有可能是L1\L2\L3 缓存，都是有可能的。</p>
<h2 id="CyclicBarrier和-CountDownLatch的区别？"><a href="#CyclicBarrier和-CountDownLatch的区别？" class="headerlink" title="CyclicBarrier和 CountDownLatch的区别？"></a>CyclicBarrier和 CountDownLatch的区别？</h2><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：<br>(1)CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>
<p>(2)CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p>
<p>(3)CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>简单说一下AQS ，AQS 全称为AbstractQueuedSychronizer ，翻译过来应该是抽象队列同步器。</p>
<p>如果说java.util.concurrent 的基础是CAS 的话，那么AQS 就是整个Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry 中并连成双向队列，前面一个线程使用ReentrantLock 好了，则双向队列实际上的第一个Entry 开始运行。</p>
<p>AQS 定义了对双向队列所有的操作，而只开放了tryLock 和tryRelease 方法给开发者使用，开发者可以根据自己的实现重写tryLock 和tryRelease 方法，以实现自己的并发功能。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>emaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个int 型整数n ，表示某段代码最多只有n 个线程可以访问，如果超出了n ，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore 构造函数中</p>
<p>传入的int 型整数n&#x3D;1，相当于变成了一个synchronized 了</p>
<h2 id="Callable-和-Future"><a href="#Callable-和-Future" class="headerlink" title="Callable 和 Future"></a>Callable 和 Future</h2><p>Callable 接口类似于Runnable，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。</p>
<p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以Callable 用于产生结果， Future 用于获取结果。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>JDK7 提供了7 个阻塞队列。分别是：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue ：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue ：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque ：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="多线程上下文切换"><a href="#多线程上下文切换" class="headerlink" title="多线程上下文切换"></a>多线程上下文切换</h2><p>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p>
<p>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe ）。“页码”信息会一直保存到CPU 的内存中，直到他们被再次使用。</p>
<p>上下文切换是存储和恢复CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h2 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h2><p>所谓后台（daemon）线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程， 并且这个线程并不属于程序中不可或缺的部分。</p>
<p>因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说， 只要有任何非后台线程还在运行，程序就不会终止。</p>
<p>必须在线程启动之前调用setDaemon(）方法，才能把它设置为后台线程。注意：后台进程在不执行finally 子句的情况下就会终止其run(）方法。</p>
<p>比如：JVM 的垃圾回收线程就是Daemon 线程，Finalizer 也是守护线程。</p>
<h2 id="乐观锁和悲观锁的理解及如何实现"><a href="#乐观锁和悲观锁的理解及如何实现" class="headerlink" title="乐观锁和悲观锁的理解及如何实现"></a>乐观锁和悲观锁的理解及如何实现</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，<strong>所以每次在拿数据的时候都会上锁</strong>，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java 里面的同步原语synchronized 关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>，可以使用版本号等机制。</p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
<p>在Java 中java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式CAS 实现的。</p>
<h3 id="乐观锁实现机制"><a href="#乐观锁实现机制" class="headerlink" title="乐观锁实现机制"></a>乐观锁实现机制</h3><ol>
<li><p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p>
</li>
<li><p>java 中的Compare and Swap 即CAS ，当多个线程尝试使用CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
</li>
</ol>
<p>CAS 操作中包含三个操作数—— 需要读写的内存位置<br>（V）、进行比较的预期原值（A）和拟写入的新值（B)。如果内存位置V 的值与预期原值A 相<br>匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包<br>含三个操作数：</p>
<ol>
<li>变量内存地址，V 表示</li>
<li>旧的预期值，A 表示</li>
<li>准备设置的阈值，B 表示</li>
</ol>
<p>当执行CAS 指令时，只有当V 等于A 时，才会用B 去更新V 的值，否则就不会执行更新操作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>ABA 的问题 ：</strong>指的是在CAS 更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS 更新的漏洞就叫做ABA。只是ABA 的问题大部分场景下都不影响并发的最终效果。</p>
<p>Java 中有AtomicStampedReference 来解决这个问题，他加入了预期标志和更新后标志两个字段， 更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<p><strong>循环时间长开销大：</strong>自旋CAS 的方式如果长时间不成功，会给CPU 带来很大的开销。</p>
<p><strong>只能保证一个共享变量的原子操作：</strong>只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference 来处理或者使用锁synchronized 实现。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120013055.png"/>

<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>线程独占：栈，本地方法栈，程序计数器线程共享：堆，方法区</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>又称方法栈，线程私有的，线程执行方法是会创建一个栈阵，用来存储局部变量表，操作栈，动态链接，方法出口等信息.调用方法时执行入栈，方法返回式执行出栈.</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与栈类似，也是用来保存执行方法的信息.执行Java 方法是使用栈，执行Native 方法时使用本地方<br>法栈.</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>保存着当前线程执行的字节码位置，每个线程工作时都有独立的计数器，只为执行Java 方法服务，执行Native 方法时，程序计数器为空.</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405122146852.png"/>

<p>JVM 内存管理最大的一块，对被线程共享， 目的是存放对象的实例，几乎所有的对象实例都会放在这里， 当堆没有可用空间时，会抛出OOM 异常.根据对象的存活周期不同，JVM 把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</p>
<h3 id="堆内分配与回收策略"><a href="#堆内分配与回收策略" class="headerlink" title="堆内分配与回收策略"></a>堆内分配与回收策略</h3><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>大多数情况下，对象在新生代Eden区中分配，当 Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC</p>
<h4 id="什么是Minor-GC"><a href="#什么是Minor-GC" class="headerlink" title="什么是Minor GC"></a>什么是Minor GC</h4><p>指发生在新生代的垃圾收集，因为 Java对象大多朝生夕灭，所以 Minor GC非常频繁， 一般回收速度也比较快</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p><strong>XX:PretenureSizeThreshold</strong> 当创建的对象超过指定大小时，直接把对象分配在老年代<br>大对象就是指需要大量连续内存空间的 Java 对象如字符串、数组，为了避免为大对象分配内存时<br>由于分配担保机制带来的复制而降低效率</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><ul>
<li>-XX:MaxTenuringThreshold 设定对象在Survivor区最大年龄阈值，超过阈值转移到老年代，默认15</li>
<li>对象头的 Age 属性记录年龄，对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1，对象</li>
<li>在 Survivor 中每熬过一次MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>并不一定要Age到达阈值才晋升到老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大<br>于 Survivor 空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><p>又称非堆区，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器优化后的代码等<br>数据.1.7 的永久栈和1.8 的元空间都是方法区的一种实现</p>
<h2 id="JVM内存可见性"><a href="#JVM内存可见性" class="headerlink" title="JVM内存可见性"></a>JVM内存可见性</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120017757.png"/>

<p>JMM 是定义程序中变量的访问规则，线程对于变量的操作只能在自己的工作内存中进行，而不能直接对主内存操作.由于指令重排序，读写的顺序会被打乱，因此JMM 需要提供原子性，可见性，有序性保证.</p>
<h2 id="类加载与卸载"><a href="#类加载与卸载" class="headerlink" title="类加载与卸载"></a>类加载与卸载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120018966.png"/>

<p>其中<strong>验证，准备，解析</strong>合成链接</p>
<p><strong>加载</strong>通过类的完全限定名，查找此类字节码文件，利用字节码文件创建Class 对象.</p>
<p><strong>验证</strong>确保Class 文件符合当前虚拟机的要求，不会危害到虚拟机自身安全.</p>
<p><strong>准备</strong>进行内存分配，为static 修饰的类变量分配内存，并设置初始值（0 或null).不包含final 修饰的静态变量，因为final 变量在编译时分配.</p>
<p><strong>解析</strong>将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.</p>
<p>初始化主要完成静态块执行以及静态变量的赋值.先初始化父类，再初始化当前类.只有对类主动<br>使用时才会初始化.</p>
<p>触发条件包括，创建类的实例时，访问类的静态方法或静态变量的时候，使用Class.forName 反射<br>类的时候，或者某个子类初始化的时候.</p>
<p>Java 自带的加载器加载的类，在虚拟机的生命周期中是不会被卸载的，只有用户自定义的加载器<br>加载的类才可以被卸.</p>
<h4 id="加载机制－双向委派模式"><a href="#加载机制－双向委派模式" class="headerlink" title="加载机制－双向委派模式"></a>加载机制－双向委派模式</h4><p>双亲委派模式，即加载器加载类时先把请求委托给自己的父类加载器执行，直到顶层的启动类加<br>载器. 父类加载器能够完成加载则成功返回，不能则子类加载器才自己尝试加载.*</p>
<ol>
<li>避免类的重复加载</li>
<li>避免Java 的核心API 被篡改</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/work/202405120020479.png"/>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/13/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%A4%8D%E4%B9%A0-1-%E9%A9%AC%E5%8E%9F/" class="post-title-link" itemprop="url">考研政治复习(1)-马原</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-13 08:14:01" itemprop="dateCreated datePublished" datetime="2023-10-13T08:14:01+08:00">2023-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-22 17:00:37" itemprop="dateModified" datetime="2023-10-22T17:00:37+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%94%BF%E6%B2%BB/" itemprop="url" rel="index"><span itemprop="name">政治</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><span style="color:red">红色</span>：重点内容<br><span style="color:orange">橙色</span>：下述内容的归纳总结</p>
<h1 id="马克思主义原理"><a href="#马克思主义原理" class="headerlink" title="马克思主义原理"></a>马克思主义原理</h1><h2 id="马克思主义的创立"><a href="#马克思主义的创立" class="headerlink" title="马克思主义的创立"></a>马克思主义的创立</h2><h3 id="马克思主义产生的社会根源、阶级基础和思想渊源"><a href="#马克思主义产生的社会根源、阶级基础和思想渊源" class="headerlink" title="马克思主义产生的社会根源、阶级基础和思想渊源"></a>马克思主义产生的社会根源、阶级基础和思想渊源</h3><ol>
<li><p>资本主义经济的发展为马克思主义的产生提供了<strong>经济</strong>、<strong>社会历史条件</strong></p>
</li>
<li><p><strong>无产阶级</strong>（工人阶级）在反抗资产阶级的斗争中逐步走向<strong>自觉</strong>（跟自发不一样，自发是自然发生，无意识），对科学理论的指导提出了强烈的需求（马克思主义产生的<strong>阶级基础和实践基础</strong>）</p>
</li>
<li><p>马克思、恩格斯的革命实践和对人类文明成果的继承与创新（主观条件）</p>
<p><strong>19世纪西欧三大先进思潮（德国古典哲学、英国古典政治经济学、英法两国的空想社会主义）</strong>为马克思主义的创立提供了直接的理论来源。<strong>19世纪的三大科学发现、即细胞学说、能量守恒与转化定律生物进化论，为马克思主义的产生提供了自然科学前提</strong></p>
</li>
</ol>
<h3 id="马恩列重要著作（第一页重点）"><a href="#马恩列重要著作（第一页重点）" class="headerlink" title="* 马恩列重要著作（第一页重点）"></a>* 马恩列重要著作（第一页重点）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310131619588.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310180939679.png"/>

<h3 id="马克思主义的创立-1"><a href="#马克思主义的创立-1" class="headerlink" title="马克思主义的创立"></a>马克思主义的创立</h3><p>一国胜利论：由于资本主义的政治发展不平衡，提出社会主义革命可能会在<strong>一国或者数国首先发生并取得胜利</strong>的论断，俄国的十月革命的胜利使其变成可现实-《国家与革命》</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181051090.png"/>

<p>毛中特补充下属内容</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181054418.png"/>

<h3 id="马克思主义的鲜明特征"><a href="#马克思主义的鲜明特征" class="headerlink" title="* 马克思主义的鲜明特征"></a>* 马克思主义的鲜明特征</h3><p>科发民革践</p>
<ol>
<li><p>科学性</p>
<p>马克思主义是对自然、社会和人类思雏<strong>发展本质和规律的正确反映</strong>。马克思主义具有科学的世界观和方法论基础，即辩证唯物主义和历史唯物主义，这是马克思主义的一个<strong>突出特征和理论优势</strong>，也是马克思主义科学性的重要体现。</p>
</li>
<li><p>发展性</p>
<p>马克思主义是不断发展的学说，具有与时俱进的理论品质。</p>
</li>
<li><p>人民性</p>
<p><strong>人民至上</strong>是马克思主义的<strong>政治立场</strong>。马克思主义政党把人民放在心中最高位置，一切奋斗都致力于实现最广大人民的根本利益。<strong>人民性是马克思主义最鲜明的品格</strong>。马克思主义博大精深，<strong>归根到底就是一句话：为人类求解放</strong></p>
</li>
<li><p><strong>革命性</strong>（科学性+革命性【人民+实践+发展】）</p>
<p>马克思主义的鲜明特征，<strong>用一句话概括，就是科学性与革命性的统一</strong>。革命性是马克思主义的内在品质，是马克思主义的人民性、实践性和发展性的应有之义和必然要求。在马克思主义指导革命的过程中，<strong>人民性、实践性和发展性集中地体现为革命性</strong>。【科发民革践】</p>
</li>
<li><p>实践性</p>
<p>马克思主义是从实践中来、到实践中去，在实践中接受检验，并随实践而不断发展的学说。<strong>实践性是马克思主义理论区别于其他理论的显著特征。实践观点是马克思主义首要的和基本的观点。</strong></p>
</li>
</ol>
<h3 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h3><ol>
<li>马克思主义理论区别于其他理论的根本特征：实践性</li>
<li><strong>实践的观点</strong>是马克思主义的基本观点</li>
<li>马克思主义的<strong>本质属性</strong>：人民性</li>
<li>马克思主义追求的<strong>根本价值目标</strong>：实现人的自由而全面的发展</li>
<li><strong>马克思的整个世界观不是教义，而是方法。</strong>它提供的不是现成的教条，是进一步研究的出发点和供这种研究使用的方法。如果选项中出现“现成答案”“现成理想方案”等，多为干扰项。</li>
</ol>
<h4 id="马克思主义的当代价值"><a href="#马克思主义的当代价值" class="headerlink" title="马克思主义的当代价值"></a>马克思主义的当代价值</h4><p>(一）观察当代世界变化的<strong>认识工具</strong><br>(二）指引当代中国发展的<strong>行动指南</strong><br>(三）引领人类杜会进步的<strong>科学真理</strong></p>
<h1 id="世界多样性与物质统一性"><a href="#世界多样性与物质统一性" class="headerlink" title="世界多样性与物质统一性"></a>世界多样性与物质统一性</h1><h2 id="物质及其存在方式"><a href="#物质及其存在方式" class="headerlink" title="物质及其存在方式"></a>物质及其存在方式</h2><h3 id="哲学基本问题及其内容"><a href="#哲学基本问题及其内容" class="headerlink" title="哲学基本问题及其内容"></a>哲学基本问题及其内容</h3><ol>
<li><p>哲学基本问题—<strong>存在和思维的关系问题。</strong></p>
<p>恩格斯第一次明确提出：“全部哲学，特别是近代哲学的重大的基本问题，是<strong>思维和存在的关系问题。</strong></p>
</li>
<li><p>哲学基本问题的内容，包括两个方面：</p>
<p>第一，存在和思维究竞谁是世界的本原，即物<strong>质和精神何者是第一性、何者是第二性的问题</strong>；</p>
<p>第二，思维能否正确认识存在的问题，即<strong>思维和存在有无同一性的问题</strong>。</p>
</li>
<li><p>唯物主义与辩证法要统一起来</p>
<p>只有既坚持唯物主义，又坚持辩证法，才能全面地认识世界的本质和发展规律。只有达到唯物主义和辩证法的内在统一，才能有科学的彻底的唯物主义和科学的彻底的辩证法</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181121085.png"/>

<h4 id="刷题总结-1"><a href="#刷题总结-1" class="headerlink" title="刷题总结"></a>刷题总结</h4><h5 id="哲学基本问题及其内容-1"><a href="#哲学基本问题及其内容-1" class="headerlink" title="哲学基本问题及其内容"></a>哲学基本问题及其内容</h5><ol>
<li>物质第一性，第二性，只是就谁是世界的本原而言的，不要把它与价值混淆。不存在物质和谁比谁更重要，也不涉及谁与社会生活的关系更密切的问题。第一性不等于第一重要，第二性也不等于第二重要。</li>
<li>唯心主义并非都是不可知论。唯物主义哲学家以及坚持唯物主义观点的科学家，都反对不可知论，主张世界是可以认识的；唯心主义既有可知论（如黑格尔），也有不可知论。</li>
<li><strong>唯心主义不等于形而上学，唯物主义不等于辩证法。</strong></li>
<li>唯心主义又分为主观唯心主义和客观唯心主义。主观唯心主义把人的感觉、观念作为世界的本原（关键词：心、观念、感觉、精神等）；客观唯心主义把某种脱离物质、脱离任何个人的精神作为世界的本原（关键词：理、理念、绝对观念、上帝、造物主、绝对精神等)</li>
</ol>
<h5 id="物质"><a href="#物质" class="headerlink" title="物质"></a>物质</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181127848.png"/>

<h3 id="物质-1"><a href="#物质-1" class="headerlink" title="物质"></a>物质</h3><ul>
<li><p><strong>[马克思主义]物质观</strong></p>
<p>马克思批判了旧唯物主义对物质世界的直观、消极的理解，强调要从<strong>能动的<span style="color:red">实践</span>出发</strong>去把握客观世界的意义</p>
</li>
<li><p><strong>[恩格斯]对物质概念作了初步概括</strong></p>
<p>“<strong>物、物质无非是各种物的总和，而这个概念就是从这一总和中抽象出来的。”</strong>这就是说，物质这个名词是一种简称，“我们就用这种简称把感官可感知的许多不同的事物依照其共同的属性概括起来”。这样就明确指出了哲学物质概念与自然科学关于具体的物质形态和物质结构的概念之间<strong>共性与个性</strong>的关系</p>
</li>
<li><p><strong>[列宁]对物质概念作了全面的科学的规定</strong></p>
<p>物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映。”<strong>列宁是从物质与的关系上来把握物质的</strong>。物质范畴是对物质世界多样性和统一性所作的最高的哲学概括。<strong>物质的共同特性（唯一特性）是客观实在性</strong>，它存在于人的之外，可以为人的所反映。换句话说，<strong>所谓物质，就是不依赖于人类的而存在，并能为人类的所反映的客观实在</strong></p>
<p><strong>马克思主义的物质概念是与实践的观点内在统一的。人类的社会生活本质上是实践的</strong></p>
</li>
</ul>
<h4 id="刷题总结-2"><a href="#刷题总结-2" class="headerlink" title="刷题总结"></a>刷题总结</h4><ol>
<li><p>客观实在不一定是人可以直接<strong>看得见、摸得着的实物</strong>（比如磁场就需要通过仪器来感知），重点在干它是存在于人的之外，不以人的意志为转移。</p>
</li>
<li><p>不要混淆<strong>自然科学物质结构概念与哲学物质范畴</strong>，它们是<strong>个别与一般、个性与共性</strong>的关系</p>
<blockquote>
<p>【个别与一般&#x3D;普遍与特殊&#x3D;个性与共性；任何个别都是一般；<span style="color:red">≠整体与部分</span></p>
<p>个别就是各种具体事物（如大李子、张三），一般则是同类事物的共同本质（人）。白马是马的一种，马腿是马的一部分】</p>
</blockquote>
</li>
<li><p>马克思主义以前的旧唯物主义在自然观上是唯物的．在历史观上却陷入唯心，所以是不彻底的“半截子”唯物主义。</p>
</li>
<li><p><span style="color:red"><strong>庸俗唯物主义不是唯物主义</strong></span>，它混淆物质与的界限，认为人的精神活动能力只不过是脑物质的分泌物。</p>
</li>
<li><p>物质和的对立，只有在它们何者为第一性、何者为第二性这一范围内才具有绝对的意义；<strong>超出这个范围，物质和的对立便是相对的。</strong></p>
</li>
<li><p>马克思主义以前的旧唯物主义在自然观上是唯物的，在历史观上却陷入唯心，所以是不彻底的“半截子”唯物主义。马克思主义既看到了自然界的物质性，又以实践为基础揭示了人类社会的物质性，实现了唯物主义自然观和历史观的统一。</p>
</li>
</ol>
<h3 id="物质的存在方式"><a href="#物质的存在方式" class="headerlink" title="物质的存在方式"></a>物质的存在方式</h3><ol>
<li><p>物质与运动</p>
<p>①<strong>运动是物质的根本属性或存在方式</strong>。世界是物质的，而物质是运动的。运动是标志一切事物和现象的变化及其过程的哲学范畴。</p>
<p>②<strong>物质和运动不可分割</strong>。一方面，物质是运动着的物质，脱离运动的物质是不存在的。<strong>设想有不运动的物质，将导致形而上学</strong>。另一方面，运动是物质的运动。<strong>物质是一切运动变化和发展过程的实在基础和承担者</strong>，世界上没有离开物质的运动，任何形式的运动都有它的物质载体，<strong>设想无物质的运动，将导致唯心主义</strong></p>
</li>
<li><p>运动与静止 <span style="color:orange">【绝对运动，相对静止】</span></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181151093.png"/>
</li>
<li><p>物质运动与时间、空间</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310181152224.png"/></li>
</ol>
<h4 id="刷题总结-3"><a href="#刷题总结-3" class="headerlink" title="刷题总结"></a>刷题总结</h4><ol>
<li><p>在很多概念的描述中，<strong>“绝对的”与“无条件的”井列，“相对的”与“有条件的”并列</strong></p>
</li>
<li><p>客观实在性是物质的共同特性，运动是物质的根本属性（存在方式)，时空是运动着的物质的基本存在形式【如果单独说时间，空间也对】</p>
</li>
</ol>
<h3 id="物质世界的二重化"><a href="#物质世界的二重化" class="headerlink" title="物质世界的二重化"></a>物质世界的二重化</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/politics/202310221122090.png"/>

<h2 id="物质与意识的辩证关系"><a href="#物质与意识的辩证关系" class="headerlink" title="物质与意识的辩证关系"></a>物质与意识的辩证关系</h2><p><span style="color:red"><strong>物质决定意识，意识依赖于物质井反作用于物质</strong></span></p>
<h3 id="物质决定意识"><a href="#物质决定意识" class="headerlink" title="物质决定意识"></a>物质决定意识</h3><p><span style="color:orange">意识是人类独有的</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">计算机组成原理(2)-存储与指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-07 19:28:57 / 修改时间：20:21:53" itemprop="dateCreated datePublished" datetime="2023-09-07T19:28:57+08:00">2023-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理笔记"><a href="#计算机组成原理笔记" class="headerlink" title="计算机组成原理笔记"></a>计算机组成原理笔记</h1><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><p>存储器的层次化结构</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071938083.png"/>

<p>存储器的分类–层次</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071938377.png"/>

<p>存储器的分类–存储介质</p>
<ul>
<li>半导体存储器：主存、Cache</li>
<li>磁表面存储器：磁盘、磁带（以磁性材料存储信息）</li>
<li>光存储器：光盘（以光介质存储信息）</li>
</ul>
<p>存储器的分类–存取方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071939552.png"/>

<p>相联存储器既可以按地址又可以按内容寻址。</p>
<p>存储器的分类–信息的可更改性</p>
<ul>
<li>读写存储器–即可读、也可写（如：磁盘、内存、Cache）</li>
<li>只读存储器–只可读，不能写</li>
</ul>
<p>存储器的分类–信息的可保存性</p>
<ul>
<li>断电后，存储信息消失的存储器–易失性存储器 (主存、Cache)</li>
<li>断电后，存储信息依然保持的存储器- – 非易失性存储器(磁盘、光盘)</li>
<li>信息读出后，原存储信息被破坏– -破坏性读出(如DRAM芯片，读出数据后要进行重写</li>
<li>信息读出后，原存储信息不被破坏– - 非破坏性读出(如SRAM芯片、磁盘、光盘)</li>
</ul>
<p>RAM都是易失性存储器；<br>ROM都是非易失性存储器；<br>随机存取存储器：RAM（专有名词）；<br>随机存取：是存取方式，ROM和RAM存取方式都是随机存取。</p>
<h2 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a><strong>存储器的性能指标</strong></h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071939078.png"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071940862.png"/>

<h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><strong>基本的半导体元件及原理</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071940021.png"/>

<p>注：MOS管可理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通。</p>
<h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a><strong>存储器芯片的基本原理</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071949374.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071954292.png"/>

<p>驱动器在译码器后面，保证译码器输出的电信号是稳定可靠的。<br>片选线作用：若有多个存储芯片，保证此次读取指定芯片的数据，CS给予低电平，其他芯片为高电平。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071954216.png"/>

<h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a><strong>寻址</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071955963.png"/>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071956297.png"/>

<h2 id="SRAM与DRAM"><a href="#SRAM与DRAM" class="headerlink" title="SRAM与DRAM"></a>SRAM与DRAM</h2><p>DRAM（动态RAM）用于主存，SRAM（静态RAM）用于Cache<br>DRAM芯片：使用栅极电容存储信息<br>SRAM芯片：使用双稳态触发器存储信息</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071957212.png"/>

<blockquote>
<p>1：电容内存储了电荷<br>0：电容内未存储电荷</p>
<p>若触发器里存储的的二进制的1，当字选择线接通之后，BLX输出低电平信号</p>
<p>若触发器里存储的的二进制的0，当字选择线接通之后，BL输出低电平信号<br>写入0：给BL加低电平，给BLX加高电平，呈现A低B高</p>
<p>栅极电容：每个存储元制造成本更低，集成度高，功耗低。电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失，2ms之内必须“刷新”一次（给电容充电）</p>
<p>双稳态触发器：每个存储元制造成本更高，集成度低，功耗大。只要不断电，触发器的状态就不会改变</p>
</blockquote>
<h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a><strong>DRAM的刷新</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071958116.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959175.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959206.png"/>

<p>分散刷新不存在死区</p>
<h3 id="DRAM的地址线复用技术"><a href="#DRAM的地址线复用技术" class="headerlink" title="DRAM的地址线复用技术"></a><strong>DRAM的地址线复用技术</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071959879.png"/>

<blockquote>
<p>地址：00000000。<br>同时送行列地址，需要8根地址线。两次送只需要4根地址线。<br>地址线复用技术：地址线是原来的1&#x2F;2（行和列相等）且地址线分行、列两次传送。<br>这里地址线取决于行和列的最大值。<br>地址引脚：log2max{行，列}</p>
</blockquote>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072000322.png"/>

<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072001457.png"/>

<p>EPROM不能作为随机存储器。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072002486.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072004305.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072005955.png"/>

<h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p>现在的计算机</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072006106.png"/>

<p><strong>存储器芯片的输入输出信号</strong></p>
<p>WE头上没有横杠，高电平表示写，低电平表示读。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072007728.png"/>

<h3 id="增加主存的存储字长-位扩展"><a href="#增加主存的存储字长-位扩展" class="headerlink" title="增加主存的存储字长-位扩展"></a><strong>增加主存的存储字长-位扩展</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008374.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008222.png"/>

<h3 id="增加主存的存储字数-字扩展"><a href="#增加主存的存储字数-字扩展" class="headerlink" title="增加主存的存储字数-字扩展"></a><strong>增加主存的存储字数-字扩展</strong></h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a><strong>线选法</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072008888.png"/>

<h4 id="译码片选线"><a href="#译码片选线" class="headerlink" title="译码片选线"></a><strong>译码片选线</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072009042.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072010084.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072010580.png"/>

<h3 id="主存容量扩展-字位同时扩展"><a href="#主存容量扩展-字位同时扩展" class="headerlink" title="主存容量扩展-字位同时扩展"></a><strong>主存容量扩展-字位同时扩展</strong></h3><p>①可以存储低四位–（D0、D1、D2、D3）</p>
<p>②可以存储另四位–（D4、D5、D6、D7）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072011694.png"/>

<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014238.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014879.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072015772.png"/></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072014088.png"/>

<h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072016516.png"/>

<h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a><strong>双端口RAM</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072016425.png"/>

<h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a><strong>多体并行存储器</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072017237.png"/>

<h3 id="应该取几个“体”"><a href="#应该取几个“体”" class="headerlink" title="应该取几个“体”"></a><strong>应该取几个“体”</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072017662.png"/>

<blockquote>
<p>当m&#x3D;T&#x2F;r时，存取流水线的效率最高，存储体的数量最少，成本最低。</p>
<p>思考？<br>假设有m个存储体，第一种方法：可以根据体号确定它属于第几个存储体；第二种方法：用十进制地址x对m取余</p>
</blockquote>
<h3 id="多模块存储体"><a href="#多模块存储体" class="headerlink" title="多模块存储体"></a><strong>多模块存储体</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072018732.png"/>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072019521.png"/>

<h2 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h2><h3 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a><strong>外存储器</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072019733.png"/>

<h3 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a><strong>磁盘设备的组成</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020333.png"/>

<h3 id="磁盘的性能指标"><a href="#磁盘的性能指标" class="headerlink" title="磁盘的性能指标"></a><strong>磁盘的性能指标</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020912.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072020736.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072021549.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309072021194.png"/>

<h3 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a><strong>磁盘阵列</strong></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">计算机组成原理(1)-概述与数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-08 21:44:13" itemprop="dateCreated datePublished" datetime="2023-08-08T21:44:13+08:00">2023-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-07 21:20:07" itemprop="dateModified" datetime="2023-09-07T21:20:07+08:00">2023-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机组成原理笔记"><a href="#计算机组成原理笔记" class="headerlink" title="计算机组成原理笔记"></a>计算机组成原理笔记</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061623419.png"/>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机的发展"><a href="#计算机的发展" class="headerlink" title="计算机的发展"></a>计算机的发展</h2><p>数据库管理系统–系统软件<br>数据库系统–应用软件</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061530626.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061530997.png"/>

<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><p>“存储程序”的概念是指将指令以<strong>二进制代码</strong>的形式事先输入计算机的主存储器，然后按其在<strong>存储器中的首地址执行程序的第一条指令</strong>，以后就按该程序的规定顺序执行其他指令，直到程序执行结束。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>输入设备</td>
<td>将信息转换成机器能识别的形式</td>
</tr>
<tr>
<td>运算器</td>
<td>算术运算逻辑运算</td>
</tr>
<tr>
<td>存储器</td>
<td>存放数据和程序</td>
</tr>
<tr>
<td>控制器</td>
<td>指挥程序运行</td>
</tr>
<tr>
<td>输出设备</td>
<td>将结果转换成人们熟悉的形式</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061533552.png"/>

<h4 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h4><ul>
<li>计算机由五大部件组成</li>
<li>指令和数据以同等地位存于存储器，可按地址访问（统一编址，指令和数据所在存储单元无差异）</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成</li>
<li>存储程序</li>
<li>以运算器为中心（输入输出设备与存储器之间的数据传送通过运算器完成）</li>
</ul>
<h4 id="数据驱动方式："><a href="#数据驱动方式：" class="headerlink" title="数据驱动方式："></a>数据驱动方式：</h4><ul>
<li>控制流驱动：指令–&gt;数据</li>
<li>数据流驱动：数据–&gt;指令</li>
</ul>
<h3 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061536471.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061539722.png"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061539037.png"/>

<h2 id="各硬件的工作原理"><a href="#各硬件的工作原理" class="headerlink" title="各硬件的工作原理"></a>各硬件的工作原理</h2><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061540782.png"/>

<ol>
<li>MAR（Memory Address Register）：MAR是一个存储器地址寄存器，用于存储要访问的内存地址。当计算机需要读取或写入内存中的数据时，它会将要访问的内存地址存储在MAR中。MAR通常是一个专门的寄存器，它可以直接与内存进行交互，将存储器地址传递给内存模块。</li>
<li>MDR（Memory Data Register）：MDR是一个存储器数据寄存器，用于存储从内存中读取或要写入内存的数据。当计算机需要从内存中读取数据时，它将数据从内存传输到MDR中。同样，当计算机需要将数据写入内存时，它将数据从MDR传输到内存中的指定位置。MDR也是一个专门的寄存器，它在内存和其他计算机组件之间传递数据。</li>
</ol>
<p>因此，MAR和MDR之间的区别在于它们的功能和作用。MAR用于存储要访问的内存地址，而MDR用于存储从内存读取的数据或要写入内存的数据。它们共同参与内存的读取和写入操作，实现了计算机与内存之间的数据传输和交互。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061546501.png"/>

<ul>
<li>存储单元：每个存储单元存放一串二进制代码</li>
<li>存储字(word)：存储单元中二进制代码的组合</li>
<li>存储字长：存储单元中二进制代码的位数</li>
<li>存储元：即存储二进制的电子元件，每个存储元可存1bit</li>
</ul>
<h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061552267.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>加</th>
<th>减</th>
<th>乘</th>
<th>除</th>
</tr>
</thead>
<tbody><tr>
<td>ACC</td>
<td>累加器，用于存放操作数，或运算结果。</td>
<td>被加数，和</td>
<td>被减数、差</td>
<td>乘积高位</td>
<td>被除数、余数</td>
</tr>
<tr>
<td>MQ</td>
<td>乘商寄存器，在乘、除运算时，用于存放作数或运算结果。</td>
<td></td>
<td></td>
<td>乘数、乘积低位</td>
<td>商</td>
</tr>
<tr>
<td>X</td>
<td>通用的操作数寄存器，用于存放操作数</td>
<td>加数</td>
<td>减数</td>
<td>被乘数</td>
<td>除数</td>
</tr>
<tr>
<td>ALU</td>
<td>算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061559165.png"/>

<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CU 控制单元</td>
<td>控制单元，分析指令，给出控制信号</td>
</tr>
<tr>
<td>IR 指令寄存器</td>
<td>指令寄存器，存放当前执行的指令</td>
</tr>
<tr>
<td>PC 程序计数器</td>
<td>程序计数器，存放下一条指令地址，自动加1功能</td>
</tr>
</tbody></table>
<h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061602437.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061602487.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603976.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603669.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603318.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603758.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061603390.png"/>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>注：现在的计算机通常把MAR,MDR也集成在CPU内</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061604660.png"/>

<h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p>汇编语言指令和机器语言指令一一对应<br>LOAD： 取数操作 ，MUL： 乘法操作</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061605498.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061608592.png"/>

<p><strong>编译程序</strong>：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后在执行机器语言程序（只需翻译一次）。 例如：使用我们使用C语言写的程序，经过编译和汇编之后，最终形成.exe文件，该.exe文件是用机器语言描述的程序，每次运行这个程序，只需加载.exe文件。</p>
<p><strong>解释程序</strong>：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着在翻译下一句（每一次都要翻译）。 编译型语言执行效率较解释型语言高。 注：编译、汇编、解释程序，可统称为“翻译程序”。</p>
<p>计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）</p>
<ul>
<li>如何设计硬件与软件之间的接口。</li>
</ul>
<p>计算机组成原理：实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p>
<ul>
<li>如何用硬件实现所定义的接口。</li>
</ul>
<p>“透明”：看不见<br>“公开透明”：看得见</p>
<table>
<thead>
<tr>
<th></th>
<th>是否一次性</th>
<th>编译时间</th>
<th>运行速度</th>
</tr>
</thead>
<tbody><tr>
<td>编译程序</td>
<td>是</td>
<td>长</td>
<td>快</td>
</tr>
<tr>
<td>解释</td>
<td>否</td>
<td>短</td>
<td>慢</td>
</tr>
</tbody></table>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061617236.png"/>

<h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>机器字长</td>
<td>能够直接处理的二进制数据的位数</td>
</tr>
<tr>
<td>指令字长</td>
<td>一个指令中包含的二进制代码的位数</td>
</tr>
<tr>
<td>存储字长</td>
<td>一个存储单元二进制数据的位数</td>
</tr>
</tbody></table>
<h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><ul>
<li>MAR位数反应存储单元的个数（最后支持多少个）</li>
<li>MDR位数&#x3D;存储字长&#x3D;每个存储单元的大小</li>
</ul>
<p>总容量&#x3D;存储单元个数×存储字长 bit &#x3D;存储单元个数×存储字长&#x2F;8 Byte<br>$$<br>总容量 &#x3D; 存储单元个数 * 存储字长 bit &#x3D; 存储单元个数 * 存储字长&#x2F;8 Byte<br>$$</p>
<blockquote>
<p>Eg:MAR为32位，MDR为8位<br>总容量&#x3D;2^32×8 bit&#x3D;4GB</p>
<p>2^10:K<br>2^20:M<br>2^30:G<br>2^40:T</p>
</blockquote>
<h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061624562.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061627825.png"/>

<p><strong>注</strong>：公式中主频的值反映的是：每秒钟会出现多少个时钟周期。</p>
<p><strong>注</strong>：注意与存储器的容量或者文件的大小中的K、M、G、T的区别</p>
<h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>数据通路带宽</td>
<td>数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</td>
</tr>
<tr>
<td>吞吐量</td>
<td>指系统在单位时间内处理请求的数量。他取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</td>
</tr>
<tr>
<td>响应时间</td>
<td>指从用户向计算发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销时间）。</td>
</tr>
</tbody></table>
<p>动态测试：基准程序（跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。</p>
<blockquote>
<p><strong>思考：</strong><br>1、主频高的CPU一定比主频低的CPU快吗？<br>答：不一定，如两个CPU，A的主频为2GHz，平均CPI&#x3D;10，一秒钟可以执行0.2G条指令；B的主频为1GHz，平均CPI&#x3D;1，一秒钟可以执行1G条指令。</p>
<p>2、若A、B两个CPU的平均CPI相同，那么A一定更快吗？<br>答：不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。</p>
<p>3、基准程序执行的越快说明机器性能越好吗？<br>答：基准程序中的语句存在频度差异，运行结果也不能完全说明问题。</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061630617.png"/>

<p>存储器的容量：衡量计算机的存储容量<br>机器字长：衡量计算机并行处理的能力<br>数据通路带宽：衡量计算机在功能部件之间传送数据的能力</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061631856.png"/>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="..进制转换"></a>..进制转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061632203.png"/>

<h3 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h3><p>无符号整数，即“自然数”，0、1、2、3、4、5…</p>
<p>C语言中的无符号整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a=<span class="number">1</span>; <span class="comment">//无符号整数 （短整型 2B）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b=<span class="number">2</span>; <span class="comment">//无符号整数 （整型 4B）</span></span><br></pre></td></tr></table></figure>

<p>无符号整数的表示</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061634609.png"/>

<h3 id="无符号整数的加法运算"><a href="#无符号整数的加法运算" class="headerlink" title="..无符号整数的加法运算"></a>..无符号整数的加法运算</h3><h3 id="带符号整数的表示和运算-原反补"><a href="#带符号整数的表示和运算-原反补" class="headerlink" title="..带符号整数的表示和运算_原反补"></a>..带符号整数的表示和运算_原反补</h3><p>带符号整数，即“整数”，-2、-1、0、1、2、3、4、5…</p>
<p>C语言中的带符号整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a=<span class="number">1</span>; <span class="comment">//带符号整数 （短整型 2B）</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">-2</span>; <span class="comment">//带符号整数 （整型 4B）</span></span><br></pre></td></tr></table></figure>

<h3 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061638672.png"/>

<h2 id="原反补码的特性对比"><a href="#原反补码的特性对比" class="headerlink" title="原反补码的特性对比"></a>原反补码的特性对比</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309061639934.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071628336.png"/>

<p>注：反码与原码表示的范围是一样的，当n是整数时，真值负数最小时，原码是1111 1111，反码是1000 0000。</p>
<h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629744.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629912.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071629875.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630537.png"/>

<h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630949.png"/>

<h3 id="定点小数原反补码的转换"><a href="#定点小数原反补码的转换" class="headerlink" title="定点小数原反补码的转换"></a><strong>定点小数原反补码的转换</strong></h3><p>注：和定点整数一模一样。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630223.png"/>

<h3 id="定点小数的加减法运算"><a href="#定点小数的加减法运算" class="headerlink" title="定点小数的加减法运算"></a><strong>定点小数的加减法运算</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071630004.png"/>

<p>小数的加减运算和整数的处理逻辑是一样的。</p>
<p>定点小数VS定点整数</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631154.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631788.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071631522.png"/>

<h2 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h2><h3 id="ALU（算数逻辑单元）"><a href="#ALU（算数逻辑单元）" class="headerlink" title="ALU（算数逻辑单元）"></a><strong>ALU（算数逻辑单元）</strong></h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071632246.png"/>

<h4 id="基本的逻辑运算"><a href="#基本的逻辑运算" class="headerlink" title="基本的逻辑运算"></a><strong>基本的逻辑运算</strong></h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071632415.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071633941.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_composition/202309071633736.png"/>

<blockquote>
<p>异或：AB不同Y为1，相同为 0；同或：AB相同Y为1，不同为0。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">软件工程基础概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 16:42:55" itemprop="dateCreated datePublished" datetime="2023-06-10T16:42:55+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-14 16:36:23" itemprop="dateModified" datetime="2023-06-14T16:36:23+08:00">2023-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><ul>
<li>软件&#x3D;程序+数据+文档</li>
<li>软件是被开发或设计的</li>
<li>软件不会磨损，但是会退化</li>
</ul>
<h2 id="软件工程的概述"><a href="#软件工程的概述" class="headerlink" title="软件工程的概述"></a>软件工程的概述</h2><p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法区开发和维护软件，以及如何把经过时间考虑而证明正确的管理技术和当前能够得到的最好技术方法结合起来的学科。</p>
<h2 id="软件工程的方法"><a href="#软件工程的方法" class="headerlink" title="软件工程的方法"></a>软件工程的方法</h2><h3 id="传统方法："><a href="#传统方法：" class="headerlink" title="传统方法："></a>传统方法：</h3><p>也称生命周期方法或结构化方法。采用结构化技术来完成软件开发的各项任务</p>
<h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>从面向对象程序设计发展起来的。有OOA面向对象分析、OOD面向对象设计、OMG对象管理组织、UML统一建模语言等概念</p>
<h3 id="面向服务方法"><a href="#面向服务方法" class="headerlink" title="面向服务方法"></a>面向服务方法</h3><p>SOA，服务提供与请求的设计模式</p>
<h3 id="面向数据的方法"><a href="#面向数据的方法" class="headerlink" title="面向数据的方法"></a>面向数据的方法</h3><p>基于数据思维，从业务逻辑的角度，强调一切业务“数据化”；从体系结构的角度，突出“面向暑假和以暑假为核心”的思想</p>
<h3 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h3><p>基于形式化数学变换的软件开发方法</p>
<h1 id="软件工程的层次"><a href="#软件工程的层次" class="headerlink" title="软件工程的层次"></a>软件工程的层次</h1><p>软件工程的定义：将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中。</p>
<ul>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程范型</li>
</ul>
<h2 id="软件工程的过程模型"><a href="#软件工程的过程模型" class="headerlink" title="软件工程的过程模型"></a>软件工程的过程模型</h2><h3 id="软件工程的三个要素"><a href="#软件工程的三个要素" class="headerlink" title="软件工程的三个要素"></a>软件工程的三个要素</h3><p>过程、方法、工具</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101647572.png"/>

<ol>
<li>支持软件工程的根基在于质量关注点（quality focus）：是对软件的组织承诺，是支持软件工程的基石</li>
<li>软件工程的基础是过程（process）层。软件过程将各个技术层次结合在一起，使得合理、及时地开发计算机软件成为可能。</li>
<li>软件工程方法（method）为构建软件提供技术上的解决方法。方法包括：沟通、需求分析、设计模型、编程、测试和技术支持。</li>
<li>软件工程工具为过程和方法提供自动化或半自动化的支持。</li>
</ol>
<h3 id="软件过程的三个阶段"><a href="#软件过程的三个阶段" class="headerlink" title="软件过程的三个阶段"></a>软件过程的三个阶段</h3><ol>
<li><p>定义阶段：<strong>“做什么”</strong>，系统和软件的关键需求被标识</p>
<p>系统和信息工程</p>
<p>软件项目计划</p>
<p>需求分析</p>
</li>
<li><p>开发阶段：<strong>“如何做”</strong>，定义数据结构、体系结构、过程细节、界面表示、算法和测试如何执行</p>
<p>软件设计</p>
<p>代码生成</p>
<p>软件测试</p>
</li>
<li><p>支持阶段：<strong>“变化”</strong>：纠正错误、随着软件环境的演化而要求的适应性修改、用户需求的变化而带来的增强性修改</p>
<p>纠错性维护</p>
<p>适应性维护</p>
<p>完善性维护</p>
<p>预防性维护</p>
</li>
</ol>
<h3 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h3><p>CMM是20世纪90年代提出的 <strong>软件能力成熟度模型</strong></p>
<ol>
<li>CMM定义了当一个组织达到不同的过程成熟度时应该具有的软件工程能力</li>
<li>CMM是一种<strong>衡量软件开发能力和成熟度的标准</strong></li>
<li>CMM模型提供了衡量一个公司软件工程实践的整体有效性的方法，且建立了<strong>五级</strong>的过程成熟度级别</li>
</ol>
<h4 id="初始级"><a href="#初始级" class="headerlink" title="初始级"></a>初始级</h4><p>软件过程是<strong>特定的和偶然的</strong>，有时甚至是混乱的，几乎没有过程定义，成功完全取决于个人能力。</p>
<h4 id="可重复级"><a href="#可重复级" class="headerlink" title="可重复级"></a>可重复级</h4><p>建立了<strong>基本的</strong>项目管理过程，能够跟踪费用、进度和功能。有适当的必要的过程规范，可以重复与疫情类似的项目的成功</p>
<h4 id="定义级"><a href="#定义级" class="headerlink" title="定义级"></a>定义级</h4><p>用于管理和工程活动的软件过程已经文档化、<strong>标准化</strong>并与整个组织的软件过程相集成。所有项目都使用统一的、文档化的、组织过程认可的版本来开发和维护软件。</p>
<p>​	包含第二级的所有特征。</p>
<h4 id="管理级"><a href="#管理级" class="headerlink" title="管理级"></a>管理级</h4><p>软件过程和产品质量的详细数据被收集，通过这些度量数据，软件过程和产品能够<strong>被定量地</strong>理解和控制，包含三级的所有特征。</p>
<h4 id="优化级"><a href="#优化级" class="headerlink" title="优化级"></a>优化级</h4><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><p>通过定量反馈进行不断的过程改进，这些反馈来自于过程或通过<strong>试验新的的想法</strong>和技术而得到。包含第四级的所有特征。</p>
<p>软件过程模型是软件开发全部过程、活动和任务的结构框架。是一种开发策略，包含过程，方法和工具三个层次以及一般性阶段，常称为：</p>
<ol>
<li>软件开发模型</li>
<li>软件生存期模型</li>
<li>软件工程模型</li>
</ol>
<h3 id="过程模型两种类型"><a href="#过程模型两种类型" class="headerlink" title="过程模型两种类型"></a>过程模型两种类型</h3><ul>
<li><p>传统的软件过程模型</p>
<ol>
<li>瀑布模型（线性顺序模型）</li>
<li>V模型</li>
<li>原型</li>
<li>RAD模型</li>
<li>增量模型</li>
<li>螺旋模型</li>
<li>形式化方法模型</li>
</ol>
</li>
<li><p>敏捷的软件过程模型</p>
<ol>
<li>极限编程（XP）</li>
<li>自适应软件开发 (ASD)</li>
<li>橄榄球模型 (Scrum)</li>
<li>特征驱动开发 (PDD)</li>
</ol>
</li>
</ul>
<h3 id="传统的软件过程模型"><a href="#传统的软件过程模型" class="headerlink" title="传统的软件过程模型"></a>传统的软件过程模型</h3><h4 id="瀑布模型（waterfall-model）："><a href="#瀑布模型（waterfall-model）：" class="headerlink" title="瀑布模型（waterfall model）："></a>瀑布模型（waterfall model）：</h4><p>又被称为经典生命周期（classic life cycle），它提出了一个系统的、顺序的软件开发方法。<br>优点：</p>
<blockquote>
<ul>
<li>有利于大型软件开发过程中人员的组织、管理，从而提高了大型软件项目开发的质量和效率。</li>
<li>当需求确定、工作采用线性的方式完成的时候瀑布模型是一个很有用的过程模型。</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>过于理想，缺乏灵活性，容易产生需求偏差。</li>
<li>实际的项目很少遵守瀑布模型提出的顺序。</li>
<li>客户通常很难清楚的描述所有的需求。</li>
<li>客户必须要有耐心，因为只有在项目接近尾声的时候，他们才能得到可以执行的程序。</li>
<li>适用范围： 需求确定，工作能够采用线性的方式完成的软件。</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101712288.png"/>

<h4 id="V模型（V-model）："><a href="#V模型（V-model）：" class="headerlink" title="V模型（V-model）："></a>V模型（V-model）：</h4><p>描述了质量保证动作同沟通、建模相关动作以及早期构建相关的动作之间的关系。<br>V模型强调软件开发的协作和速度，将软件实现和验证有机地结合起来，在保证较高的软件质量情况下缩短开发周期。<br>优点：适合工程量小、人力资源少并且开发过程中改动不大的项目<br>缺点：错误发现时间迟，产生的风险代价高</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101714922.png"/>

<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><h5 id="抛弃式（一次性）原型不作为最终产品使用"><a href="#抛弃式（一次性）原型不作为最终产品使用" class="headerlink" title="抛弃式（一次性）原型不作为最终产品使用"></a>抛弃式（一次性）原型不作为最终产品使用</h5><blockquote>
<ul>
<li>降低项目中的风险，看看是否可以做些什么。（优势）</li>
<li>捕获需求，即客户是否可以喜欢GUI。（优势）</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li><p>资源可能会被浪费，因此需要控制</p>
</li>
<li><p>需要良好的项目管理</p>
</li>
<li><p>需要与客户进行良好的沟通</p>
</li>
<li><p>什么时候是停止开发原型的好时机</p>
</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101803536.png"/>

<h5 id="演化式"><a href="#演化式" class="headerlink" title="演化式"></a>演化式</h5><p>逐步改进和细化原型，将原型进化为最终系统</p>
<p>优势</p>
<blockquote>
<ul>
<li>客户可以看到他们想要的更改。</li>
<li>非常适合用户界面的接受。</li>
</ul>
</blockquote>
<p>缺点</p>
<blockquote>
<ul>
<li>在文档方面非常薄弱（即系统不断变化）。</li>
<li>需要强有力的项目控制，领导者需要监控发展。</li>
<li>什么时候是停止发展和完成项目的好时机可能会导致系统结构不良。</li>
<li>可能需要特殊的开发人员。</li>
</ul>
</blockquote>
<h6 id="演化过程模型（Evolutionary-Model）"><a href="#演化过程模型（Evolutionary-Model）" class="headerlink" title="演化过程模型（Evolutionary Model）"></a>演化过程模型（Evolutionary Model）</h6><p>演化模型是迭代的过程模型。</p>
<p>原型开发（prototyping ）：当需求很模糊的时候，原型开发可以帮助软件开发人员和利益相关者更好地理解究竟需要做什么。<br><strong>优点：</strong><br>开发者与用户充分交流，可以澄清模糊需求，需求定义比其他模型好得多<br>开发过程与用户培训过程同步<br>为用户需求的改变提供了充分的余地<br>开发风险低，产品柔性好<br>开发费用低，时间短<br>系统易维护，对用户更友好</p>
<p><strong>缺点：</strong><br>1、 没有考虑软件的整体质量和长期的可维护性。<br>2、 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>3、 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。<br>适用范围：<br>尽管原型可以用作独立的流程模型，但它更常用作一种可以在任何流模型的上下文中实现的技术。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715254.png"/>

<h5 id="增量型"><a href="#增量型" class="headerlink" title="增量型"></a>增量型</h5><p>在建立软件总体设计基础上，采用增量开发方法，使原型成为最终系统。</p>
<p>优势：</p>
<blockquote>
<p>有利于将一个更大的系统分解成多个部分，从而使组件更容易构建。<br>客户对系统的看法是分阶段的，所以没有“大爆炸”的方法。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>需要良好的沟通和协议。<br>需要良好的项目管理、控制和监控工作。</p>
</blockquote>
<h6 id="增量过程模型（Incremental-Model）"><a href="#增量过程模型（Incremental-Model）" class="headerlink" title="增量过程模型（Incremental Model）"></a>增量过程模型（Incremental Model）</h6><p><strong>增量模型融合了瀑布模型的基本成分和原型的迭代特征</strong></p>
<p>增量过程模型侧重于每一个增量都提交一个可以运行的产品。<br><strong>优点：</strong></p>
<ol>
<li>能在较短的时间内向用户提交可完成部分工作的产品。</li>
<li>逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
<li>规避技术风险</li>
<li>可并行开发构件，加快开发的进度</li>
<li>对于在业务截止日期之前完全实施的人员配置非常有用。<br><strong>缺点：</strong><br>（1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；<br>（2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。</li>
</ol>
<p><strong>适用范围：</strong><br>（1）进行已有产品升级或新版本开发，增量模型是非常适合的；<br>（2）对完成期限严格要求的产品，可以使用增量模型；<br>（3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。<br>（4）项目在既定的商业要求期限之前不可能找到足够的开发人员</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101715951.png"/>

<h4 id="统一过程（Unified-Process）"><a href="#统一过程（Unified-Process）" class="headerlink" title="统一过程（Unified Process）"></a>统一过程（Unified Process）</h4><p><strong>统一过程模型</strong><br>统一过程模型是一种“用例驱动、以体系结构为核心、迭代及增量”的软件 过程框架，由 UML 方法和工具支持。它是一种增量模型，定义了五个阶段：<br>a、起始阶段，包括用户沟通和计划活动，强调定义和细化用例<br>b、细化阶段，包括用户沟通和建模活动，重点是创建分析和设计模型。<br>c、构件阶段，细化模型设计，并将设计模型转化为软件构件实现<br>d、转化阶段，将软件从开发人员传递给最终用户，并由用户完成 beta 测试和验收测试<br>e、生产阶段，持续地监控软件的运行，并提供技术支持。</p>
<p><strong>优点：</strong><br>1.任何功能开发后就进入测试过程，及早进行验证<br>2.早期风险识别，采取预防措施</p>
<p><strong>缺点：</strong></p>
<ol>
<li>需求必须在开始之前完全弄清楚，否怎有可能在架构上出现错误</li>
<li>必须有严格的过程管理，以免使过程退化为原始的试→错→改模式</li>
<li>如果不加控制的让用户过早接触没有测试完全、版本不稳定的产品可能对用户和开发团队都带来负面的影响。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101717848.png"/>

<h4 id="RAD模型"><a href="#RAD模型" class="headerlink" title="RAD模型"></a>RAD模型</h4><p>通过使用“基于构件的建造方法”赢得快速开发</p>
<ul>
<li><p>业务建模</p>
</li>
<li><p>数据建模</p>
</li>
<li><p>过程建模</p>
</li>
<li><p>应用生成</p>
</li>
<li><p>测试及反复</p>
</li>
</ul>
<p>特点：</p>
<blockquote>
<ul>
<li>强调极短的开发时 间，每一个主要功能在不到三个月的时间内完成。</li>
<li>强调复用。</li>
</ul>
</blockquote>
<p> 缺点：</p>
<blockquote>
<ul>
<li>对于大型的的项目，RAD需要足够的人力资源以建立足够的RAD组。</li>
<li>RAD要求开发者和客户承担在一个很短的时间框架下完成一个系统所必要的快速活动。</li>
<li>并非所有应用都适合RAD,不适合技术风险很高的情况</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101807461.png"/>

<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>主要适用于内部开发的大规模软件项目</p>
<ul>
<li>客户交流一建立开发者和客户之间有效的通信所需的任务。</li>
<li>计划一定义资源、进度及其他相关项目所需要的任务。</li>
<li>风险分析一评估技术的及管理的风险所需的任务。</li>
<li>工程一建立应用的一个或多个表示所需要的任务。</li>
<li>构造及发布一构造、测试、安装和提供用户支持（如文档及培训）所需的任务</li>
<li>客户评估一基于对在工程阶段产生的或在安装阶段实现的软件表示的评估，获得客户反馈所需要的任务。</li>
</ul>
<p>优点：</p>
<blockquote>
<p>随着过程进展演化，开发者和客户能够更好地理解和对待每一个级别上的<br>风险，使用原型实现作为降低风险的机制。<br>更真实地反映了现实世界。<br>如应用得当，能在风险变成问题之前降低它。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>模型的成功依赖于风险评估的专门技术，<br>是一个较新的模型，功效的确定尚需若干年时间。</p>
</blockquote>
<h3 id="敏捷的软件过程模型"><a href="#敏捷的软件过程模型" class="headerlink" title="敏捷的软件过程模型"></a>敏捷的软件过程模型</h3><h4 id="敏捷开发-敏捷宣言（Agile-development-manifesto）："><a href="#敏捷开发-敏捷宣言（Agile-development-manifesto）：" class="headerlink" title="敏捷开发-敏捷宣言（Agile development manifesto）："></a><strong>敏捷开发-敏捷宣言（Agile development manifesto）：</strong></h4><p><strong>应付变化而来的开发模型</strong></p>
<ul>
<li><strong>个体和互动 高于 流程和工具</strong>：个人和他们之间的交流胜过了开发过程和工具</li>
<li><strong>工作的软件 高于 详尽的文档</strong>：可运行的软件胜过了宽泛的文档</li>
<li><strong>客户合作 高于 合作谈判</strong>：客户合作胜过了合同谈判</li>
<li><strong>响应变化 高于 遵循计划</strong>：对变更的良好响应胜过了按部就班地遵循计划</li>
</ul>
<h4 id="极限编程（Extreme-Programming-XP-）"><a href="#极限编程（Extreme-Programming-XP-）" class="headerlink" title="极限编程（Extreme Programming (XP)）"></a>极限编程（Extreme Programming (XP)）</h4><p>极限编程是敏捷软件开发使用最广泛的一个方法。</p>
<ol>
<li><p>策划：<br>开始创造“用户故事”<br>敏捷团队评估每个故事并分配一个成本（开发周数）<br>故事被分组到一个可交付增量<br>承诺在交付日期进行<br>在第一次递增之后，“项目速度”用于帮助估计后续发行版本的发布日期和进度安排，确定是否对整个开发项目中的所有故事有过分承诺。</p>
</li>
<li><p>设计<br>遵循KIS（保持简洁）原则<br>对于困难的设计问题，建议创建“尖峰解决方案” - 一个设计原型<br>鼓励“重构”： 重构是以不改变代码外部行为而改进其内部结构的方式来修改软件系统的过程。</p>
<blockquote>
<p>重构是XP的一个重要组成部分。所谓重构是指在 不改变代码外在行为的前提下对代码做出的修改，以 改进代码的内部结构。重构是一种有纪律的、经过训 练的、有条不紊的代码整理方法，可以将整理过程中 不小心引入错误的可能性降到最低。从本质上说，重 构就是在代码写好之后改进它的设计。 重构的节奏：重新推理、小的更改、重新推理、 小的更改、重新推理…</p>
</blockquote>
</li>
<li><p>编码<br>在编码开始之前，建议对故事进行单元测试<br>鼓励“结队编程”</p>
<blockquote>
<p>结对编程是让两个人共同设计和开发代码的实践。结对者是全职合作者，轮流执行键入和监视；这提供了持续的设计和代码评审。<br>不是两个人做一个人的事情。</p>
</blockquote>
<p>连续集成<br>有助于避免兼容性和接口问题，建立能及早发现错误的“冒烟测试”</p>
<blockquote>
<p>​	持续集成的思想是任何时候，只要有一项任务完成，就集成新代码，构造系统并测试。持续集成是每日构建\每晚构建的一种极限形式，是XP的重要基础。<br>​	每日构建\每晚构建是将一个软件项目的所有最新代码取出，从头开始编译、链接，用安装软件包将链接好的程序安 装好，运行安装后的软件，使用测试工具对主要功能进行测 试，发现错误并报告错误的完整过程。<br>​	让开发人员在第一时间了解到软件的错误，并迅速排除错误，是每日构建\每晚构建最重要的目标之一。<br>​	每日构建\每晚构建必须出日志和报告，并发布构建结<br>果的有关信息，最好能够使用自动化工具发出电子邮件通知</p>
</blockquote>
</li>
<li><p>所有的单元测试每天都执行<br>“验收测试”，由客户规定技术条件，并且着眼于客户可见的、可评审的系统级的特征和功能。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730576.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101730350.png"/></li>
</ol>
<h4 id="橄榄球模型（Scrum）"><a href="#橄榄球模型（Scrum）" class="headerlink" title="橄榄球模型（Scrum）"></a>橄榄球模型（Scrum）</h4><ul>
<li>待定项(backlog)——一个能为用户提供商业价值的项目需求或特性的优先級列表。待定项中可以随时加入新项(这就是变更的引入)。产品经理根据需要评估待定项并修改优先级。</li>
<li>冲刺(sprint) ——一些工作单元组成，这些工作单元是达到待定项中定义的需求所必需的，并且必须能在预定的时间段( time-box9)内(一般情况下为30天)完成。冲刺过程中不允许有变更(例如积压工作项)。因此，冲刺给开发团队成员的工作提供了短期但稳定的环境。</li>
<li>Scrum例会——Serum 团队每天召开的短会(一般情况为15分钟)，会上所有成员要回答三个问题[Noy02]:<ol>
<li>上次例会后做了什么?</li>
<li>遇到了什么困难?</li>
<li>下次例会前计划做些什么</li>
</ol>
</li>
<li>演示——交付软件，客户进行评估</li>
</ul>
<p>燃尽图：衡量在一个Sprint时间段内剩余的Sprint待办事项列表条目。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306101759647.png"/>

<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="软件项目管理的定义"><a href="#软件项目管理的定义" class="headerlink" title="软件项目管理的定义"></a>软件项目管理的定义</h2><p>软件项目管理是为了使软件项目能够顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p>
<p><strong>对软件工程项目</strong>：他所涉及的范围覆盖了整个软件工程过程</p>
<p><strong>这种项目挂你在技术工作开始之前就应该开始</strong>，在软件从概念到实现的过程中<strong>继续进行</strong>，当软件工程过程最后结束时<strong>才终止</strong></p>
<h2 id="管理的四要素"><a href="#管理的四要素" class="headerlink" title="管理的四要素"></a>管理的四要素</h2><ul>
<li>人员People：成功项目的重要因素</li>
<li>产品Product：要开发的软件</li>
<li>过程Process：软件工程的框架活动，包括了任务、里程碑、工作一起质量保证点</li>
<li>项目Project：开发软件所需要的所有工作</li>
</ul>
<h2 id="项目管理小组结构"><a href="#项目管理小组结构" class="headerlink" title="项目管理小组结构"></a>项目管理小组结构</h2><ul>
<li><p>民主分散式（democratic decentralized，DD）【比以下两种缺陷要多】</p>
<p>没有固定的负责人，适合难度比较高、交付期限很长及生存期较长的项目，最适合于解决模块化程度比较低的问题，因为需要通信</p>
</li>
<li><p>控制分散式（controlled decentralized，CD）</p>
<p>CD(控制分散式）:有一个固定的负责人，若有子负责人，<strong>子负责人和总负责人的通信是垂直的</strong>，而个人间的通信是水平的，适合交付期限较长、比较简单的项目</p>
</li>
<li><p>控制集中式（controlled centralized，CC）</p>
<p>CC(控制集中式）:负责人和小组成员之间的通信是垂直的，适合解决<strong>交付期限比较严格的、简单的、模块化程度高</strong>的项目</p>
</li>
</ul>
<h3 id="小组通信路径"><a href="#小组通信路径" class="headerlink" title="小组通信路径"></a>小组通信路径</h3><p> <em>C &#x3D; (n * (n-1))&#x2F;2</em></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121025899.png"/>

<h3 id="软件范围"><a href="#软件范围" class="headerlink" title="软件范围"></a>软件范围</h3><ul>
<li>在进行项目计划之前，软件开发者和客户必须一起定义产品的目的和范围考虑可选的解决方案，标识技术和管理的约束。</li>
<li>没有这些信息，就不可能进行合理的（准确的）成本估算、有效的风险评估、适当的项目任务划分或是可管理的项目进度安排。</li>
<li>软件范围是软件项目管理的第一个活动。</li>
</ul>
<h1 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h1><h2 id="软件度量的目的"><a href="#软件度量的目的" class="headerlink" title="软件度量的目的"></a>软件度量的目的</h2><ul>
<li>改进过程</li>
<li>提高产品的质量</li>
</ul>
<h2 id="度量的作用"><a href="#度量的作用" class="headerlink" title="度量的作用"></a>度量的作用</h2><p>有效地定量地进行管理</p>
<h2 id="过程度量"><a href="#过程度量" class="headerlink" title="过程度量"></a>过程度量</h2><ul>
<li>在软件发布之前的错误数的测量</li>
<li>交付给最终用户并由最终用户报告的缺陷的测量</li>
<li>交付的工作产品（生产率）的测量</li>
<li>花费的工作量的测量</li>
<li>花费的时间的测量</li>
<li>与进度是否一致的测量</li>
</ul>
<h2 id="度量的方式"><a href="#度量的方式" class="headerlink" title="度量的方式"></a>度量的方式</h2><h3 id="物理度量方式"><a href="#物理度量方式" class="headerlink" title="物理度量方式"></a>物理度量方式</h3><p>直接测量</p>
<p>间接测量</p>
<h3 id="软件度量方式"><a href="#软件度量方式" class="headerlink" title="软件度量方式"></a>软件度量方式</h3><p>直接测量</p>
<ul>
<li>软件工程过程的直接测量包括所投入的成本和工作量。</li>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<p>间接测量</p>
<ul>
<li>软件产品的直接测量包括产生的代码行数（LOC)、执行速度、存储量大小、在某种时间周期中所报告的差错数。</li>
</ul>
<h2 id="度量的分类"><a href="#度量的分类" class="headerlink" title="度量的分类"></a>度量的分类</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121414638.png"/>

<ul>
<li>需要注意的是：在表格中记载的工作量和成本是整个软件工程的活动（分析、设计、编码和测试）,<strong>而不仅仅是编码活动</strong></li>
<li>对于每一个项目，可以根据表格中列出的<strong>基本数据</strong>计算简单的<strong>面向规模</strong>的生产率和质量等的度量</li>
<li>根据表格可以对所有的项目计算出的有用度量：<ul>
<li>生产率&#x3D;<strong>KLOC</strong>&#x2F;PM(人月）</li>
<li>质量&#x3D;错误数&#x2F;<strong>KLOC</strong></li>
<li>成本&#x3D;元&#x2F;<strong>LOC</strong></li>
<li>文档&#x3D;文档页数&#x2F;<strong>KLOC</strong></li>
</ul>
</li>
</ul>
<h3 id="基于FP的软件度量"><a href="#基于FP的软件度量" class="headerlink" title="基于FP的软件度量"></a>基于FP的软件度量</h3><ul>
<li>每个FP的错误数（Errors per FP)</li>
<li>每个FP的缺陷数（Defects per FP)</li>
<li>每个FP的花费（$ per FP)</li>
<li>每个FP的文档页数（Pages of documentation per FP)</li>
<li>每人月完成的FP数（FP per person-month)</li>
</ul>
<h2 id="度量的计算"><a href="#度量的计算" class="headerlink" title="度量的计算"></a>度量的计算</h2><p>计算功能点，使用如下的计算公式<br>$$<br>FP &#x3D; 总计算值*[0.65+0.01*∑(Fi)]<br>$$<br>总计数值是所有加权计数项的和</p>
<p>Fi（i&#x3D;1…14）是复杂性校正值，它们应通过逐一回答如下提问来确定。</p>
<blockquote>
<p>Fi的取值0..5:<br>0没有影响	1微小影响<br>2轻度			3中度<br>4显著			5重大</p>
</blockquote>
<p>∑(Fi)是求和函数</p>
<h2 id="软件质量度量指标"><a href="#软件质量度量指标" class="headerlink" title="软件质量度量指标"></a>软件质量度量指标</h2><ul>
<li><p>正确性</p>
</li>
<li><p>可维护性</p>
</li>
<li><p>完整性</p>
<ul>
<li><p>危险性是特定类型的攻击将在一给定时间内发生的概率。<br>安全性是排除特定类型攻击的概率。</p>
</li>
<li><p>一个系统的完整性可定义为<br>$$<br>完整性&#x3D;∑[1-危险性×(1-安全性）]<br>$$<br>其中，对每一个攻击的危险性和安全性都进行累加。</p>
</li>
</ul>
</li>
<li><p>可用性</p>
</li>
</ul>
<h2 id="DRE缺陷排除效率"><a href="#DRE缺陷排除效率" class="headerlink" title="DRE缺陷排除效率"></a>DRE缺陷排除效率</h2><p>DRE是对质量保证及控制活动中滤除缺陷能力的一个测量</p>
<h1 id="软件风险"><a href="#软件风险" class="headerlink" title="软件风险"></a>软件风险</h1><h2 id="风险及风险管理"><a href="#风险及风险管理" class="headerlink" title="风险及风险管理"></a>风险及风险管理</h2><ul>
<li>风险：所有在软件开发过程中带来负面影响的问题，是一个潜在的问题</li>
<li>风险分析和管理是标识风险、评估其发生的概率、估算其影响并建立问题实际发生情形下的应急计划，是一系列帮助软件小组理解和管理部确定的步骤</li>
</ul>
<h2 id="被动的风险策略"><a href="#被动的风险策略" class="headerlink" title="被动的风险策略"></a>被动的风险策略</h2><p>被动风险策略：对风险不闻不问，直到发生了错误项项目组才赶紧采取行动，试图迅速地纠正错误。</p>
<h2 id="主动的风险策略"><a href="#主动的风险策略" class="headerlink" title="主动的风险策略"></a>主动的风险策略</h2><p>主动风险策略：在技术工作开始之前就已经启动，标识出潜在的风险，评估出现的概率及产生的影响，且按重要性加以排序。主要目标预防风险，需要建立一个应急计划，使必要时能够以可控的及有效地方式做出反应。</p>
<h2 id="风险的类型"><a href="#风险的类型" class="headerlink" title="风险的类型"></a>风险的类型</h2><h3 id="项目风险"><a href="#项目风险" class="headerlink" title="项目风险"></a>项目风险</h3><p>威胁到项目技术</p>
<p>潜在的预算、进度、人力资源、客户及需求等方面的问题</p>
<h3 id="技术风险"><a href="#技术风险" class="headerlink" title="技术风险"></a>技术风险</h3><p>威胁到要开发软件的质量和交付时间</p>
<p>潜在的设计、实现、接口、验证和维护等方面的问题</p>
<h3 id="商业风险"><a href="#商业风险" class="headerlink" title="商业风险"></a>商业风险</h3><p>威胁到要开发软件的生存能力</p>
<p>商业风险的分类</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>开发了一个没有人真正需要的优秀产品或系统</td>
<td>市场风险</td>
</tr>
<tr>
<td>开发的产品不再符合公司的整体商业策略</td>
<td>策略风险</td>
</tr>
<tr>
<td>建造了一个销售部门不知道如何去出售的产品</td>
<td>销售风险</td>
</tr>
<tr>
<td>由于重点转移或人员的变动而失去了高级管理层的支持</td>
<td>管理风险</td>
</tr>
<tr>
<td>没有得到预算或人力上的保证。</td>
<td>预算风险</td>
</tr>
</tbody></table>
<h2 id="风险管理的步骤"><a href="#风险管理的步骤" class="headerlink" title="风险管理的步骤"></a>风险管理的步骤</h2><h3 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h3><ul>
<li>风险识别的方法一建立风险条目检查表。</li>
<li>产品规模–与要建造或要修改的软件的总体规模相关的经验；</li>
<li>商业影响–与管理或市场所加的约束相关的风险；</li>
<li>客户特征–与客户的素质以及开发者和客户及时通信的能力相关的风险；</li>
<li>过程定义–与软件过程被定义的程度以及他们被开发组织所遵守的程度相关的风险；</li>
</ul>
<h3 id="风险预测"><a href="#风险预测" class="headerlink" title="风险预测"></a>风险预测</h3><p>风险预测从两个方面评估风险：风险发生的可能性或概率、风险发生所产生的后果（评估风险影响）。</p>
<h4 id="评估风险影响"><a href="#评估风险影响" class="headerlink" title="评估风险影响"></a>评估风险影响</h4><p>风险显露度（risk exposure)<br>$$<br>RE &#x3D; P * C<br>$$<br>其中，P是风险发生的概率，c是风险发生时带来的项目成本</p>
<blockquote>
<p>一个例子：计划了60个可复用构件，其中只有70%可能被使用，剩下的要重新定制开发，已知构件平均是100LOC,每个LOC的成本是14美元，假设该风险发生的概率是80%,计算风险显露度RE。</p>
</blockquote>
<p>$$<br>RE &#x3D; 80%*C<br>$$</p>
<p>$$<br>C &#x3D; 60 *(1-70%)<em>100</em>14<br>$$</p>
<h1 id="项目进度安排与跟踪"><a href="#项目进度安排与跟踪" class="headerlink" title="项目进度安排与跟踪"></a>项目进度安排与跟踪</h1><h2 id="通信开销"><a href="#通信开销" class="headerlink" title="通信开销"></a>通信开销</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527813.png"/>

<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527622.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121527818.png"/></p>
</blockquote>
<h2 id="项目进度安排方法"><a href="#项目进度安排方法" class="headerlink" title="项目进度安排方法"></a>项目进度安排方法</h2><h3 id="关键路径方法（CPM）"><a href="#关键路径方法（CPM）" class="headerlink" title="关键路径方法（CPM）"></a>关键路径方法（CPM）</h3><p>在关键路径上的活动才是按时完成任务的关键</p>
<h3 id="项目-进度计划-评估和评审技术-PERT）"><a href="#项目-进度计划-评估和评审技术-PERT）" class="headerlink" title="项目(进度计划)评估和评审技术(PERT）"></a>项目(进度计划)评估和评审技术(PERT）</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530592.png"/>

<h3 id="获得值分析"><a href="#获得值分析" class="headerlink" title="获得值分析"></a>获得值分析</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534873.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121530680.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121531061.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121533877.png"/>

<h1 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h1><h2 id="数据流图DFD"><a href="#数据流图DFD" class="headerlink" title="数据流图DFD"></a>数据流图DFD</h2><ul>
<li>面向数据流进行需求分析的方法</li>
<li>适合于数据处理类型软件的需求分析</li>
<li>用抽象模型的概念，按照软件内部数据传递、变换的关系，自项向下逐层分解，直到满足所有的功能要求。<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121534481.png"/></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121535618.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121536102.png"/>

<h2 id="数据字典DD"><a href="#数据字典DD" class="headerlink" title="数据字典DD"></a>数据字典DD</h2><ul>
<li>数据字典对数据流图中的各种成分起注解、说明作用，给这些成分赋以实际的内容。</li>
<li>数据字典与数据流图配合，能清楚地表达数据处理的要求。</li>
<li>条目：数据流、数据元素、数据存储、数据加工、外部实体。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121537663.png"/>

<h2 id="结构化英语"><a href="#结构化英语" class="headerlink" title="结构化英语"></a>结构化英语</h2><ul>
<li>顺序结构</li>
<li>重复结构</li>
<li>判定结构</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121538728.png"/>

<h1 id="结构化设计概述"><a href="#结构化设计概述" class="headerlink" title="结构化设计概述"></a>结构化设计概述</h1><h2 id="分析模型到设计模型"><a href="#分析模型到设计模型" class="headerlink" title="分析模型到设计模型"></a>分析模型到设计模型</h2><ul>
<li>数据设计：侧重于数据结构的定义</li>
<li>体系结构设计：定义软件系统各主要成份之间的关系</li>
<li>接口设计：描述了软件内部、软件和协作系统之间以及软件同人之间如何通信</li>
<li>过程设计：则是把结构成份转换成软件的过程性描述</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>结构图反映了模块之间的层次调用关系和联系：它以特定的符号表示模块、模块间的调用关系和模块间信息的传递</p>
<h3 id="模块的调用关系"><a href="#模块的调用关系" class="headerlink" title="模块的调用关系"></a>模块的调用关系</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542806.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121542853.png"/>

<ul>
<li>模块独立性，是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其它的模块的接口是简单的。</li>
<li>例如，若一个模块只具有单一的功能且与其它模块没有太多的联系，则称此模块具有模块独立性。</li>
<li>一般采用两个准则度量模块独立性。即模块间藕合和模块内聚。</li>
<li>藕合是模块之间的互相连接的紧密程度的度量。</li>
<li>内聚是模块功能强度（一个模块内部各个元素彼此结合的紧密程度）的度量。</li>
<li>模块独立性比较强的模块应是高内聚低精合的模块。</li>
</ul>
<h3 id="模块间的耦合"><a href="#模块间的耦合" class="headerlink" title="模块间的耦合"></a>模块间的耦合</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121545118.png"/>

<h3 id="体系结构设计-系统结构模块"><a href="#体系结构设计-系统结构模块" class="headerlink" title="体系结构设计(系统结构模块)"></a>体系结构设计(系统结构模块)</h3><ul>
<li>传入模块</li>
<li>传出模块</li>
<li>变换模块</li>
<li>协调模块</li>
</ul>
<h3 id="模块的独立性"><a href="#模块的独立性" class="headerlink" title="模块的独立性"></a>模块的独立性</h3><table>
<thead>
<tr>
<th>模块间耦合形成</th>
<th>可读性</th>
<th>错误扩散能力</th>
<th>可修改性</th>
<th>通用性</th>
</tr>
</thead>
<tbody><tr>
<td>数据耦合</td>
<td>好</td>
<td>弱</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>控制耦合</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>公共耦合</td>
<td>不好</td>
<td>强</td>
<td>不好</td>
<td>不好</td>
</tr>
<tr>
<td>内容耦合</td>
<td>差</td>
<td>最强</td>
<td>最差</td>
<td>最差</td>
</tr>
</tbody></table>
<ul>
<li>在系统结构图中的模块</li>
<li>传入模块——从下属模块取得数据，经过某些处理，再将其传送给上级模 块。它传送的数据流叫做逻辑输入数据流。</li>
<li>传出模块——从上级模块获得数据，进行某些处理，再将其传送给下属模 块。它传送的数据流叫做理输出数据流。</li>
<li>变换模块——它从上级模块取得数据，进行特定的处理，转换成其它形式， 再传送回上级模块。它加工的数据流叫做变换数据流。</li>
<li>协调模块——对所有下属模块进行协调和管理的模块。</li>
</ul>
<h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121546537.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552195.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121552021.png"/>

<h1 id="面向对象和UML"><a href="#面向对象和UML" class="headerlink" title="面向对象和UML"></a>面向对象和UML</h1><h2 id="面向对象方法-1"><a href="#面向对象方法-1" class="headerlink" title="面向对象方法"></a>面向对象方法</h2><h3 id="传统分析设计方法"><a href="#传统分析设计方法" class="headerlink" title="传统分析设计方法"></a>传统分析设计方法</h3><ul>
<li>以功能为中心的软件开发方法（结构化方法）</li>
<li>低内聚，高精合，缺乏灵活性和可维护性</li>
<li>分析与设计阶段采用的概念和表示不一致</li>
<li>以数据为中心的软件开发方法（信息建模方法）</li>
<li>对功能的处理较弱，不适合具有复杂功能的系统</li>
</ul>
<h3 id="类（抽象，分类）"><a href="#类（抽象，分类）" class="headerlink" title="类（抽象，分类）"></a>类（抽象，分类）</h3><p>类是具有共同属性和操作的对象的集合，对象是类的一个实例，类用于创建对象。</p>
<p>体现了抽象及分类原则，是人们分析问题的基本方法</p>
<ul>
<li><p>抽象：忽路事物的非本质特征，抽取共同的本质特征</p>
</li>
<li><p>分类：把具有共性的事物划分为一类</p>
</li>
</ul>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性：特殊类可以对继承来的属性和操作做出自己的解释，即在继承关系的类层次结构中可以定义同名操作或属性，形成同一操作或属性的多种形态，这样可以按不同的行为响应同一个消息。<br>多态性进一步体现了信息隐蔽的原则，可以实现接口的独立封装</p>
<h3 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555429.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121555544.png"/>

<h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><h3 id="对象建模"><a href="#对象建模" class="headerlink" title="对象建模"></a>对象建模</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121557058.png"/>

<h3 id="协作图-x2F-通信图"><a href="#协作图-x2F-通信图" class="headerlink" title="协作图&#x2F;通信图"></a>协作图&#x2F;通信图</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/software_engineering/202306121558079.png"/>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">数学-线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-09 09:29:59" itemprop="dateCreated datePublished" datetime="2023-03-09T09:29:59+08:00">2023-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 13:32:28" itemprop="dateModified" datetime="2023-03-30T13:32:28+08:00">2023-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>本视频基于【2023考研数学汤家凤线性代数基础课程】</strong></p>
<p>[第一章行列式.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==">https://pan.baidu.com/link/zhihu/7BhFzeuShBi0QJl2ZGRy1181YTQVNlbQQxhT==</a></p>
<p>[第二章矩阵.pdf]<a target="_blank" rel="noopener" href="https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==">https://pan.baidu.com/link/zhihu/79hmzNuchpiEMnJXdlbZtFBTUDWQNTcwZTxE==</a></p>
<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p>核心1:线性方程级</p>
<blockquote>
<table>
<thead>
<tr>
<th>工具</th>
</tr>
</thead>
<tbody><tr>
<td>行列式</td>
</tr>
<tr>
<td>矩阵</td>
</tr>
<tr>
<td>向量</td>
</tr>
</tbody></table>
</blockquote>
<p>核心2:矩阵对角比</p>
<blockquote>
<p>特征值与特征向量</p>
</blockquote>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h2><p>i,j ∈ N（自然数）且 i ≠ j</p>
<blockquote>
<p>这样就会形成两种情况</p>
<p>i &lt; j （i ，j ）即顺序</p>
<p>i &gt; j  （i，j）即逆序</p>
</blockquote>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>设<br>$$<br>i,i_2,…,i_n 为1，2，…n的一个排列i_1,i_2,…i_n含逆序个数之和称为逆序数<br>$$<br>记做<br>$$<br>\tau(i_1,i_2,…,i_n)<br>$$</p>
<blockquote>
<p>例如<br>$$<br>\tau（5,1,4,2,3）&#x3D; 6<br>$$<br>那其中这个6就成为逆序数</p>
</blockquote>
<h2 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h2><p>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n} \<br>…\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn} \<br>\end{matrix}\right|<br>&amp; 称为n阶行列式<br>$$</p>
<p>行列式计算</p>
<p>此处以三阶行列式为例<br>$$<br>D &#x3D;<br>\left|\begin{matrix}<br>a_{11} &amp; a_{12} &amp; a_{13} \<br>a_{21} &amp; a_{22} &amp; a_{23} \<br>a_{31} &amp; a_{32} &amp; a_{33} \<br>\end{matrix}\right|<br>$$</p>
<p>$$<br>D&#x3D;+a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32}+a_{12}a_{13}a_{21}+a_{32}-a_{13}a_{22}a_{31}<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" class="post-title-link" itemprop="url">英语语法学习笔记(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 12:24:51 / 修改时间：13:48:00" itemprop="dateCreated datePublished" datetime="2023-03-01T12:24:51+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">英语语法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法概论"><a href="#语法概论" class="headerlink" title="语法概论"></a>语法概论</h1><h2 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h2><h3 id="实词"><a href="#实词" class="headerlink" title="实词"></a>实词</h3><table>
<thead>
<tr>
<th>词类</th>
<th>名称全称</th>
<th>全程简称</th>
<th>作用</th>
<th>句子成分</th>
<th>列词</th>
</tr>
</thead>
<tbody><tr>
<td>名词</td>
<td>Noun</td>
<td>n.</td>
<td>表示人或事物的名称</td>
<td>主、宾、表、同位语、补足语、定语</td>
<td>Lily、childhood</td>
</tr>
<tr>
<td>代词</td>
<td>pronoun</td>
<td>pron.</td>
<td>代替名词、数词等</td>
<td>主、宾、表、同位语、定语</td>
<td>I、we、none</td>
</tr>
<tr>
<td>数词</td>
<td>Numeral</td>
<td>num.</td>
<td>表示数目或顺序</td>
<td>主、宾、表、同位语、定语</td>
<td>one、ninth</td>
</tr>
<tr>
<td>形容词</td>
<td>Adjective</td>
<td>adj.</td>
<td>表示事物的特种</td>
<td>主、定、状、补足语</td>
<td>effective、popular</td>
</tr>
<tr>
<td>副词</td>
<td>Adverb</td>
<td>adv.</td>
<td>表示行为或状态特征（修饰动词）</td>
<td>状语、表语、补足语、定语</td>
<td>curiously、bravely</td>
</tr>
<tr>
<td>动词</td>
<td>Verb</td>
<td>v.</td>
<td>表示动词或状态</td>
<td>谓语</td>
<td>absorb、devote</td>
</tr>
</tbody></table>
<h3 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h3><table>
<thead>
<tr>
<th>词类</th>
<th>名称全称</th>
<th>全程简称</th>
<th>作用</th>
<th>句子成分</th>
<th>列词</th>
</tr>
</thead>
<tbody><tr>
<td>冠词</td>
<td>Article</td>
<td>art.</td>
<td>用在名词前，起限定作用</td>
<td></td>
<td>a、an、the</td>
</tr>
<tr>
<td>介词</td>
<td>Preposition</td>
<td>prep.</td>
<td>用在名词、代词等前，说明与其他词的关系</td>
<td></td>
<td>in、before、beyond</td>
</tr>
<tr>
<td>连词</td>
<td>Conjunction</td>
<td>conj.</td>
<td>用来连接词与词、短语与短语或句子与句子</td>
<td></td>
<td>and、when、until、if、once</td>
</tr>
<tr>
<td>感叹词</td>
<td>Interjection</td>
<td>interj.</td>
<td>表示说话时的感情或语气</td>
<td></td>
<td>oh、ah、aha、hurrah</td>
</tr>
</tbody></table>
<h2 id="句子成分"><a href="#句子成分" class="headerlink" title="句子成分"></a>句子成分</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称(英)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>主语</td>
<td>Subject</td>
<td>一句话的中心</td>
</tr>
<tr>
<td>谓语</td>
<td>Predicate</td>
<td>主语的主要情况，即表示动作，也可表示状态</td>
</tr>
<tr>
<td>宾语</td>
<td>Object</td>
<td>动作的承受者或动作针对的对象</td>
</tr>
<tr>
<td>表语</td>
<td>Predicative</td>
<td>主语的身份、性质、特征、状态等、和系动词一起构成谓语<br />【Life is not <strong>all roses</strong>】</td>
</tr>
<tr>
<td>定语</td>
<td>Attribute</td>
<td>修饰名词、代词等</td>
</tr>
<tr>
<td>状语</td>
<td>Adverbial</td>
<td>修辞动词、形容词、副词等</td>
</tr>
</tbody></table>
<h2 id="短语与从句"><a href="#短语与从句" class="headerlink" title="短语与从句"></a>短语与从句</h2><h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>动词短语</td>
<td></td>
</tr>
<tr>
<td>不定式短语</td>
<td></td>
</tr>
<tr>
<td>动名词短语</td>
<td></td>
</tr>
<tr>
<td>分词短语</td>
<td></td>
</tr>
<tr>
<td>分词短语</td>
<td></td>
</tr>
<tr>
<td>介词短语</td>
<td></td>
</tr>
<tr>
<td>名词短语</td>
<td></td>
</tr>
</tbody></table>
<h3 id="从句"><a href="#从句" class="headerlink" title="从句"></a>从句</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>名词性从句</td>
<td></td>
</tr>
<tr>
<td>状语从句</td>
<td></td>
</tr>
<tr>
<td>定语从句</td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MEIDE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MEIDE'S BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 13:27:36" itemprop="dateCreated datePublished" datetime="2023-02-18T13:27:36+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-12 00:49:42" itemprop="dateModified" datetime="2023-05-12T00:49:42+08:00">2023-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">计算机系统概述</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87">操作系统的功能和目标</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81">操作系统的四个特征</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">操作系统的运行机制和体系结构</a><ul>
<li><a href="#%E6%8C%87%E4%BB%A4">指令</a></li>
<li><a href="#cpu">CPU</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F">程序</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8">操作系统的内核</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8">中断和异常</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8">概念和作用</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>系统调用和库函数的区别</strong></a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E7%BB%84%E6%88%90%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%89%B9%E5%BE%81">进程的定义，组成，组织方式，特征</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F">进程的组织方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81">进程的特征</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2">进程的状态和转换</a><ul>
<li><a href="#%E7%8A%B6%E6%80%81">状态</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2">转换</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6">进程控制</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-1">含义</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD">相关原语</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a><ul>
<li><a href="#%E5%90%AB%E4%B9%89-2">含义</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1">共享存储，消息传递，管道通信。</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">线程概念和多线程模型</a><ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB">线程分类</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">多线程模型</a><ul>
<li><a href="#%E5%A4%9A%E5%AF%B91%E6%A8%A1%E5%9E%8B">多对1模型</a></li>
<li><a href="#1%E5%AF%B91%E6%A8%A1%E5%9E%8B">1对1模型</a></li>
<li><a href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B">多对多模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1">处理机调度的概念和层次</a><ul>
<li><a href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%88%9D%E7%BA%A7%E8%B0%83%E5%BA%A6">高级调度，中级调度，初级调度。</a><ul>
<li><a href="#1%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6">1.高级调度</a></li>
<li><a href="#2%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6">2.中级调度</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B">补充知识：进程的七状态模型</a></li>
</ul>
</li>
<li><a href="#3%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6">3.低级调度</a></li>
<li><a href="#%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%AF%B9%E6%AF%94">三种调度的联系和对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%B9%E5%BC%8F">进程调度的时机，切换过程和方式</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA">进程调度时机</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F">进程调度的方式</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B">进程的切换与过程</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87">调度算法的评价指标</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">调度算法</a><ul>
<li><a href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E9%AB%98%E5%93%8D%E5%BA%94%E5%BF%85%E4%BC%98%E5%85%88">先来先服务，短作业优先，高响应必优先</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85">补充：</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">时间片轮转调度，优先级调度算法，多级反馈队列调度算法</a><ul>
<li><a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6rr">时间片轮转调度RR</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">优先级调度算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">多级反馈队列调度算法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程同步与进程互斥</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">进程互斥</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的软件实现方法</a><ul>
<li><a href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95">单标志法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95">双标志先检查法</a></li>
<li><a href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95">双标志后检查法</a></li>
<li><a href="#peterson%E7%AE%97%E6%B3%95">Peterson算法</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">进程互斥的硬件实现方法</a><ul>
<li><a href="#testandset%E6%8C%87%E4%BB%A4">TestAndSet指令</a></li>
<li><a href="#swap%E6%8C%87%E4%BB%A4">Swap指令</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81">进程互斥：锁</a><ul>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81-1">互斥锁</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6">信号量机制</a><ul>
<li><a href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F">整形信号量</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F">记录型信号量</a></li>
<li><a href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">用信号量实现进程互斥，同步，前驱关系</a><ul>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">信号量机制实现进程互斥</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">信号量机制实现进程同步</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB">信号量机制实现前驱关系</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者——消费者问题</a></li>
<li><a href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85">多生产者——多消费者</a></li>
<li><a href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98">吸烟者问题</a></li>
<li><a href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">读者——写者问题</a></li>
<li><a href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD">哲学家吃饭</a></li>
<li><a href="#%E7%AE%A1%E7%A8%8B">管程</a><ul>
<li><a href="#java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">java中类似于管程的机制（单例模式）</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a><ul>
<li><a href="#%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB">死锁，饥饿，死循环的区别</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁产生的必要条件</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81">什么时候会发生死锁</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">死锁的处理策略</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ol>
<li><p>作为系统资源的管理者</p>
<ul>
<li><p>文件管理</p>
</li>
<li><p>内存管理</p>
</li>
<li><p>处理及（CPU）管理</p>
</li>
<li><p>设备（计算机硬件，例如摄像头）管理</p>
</li>
</ul>
</li>
<li><p>作为用户和计算机硬件之间的接口</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181513303.png"/>


</li>
<li><p>对硬件机器的扩展</p>
</li>
</ol>
<h2 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a>操作系统的四个特征</h2><ol>
<li><p>并发</p>
<p>并发是指<strong>两个或多个事件在同一时间间隔内发生</strong>。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p>
<p><span style="color:red">易混淆的概念——并行：两个或多个事件在同一时刻同时发生</span></p>
</li>
<li><p>共享</p>
<p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p>
<table>
<thead>
<tr>
<th>两种资源共享方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>互斥共享方式</td>
<td>系统中的某些资源，虽然可以提供给多个进程使用，<br><span style="color:red">但<strong>一个时间段内只允许一个进程访问该资源</strong></span></td>
</tr>
<tr>
<td>同时共享方式</td>
<td>系统中的某些资源，<br><span style="color:red"><strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></span></td>
</tr>
</tbody></table>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p>
<p>例如：</p>
<ul>
<li><p>互斥共享方式：使用QQ和微信进行视频，但是同一个时间段内摄像头只能分配给其中一个进程</p>
</li>
<li><p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></p>
</li>
</ul>
</li>
<li><p>虚拟</p>
<p>虚拟是指把一个屋里上的实体变成若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<table>
<thead>
<tr>
<th>虚拟技术</th>
<th>例如</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空分复用技术</td>
<td>虚拟存储器技术</td>
<td></td>
</tr>
<tr>
<td>时分复用技术</td>
<td>虚拟处理器</td>
<td>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<span style="color:red"><strong>没有并发性，就谈不上虚拟性</strong></span></td>
</tr>
</tbody></table>
</li>
<li><p>异步</p>
<p>异步是指,在多道程序环境下，<strong>允许多个程序并发执行</strong>，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<ul>
<li>只有系统拥有并发性，才有可能导致异步性。</li>
</ul>
</li>
</ol>
<h2 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>特权指令</td>
<td>如内存清零指令（不允许用户程序使用）</td>
</tr>
<tr>
<td>非特权指令</td>
<td>如普通的运算指令</td>
</tr>
</tbody></table>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><table>
<thead>
<tr>
<th>两种处理器状态</th>
<th>(用程序状态字寄存器（PSW)中的某 标志位来标识当前处理器处于什么状 态。如0为用户态，1为核心态)</th>
</tr>
</thead>
<tbody><tr>
<td>用户态（目态）</td>
<td>此时CPU只能执行非特权指令</td>
</tr>
<tr>
<td>核心态（管态）</td>
<td>特权指令、非特权指令都可执行</td>
</tr>
</tbody></table>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><table>
<thead>
<tr>
<th>两种程序</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>内核程序</td>
<td>操作系统的内核程序是系统的管理者，即可执行特权指令，也可以执行非特权指令，运行也在核心态</td>
</tr>
<tr>
<td>应用程序</td>
<td>为了保证系统能安全运行，普通应用程序只能执行费特权指令，运行在用户态</td>
</tr>
</tbody></table>
<h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>由于内核划分功能的不同，内核分为大内核和微内核</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181514707.png"/>

<ul>
<li><p>大内核和微内核的优缺点</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181515691.png"/></li>
</ul>
<p>类比：</p>
<ul>
<li>操作系统的体系结构问题与企业的管理问题很相似。</li>
<li>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</li>
<li>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</li>
<li>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</li>
</ul>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><p><strong>中断</strong>是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li>
<li>对于不同的中断信号，会进行不同的处理。</li>
<li>有了中断，才能实现多道程序并发执行。</li>
<li>“用户态→核心态”是通过中断实现的，<strong>并且中断是唯一途径</strong>。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p> 中断型号的来源来自CPU内部称为内中断，外部称为外中断。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181520216.png"/>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302181523855.png"/>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证操作系统的稳定性和安全性，防止用户进行非法操作。</p>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h3><p>编程语言（C、JAVA）中里边有很多库函数，其实他们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li>
<li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进行核心态。</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的定义，组成，组织方式，特征"><a href="#进程的定义，组成，组织方式，特征" class="headerlink" title="进程的定义，组成，组织方式，特征"></a>进程的定义，组成，组织方式，特征</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序：就是指令序列</p>
<p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p>
<p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p>
<p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p>
<p><strong>PCB是进程存在的唯一标识。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201633291.png"/>



<h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p>
<p>相当于java中的链表和数组。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201634493.png"/>

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201635642.png"/>



<h2 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201638848.png"/>

<p>除此之外，进程还有两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640201.png"/>

<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201640665.png"/>

<blockquote>
<p>注意：<strong>不能由阻塞态直接转换为运行态也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121229670.png"/>

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>进程控制就是要<strong>实现进程状态转换</strong>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</p>
<p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 <strong>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201648777.png"/>

<p>那么原语是如何实现进程状态的转换呢？</p>
<ol>
<li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>a.所有的进程控制原语一定都会修改进程状态标志<br>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c.某进程开始运行前必然要恢复期运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配&#x2F;回收资源</li>
</ol>
<p>具体实现如图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201704327.png"/>

<h3 id="相关原语"><a href="#相关原语" class="headerlink" title="相关原语"></a>相关原语</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121237633.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121238008.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121239248.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121240249.png"/>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>进程通信就是<strong>进程间的信息交换</strong></p>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p>
<h3 id="共享存储，消息传递，管道通信。"><a href="#共享存储，消息传递，管道通信。" class="headerlink" title="共享存储，消息传递，管道通信。"></a>共享存储，消息传递，管道通信。</h3><ol>
<li><p>共享存储</p>
<p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式<br><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信</strong>方式。</p>
<p>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的（互斥访问通过操作系统提供的工具实现）<br>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201843057.png"/>
</li>
<li><p>管道通信</p>
</li>
</ol>
<blockquote>
<p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
<p>2.各进程要互斥地访问管道。</p>
<p>3.数据以字符流的形式写入管道，当管道<strong>写满时</strong>，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。</p>
<p>4.<strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></p>
<p>5．数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个，否则可能会有读错数据的情况。</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201847528.png"/>

<ol start="3">
<li><p>消息传递</p>
<p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p>
<p>类似于Http协议。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201849801.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121248665.png"/></li>
</ol>
<h2 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h2><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能<strong>串行</strong>执行一系列程序。因此，引入“线程”，来增加并发度。</p>
<ul>
<li>可以把线程理解为轻量级的进程。</li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</li>
<li>引入线程后，进程作为除CPU之外的系统资源的分配单元。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201852799.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121252713.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121253934.png"/></p>
<h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><ol>
<li>用户级线程</li>
</ol>
<ul>
<li>用户级线程由应用程序通过线程库实现。<strong>所有的线程管理工作都由应用程序负责（包括线程切换)</strong></li>
<li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预。</strong></li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li>
<li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li>
</ul>
<ol start="2">
<li>内核级线程</li>
</ol>
<ul>
<li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li>
</ul>
<p><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对1模型"><a href="#多对1模型" class="headerlink" title="多对1模型"></a>多对1模型</h4><ul>
<li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li>
<li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li>
<li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201913689.png"/>

<h4 id="1对1模型"><a href="#1对1模型" class="headerlink" title="1对1模型"></a>1对1模型</h4><ul>
<li>一对一模型:一个用户级线程映射到一个内核级线程。</li>
<li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li>
<li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201917778.png"/>

<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><ul>
<li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201918142.png"/><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303121258062.png"/></p>
<h2 id="处理机调度的概念和层次"><a href="#处理机调度的概念和层次" class="headerlink" title="处理机调度的概念和层次"></a>处理机调度的概念和层次</h2><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p>
<p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p>
<p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p>
<h3 id="高级调度，中级调度，初级调度。"><a href="#高级调度，中级调度，初级调度。" class="headerlink" title="高级调度，中级调度，初级调度。"></a>高级调度，中级调度，初级调度。</h3><h4 id="1-高级调度"><a href="#1-高级调度" class="headerlink" title="1.高级调度"></a>1.高级调度</h4><ul>
<li><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
</li>
<li><p>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</p>
</li>
<li><p><strong>高级调度是辅存（外存）与内存之间的调度</strong>。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。<strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201923361.png"/></li>
</ul>
<h4 id="2-中级调度"><a href="#2-中级调度" class="headerlink" title="2.中级调度"></a>2.中级调度</h4><ul>
<li><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量</strong>。</p>
</li>
<li><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p>
</li>
<li><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></p>
</li>
<li><p>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201924752.png"/></li>
</ul>
<h5 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h5><ul>
<li><p>暂时被调到外存等待的进程状态称为挂起状态。</p>
</li>
<li><p>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302201926432.png"/></li>
</ul>
<h4 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h4><ul>
<li>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的频率很高，一般几十毫秒一次。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202014458.png"/>

<h4 id="三种调度的联系和对比"><a href="#三种调度的联系和对比" class="headerlink" title="三种调度的联系和对比"></a>三种调度的联系和对比</h4><table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度（作业调度）</td>
<td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存（面向作业）</td>
<td>最低</td>
<td>无-创建态-就绪态</td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td>外存-&gt;内存（面向进程）</td>
<td>中等</td>
<td>挂起态-就绪态（阻塞挂起-阻塞态）</td>
</tr>
<tr>
<td>低级调度（进程调度）</td>
<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-运行态</td>
</tr>
</tbody></table>
<h2 id="进程调度的时机，切换过程和方式"><a href="#进程调度的时机，切换过程和方式" class="headerlink" title="进程调度的时机，切换过程和方式"></a>进程调度的时机，切换过程和方式</h2><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302202048883.png"/>

<p>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><ul>
<li>非剥夺调度方式，又称非抢占方式。即，<strong>只允许进程主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
</ul>
<p>优点：实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
<ul>
<li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
</ul>
<p>优点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<p><strong>优点：</strong></p>
<p>可以有限处理更紧急的进程，也可实现让哥进程按时间骗轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别:</p>
<ul>
<li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p>
</li>
<li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
</li>
</ul>
<p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p>
<p>进程切换的过程主要完成了:</p>
<ul>
<li>1.对原来运行进程各种数据的保存</li>
<li>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ul>
<p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><ul>
<li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li>
<li>系统吞吐量：单位时间内完成作业的数量。</li>
</ul>
<p>$$<br>系统吞吐量&#x3D;{总共完成了多少道作业\over总共花了多少时间}<br>$$</p>
<ul>
<li><p>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</p>
<p><span style="color:red"><strong>周转时间&#x3D;作业完成时的时间-作业提交时间</strong></span></p>
<p><span style="color:red"><strong>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</strong></span></p>
</li>
</ul>
<p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。<br>$$<br>带权周转时间&#x3D;{作业周转时间\over作业实际运行的时间}&#x3D;{作业完成的时间-作业提交时间\over作业实际运行的时间}<br>$$</p>
<p>$$<br>平均的带权周转时间&#x3D;{各个作业带权周转时间之和\over作业数}<br>$$</p>
<ul>
<li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li>
</ul>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<ul>
<li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务，短作业优先，高响应必优先"><a href="#先来先服务，短作业优先，高响应必优先" class="headerlink" title="先来先服务，短作业优先，高响应必优先"></a>先来先服务，短作业优先，高响应必优先</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>算法思想与规则</th>
<th>可抢占？</th>
<th>优点</th>
<th>缺点</th>
<th>考虑到等待时间&amp;运行时间？</th>
<th>会导致饥饿？</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务</td>
<td>FCFS</td>
<td>公平，先到先得</td>
<td>非</td>
<td>公平，实现简单</td>
<td>对短作业不利</td>
<td>有等待，无运行</td>
<td>不</td>
</tr>
<tr>
<td>短作业优先</td>
<td>SJF&#x2F;SPF</td>
<td>追求快<br />时间最短的先服务</td>
<td>默认为非抢占式版本，也有SJF的抢占式版本最短剩余时间优先算法(SRTN)</td>
<td>“最短的”平均等待&#x2F;周转时间</td>
<td>对长作业不利，可能导致饥饿；难以做到真正的短时间优先</td>
<td>有运行，无等待</td>
<td>会</td>
</tr>
<tr>
<td>高响应必优先</td>
<td>HRRN</td>
<td>作业&#x2F;进程的等待时间<br />计算<span style="color:red">响应比</span>,选择<span style="color:red">响应比最高的</span>作业&#x2F;进程优先</td>
<td>非</td>
<td>权衡折中，综合考虑等待时间和运行时间</td>
<td></td>
<td>都有</td>
<td>不</td>
</tr>
</tbody></table>
<p><span style="color:red">响应比</span> (响应比&gt;&#x3D;1) ：<br>$$<br>响应比&#x3D;{等待时间+要求服务时间\over要求服务时间}<br>$$<br>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><blockquote>
<ol>
<li><p>FCFS 由于在长作业过程中，后面的短作业需要等很长的时间，带权周转时间很大，对短作业用户体验不好。</p>
</li>
<li><p>FCFS 用于作业调度时，考虑的是那个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p>
</li>
<li><p>SJF 是用于作业调度，也可用于进程调度。用于进程调度时成为”短进程优先”(SPF，Shortest Process First)</p>
</li>
<li><p>SJF 和 SPF 是非抢占式算法，但是也有抢占式的版本–最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)</p>
</li>
<li><p>SJF 对长作业不利，可能产生饥饿现象。另外，作业&#x2F;进程真正运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p>
</li>
<li><p>SJF 如果有源源不断地有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生”饥饿”现象，如果一直得不到服务，则称为 饿死</p>
</li>
<li><p>HRRN 在每次调度室先计算各个作业&#x2F;进程的 响应比 ，选择响应比<span style="color:red">最高</span>的作业&#x2F;进程为其服务</p>
</li>
<li><ul>
<li><p>HRRN 综合考虑了等待时间和运行时间（要求服务时间）</p>
</li>
<li><p>等待时间相同时，要求服务时间端的优先（SJF 的优点）</p>
</li>
<li><p>要求服务时间相同时，等待时间长的优先（FCFS的优点）</p>
</li>
<li><p>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"><a href="#时间片轮转调度，优先级调度算法，多级反馈队列调度算法" class="headerlink" title="时间片轮转调度，优先级调度算法，多级反馈队列调度算法"></a>时间片轮转调度，优先级调度算法，多级反馈队列调度算法</h3><h4 id="时间片轮转调度RR"><a href="#时间片轮转调度RR" class="headerlink" title="时间片轮转调度RR"></a>时间片轮转调度RR</h4><table>
<thead>
<tr>
<th>时间片轮转调度<br />（RR，Round-Robin）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td>
</tr>
<tr>
<td>算法规则</td>
<td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<span style="color:red">时间片</span>（如100ms)。若进程未在一个时间片内执行完则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度（只有作业放入内存建立了相应的进程后，<br/>才能被分配处理机时间片）</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>若进程未能在时间片内运行完，将被强行剥夺处理机使权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：公平；响应快，适用于分时操作系统；<br />缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>否</td>
</tr>
<tr>
<td>补充</td>
<td>时间片问题：<br />如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。<br />另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。<br />一般来说，设计时间片要让切换进程的开销占比不超过1%。</td>
</tr>
</tbody></table>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><table>
<thead>
<tr>
<th>优先级调度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场最需要根据任务的紧急程度来决定处理顺序</td>
</tr>
<tr>
<td>算法规则</td>
<td>调度时选择优先级最高的作业&#x2F;进程</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>既可用于作业调度，也可用于进程调度。甚至还会用于在之后会学习的I&#x2F;O调度中</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需任就绪队列变化时，检查是否会发生抢占。</td>
</tr>
<tr>
<td>优缺点</td>
<td>优点：用优先级区分紧总程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充</td>
<td>如下图</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251342602.png"/>

<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><table>
<thead>
<tr>
<th>多级反馈队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>对其他调度算法的折中权衡</td>
</tr>
<tr>
<td>算法规则</td>
<td>1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td>
</tr>
<tr>
<td>用于作业&#x2F;进程调度</td>
<td>用于进程调度</td>
</tr>
<tr>
<td>是否可抢占？</td>
<td>抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k级 队列队尾</td>
</tr>
<tr>
<td>优缺点</td>
<td>对各类型进程相对公平(FCFS的优点)：每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的时间就可完成(SPF的优点)；不必实现估计进程的运行时间（避免用户作假）：可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、&#x2F;O密集型进程（拓展：可以将因&#x2F;O而阻塞的进程重新放回原队列，这样&#x2F;O型进程就可以保持较高优先级)</td>
</tr>
<tr>
<td>是否会导致饥饿</td>
<td>会</td>
</tr>
<tr>
<td>补充理解</td>
<td>如下文</td>
</tr>
</tbody></table>
<blockquote>
<p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>P1(1) —— P2(1) —— P1(2) —— P2(1) —— P3(1) —— P2(2) —— P1(4) —— P1(1)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302251358421.png"/>

<p>设置多级就绪队列，各级队列<strong>优先级从高到低</strong>，<strong>时间片从小到大</strong></p>
<p><span style="color:red">新进程</span>到达时<span style="color:red">先进入第1级队列</span>，按<span style="color:red">FCFS原则</span>排队等待被分配时间片。若用完时间片进程还<strong>未结束</strong>，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>己经在最下级</strong>的队列，则<strong>重新放回</strong>最下级队列队尾</p>
<p>只有第<strong>k级队列为空</strong>时，才会<strong>为k+1级</strong>队头的进程<strong>分配时间片</strong><br><strong>被抢占处理机的进程重新放回原队列队尾</strong></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括<strong>分时操作系统、实时操作系统</strong>等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统。</strong>(比如UNIX使用的就是多级反馈队列调度算法)</p>
<h3 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>以下例子为管道通信为实例</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282350043.png"/>

<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></p>
<blockquote>
<p>含义</p>
</blockquote>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><ul>
<li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li>
<li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li>
<li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282351880.png"/>

<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202302282359512.png"/>

<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091148134.png"/>

<blockquote>
<p>turn的初值为0，即刚开始只允许0号进程进入临界区。<br>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。<br>因此，<strong>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p>
<p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p>
<p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→…这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。<br>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p>
</blockquote>
<h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091154224.png"/>

<p>若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091158727.png"/>

<p>若按照①⑤②⑥…的顺序执行，P0和P1将都无法进入临界区因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303091200387.png"/>

<ul>
<li>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li>
<li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li>
</ul>
<h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516619.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261516916.png"/>

<blockquote>
<p>关中断指令只对执行关中断指令的处理机有用</p>
</blockquote>
<h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518026.png"/>

<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261518466.png"/>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="进程互斥：锁"><a href="#进程互斥：锁" class="headerlink" title="进程互斥：锁"></a>进程互斥：锁</h4><h5 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>解决临界区最简单的工具就是互斥锁（mutexlock)。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available); <span class="comment">//忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>; <span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>; <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。<br>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁（</strong>spin lock)，如TSL指令、swap指令、单标志法 </p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261531895.png"/>

<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li><strong>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，</strong>可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li>
<li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li>
<li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li>
<li>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202303261532635.png"/>

<p>进程互斥的四种软件实现方式（单标志法，双标志先检查，双标志后检查，Peterson算法）</p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法，TS&#x2F;TSL指令，Swap&#x2F;XCHG指令）</p>
<p>1.在双标志先检查法中，进去区的”检查“，”上锁“操作无法一气呵成，中间有可能先执行了检查就进行了进程切换，从而导致了两个进程有可能同时进入临界区的问题；</p>
<p>2.所有的解决方案都无法实现”让权等待“</p>
<blockquote>
<p>其中单标志法，双标志先检查，双标志后检查都存在着比较严重的一些问题的隐患。Peterson算法还有后面的三种硬件实现方式其实问题都不大，但是这些方式也都无法解决”让权等待“原则</p>
</blockquote>
<h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072113564.png"/>

<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072114497.png"/>

<h3 id="用信号量实现进程互斥，同步，前驱关系"><a href="#用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="用信号量实现进程互斥，同步，前驱关系"></a>用信号量实现进程互斥，同步，前驱关系</h3><h4 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol>
<li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li>
<li>设置互斥信号量mutex，初值为1</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072115578.png"/>

<p>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p>
<p><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p>
<h4 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序的进行。</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li>
<li>设置同步信号量s,初始为0</li>
<li>在“前操作”之后执行v(S)</li>
<li>在“后操作”之前执行P(S)</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072117802.png"/>

<h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，</p>
<ol>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在“前操作”之后对相应的同步变量执行V操作</li>
<li>在“后操作”之前对相应的同步变量执行Р操作</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072118787.png"/>

<h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
<li>缓冲区是临界资源，各进程必须互斥地访问。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119845.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119979.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119956.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072119961.png"/>

<h3 id="多生产者——多消费者"><a href="#多生产者——多消费者" class="headerlink" title="多生产者——多消费者"></a>多生产者——多消费者</h3><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123688.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072123924.png"/>

<p>问题：可不可以不使用问题信号量？</p>
<p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p>
<p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p>
<p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p>
<ol>
<li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li>
<li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li>
</ol>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124996.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072124492.png"/>

<h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p>
<p>①允许多个读者可以同时对文件执行读操作;</p>
<p>②只允许一个写者往文件中写信息;</p>
<p>③任一写者在完成写操作之前不允许其他读者或写者工作;</p>
<p>④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125799.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125176.png"/>

<ul>
<li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072125944.png"/>

<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。<br>其核心思想在于<strong>设置了一个计数器count用来记录当前正在访问共享文件的读进程数</strong>。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，<strong>如果需要实现“一气呵成”，自然应该想到用互斥信号量。</strong><br>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126626.png"/>

<p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<p>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p>
<blockquote>
<p>以下方式会出现死锁问题</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072126279.png"/>
</blockquote>
<p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072127517.png"/>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程相当于对临界区资源进行抽象而编写的一个类。</strong></p>
<p>管程是一种特殊的软件模块，有这些部分组成:</p>
<p>1.局部于管程的共享数据结构说明; （一个类）</p>
<p>2.对该数据结构进行操作的一组过程; （类中的方法）</p>
<p>3．对局部于管程的共享数据设置初始值的语句; （类中的变量）</p>
<p>4.管程有一个名字。 （类名）</p>
<p>管程的基本特征:</p>
<p>1．局部于管程的数据只能被局部于管程的过程所访问; （类中变量有自己的作用范围）</p>
<p>**2.一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** <strong>这种互斥特性是由编译器来实现的。</strong></p>
<p><strong>3．每次仅允许一个进程在管程内执行某个内部过程。</strong></p>
<blockquote>
<h4 id="java中类似于管程的机制（单例模式）"><a href="#java中类似于管程的机制（单例模式）" class="headerlink" title="java中类似于管程的机制（单例模式）"></a>java中类似于管程的机制（单例模式）</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072128379.png"/>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p>
<p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p>
<h4 id="死锁，饥饿，死循环的区别"><a href="#死锁，饥饿，死循环的区别" class="headerlink" title="死锁，饥饿，死循环的区别"></a>死锁，饥饿，死循环的区别</h4><ul>
<li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li>
<li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072129588.png"/>

<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求 和 保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>)</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</p>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li>
<li><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304072130399.png"/>

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061307159.png"/>

<p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081538138.png"/>

<h2 id="相对地址和绝对地址"><a href="#相对地址和绝对地址" class="headerlink" title="相对地址和绝对地址"></a>相对地址和绝对地址</h2><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong><br>编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>
<p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p>
<h2 id="三种装入模式"><a href="#三种装入模式" class="headerlink" title="三种装入模式"></a>三种装入模式</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061302897.png"/>

<h3 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h3><p>这种方式的灵活性很差，只适用于单道程序环境，早期还没有操作系统的阶段使用的就是这种方式</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061316431.png"/>

<h3 id="可重定位装入"><a href="#可重定位装入" class="headerlink" title="可重定位装入"></a>可重定位装入</h3><p>这种方式的特点是我们给这个作业&#x2F;进程分配的这些地址空间必须是连续的，并且这个作业必须一次全部装入内存</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317740.png"/>

<h3 id="动态运行时装入"><a href="#动态运行时装入" class="headerlink" title="动态运行时装入"></a>动态运行时装入</h3><p>CPU在对一个内存地址进行访问的时候会把逻辑地址和重定位寄存器当中存放的起始地址进行相加得到最终可以访问的地址</p>
<p>想让进程的数据在运行过程当中发生移动是很方便的，只需要修改重定位寄存器的值就可以</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317519.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061317630.png"/>

<h2 id="程序运行逻辑"><a href="#程序运行逻辑" class="headerlink" title="程序运行逻辑"></a>程序运行逻辑</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202304081539943.png"/>

<p>这些目标模块文件当中已经包含了这些代码所对应的那些指令，而这些指令的编址都是逻辑地址。每一个模块的逻辑地址编址都是相互独立的，都从0开始</p>
<p>链接把这些目标模块组装起来形成一个完整的装入模块</p>
<p>在链接这一步，除了我们自己编写的这些目标模块需要链接以外，还需要把它们所调用到的一些库函数（如printf）也链接起来</p>
<h3 id="程序运行前—静态连接"><a href="#程序运行前—静态连接" class="headerlink" title="程序运行前—静态连接"></a>程序运行前—静态连接</h3><p>就是我们刚才所提到的这种方式，在形成装入模块之后就确定了这个装入模块的完整的逻辑地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061319738.png"/>

<h3 id="装入时—动态连接"><a href="#装入时—动态连接" class="headerlink" title="装入时—动态连接"></a>装入时—动态连接</h3><p>采用这种方式的话，这个进程的完整的逻辑地址是一边装入一边形成的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061320350.png"/>

<h3 id="运行时—动态连接"><a href="#运行时—动态连接" class="headerlink" title="运行时—动态连接"></a>运行时—动态连接</h3><p>需要用到某一个模块的时候再把它调入内存，装入的同时进行链接</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321161.png"/>

<h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061321531.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061323512.png"/>

<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<ol>
<li><p>操作系统负责内存空间的分配与回收</p>
</li>
<li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址的转换</strong></p>
</li>
</ol>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。 </p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305061326837.png"/>

<p>绝对装入是在编译的时候就产生了绝对地址，或者说在程序员写程序的时候直接就写了绝对地址。这个地址转换是由编译器而不是操作系统完成的</p>
<p>可重定位装入中地址转换的过程由装入程序负责进行，而装入程序也是操作系统的一部分</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111342928.png"/>

<h4 id="上下寄存器"><a href="#上下寄存器" class="headerlink" title="上下寄存器"></a>上下寄存器</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111342779.png"/>

<h4 id="重定位寄存器"><a href="#重定位寄存器" class="headerlink" title="重定位寄存器"></a>重定位寄存器</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111343667.png"/>

<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111344101.png"/>

<h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。<br>后来人们引入了<strong>覆盖技术，用来解决“程小超过物理内存总和”的问题</strong></p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111346095.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111346097.png"/>

<blockquote>
<p>A这个模块会依次调用B模块和C模块。注意是依次调用，B模块和C模块只可能被A模块在不同的时间段调用，不可能是同时访问B和C这两个模块</p>
</blockquote>
<p>操作系统并不知道程序的调用结构，程序的调用结构必须由程序员显性地声明，操作系统根据程序员声明的调用结构&#x2F;覆盖结构完成自动覆盖</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111350389.png"/>

<p>第二章讲处理机调度的时候讲过一个处理机调度层次的概念，分为高级调度，中级调度和低级调度。其中中级调度就是为了实现交换技术而使用的一种调度策略</p>
<p>换出外存的进程相关的PCB会保留在内存当中并且插入到挂起队列里</p>
<p>为什么进程的PCB要常驻内存呢？因为进程被换出外存之后，必须要通过某种方式记录下进程到底是放在外存的什么位置，这个信息记录在对应的PCB当中，操作系统就可以根据PCB当中记录的这些信息对这些进程进行管理</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111350777.png"/>

<p>一个本来处于就绪态的进程被换出外存，这个进程就处于就绪挂起态</p>
<p>一个本来处于阻塞态的进程被换出外存，这个进程就处于阻塞挂起态</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111351844.png"/>

<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111351402.png"/>

<p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111352995.png"/>

<p>内存当中同一时刻只能有一道用户程序，它并不支持多道程序并发运行</p>
<p>因为系统中只会运行一个用户程序，即使这个用户程序出问题了也只会影响用户程序本身，或者说即使这个用户程序越界损坏操作系统的数据，这个数据一般来说也可以通过重启计算机就可以很方便地进行修复，所以说采用单一连续分配的系统当中不一定采取内存保护</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111353659.png"/>

<p>分区大小相等：如果有一个比较大的进程进入的话，如果这些分区的大小都不能满足这个大进程的需求，那么这个大进程就不能被装入这个系统，或者说只能采用覆盖技术在逻辑上来拓展各个分区的大小，而这显然又会增加一些系统开销</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111354699.png"/>

<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111354258.png"/>

<h5 id="动态分区存在的问题"><a href="#动态分区存在的问题" class="headerlink" title="动态分区存在的问题"></a>动态分区存在的问题</h5><ol>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111359562.png"/>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111400729.png"/>
</li>
<li><p>分区分配：<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111400169.png"/></p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111410550.png"/>

<ol start="4">
<li>分区回收：<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111411848.png"/></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111414369.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111414421.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111415359.png"/>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>这几种情况本质上可以用一句话来进行总结：在进行内存分区回收的时候，如果说回收了之后发现有一些空闲分区是相邻的，那我们就需要把这些相邻的空闲分区全部合并</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111415841.png"/>

<p>紧凑技术其实就是把各个进程挪位，把它们全部攒到一起，挪出一个更大的连续空闲区间</p>
<p>动态重定位的方式最方便实现程序或者说进程在内存当中移动位置</p>
<p>紧凑之后需要修改各个进程的起始地址，进程的起始地址信息一般存放在进程对应的PCB当中，当进程要上CPU运行之前会把进程的起始地址信息放到重定位寄存器（基址寄存器）里</p>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111416487.png"/>

<p>动态分区分配算法：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区</p>
<p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块。因此这种方法会产生很多的外部碎片</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>又称 最大适应算法（Largest Fit）</p>
<p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p>
<p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有”大进程“到达，就没有内存分区可用了</p>
<h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</p>
<p>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>假如说此时系统当中的内存使用情况如下图所示，把这些空闲分区按照地址递增的次序依次进行排列，排成一个循环链表</p>
<p>如果有一个需要5MB内存空间的进程到达，就从链头的位置开始查找直到找到合适的分区进行分配。同时更新链当中的结点，包括分区的大小，还有分区的起始地址</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111418851.png"/>

<p>采用邻近适应算法和首次适应算法只需要按照地址递增的次序进行排列。所以即使这里内存分区的大小发生了一个比较大的变化，但是我们依然不需要像最佳适应算法和最坏适应算法一样可能要对整个链表进行重新排列，算法的开销会比较小</p>
<p>接下来假如一个需要5MB内存空间的新进程到达，按照规则从上一次查找到的位置依次再往后查找即可。以后的过程都是类似的</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111419898.png"/>

<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>
<p>综合来看，四种算法中，首次适应算法的效果反而更好</p>
</blockquote>
<h3 id="基本分页存储管理的概念"><a href="#基本分页存储管理的概念" class="headerlink" title="基本分页存储管理的概念"></a>基本分页存储管理的概念</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111420967.png"/>

<p>非连续分配：为用户进程分配的可以是一些分散的内存空间</p>
<h4 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111420848.png"/>

<p>内存里存放的无非就是各个进程的数据，包括进程的代码，进程的指令等等</p>
<h4 id="页表——重要的数据结构"><a href="#页表——重要的数据结构" class="headerlink" title="页表——重要的数据结构"></a>页表——重要的数据结构</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111421980.png"/>

<blockquote>
<p>内存块就是页框(page flame)</p>
</blockquote>
<h4 id="问题1：每个页表项占多少字节"><a href="#问题1：每个页表项占多少字节" class="headerlink" title="问题1：每个页表项占多少字节"></a>问题1：每个页表项占多少字节</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111422216.png"/>

<p>这里计算机分配存储空间是以字节为单位而不是以bit为单位，所以20bit至少要用3B来存储</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111428370.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111428490.png"/>

<p>一个页表项在逻辑上是包含了页号和块号这两个信息，但是在物理上它只需要存放块号这个信息，只有块号需要占用存储空间</p>
<h4 id="问题2：如何实现地址的转换"><a href="#问题2：如何实现地址的转换" class="headerlink" title="问题2：如何实现地址的转换"></a>问题2：如何实现地址的转换</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111431445.png"/>

<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111431771.png"/>

<p>页内偏移量：相对于页面的起始位置而言的偏移量是多少</p>
<h5 id="如何确定一个逻辑地址对应的页号，页内偏移量？"><a href="#如何确定一个逻辑地址对应的页号，页内偏移量？" class="headerlink" title="如何确定一个逻辑地址对应的页号，页内偏移量？"></a>如何确定一个逻辑地址对应的页号，页内偏移量？</h5><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111432887.png"/>

<h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111433183.png"/>

<h3 id="基本地址变化机构"><a href="#基本地址变化机构" class="headerlink" title="基本地址变化机构"></a>基本地址变化机构</h3><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111434511.png"/>

<p>基本地址变换机构是基本分页存储管理中用于实现逻辑地址到物理地址转换的一组硬件机构</p>
<h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>在分页存储管理当中如果要把逻辑地址转换成物理地址的话，总共需要做4件事：</p>
<p>1.知道逻辑地址对应的页号</p>
<p>2.知道逻辑地址对应的页内偏移量</p>
<p>3.知道逻辑地址对应的页面在内存当中存放的位置到底是多少</p>
<p>4.根据页面在内存当中的起始位置和页内偏移量就可以得到最终的物理地址</p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个<strong>页表寄存器</strong>（PTR),<strong>存放页表在内存中的起始地址F和页表长度M</strong>。进程未执行时，页表的始址和页表长度放在**进程控制块（PCB)**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<blockquote>
<p>注意：<strong>页面大小是2的整数幂</strong></p>
<p>设页面大小为L,逻辑地址A到物理地址E的变换过程如下：</p>
<p>操作系统会把内存分为系统区和用户区。系统区当中存放着操作系统对整个计算机软硬件进行管理的一些相关的数据结构，包括PCB</p>
<p>如果一个进程被调度需要上处理机运行，进程切换相关的那些内核程序就会把这个进程的运行环境给恢复。这些进程运行环境相关的信息本来是保存在PCB当中的，内核程序会把这些信息放到相应的一系列寄存器当中，包括页表寄存器。另外程序计数器PC也是需要恢复的，PC指向这个进程下一条需要执行的指令的逻辑地址。接下来看怎么把这个逻辑地址转换成实际的物理地址，即CPU怎么在内存当中找到接下来要执行的这一条指令</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111437646.png"/>

<p>采用分页存储管理方式的系统当中，逻辑地址结构肯定是固定不变的，在一个逻辑地址当中页号有多少位，页内偏移量有多少位操作系统都是知道的。所以只要知道了逻辑地址就可以很快地切分出页号和页内偏移量这两个部分</p>
<p>接下来会对页号的合法性进行一个检查，越界就会抛出中断由中断处理程序进行处理</p>
<blockquote>
<p>一个进程的页表长度M指的是这个进程的页表当中有M个页表项，也就意味着这个进程的页面总共有M页</p>
</blockquote>
<p>如果页号是合法的，接下来会用这个页号和页表始址来进行计算，找到这个页号对应的页表项到底是多少</p>
<p>页表当中的每一个页表项的长度是相同的。所以只要知道了页号，页表起始地址和每一个页表项的长度就可以算出我们想要访问的页号对应的页表项所存放的位置</p>
<p>既然知道了存放的内存块号，就可以用内存块号结合页内偏移量得到最终的物理地址，然后就可以顺利地访问逻辑地址所对应的内存单元了</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111441369.png"/>
</blockquote>
<p>该过程的文字描述如下</p>
<blockquote>
<ol>
<li><p>计算页号P和页内偏移量W（如果用十进制数手算，则 P&#x3D;A&#x2F;L，W&#x3D;A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号，页内偏移量）</p>
</li>
<li><p>比较页号P和页表长度M，若P ≥ M P\ge M<em>P</em>≥<em>M</em>，则产生越界中断，否则继续执行。（注意：页号从0开始的，而页表长度至少是1，因此 P&#x3D;M 时也会越界）</p>
</li>
<li><p>页表中页号P对应的页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度，页表长度，页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</p>
</li>
<li><p>计算E&#x3D;b*L+W,用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</p>
</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443343.png"/>

<h4 id="对页表项大小的进一步探讨"><a href="#对页表项大小的进一步探讨" class="headerlink" title="对页表项大小的进一步探讨"></a>对页表项大小的进一步探讨</h4><img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443247.png"/>

<p>页表项不能跨页框存储</p>
<p>如果说我们的这些页表项并不能装满整个页框的话，那在查找页表项的时候会造成一些麻烦</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111443524.png"/>

<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表，又称联想寄存器（TLB,translation lookaside buffer),是一种访问速度比内存快很多的高速缓存（TLB不是内存！),用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111522029.png"/>

<blockquote>
<p>进程最先要访问的逻辑地址是(0，0)</p>
<p>首先进行越界异常的检查，该页号需要和页表寄存器当中的页表长度对比</p>
<p>接下来就会查询快表，由于快表此时的内容是空的，因此在快表中找不到页号为0对应的页表项，快表没有命中。接下来就不得不去访问内存当中存放的慢表，通过页表始址和页号计算出对应的页表项存放的位置</p>
<p>查询完慢表之后就可以知道0号页面所存放的内存块号是600，再通过内存块号和页内偏移量就可以得到最终的物理地址，最后就可以访问这个逻辑地址所对应的内存单元了</p>
<p>注意在访问了这个页表项之后同时也会把该页表项复制一份放到快表当中</p>
<p>接下来要访问的逻辑地址是(0，4)</p>
<p>同样地刚开始会进行越界异常的判断，发现没有越界</p>
<p>接下来会根据页号来查询快表以确认这个页号所对应的页表项是否在快表当中，由于刚才已经复制到了快表当中，因此这次的查询就可以命中。系统可以直接知道0号页面存放的页面是600，所以接下来就不需要查询内存当中的慢表而是直接用内存块号和页内偏移量得到最终想要访问的物理地址然后进行访存</p>
<p><strong>（0，0）前面指的是页号，后面指的是页内偏移量</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111524247.png"/>

<h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><blockquote>
<ol>
<li><p>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较</p>
</li>
<li><p>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
</li>
<li><p>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p>
</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us,访问一次内存耗时100us。若快表的命中率为90%,那么访问一个逻辑地址的平均耗时是多少？</p>
<p>(1+100)*0.9+(1+100+100)*0.1&#x3D;111us</p>
<p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是</p>
<p>（1+100)*0.9+(100+100)*0.1&#x3D; 110.9us</p>
<p>若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<img src="https://cdn.jsdelivr.net/gh/blackhaird/blog_img@main/computer_system/202305111528656.png"/>
</blockquote>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MEIDE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MEIDE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/meideblog/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/meideblog/velocity/velocity.min.js"></script>
  <script src="/meideblog/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
